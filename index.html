<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="T0UGH&#39;s BLOG">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="T0UGH&#39;s BLOG">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="T0UGH&#39;s BLOG">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>T0UGH's BLOG</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">T0UGH's BLOG</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">自娱自乐ing...</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/06/动态规划/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/06/动态规划/" itemprop="url">动态规划</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-06T20:16:50+08:00">
                2019-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="动态规划-Dynamic-Programing-DP"><a href="#动态规划-Dynamic-Programing-DP" class="headerlink" title="动态规划(Dynamic Programing, DP)"></a>动态规划(Dynamic Programing, DP)</h2><p>动态规划是一种通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法</p>
<p>动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间远少于朴素解法</p>
<p>动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分，再根据子问题的解以得出原问题的解</p>
<p>通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解时直接查表。这种做法在重复子问题的数目关于输出的规模呈指数增长时特别有用</p>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>动态规划在查找有许多重叠子问题的情况的最优解时有效，它将问题重新组合为子问题。为了避免多次解决这些子问题，它们的结果都逐渐被计算并被保存，从简单的问题直到整个问题都被解决。因此，动态规划保存递归时的结果，因而不会在解决同样的问题时花费时间。</p>
<p>动态规划只能应用于有最优子结构的问题。最优子结构的意思是局部最优解能决定全局最优解。简单来说，问题可以被划分为子问题来解决</p>
<h3 id="适用情况"><a href="#适用情况" class="headerlink" title="适用情况"></a>适用情况</h3><ol>
<li>最优子结构性质: 如果问题的最优解所包含的子问题的解也是最优的，我们就称该问题具有最优子结构性质。最优子结构性质为动态规划算法解决问题提供了重要的线索</li>
<li>无后效性: 即子问题的解一旦确定，就不再改变，不受在这之后、包含它的更大的问题的求解决策影响</li>
<li>子问题重叠性质: 子问题重叠性质是指在用递归算法自顶向下对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。动态规划算法正是利用了这种子问题重叠性质，对每个子问题只计算一次，然后将其计算结果保存到一个表格中，当再次需要计算已经计算过的子问题时，只是在表格中简单地查看一下结果，从而获得较高的效率</li>
</ol>
<h3 id="实例–01背包问题"><a href="#实例–01背包问题" class="headerlink" title="实例–01背包问题"></a>实例–01背包问题</h3><h4 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h4><p>有<code>N</code>件物品和一个容量为<code>V</code>的背包。第i件物品的费用是<code>c[i]</code>，价值为<code>w[i]</code>。求解将哪些物品装入背包可使价值总和最大</p>
<h4 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h4><p>这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。 用子问题定义状态：即<code>f[i][v]</code>表示前<code>i</code>件物品恰放入一个容量为<code>v</code>的背包可以获得的最大价值。其状态转移方程为</p>
<blockquote>
<p>f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}</p>
</blockquote>
<p>其中<code>i</code>表示放第<code>i</code>个物品</p>
<p><code>v</code>表示背包所容纳的重量</p>
<p><code>f[i][v]</code>表示前<code>i</code>件物品恰放入一个容量为<code>v</code>的背包可以获得的最大价值</p>
<p><code>w[i]</code>表示第<code>i</code>件商品的价值</p>
<p>若只考虑第<code>i</code>件物品的策略（放或不放），那么就可以转化为一个只牵扯前<code>i-1</code>件物品的问题。</p>
<p>如果不放第<code>i</code>件物品，那么问题就转化为前<code>i-1</code>件物品放入容量为<code>v</code>的背包中，价值为<code>f[i-1][v]</code>；</p>
<p>如果放第<code>i</code>件物品，那么问题就转化为前<code>i-1</code>件物品放入剩下的容量为<code>v-c[i]</code>的背包中”，此时能获得的最大价值就是<code>f[i-1][v-c[i]]</code>再加上通过放入第i件物品获得的价值<code>w[i]</code></p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>假设现在有5件商品，每件商品的的价值和重量如下图所示，背包的容量 <code>C = 11</code>，现在来求解这个01背包问题</p>
<p><img src="/2019/03/06/动态规划/dp_1.jpg" alt=""></p>
<p>首先，我们制作一个表格</p>
<p><img src="/2019/03/06/动态规划/dp_3.jpg" alt=""></p>
<p>表格的每一列表示产品，列数等于产品数加一，即列数为6列。表格的行数等于背包的容量数加一，即行数为12行。</p>
<p>假设我们按照商品序号从<code>1</code>到<code>5</code>的顺序放入商品，表格中的每个元素表示：当背包容量为j时，我们放到第<code>i</code>个商品时，背包价值的最大值。</p>
<p>首先当背包为空时，价值为0，所以我们把第一行初始化为0。</p>
<p>而当背包的容量为0时，我们无法放入任何商品，价值为0，所以我们把第一列初始化为0。</p>
<p>对于其他元素，进行如下判断</p>
<ul>
<li><p>当商品重量大于背包容量时，我们一定无法放入商品，所以此时背包的价值继承自放入上一商品时的最大价值，即表格同列的上一个值。</p>
</li>
<li><p>当重量小于总重时，我们需要考虑是否放入此商品。我们比较放与不放的价值哪个较大。对于放入商品的价值，我们将背包容量减去此商品的重量后，查表。对于不放入商品的价值，继承自放入上一商品时的最大价值。例如，当表格运算到<code>[{1,2,3}, 5]</code>时,我们首先考虑将商品放入背包，则此时背包重量为0，我们查询<code>[{1,2},0]</code>发现此时价值为0，则这种情况下的价值为<code>0 + 18 = 18</code>。然后我们考虑不将商品放入背包，此时背包的价值继承自放入上一商品时的最大价值，我们查询<code>[{1, 2}, 5]</code>,这种情况下的价值为 <code>7</code>。明显第一种情况更好，则我们将这个元素的值设置为<code>18</code>。</p>
</li>
</ul>
<p>当我们计算到表格的右下角元素时，此问题已经解决了，就是右下角元素的值</p>
<h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><p><img src="/2019/03/06/动态规划/dp_2.jpg" alt=""></p>
<h3 id="与内容无关的部分"><a href="#与内容无关的部分" class="headerlink" title="与内容无关的部分"></a>与内容无关的部分</h3><p><img src="/2019/03/06/动态规划/Raspberry_Pi.png" alt=""></p>
<p><img src="/2019/03/06/动态规划/ubuntu魔改MAC.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/05/Tensorflow-1-深度学习简介/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/Tensorflow-1-深度学习简介/" itemprop="url">[Tensorflow][1]深度学习简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-05T20:35:42+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Tensorflow/" itemprop="url" rel="index">
                    <span itemprop="name">Tensorflow</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Tensorflow-1-深度学习简介"><a href="#Tensorflow-1-深度学习简介" class="headerlink" title="[Tensorflow][1]深度学习简介"></a>[Tensorflow][1]深度学习简介</h2><h3 id="1-1-人工智能、机器学习与深度学习"><a href="#1-1-人工智能、机器学习与深度学习" class="headerlink" title="1.1 人工智能、机器学习与深度学习"></a>1.1 人工智能、机器学习与深度学习</h3><h4 id="1-1-1-人工智能"><a href="#1-1-1-人工智能" class="headerlink" title="1.1.1 人工智能"></a>1.1.1 人工智能</h4><ul>
<li><p>背景：一些人类通过直觉可以很快解决的问题，目前却很难通过计算机解决。这些问题包括自然语言处理、图像识别、语音识别等。</p>
</li>
<li><p>人工智能：一类非常广泛的问题，它旨在通过计算机实现类似人类的智能</p>
</li>
<li><p>特定环境：很多早期的人工智能系统只能成功应用于相对 <strong>特定的环境(specific domain)</strong>，在这些特定环境下，计算机需要了解的知识很容易被严格和完整地定义</p>
</li>
<li><p>知识图库(Ontology)</p>
<ul>
<li>定义：将单词整理为<strong>近义词集(synsets)</strong>，并定义近义词集之间的关系</li>
<li>缺点<ul>
<li>花费大量人力物力</li>
<li>可以通过知识图库方式明确定义的知识有限，很大部分无法明确定义的知识，就是人类的经验</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-1-2-机器学习"><a href="#1-1-2-机器学习" class="headerlink" title="1.1.2 机器学习"></a>1.1.2 机器学习</h4><ul>
<li><p>背景：如何让计算机可以和人类一样从历史的经验中获取新的知识？这就是机器学习需要解决的问题</p>
</li>
<li><p>机器学习：</p>
<ul>
<li>定义：如果 <strong>一个程序</strong> 可以在 <strong>任务T</strong> 上，随着 <strong>经验E</strong> 的增加，<strong>效果P</strong> 也可以随之增加，则称这个程序可以从经验中学习</li>
<li>以垃圾邮件分类的方法来解释机器学习<ul>
<li>一个程序：需要用到的机器学习算法，比如逻辑回归算法</li>
<li>任务T：区分垃圾邮件的任务</li>
<li>经验E：已经区分过是否为垃圾邮件的历史邮件</li>
<li>效果P：机器学习算法在区分是否为垃圾邮件任务上的正确率</li>
</ul>
</li>
</ul>
</li>
<li><p>特征(feature)：例如进行垃圾邮件分类时，会从每封邮件中提取对分类结果可能有影响的因素，每个因素称为一个特征(feature)</p>
</li>
<li><p>逻辑回归算法可以从训练数据中计算出每个特征和预测结果的相关度</p>
</li>
<li><p>在训练数据达到一定数量之前，越多的训练数据可以使逻辑回归算法对未知邮件做出的判断越精确</p>
</li>
<li><p>逻辑回归算法可以根据训练数据(经验E)提高在垃圾邮件分类问题(任务T)上的正确率(效果P)</p>
</li>
<li><p>逻辑回归算法的效果也依赖于从数据中提取的特征</p>
</li>
<li><p>如何从实体中提取特征，对于很多传统机器学习算法的性能有巨大影响</p>
</li>
</ul>
<h4 id="1-1-3-深度学习"><a href="#1-1-3-深度学习" class="headerlink" title="1.1.3 深度学习"></a>1.1.3 深度学习</h4><ul>
<li><p>背景：对许多机器学习问题来说，特征提取不是一件简单的事情，在一些复杂问题上，要通过手动的方式设计有效的特征集合，需要很多的时间和精力</p>
</li>
<li><p>深度学习</p>
<ul>
<li>定义：深度学习是机器学习的一个分支，它除了可以学习特征和任务之间的关联，还能自动从简单特征中提取更加复杂的特征</li>
<li>深度学习解决的核心问题之一就是自动地将简单的特征组合成更加复杂的特征，并使用这些组合特征解决问题</li>
<li>深度学习算法可以从数据中学习更加复杂的特征表达，使得最后一步权重学习变得更加简单且高效</li>
</ul>
</li>
<li><p>深度学习与传统机器学习流程的对比<br><img src="/2019/03/05/Tensorflow-1-深度学习简介/深度学习与传统机器学习流程对比.jpg" alt=""></p>
</li>
</ul>
<h4 id="1-1-4-深度学习与传统神经科学"><a href="#1-1-4-深度学习与传统神经科学" class="headerlink" title="1.1.4 深度学习与传统神经科学"></a>1.1.4 深度学习与传统神经科学</h4><ul>
<li><p>早期深度学习受到神经科学的启发</p>
</li>
<li><p>例如</p>
<ul>
<li>神经科学的研究：虽然哺乳动物大脑分为了很多区域，但这些区域的学习机制却是相似的</li>
<li>深度学习的运用：深度学习算法具有通用性，深度学习研究者往往可以跨越多个研究方向甚至同时活跃于所有的研究方向</li>
</ul>
</li>
<li><p>现代深度学习的发展并不拘泥于模拟人脑神经元和人脑的工作机理，模拟人类大脑也不再是深度学习研究的主导方向</p>
</li>
<li><p>计算神经学：试图从算法层理解大脑的工作机制</p>
</li>
</ul>
<hr>
<h3 id="1-2-深度学习的发展历程"><a href="#1-2-深度学习的发展历程" class="headerlink" title="1.2 深度学习的发展历程"></a>1.2 深度学习的发展历程</h3><p>神经网络的发展史大致可以分为三个阶段</p>
<h4 id="1-2-1-第一个阶段—仿生"><a href="#1-2-1-第一个阶段—仿生" class="headerlink" title="1.2.1 第一个阶段—仿生"></a>1.2.1 第一个阶段—仿生</h4><ul>
<li><p>早期的神经网络模型类似于仿生机器学习，它试图模拟大脑的学习机理</p>
</li>
<li><p>McCulloch-Pitts Neuron结构</p>
<ul>
<li>简介：McCulloch-Pitts Neuron结构大致模拟了人类神经元的工作原理，它们都有一些输入，然后将输入进行一些变换后得到输出结果</li>
<li>如图<br><img src="/2019/03/05/Tensorflow-1-深度学习简介/神经元结构.jpg" alt=""></li>
<li>理解：McCulloch-Pitts Neuron结构使用简单的线性加权和的方式来模拟这个变换，将n个输入值提供给McCulloch-Pitts Neuron结构后，McCulloch-Pitts Neuron结构会通过n个权重w1,w2,…,wn来计算这n个输入的加权和，然后用这个加权和经过一个阈值函数得到一个0或1的输出</li>
</ul>
</li>
<li><p>感知机( perceptron )</p>
<ul>
<li>首个可以根据样例数据学习特征权重的模型</li>
<li>感知机模型只能解决线性不可分问题</li>
</ul>
</li>
</ul>
<h4 id="1-2-2-第二个阶段—分布式知识表达和反向传播算法"><a href="#1-2-2-第二个阶段—分布式知识表达和反向传播算法" class="headerlink" title="1.2.2 第二个阶段—分布式知识表达和反向传播算法"></a>1.2.2 第二个阶段—分布式知识表达和反向传播算法</h4><ul>
<li><p>分布式知识表达</p>
<ul>
<li>核心思想：现代世界中的知识和概念应该由多个神经元(neuron)来表达，而模型中的每个神经元也应该参与表达多个概念</li>
<li>意义：大大加强了模型的表达能力，让神经网络从宽度的方向走向了深度的方向</li>
<li>深层神经网络解决了线性不可分问题</li>
</ul>
</li>
<li><p>反向传播算法</p>
<ul>
<li>大幅降低了训练神经网络所需要的时间</li>
</ul>
</li>
<li><p>此阶段的两大阻碍</p>
<ol>
<li>在当时的计算资源下，要训练深层的神经网络仍然是非常困难的</li>
<li>当时的数据量较少，无法满足训练深层神经网络的需求</li>
</ol>
</li>
</ul>
<h4 id="1-2-2-第三个阶段—计算能力和数据量的提升"><a href="#1-2-2-第三个阶段—计算能力和数据量的提升" class="headerlink" title="1.2.2 第三个阶段—计算能力和数据量的提升"></a>1.2.2 第三个阶段—计算能力和数据量的提升</h4><ul>
<li>此阶段解决了第二阶段的两大阻碍<ol>
<li>随着云计算和GPU的出现，计算量已经不再是阻碍神经网络发展的问题</li>
<li>随着互联网+的发展，获得海量数据也不再困难 </li>
</ol>
</li>
</ul>
<hr>
<h3 id="1-3-深度学习的应用"><a href="#1-3-深度学习的应用" class="headerlink" title="1.3 深度学习的应用"></a>1.3 深度学习的应用</h3><h4 id="1-3-1-计算机视觉"><a href="#1-3-1-计算机视觉" class="headerlink" title="1.3.1 计算机视觉"></a>1.3.1 计算机视觉</h4><ul>
<li><p>传统的机器学习算法很难抽象出足够有效地特征，使得学习模型既可以区分不同的个体，又可以区分相同个体在不同环境下<br>的变化</p>
</li>
<li><p>深度学习技术通过从海量数据中自动习得更加有效地特征表达，可以很好的解决这个问题</p>
</li>
<li><p>光学字符识别(OCR)：使用计算机程序将计算机无法理解的图片中的字符，比如数字、字母、汉字等符号，转化为计算机可以理解的文本格式</p>
</li>
</ul>
<h4 id="1-3-2-语音识别"><a href="#1-3-2-语音识别" class="headerlink" title="1.3.2 语音识别"></a>1.3.2 语音识别</h4><ul>
<li>随着数据量的增大，使用深度学习模型无论在正确率的增长数值上还是在增长比率上都要优于使用混合高斯模型的算法</li>
</ul>
<h4 id="1-3-3-自然语言处理"><a href="#1-3-3-自然语言处理" class="headerlink" title="1.3.3 自然语言处理"></a>1.3.3 自然语言处理</h4><ul>
<li><p>包括：语言模型、机器翻译、词性标注、实体识别、情感分析、广告推荐、搜索排序等</p>
</li>
<li><p>单词向量(word embedding)</p>
<ul>
<li>单词向量提供了一种更加灵活的方式来刻画单词的语义</li>
<li>单词向量会将一个单词表示为一个相对较低维度的向量(比如100维或200维)。对于语义相近的单词，其对应的单词向量在空间中的距离也应该接近。于是单词语义上的相似度可以通过空间中的距离来描述。</li>
<li>通过单词向量可以进行单词之间的运算</li>
</ul>
</li>
</ul>
<h4 id="1-3-4-人机博弈"><a href="#1-3-4-人机博弈" class="headerlink" title="1.3.4 人机博弈"></a>1.3.4 人机博弈</h4><ul>
<li>AlphaGo<ul>
<li>AlphaGo的组成部分：蒙特卡罗树搜索(Monte Carlo tree search,MCTS)、估值网络(value network)和走棋网络(policy network)。</li>
<li>蒙特卡罗树搜索：实现对不同落子点的搜索</li>
<li>走棋网络：预测下一步在哪里落子</li>
<li>估值网络：给定当前的棋盘，判断黑棋赢的概率</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/理解LSTM网络/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/理解LSTM网络/" itemprop="url">理解LSTM网络</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T15:27:26+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/深度学习/" itemprop="url" rel="index">
                    <span itemprop="name">深度学习</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="理解LSTM网络"><a href="#理解LSTM网络" class="headerlink" title="理解LSTM网络"></a>理解LSTM网络</h2><h3 id="循环神经网络-RNN"><a href="#循环神经网络-RNN" class="headerlink" title="循环神经网络(RNN)"></a>循环神经网络(RNN)</h3><p>人类不会每时每刻都重新开始思考。当你阅读这篇文章时，你会根据你对之前单词的理解来理解每个单词。你不要丢掉之前的内容，然后再从头开始思考。你的思考是有持久性的。</p>
<p>传统的神经网络不能做到这一点，这似乎是一个主要的缺点。例如，假设您想要对电影中每个点发生的事件进行分类。目前尚不清楚传统神经网络如何利用其对电影中先前事件的推理来得出后面的事件。</p>
<p>循环神经网络解决了这个问题。它们是带有循环的网络，允许信息持续存在。</p>
<p><img src="/2019/03/03/理解LSTM网络/RNN-rolled.png" alt=""></p>
<p>在上图中，神经网络结构 A 通过一些输入 x<sub>t</sub> 并输出一个值 h<sub>t</sub>。循环允许信息从网络的一个步骤传递到下一个步骤。</p>
<p>这些循环使得循环神经网络看起来有点神秘。但是，如果你多想一点，事实证明它们与普通的神经网络并没有什么不同。可以将循环神经网络视为同一网络的多个副本，每个副本都将消息传递给后继者。考虑如果我们展开循环会发生什么：</p>
<p><img src="/2019/03/03/理解LSTM网络/RNN-unrolled.png" alt=""></p>
<p>这种类似链的性质表明，递归神经网络与序列和列表密切相关。它们是用于此类数据的神经网络的自然架构。 </p>
<p>他们肯定会被使用！在过去几年中，将RNN应用于各种问题取得了令人难以置信的成功：语音识别，语言建模，翻译，图像识别……这个列表还在继续。我将不展开讨论使用RNNs可以实现的惊人壮举，以及Andrej Karpathy的优秀博客文章，回归神经网络的不合理有效性。但他们真的很棒。</p>
<p>这些成功的关键在于使用“LSTM”，这是一种非常特殊的递归神经网络，对于许多任务而言，它比标准版本好得多。几乎所有基于递归神经网络的令人兴奋的结果都是用它们实现的。这篇论文将探讨这些LSTM。</p>
<h3 id="长期依赖问题"><a href="#长期依赖问题" class="headerlink" title="长期依赖问题"></a>长期依赖问题</h3><p>RNN的一个优点是他们可能能够将先前信息连接到当前任务，例如使用先前的视频帧中的信息可能得出对当前帧的理解。如果RNN可以做到这一点，它们将非常有用。 </p>
<p>有时，我们只需要通过很近的信息来得到当前任务。例如，考虑一种语言模型，试图根据之前的单词预测下一个单词。如果我们试图预测 “the clouds are in the sky” 的最后一个词，我们不需要任何进一步的背景 - 很明显下一个词将是 “sky”。在这种情况下，如果相关信息与所需信息之间的距离很小，则RNN可以学习使用过去的信息。</p>
<p><img src="/2019/03/03/理解LSTM网络/RNN-shorttermdepdencies.png" alt=""></p>
<p>但也有一些情况需要更多的背景知识。考虑尝试预测文本中的最后一个词“我在法国长大……我说流利的法语。”最近的信息表明，下一个词可能是一种语言的名称，但如果我们想缩小哪种语言，我们需要从更进一步的背景来看，法国的背景。相关信息之间距离很大是完全可能的。 </p>
<p>不幸的是，随着距离的扩大，RNN无法学习连接信息</p>
<p><img src="/2019/03/03/理解LSTM网络/RNN-longtermdependencies.png" alt=""></p>
<p>理论上，RNN绝对能够处理这种“长期依赖性”。人类可以仔细挑选参数来解决这种形式的玩具问题。遗憾的是，在实践中，RNN似乎无法学习它们。 Hochreiter和Bengio等人对该问题进行了深入探讨。他们找到了一些非常根本的原因来说明为什么它可能很难。</p>
<p>值得庆幸的是，LSTM结构不存在这个问题！</p>
<h3 id="LSTM-网络"><a href="#LSTM-网络" class="headerlink" title="LSTM 网络"></a>LSTM 网络</h3><p>长短期记忆网络 - 通常只称为“LSTM” - 是一种特殊的RNN，能够学习长期依赖性。它们是由Hochreiter和Schmidhuber提出的.它在各种各样的问题上都表现得非常好，现在被广泛使用。</p>
<p>LSTM明确旨在解决长期依赖性问题。长时间记住信息实际上是他们的默认行为，而不是他们难以学习的东西！</p>
<p>所有递归神经网络都具有一个循环体。在标准RNN中，该循环体将具有非常简单的结构，例如单个tanh层。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-SimpleRNN.png" alt=""></p>
<p>LSTM也具有循环体，但循环体具有不同的结构。它由四个被称为门的结构组成，而不是一个简单的tanh，并以一种非常特殊的方式进行交互。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-chain.png" alt=""></p>
<p>不要担心发生了什么的细节。我们将逐步介绍LSTM图。现在，让我们试着理解我们将要使用的符号。 </p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM2-notation.png" alt=""></p>
<p>在上图中，每条线都携带一个整个向量，从一个节点的输出到其他节点的输入。粉色圆圈表示逐位运算，如矢量加法，而黄色框表示简单的神经网络结构。行合并表示连接，而行分叉表示其内容被复制，副本将转移到不同的位置。</p>
<h3 id="LSTM的核心理念"><a href="#LSTM的核心理念" class="headerlink" title="LSTM的核心理念"></a>LSTM的核心理念</h3><p>LSTM的关键是单元状态，水平线贯穿图的顶部。 </p>
<p>单元状态有点像传送带。它直接沿着整个链运行，只有一些次要的线性交互。信息很容易沿着它不变地流动。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-C-line.png" alt=""></p>
<p>LSTM能够通过被称为门的结构来移除或添加信息到单元状态。 </p>
<p>门是一种可选择通过信息的方式。它们由sigmoid神经网络层和逐位乘法运算组成。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-gate.png" alt=""></p>
<p>sigmoid层输出0到1之间的数字，描述每个组件应该通过多少信息。值为零意味着“不让任何信息通过”，而值为1则意味着“让一切都通过！</p>
<p>LSTM具有三个这样的门，用于保护和控制单元状态。</p>
<h3 id="LSTM详细运算过程"><a href="#LSTM详细运算过程" class="headerlink" title="LSTM详细运算过程"></a>LSTM详细运算过程</h3><p>LSTM的第一步是确定我们将从单元状态中丢弃哪些信息。该判定由称为“遗忘门层”的sigmoid层来进行。它输入h<sub>t-1</sub>和x<sub>t</sub>，并在单元状态C<sub>t-1</sub>中为每个数字输出一个0到1之间的数字。 1代表“完全保留这个”，而0代表“完全丢弃这个”。</p>
<p>让我们回到之前提到的试图根据以前的所有单词预测下一个单词的那个语言模型的示例。在这样的问题中，单元状态可能包括当前受试者的性别，因此可以使用正确的代词。当我们看到一个新受试者时，我们想要忘记旧受试者的性别。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-focus-f.png" alt=""></p>
<p>下一步是确定我们将在单元状态中存储哪些新信息。这有两个部分。首先，称为“输入门层”的sigmoid层决定我们将更新哪些值。接下来，tanh层创建可以添加到状态的新候选值C<sub>t</sub>的向量。然后，我们将结合他们两个的结构来创建状态更新。</p>
<p>在我们的语言模型的例子中，我们想要将新受试者的性别添加到单元状态中，以替换我们需要忘记的旧受试者。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-focus-i.png" alt=""></p>
<p>现在是时候将旧的单元状态C<sub>t-1</sub>更新为新的单元状态C<sub>t</sub>。之前的步骤已经决定要做什么，我们只需要实际做到这一点。</p>
<p>我们将旧状态逐位乘以f<sub>t</sub>，忘记我们之前的步骤中决定忘记的内容。然后我们把它和i<sub>t</sub> * C<sub>t</sub>相加。这是新的状态。</p>
<p>在语言模型的情况下，我们实际上丢弃了关于旧主题的性别的信息并添加新信息，正如我们在前面的步骤中所做的那样。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-focus-C.png" alt=""></p>
<p>最后，我们需要决定我们要输出的内容。此输出将基于我们的单元状态，但将是被过滤的版本。首先，我们运行一个sigmoid层，它决定我们要输出的单元状态的哪些部分。然后，我们将单元状态通过tanh（将值变到-1和1之间）并将其乘以sigmoid门的输出，这样我们只输出我们决定输出的部分。</p>
<p><img src="/2019/03/03/理解LSTM网络/LSTM3-focus-o.png" alt=""></p>
<h3 id="长期记忆的变种"><a href="#长期记忆的变种" class="headerlink" title="长期记忆的变种"></a>长期记忆的变种</h3><p>到目前为止我所描述的是一个非常常规的LSTM。但并非所有LSTM都与上述相同。事实上，似乎几乎所有涉及LSTM的论文都使用略有不同的版本。差异很小，但值得一提。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>早些时候，我提到了人们使用RNN取得的显着成果。基本上所有这些都是使用LSTM实现的。对于大多数任务来说，它们确实工作得更好！ </p>
<p>写下来作为一组方程式，LSTM看起来非常令人生畏。希望在这篇文章中逐步走过它们，使它们更加平易近人。 </p>
<p>LSTM是我们通过RNN实现的重要一步。很自然地想知道：还有另一个重要的步骤吗？研究人员普遍认为：“是的！下一步是它的注意力！“我们的想法是让RNN的每一步都从一些更大的信息集中选择信息。例如，如果您使用RNN创建描述图像的标题，则可能会选择图像的一部分来查看其输出的每个单词。实际上，徐等人做到这一点，如果你想探索注意力，它可能是一个有趣的起点！使用注意力已经取得了许多非常令人兴奋的结果，而且似乎还有很多事情即将来临……</p>
<p>注意力不是RNN研究中唯一激动人心的线索。例如，Kalchbrenner等人的Grid LSTMs似乎非常有希望。在生成模型中使用RNN的工作似乎也很有趣。过去几年对于递归神经网络来说是一个激动人心的时刻，即将到来的神经网络只会更加激动人心！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/03/YAML学习/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/03/YAML学习/" itemprop="url">YAML学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-03-03T13:57:29+08:00">
                2019-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="YAML学习"><a href="#YAML学习" class="headerlink" title="YAML学习"></a>YAML学习</h2><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h3><p>YAML语言的设计目标，就是方便人类书写。它实质上是一种通用的数据串行化格式</p>
<h4 id="1-1-YAML的基本语法规则"><a href="#1-1-YAML的基本语法规则" class="headerlink" title="1.1 YAML的基本语法规则"></a>1.1 YAML的基本语法规则</h4><ol>
<li><p>大小写敏感</p>
</li>
<li><p>使用缩进表示层级关系</p>
</li>
<li><p>缩进时不允许使用tab键，只允许使用空格</p>
</li>
<li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
</li>
<li><p>#表示注释，从这个字符一直到行尾，都会被解释器忽略</p>
</li>
</ol>
<h4 id="1-2-YAML支持的数据结构有三种"><a href="#1-2-YAML支持的数据结构有三种" class="headerlink" title="1.2 YAML支持的数据结构有三种"></a>1.2 YAML支持的数据结构有三种</h4><ol>
<li><p>对象: 键值对的集合, 又称为映射(mapping)/哈希(hashes)/字典(dictionary)</p>
</li>
<li><p>数组: 一组按次序排列的值, 又称为序列(sequence)/列表(list)</p>
</li>
<li><p>纯量(scalars): 单个的, 不可再分的值</p>
</li>
</ol>
<h3 id="2-对象"><a href="#2-对象" class="headerlink" title="2 对象"></a>2 对象</h3><p>对象是一组键值对, 使用冒号结构表示<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">pets</span></span><br></pre></td></tr></table></figure></p>
<p>转为JavaScript如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">animal</span>: <span class="string">'pets'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="3-数组"><a href="#3-数组" class="headerlink" title="3 数组"></a>3 数组</h3><p>一组连词线开头的行，构成一个数组</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure>
<p>转为JavaScript如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span>]</span><br></pre></td></tr></table></figure></p>
<p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Cat</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Dog</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Goldfish</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ] ]</span><br></pre></td></tr></table></figure></p>
<p>数组也可以采用行内表示法<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">animal:</span> <span class="string">[Cat,</span> <span class="string">Dog]</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-复合结构"><a href="#4-复合结构" class="headerlink" title="4 复合结构"></a>4 复合结构</h3><p>对象和数组可以结合使用，形成复合结构。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">languages:</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Ruby</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Perl</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">Python</span> </span><br><span class="line"><span class="attr">websites:</span></span><br><span class="line"><span class="attr"> YAML:</span> <span class="string">yaml.org</span> </span><br><span class="line"><span class="attr"> Ruby:</span> <span class="string">ruby-lang.org</span> </span><br><span class="line"><span class="attr"> Python:</span> <span class="string">python.org</span> </span><br><span class="line"><span class="attr"> Perl:</span> <span class="string">use.perl.org</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">  websites: </span><br><span class="line">   &#123; <span class="attr">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">     Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">     Python: <span class="string">'python.org'</span>,</span><br><span class="line">     Perl: <span class="string">'use.perl.org'</span> &#125; &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="5-纯量"><a href="#5-纯量" class="headerlink" title="5 纯量"></a>5 纯量</h3><p>纯量是最基本的、不可再分的值。以下数据类型都属于JavaScript纯量</p>
<ul>
<li>字符串</li>
<li>布尔值</li>
<li>整数</li>
<li>浮点数</li>
<li>Null</li>
<li>时间</li>
<li>日期</li>
</ul>
<p>数值直接以字面量的形式表示。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">number:</span> <span class="number">12.30</span></span><br></pre></td></tr></table></figure>
<p>转为 JavaScript 如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">number</span>: <span class="number">12.30</span> &#125;</span><br></pre></td></tr></table></figure>
<p>布尔值用true和false表示</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">isSet:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">isSet</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p><code>null</code>用<code>~</code>表示<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">parent:</span> <span class="string">~</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>时间采用 ISO8601 格式<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">start_time:</span> <span class="number">2001</span><span class="bullet">-12</span><span class="bullet">-14</span><span class="attr">t21:59:43.10-05:00</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">iso8601</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2001-12-14t21:59:43.10-05:00'</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>日期采用复合 iso8601 格式的年、月、日表示<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">date:</span> <span class="number">1976</span><span class="bullet">-07</span><span class="bullet">-31</span></span><br></pre></td></tr></table></figure></p>
<p>转为JavaScript如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1976-07-31'</span>) &#125;</span><br></pre></td></tr></table></figure></p>
<p>YAML 允许使用两个感叹号，强制转换数据类型<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">e:</span> <span class="type">!!str</span> <span class="number">123</span></span><br><span class="line"><span class="attr">f:</span> <span class="type">!!str</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">e</span>: <span class="string">'123'</span>, <span class="attr">f</span>: <span class="string">'true'</span> &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="6-字符串"><a href="#6-字符串" class="headerlink" title="6 字符串"></a>6 字符串</h3><p>字符串是最常见，也是最复杂的一种数据类型</p>
<p>字符串默认不使用引号表示</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">这是一行字符串</span></span><br></pre></td></tr></table></figure>
<p>如果字符串之中包含空格或特殊字符，需要放在引号之中<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">str:</span> <span class="string">'内容： 字符串'</span></span><br></pre></td></tr></table></figure></p>
<h3 id="7-引用"><a href="#7-引用" class="headerlink" title="7 引用"></a>7 引用</h3><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span> <span class="meta">&amp;defaults</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line">  <span class="string">&lt;&lt;:</span> <span class="meta">*defaults</span></span><br></pre></td></tr></table></figure>
<p>等同于下面的代码<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">defaults:</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">development:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_development</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  database:</span> <span class="string">myapp_test</span></span><br><span class="line"><span class="attr">  adapter:</span>  <span class="string">postgres</span></span><br><span class="line"><span class="attr">  host:</span>     <span class="string">localhost</span></span><br></pre></td></tr></table></figure></p>
<p><code>&amp;</code>用来建立锚点（<code>defaults</code>），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点</p>
<p>下面是另一个例子<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="meta">&amp;showell</span> <span class="string">Steve</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Clark</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Brian</span> </span><br><span class="line"><span class="bullet">-</span> <span class="string">Oren</span> </span><br><span class="line"><span class="bullet">-</span> <span class="meta">*showell</span></span><br></pre></td></tr></table></figure></p>
<p>转为 JavaScript 代码如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span> ]</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/03/03/YAML学习/IBM_5100.jpg" alt=""></p>
<p><img src="/2019/03/03/YAML学习/zhizhi.jpg" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/最大子数组问题/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/最大子数组问题/" itemprop="url">最大子数组问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-20T19:51:16+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法/" itemprop="url" rel="index">
                    <span itemprop="name">算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第4章-分治策略"><a href="#第4章-分治策略" class="headerlink" title="第4章 分治策略"></a>第4章 分治策略</h2><ul>
<li><p>在分治策略中，我们递归地求解一个问题，在每层递归中运用如下三个步骤</p>
<ol>
<li><strong>分解</strong>(Divide)：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小</li>
<li><strong>解决</strong>(Comquer)：递归的求解出子问题，如果子问题的规模足够小，则停止递归，直接求解</li>
<li><strong>合并</strong>(Combine)：将子问题的解组合成原问题的解</li>
</ol>
</li>
<li><p>递归情况和基本情况</p>
<ul>
<li>当子问题足够大时，需要地柜求解，我们称之为<strong>递归情况</strong>(recursive case)</li>
<li>当子问题变得足够小，不再需要递归时，我们说递归已经”触底”，进入<strong>基本情况</strong>(base case)</li>
</ul>
</li>
<li><p>递归式</p>
<ul>
<li>一个递归式(recurrence)就是一个等式或不等式，它通过更小的输入上的函数值来描述一个函数</li>
<li>例如<br><img src="/2019/01/20/最大子数组问题/递归式例子.png" alt=""></li>
<li>三种求解递归式的方法<ul>
<li>代入法：我们猜测一个界，然后用数学归纳法证明其正确性</li>
<li>递归树法：将递归式转换为一棵树，其节点表示不同层次的递归调用的代价，然后采用边界和技术求解</li>
<li>主方法：可求解形如下式的递归式<br><img src="/2019/01/20/最大子数组问题/主方法递归式.png" alt=""></li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-1-最大子数组问题"><a href="#4-1-最大子数组问题" class="headerlink" title="4.1 最大子数组问题"></a>4.1 最大子数组问题</h3><h4 id="4-1-1-问题描述"><a href="#4-1-1-问题描述" class="headerlink" title="4.1.1 问题描述"></a>4.1.1 问题描述</h4><ul>
<li><p>寻找一个数组的<strong>和最大</strong>的非空连续子数组，这样的数组我们称为<strong>最大子数组</strong>(maximum subarray)</p>
</li>
<li><p>注意：只有<strong>当数组中包含负数</strong>时，最大子数组问题才<strong>有意义</strong>。如果所有数组元素都是非负的，最大子数组问题没有任何难度，因为整个数组的和肯定是最大的</p>
</li>
</ul>
<h4 id="4-1-2-暴力求解方法"><a href="#4-1-2-暴力求解方法" class="headerlink" title="4.1.2 暴力求解方法"></a>4.1.2 暴力求解方法</h4><ul>
<li><p>简单的尝试每对可能的{数组下标,数组上标},寻找最大值</p>
</li>
<li><p>时间复杂度:O(n<sub>2</sub>),一共有(n-1)*n/2种情况</p>
</li>
<li><p>样例</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A)</span>:</span></span><br><span class="line">    low = <span class="number">0</span></span><br><span class="line">    high = <span class="number">0</span></span><br><span class="line">    max_val = float(<span class="string">'-inf'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(A)):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, len(A)):</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> s <span class="keyword">in</span> range(i, j + <span class="number">1</span>):</span><br><span class="line">                sum += A[s]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; max_val:</span><br><span class="line">                max_val = sum</span><br><span class="line">                low = i</span><br><span class="line">                high = j</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> low, high, max_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    A = [<span class="number">13</span>, <span class="number">-3</span>, <span class="number">-25</span>, <span class="number">20</span>, <span class="number">-3</span>, <span class="number">-16</span>, <span class="number">-23</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">-7</span>, <span class="number">12</span>, <span class="number">-5</span>, <span class="number">-22</span>, <span class="number">15</span>, <span class="number">-4</span>, <span class="number">7</span>]</span><br><span class="line">    print(find_maximum_subarray(A))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">(7, 10, 43)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-1-3-使用分治策略的求解方法"><a href="#4-1-3-使用分治策略的求解方法" class="headerlink" title="4.1.3 使用分治策略的求解方法"></a>4.1.3 使用分治策略的求解方法</h4><ul>
<li><p>首先我们把数组 <code>A[low..high]</code> 划分为两个规模尽量相等的子数组: <code>A[low..mid]</code> 和 <code>A[mid+1..high]</code></p>
</li>
<li><p><code>A[low..high]</code> 的任何连续子数组<code>A[i..j]</code>所处的位置必然是一下三种情况之一,如下图</p>
<ol>
<li>完全位于子数组 <code>A[low..mid]</code> 中，因此 <code>low&lt;=i&lt;=j&lt;=mid</code></li>
<li>完全位于子数组 <code>A[mid+1..high]</code> 中，因此 <code>mid&lt;i&lt;=j&lt;=high</code></li>
<li>跨越了中点,因此 <code>low&lt;=i&lt;=mid&lt;j&lt;=high</code><br><img src="/2019/01/20/最大子数组问题/子数组的三种情况.png" alt=""></li>
</ol>
</li>
<li><p>因此 <code>A[low..high]</code> 的一个最大子数组所处的位置必定是这三种情况之一.我们可以递归的求解 <code>A[low..mid]</code> 和 <code>A[mid+1..high]</code> 的最大子数组，因为这两个子问题仍然是最大子数组问题，只是规模更小.因此，剩下的问题就是寻找跨越中点的最大子数组,然后在三种情况中选取和最大者</p>
</li>
<li><p>我们可以很容易地使用线性时间(O(n))内求出跨越中点的最大子数组，算法如下</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_max_crossing_subarray</span><span class="params">(A, low, mid, high)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">求解跨越了中点的最大子数组</span></span><br><span class="line"><span class="string">:param A: 数组</span></span><br><span class="line"><span class="string">:param low: 数组下标</span></span><br><span class="line"><span class="string">:param mid: 数组中点</span></span><br><span class="line"><span class="string">:param high: 数组上标</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"find_max_crossing_subarray:"</span>, A, low, mid, high)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里需要考虑一种特殊情况,可以忽略但不影响逻辑理解</span></span><br><span class="line"><span class="keyword">if</span> low == mid:</span><br><span class="line">    <span class="keyword">return</span> find_max_crossing_subarray_base_case(A, low)</span><br><span class="line"></span><br><span class="line">left_sum = float(<span class="string">"-inf"</span>)</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(mid, low - <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">    sum += A[i]</span><br><span class="line">    <span class="keyword">if</span> sum &gt; left_sum:</span><br><span class="line">        left_sum = sum</span><br><span class="line">        max_left = i</span><br><span class="line"></span><br><span class="line">right_sum = float(<span class="string">"-inf"</span>)</span><br><span class="line">sum = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(mid + <span class="number">1</span>, high + <span class="number">1</span>):</span><br><span class="line">    sum += A[i]</span><br><span class="line">    <span class="keyword">if</span> sum &gt; right_sum:</span><br><span class="line">        right_sum = sum</span><br><span class="line">        max_right = i</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> max_left, max_right, left_sum + right_sum</span><br></pre></td></tr></table></figure>
</li>
<li><p>有了一个线性的<code>find_max_crossing_subarray</code>在手，我们就可以设计求解最大子数组问题的分治算法了</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_maximum_subarray</span><span class="params">(A, low, high)</span>:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">通过分治方法递归的求解最大子数组</span></span><br><span class="line"><span class="string">:param A: 数组</span></span><br><span class="line"><span class="string">:param low: 数组下标</span></span><br><span class="line"><span class="string">:param high: 数组上标</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">print(<span class="string">"find_maximum_subarray:"</span>, A, low, high)</span><br><span class="line"><span class="keyword">if</span> low == high:</span><br><span class="line">    <span class="keyword">return</span> low, high, A[low]</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">    mid = int((low + high) / <span class="number">2</span>)</span><br><span class="line">    (left_low, left_high, left_sum) = find_maximum_subarray(A, low, mid)</span><br><span class="line">    (right_low, right_high, right_sum) = find_maximum_subarray(A, mid + <span class="number">1</span>, high)</span><br><span class="line">    (cross_low, cross_high, cross_sum) = find_max_crossing_subarray(A, low, mid, high)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> left_sum &gt;= right_sum <span class="keyword">and</span> left_sum &gt;= cross_sum:</span><br><span class="line">        <span class="keyword">return</span> left_low, left_high, left_sum</span><br><span class="line">    <span class="keyword">elif</span> right_sum &gt;= left_sum <span class="keyword">and</span> right_sum &gt;= cross_sum:</span><br><span class="line">        <span class="keyword">return</span> right_low, right_high, right_sum</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> cross_low, cross_high, cross_sum</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-1-4-分治算法的分析"><a href="#4-1-4-分治算法的分析" class="headerlink" title="4.1.4 分治算法的分析"></a>4.1.4 分治算法的分析</h4><ul>
<li><p>接下来我们建立一个递归式来分析分治算法<br>  <img src="/2019/01/20/最大子数组问题/分治法递归式.png" alt=""></p>
</li>
<li><p>最终可以求得时间复杂度为:O(nlgn)</p>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/20/软件测试/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="T0UGH's BLOG">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/20/软件测试/" itemprop="url">软件测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-20T18:34:31+08:00">
                2019-01-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Software-Quality-Assurance-and-Testing"><a href="#Software-Quality-Assurance-and-Testing" class="headerlink" title="Software Quality Assurance and Testing"></a>Software Quality Assurance and Testing</h2><h3 id="CH1-Overview"><a href="#CH1-Overview" class="headerlink" title="CH1 Overview"></a>CH1 Overview</h3><h4 id="1-1-About-Software-Quality-关于软件质量-P3"><a href="#1-1-About-Software-Quality-关于软件质量-P3" class="headerlink" title="1.1 About Software Quality(关于软件质量, P3)"></a>1.1 About Software Quality(关于软件质量, P3)</h4><ul>
<li>What is Quality </li>
</ul>
<h4 id="1-2-About-Software-Testing-关于软件测试-P11"><a href="#1-2-About-Software-Testing-关于软件测试-P11" class="headerlink" title="1.2 About Software Testing(关于软件测试, P11)"></a>1.2 About Software Testing(关于软件测试, P11)</h4><ul>
<li><p>Qualified rate of products(产品合格率)</p>
</li>
<li><p>Software defect(软件缺陷)</p>
<ul>
<li>What is software defect<ul>
<li>软件产品中所存在的问题，最终表现为用户所需要的功能没有完全实现，没有满足用户的要求。</li>
</ul>
</li>
<li>The Source of defects</li>
</ul>
</li>
<li><p>Software testing(软件测试)</p>
<ul>
<li>Software testing definition </li>
<li>Verification(验证）&amp;Validation(确认)<ul>
<li>The essential function of software testing is verification(验证）and validation(确认).</li>
</ul>
</li>
<li>Test &amp; debug</li>
<li>Purpose of software testing</li>
<li>Types of testing<ul>
<li>C1:按照测试生成的来源</li>
<li>C2：按照生命周期的阶段</li>
<li>C3：按照测试活动的目的</li>
<li>C4：按被测对象的特征</li>
<li>C5：按测试过程的模型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="1-3-Software-Testing-Rules-软件测试规则-P58"><a href="#1-3-Software-Testing-Rules-软件测试规则-P58" class="headerlink" title="1.3 Software Testing Rules(软件测试规则, P58)"></a>1.3 Software Testing Rules(软件测试规则, P58)</h4><ul>
<li><p>Test passing Rules(测试通过规则)</p>
</li>
<li><p>What is test case</p>
</li>
<li><p>Test case design rules</p>
</li>
<li><p>Capability for Software Tester(软件测试员的能力)</p>
</li>
</ul>
<hr>
<h3 id="CH2-System-and-Software-Quality-Engineering-and-Standards-系统和软件质量工程和标准"><a href="#CH2-System-and-Software-Quality-Engineering-and-Standards-系统和软件质量工程和标准" class="headerlink" title="CH2 System and Software Quality Engineering and Standards(系统和软件质量工程和标准)"></a>CH2 System and Software Quality Engineering and Standards(系统和软件质量工程和标准)</h3><h4 id="2-1-SQC-Concepts-and-Methods-软件质量控制的概念和方法-P70"><a href="#2-1-SQC-Concepts-and-Methods-软件质量控制的概念和方法-P70" class="headerlink" title="2.1 SQC Concepts and Methods(软件质量控制的概念和方法, P70)"></a>2.1 SQC Concepts and Methods(软件质量控制的概念和方法, P70)</h4><ul>
<li>What is Quality Control</li>
</ul>
<h4 id="2-2-SQC-Models-and-Techniques-软件质量控制的模型和技术-P92"><a href="#2-2-SQC-Models-and-Techniques-软件质量控制的模型和技术-P92" class="headerlink" title="2.2 SQC Models and Techniques(软件质量控制的模型和技术, P92)"></a>2.2 SQC Models and Techniques(软件质量控制的模型和技术, P92)</h4><ul>
<li><p>Goal question metric approach(GQM, 目标问题度量方法)</p>
</li>
<li><p>Risk management approach(风险管理, RM)</p>
</li>
<li><p>PDCA quality control approach(Plan, Do, Check, and Action)</p>
</li>
<li><p>TSQC(Total Statistical Quality Control Model based on PDCA，全面统计质量控制)</p>
</li>
</ul>
<h4 id="2-3-Software-Quality-Assurance-软件质量保证-P116"><a href="#2-3-Software-Quality-Assurance-软件质量保证-P116" class="headerlink" title="2.3 Software Quality Assurance(软件质量保证, P116)"></a>2.3 Software Quality Assurance(软件质量保证, P116)</h4><ul>
<li><p>What is Quality Assurance? </p>
</li>
<li><p>Software Quality Assurance involves</p>
</li>
<li><p>Why are we concerned with software quality assurance</p>
</li>
<li><p>SQA Methodology(SQA方法论)</p>
<ul>
<li>PPQA audits(审核)</li>
</ul>
</li>
<li><p>SQA activities</p>
</li>
<li><p>The role of SQA</p>
</li>
<li><p>Advantages of SQA</p>
</li>
<li><p>Quality Cost</p>
</li>
</ul>
<h4 id="2-4-Software-Quality-Standards-软件质量标准-P130"><a href="#2-4-Software-Quality-Standards-软件质量标准-P130" class="headerlink" title="2.4 Software Quality Standards(软件质量标准, P130)"></a>2.4 Software Quality Standards(软件质量标准, P130)</h4><ul>
<li><p>Why are software standards important?</p>
</li>
<li><p>Software Quality Standards Levels</p>
</li>
<li><p>Commonly used software quality standards</p>
<ul>
<li>ISO 9001/9000-3</li>
<li>CMM</li>
<li>CMMI</li>
<li>IEEE Software engineering standars</li>
<li>ISO/IEC TR 15504</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CH3-Software-Quality-Metrics-软件质量指标"><a href="#CH3-Software-Quality-Metrics-软件质量指标" class="headerlink" title="CH3 Software Quality Metrics(软件质量指标)"></a>CH3 Software Quality Metrics(软件质量指标)</h3><h4 id="3-1-Metrics-and-Software-Metrics-指标和软件指标-P147"><a href="#3-1-Metrics-and-Software-Metrics-指标和软件指标-P147" class="headerlink" title="3.1 Metrics and Software Metrics(指标和软件指标, P147)"></a>3.1 Metrics and Software Metrics(指标和软件指标, P147)</h4><ul>
<li><p>Measure</p>
</li>
<li><p>Measurement</p>
</li>
<li><p>Metric(指标): 系统，组件或过程拥有给定属性的程度的定量度量</p>
</li>
<li><p>Indicator</p>
</li>
<li><p>Metrics Characteristics(指标的特征)</p>
</li>
<li><p>Why do we measure(为什么衡量)</p>
</li>
<li><p>Why do we use metrics(为什么使用指标)</p>
</li>
<li><p>Metric Guidelines(指标指南)</p>
</li>
<li><p>Example Metrics(指标的例子)</p>
</li>
<li><p>Types of metrics(指标的类型)</p>
<ul>
<li>Process Metrics(过程指标)</li>
<li>Product Metrics(产品指标)</li>
<li>Project Metrics(项目指标)</li>
</ul>
</li>
<li><p>Process Metrics(过程指标)</p>
<ul>
<li>The rational way to improve any process</li>
<li>Quantitative Management(量化管理)</li>
<li>Statistical Software Process Improvement (SSPI, 统计软件过程改进)</li>
<li>Defect Removal Efficiency (DRE, 缺陷排除效率)</li>
<li>How to measure effectiveness of a software process?</li>
</ul>
</li>
<li><p>Product Metrics(产品指标)</p>
</li>
<li><p>Project Metrics(项目指标)</p>
</li>
<li><p>Types of Software Measurements</p>
<ul>
<li>Direct measures</li>
<li>Indirect measures</li>
</ul>
</li>
<li><p>Normalization of Metrics(指标的标准化)</p>
<ul>
<li>Size-oriented metrics(面向大小的指标)<ul>
<li>eg: Cost,LOC,kLOC… </li>
<li>Advantages of size oriented metrics</li>
<li>Disadvantages of size oriented metrics</li>
</ul>
</li>
<li>Function oriented metrics(面向功能的指标)<ul>
<li>Function point(功能点)</li>
<li>steps in calculating FP(计算功能点的步骤)</li>
<li>Software information domain values</li>
<li>Rate Complexity Factors(比率复杂性因素)<ul>
<li>For each complexity adjustment factor, give a rating on a scale of 0 to 5</li>
</ul>
</li>
<li>Complexity Adjustment Factors(复杂度调整因素)</li>
<li>Complexity Adjustment Value(复杂性调整价值)</li>
<li>FP Characteristics<ul>
<li>advantages</li>
<li>disadvantages</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-Software-Quality-Metrics-软件质量指标-P202"><a href="#3-2-Software-Quality-Metrics-软件质量指标-P202" class="headerlink" title="3.2 Software Quality Metrics(软件质量指标, P202)"></a>3.2 Software Quality Metrics(软件质量指标, P202)</h4><ul>
<li><p>Software Quality Metrics</p>
</li>
<li><p>Correctness</p>
</li>
<li><p>Maintainability</p>
</li>
</ul>
<hr>
<h3 id="CH4-Black-Box-Testing-黑盒测试"><a href="#CH4-Black-Box-Testing-黑盒测试" class="headerlink" title="CH4 Black-Box Testing(黑盒测试)"></a>CH4 Black-Box Testing(黑盒测试)</h3><h4 id="4-1-Introduction-P208"><a href="#4-1-Introduction-P208" class="headerlink" title="4.1 Introduction(P208)"></a>4.1 Introduction(P208)</h4><ul>
<li><p>Black-Box Testing</p>
</li>
<li><p>The advantages of black-box testing</p>
</li>
<li><p>Test case</p>
<ul>
<li>Test case must be designed follow these characteristics</li>
<li>How to design a test case?</li>
<li>Test methods<ul>
<li>Equivalence partitioning、Boundary value analysis、Decision tables、Cause-effect graphing、Orthogonal array testing、Scenario testing</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-2-Equivalence-Partitioning-等价划分-P220"><a href="#4-2-Equivalence-Partitioning-等价划分-P220" class="headerlink" title="4.2 Equivalence Partitioning(等价划分, P220)"></a>4.2 Equivalence Partitioning(等价划分, P220)</h4><ul>
<li><p>Equivalence Partition</p>
</li>
<li><p>Equivalence class definition(等价类定义)</p>
</li>
<li><p>Partition situation(划分情况)</p>
<ul>
<li>Valid equivalence class(有效等价类)</li>
<li>Invalid equivalence class(无效等价类)</li>
</ul>
</li>
<li><p>Guidelines for  generating equivalence classes for variables(等价类划分指南)</p>
</li>
<li><p>Single Fault(单一故障，故障通常单一发生)</p>
</li>
<li><p>The steps of design test case(设计测试用例的步骤)</p>
</li>
</ul>
<h4 id="4-3-Boundary-Value-Analysis-边界值分析-P246"><a href="#4-3-Boundary-Value-Analysis-边界值分析-P246" class="headerlink" title="4.3 Boundary Value Analysis(边界值分析, P246)"></a>4.3 Boundary Value Analysis(边界值分析, P246)</h4><ul>
<li><p>Boundary Value Analysis</p>
</li>
<li><p>Basic idea(基本思路)</p>
</li>
<li><p>Boundary Value Analysis is based Single fault.</p>
</li>
<li><p>Limitations of Boundary Value Analysis(边界值分析的适用范围)</p>
</li>
<li><p>Robustness Testing(稳健性测试, 边界值测试的扩展版)</p>
</li>
</ul>
<h4 id="4-4-Decision-Tables-决策表-P260"><a href="#4-4-Decision-Tables-决策表-P260" class="headerlink" title="4.4 Decision Tables(决策表, P260)"></a>4.4 Decision Tables(决策表, P260)</h4><ul>
<li><p>Decision Tables</p>
</li>
<li><p>Four portions of decision table(决策表的四个部分)</p>
</li>
</ul>
<h4 id="4-5-Cause-Effect-Graphing-因果图-P289"><a href="#4-5-Cause-Effect-Graphing-因果图-P289" class="headerlink" title="4.5 Cause-Effect Graphing(因果图, P289)"></a>4.5 Cause-Effect Graphing(因果图, P289)</h4><ul>
<li><p>What is cause-effect graphing?</p>
</li>
<li><p>Notation used in cause-effect graphing(因果图表中使用的表示法)</p>
<ul>
<li>The relations between causes and effects(因果之间的关系)<ul>
<li>Implication(等价)、Not(非)、Or(或)、And(与)</li>
</ul>
</li>
<li>Constraint(约束)<ul>
<li>Exclusive(E, 异)、Inclusive(I, 或)、One and only one(O, 唯一)、Requires(R, 要求)、Masking(M, 强制)</li>
</ul>
</li>
</ul>
</li>
<li><p>The steps of cause-effect graph design(因果图设计的步骤)</p>
</li>
<li><p>How to use cause-effect graph design test case(如何使用因果图设计测试用例)</p>
</li>
<li><p>Disadvantages of CEG test case design</p>
</li>
</ul>
<h4 id="4-6-Orthogonal-Array-Testing-正交阵列测试-P323"><a href="#4-6-Orthogonal-Array-Testing-正交阵列测试-P323" class="headerlink" title="4.6 Orthogonal Array Testing(正交阵列测试, P323)"></a>4.6 Orthogonal Array Testing(正交阵列测试, P323)</h4><ul>
<li><p>Orthogonal Array Testing</p>
</li>
<li><p>The type of experimental design methods</p>
<ul>
<li><p>Comprehensive test(综合测试, 把所有的因素都组合一遍)</p>
</li>
<li><p>Single factor test(单因素测试, 每次只变动一个因素)</p>
</li>
<li><p>Orthogonal test(正交测试)</p>
</li>
</ul>
</li>
<li><p>Orthogonal table(正交表)</p>
</li>
<li><p>Steps of orthogonal test case design</p>
</li>
</ul>
<h4 id="4-7-Scenario-Testing-场景测试-P347"><a href="#4-7-Scenario-Testing-场景测试-P347" class="headerlink" title="4.7 Scenario Testing(场景测试, P347)"></a>4.7 Scenario Testing(场景测试, P347)</h4><ul>
<li><p>Scenario Testing</p>
</li>
<li><p>The ideal scenario has five key characteristics(理想场景有五个关键特征)</p>
</li>
<li><p>flow of events(事件流)</p>
<ul>
<li>Basic flow of events(基本流)</li>
<li>Alternate flows events(备选流)</li>
</ul>
</li>
<li><p>A three-step process for generating test cases from a fully-detailed use case(从详细用例生成测试用例的三个步骤)</p>
<ul>
<li>Step One: Generate Scenarios</li>
<li>Step Two: Identify Test Cases and create a scenario matrix</li>
<li>Step Three: Identify the data values with which to test.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CH5-White-Box-Testing-白盒测试"><a href="#CH5-White-Box-Testing-白盒测试" class="headerlink" title="CH5 White-Box Testing(白盒测试)"></a>CH5 White-Box Testing(白盒测试)</h3><h4 id="5-1-Basic-Concepts-基本概念-P372"><a href="#5-1-Basic-Concepts-基本概念-P372" class="headerlink" title="5.1 Basic Concepts(基本概念, P372)"></a>5.1 Basic Concepts(基本概念, P372)</h4><ul>
<li><p>White-box testing</p>
</li>
<li><p>static testing and dynamic testing(静态白盒测试和动态白盒测试)</p>
</li>
<li><p>White-box testing must follow several principles(白盒测试的准则)</p>
</li>
<li><p>White-box Testing Difficulties(白盒测试的难度)</p>
</li>
<li><p>Why we can’t use exhaustive testing(为什么我们不能使用穷举测试)</p>
</li>
<li><p>Development of White-box Testing divided into four generations(四代白盒测试)</p>
</li>
<li><p>A Comparison on four generations of White-box Testing(四代白盒测试的比较)</p>
</li>
<li><p>白盒测试方法测试过程</p>
</li>
</ul>
<h4 id="5-2-Logic-Coverage-逻辑覆盖-P382"><a href="#5-2-Logic-Coverage-逻辑覆盖-P382" class="headerlink" title="5.2 Logic Coverage(逻辑覆盖, P382)"></a>5.2 Logic Coverage(逻辑覆盖, P382)</h4><ul>
<li><p>Statement coverage(语句覆盖, 所有程序语句都执行一遍即可)</p>
</li>
<li><p>Decision coverage(判定覆盖, 判断语句的对错)</p>
</li>
<li><p>Condition coverage(条件覆盖, 判断语句中每个条件的对错)</p>
</li>
<li><p>Condition/decision coverage(条件判断覆盖, 判断语句的对错+判断语句中每个条件的对错)</p>
</li>
<li><p>Condition combination coverage(条件组合覆盖, 使每个判断的所有可能的条件组合至少一次) </p>
</li>
<li><p>Path coverage(路径覆盖, 覆盖过程中所有可能的路径)</p>
</li>
<li><p>N-S graph</p>
</li>
</ul>
<h4 id="5-3-Control-Flow-Graph-控制流图-P406"><a href="#5-3-Control-Flow-Graph-控制流图-P406" class="headerlink" title="5.3 Control Flow Graph(控制流图, P406)"></a>5.3 Control Flow Graph(控制流图, P406)</h4><ul>
<li><p>Concept</p>
</li>
<li><p>Common control flow graph(基本控制流图)</p>
</li>
<li><p>Change a program flow chart into a control flow graph(把程序流程图改成控制流图)</p>
</li>
</ul>
<h4 id="5-4-Basis-Path-Testing-基本路径测试-P416"><a href="#5-4-Basis-Path-Testing-基本路径测试-P416" class="headerlink" title="5.4 Basis Path Testing(基本路径测试, P416)"></a>5.4 Basis Path Testing(基本路径测试, P416)</h4><ul>
<li><p>Concept</p>
</li>
<li><p>Cyclomatic Complexity(圈复杂度)</p>
</li>
<li><p>Independent Paths(独立路径)</p>
</li>
</ul>
<h4 id="5-5-Loop-Testing-循环测试-P433"><a href="#5-5-Loop-Testing-循环测试-P433" class="headerlink" title="5.5 Loop Testing(循环测试, P433)"></a>5.5 Loop Testing(循环测试, P433)</h4><ul>
<li><p>Focuses exclusively on the validity of loop constructs(专门关注循环构造的有效性)</p>
</li>
<li><p>Types of Loop(循环的类型)</p>
</li>
<li><p>Simple Loops(简单循环)</p>
</li>
<li><p>Nested Loops(嵌套循环)</p>
</li>
<li><p>Concatenated Loops(连接式循环)</p>
</li>
<li><p>Unstructured Loops(非结构化循环)</p>
</li>
</ul>
<h4 id="5-6-Data-Flow-Testing-数据流测试-P445"><a href="#5-6-Data-Flow-Testing-数据流测试-P445" class="headerlink" title="5.6 Data Flow Testing(数据流测试, P445)"></a>5.6 Data Flow Testing(数据流测试, P445)</h4><ul>
<li><p>data flow testing(数据流测试)</p>
</li>
<li><p>data flow graph(数据流图)</p>
</li>
<li><p>define-use-kill patterns</p>
</li>
<li><p>Static Data Flow Testing</p>
</li>
<li><p>Dynamic Data Flow Testing</p>
</li>
</ul>
<h4 id="5-7-Mutation-Testing-变异测试-P458"><a href="#5-7-Mutation-Testing-变异测试-P458" class="headerlink" title="5.7 Mutation Testing(变异测试,P458)"></a>5.7 Mutation Testing(变异测试,P458)</h4><ul>
<li><p>Mutation Testing: 用来衡量软件测试的质量</p>
</li>
<li><p>We use mutation analysis for testing to</p>
</li>
<li><p>Mutation Testing is capable of testing software at</p>
</li>
<li><p>Fundamental Premise (基本前提) of Mutation Testing</p>
</li>
<li><p>Mutation and Mutants（变异体）</p>
</li>
<li><p>Mutation operators（变异算子）</p>
</li>
<li><p>First-order mutants And Higher-order mutants(一阶变异体和高阶变异体)</p>
</li>
<li><p>Syntax and semantics of mutants(突变体的句法和语义<br>)</p>
</li>
<li><p>Strong mutation testing &amp; Weak mutation testing</p>
</li>
<li><p>Procedure for test-adequacy assessment(测试充分性评估的步骤)</p>
</li>
</ul>
<h4 id="5-8-A-Comparison-of-White-box-Testing-and-Black-box-Testing-白盒和黑盒测试的比较-P491"><a href="#5-8-A-Comparison-of-White-box-Testing-and-Black-box-Testing-白盒和黑盒测试的比较-P491" class="headerlink" title="5.8 A Comparison of White-box Testing and Black-box Testing(白盒和黑盒测试的比较, P491)"></a>5.8 A Comparison of White-box Testing and Black-box Testing(白盒和黑盒测试的比较, P491)</h4><hr>
<h3 id="CH6-Unit-Testing-单元测试"><a href="#CH6-Unit-Testing-单元测试" class="headerlink" title="CH6 Unit Testing(单元测试)"></a>CH6 Unit Testing(单元测试)</h3><h4 id="6-1-What-is-Unit-Testing-P495"><a href="#6-1-What-is-Unit-Testing-P495" class="headerlink" title="6.1 What is Unit Testing(P495)"></a>6.1 What is Unit Testing(P495)</h4><ul>
<li><p>Unit testing</p>
</li>
<li><p>Basic attributes of unit testing(单元测试基本属性)</p>
</li>
<li><p>Purpose of unit testing(单元测试的目的)</p>
</li>
<li><p>单元测试的过程</p>
</li>
<li><p>Benefits</p>
</li>
<li><p>Static testing And Dynamic testing</p>
</li>
<li><p>Misunderstanding about unit testing(对单元测试的误解)</p>
</li>
</ul>
<h4 id="6-2-Unit-Testing-Strategies-P509"><a href="#6-2-Unit-Testing-Strategies-P509" class="headerlink" title="6.2 Unit Testing Strategies(P509)"></a>6.2 Unit Testing Strategies(P509)</h4><ul>
<li><p>Stub(桩)</p>
</li>
<li><p>Driver module(驱动模块)</p>
</li>
<li><p>Top-down unit testing strategy</p>
</li>
<li><p>Bottom-up unit testing strategy</p>
</li>
<li><p>Isolation testing(隔离测试) </p>
</li>
</ul>
<h4 id="6-3-Unit-Testing-Analysis-P513"><a href="#6-3-Unit-Testing-Analysis-P513" class="headerlink" title="6.3 Unit Testing Analysis(P513)"></a>6.3 Unit Testing Analysis(P513)</h4><ul>
<li>Considered aspect of unit testing(单元测试需要考虑的方面)</li>
</ul>
<h4 id="6-4-Unit-Testing-Guidelines-27个原则-P514"><a href="#6-4-Unit-Testing-Guidelines-27个原则-P514" class="headerlink" title="6.4 Unit Testing Guidelines(27个原则, P514)"></a>6.4 Unit Testing Guidelines(27个原则, P514)</h4><h4 id="6-5-How-to-use-JUnit-P525"><a href="#6-5-How-to-use-JUnit-P525" class="headerlink" title="6.5 How to use JUnit(P525)"></a>6.5 How to use JUnit(P525)</h4><ul>
<li><p>Tools of Unit test</p>
</li>
<li><p>JUnit features include(JUnit功能包括)</p>
</li>
<li><p>Test Fixtures(测试装置)</p>
</li>
<li><p>Test Suites(测试套件)</p>
</li>
<li><p>Test Execution(测试运行)</p>
</li>
<li><p>Assertions(断言)</p>
</li>
<li><p>Criteria for test methods(测试方法必须遵循的条件)</p>
</li>
<li><p>How JUnit run a test</p>
</li>
</ul>
<hr>
<h3 id="CH7-Integration-Testing"><a href="#CH7-Integration-Testing" class="headerlink" title="CH7 Integration Testing"></a>CH7 Integration Testing</h3><h4 id="7-1-Integration-Testing-Introduction-集成测试介绍-P554"><a href="#7-1-Integration-Testing-Introduction-集成测试介绍-P554" class="headerlink" title="7.1 Integration Testing Introduction(集成测试介绍, P554)"></a>7.1 Integration Testing Introduction(集成测试介绍, P554)</h4><ul>
<li><p>Test、Software development、Gray Box Testing</p>
</li>
<li><p>Integration testing</p>
</li>
<li><p>Integration testing VS Unit testing</p>
</li>
<li><p>Integration testing VS System testing</p>
</li>
<li><p>The purpose of integration testing(集成测试的目的)</p>
</li>
<li><p>The major advantages of integration testing(集成测试的好处)</p>
</li>
<li><p>Major testing focuses(主要测试重点)</p>
</li>
<li><p>Integration Testing Steps(集成测试步骤)</p>
</li>
<li><p>决定重复测试周期的次数和总集成时间的因素</p>
</li>
<li><p>When to complete the integration testing</p>
</li>
<li><p>Integration testing features(集成测试特点)</p>
</li>
<li><p>The relationship between integration testing and development(集成测试与开发的关系)</p>
</li>
<li><p>When to carry out the integration testing(什么时候开始集成测试)</p>
</li>
<li><p>Integration testing levels(集成测试等级)</p>
</li>
</ul>
<h4 id="7-2-Integration-Testing-Strategy-集成测试策略-P575"><a href="#7-2-Integration-Testing-Strategy-集成测试策略-P575" class="headerlink" title="7.2 Integration Testing Strategy(集成测试策略, P575)"></a>7.2 Integration Testing Strategy(集成测试策略, P575)</h4><ul>
<li><p>Integration testing can be divided into two categories(集成测试基本策略分类)</p>
</li>
<li><p>Instantaneous vs. incremental integration testing</p>
</li>
<li><p>Big bang（大爆炸） integration </p>
</li>
<li><p>Top-down （自顶向下）integration </p>
</li>
<li><p>Bottom-up （自底向上）integration </p>
</li>
<li><p>Sandwich（三明治） integration </p>
</li>
<li><p>Layers（分层） integration </p>
</li>
<li><p>High-frequency （高频）integration </p>
</li>
<li><p>Event-based（基于事件） integration</p>
</li>
</ul>
<h4 id="7-3-Integration-Testing-Analysis-集成测试分析-P621"><a href="#7-3-Integration-Testing-Analysis-集成测试分析-P621" class="headerlink" title="7.3 Integration Testing Analysis(集成测试分析, P621)"></a>7.3 Integration Testing Analysis(集成测试分析, P621)</h4><ul>
<li><p>The concern contents of integration testing(集成测试关注)</p>
</li>
<li><p>Architecture Analysis(体系结构分析)</p>
</li>
<li><p>Module analysis(模块分析) </p>
</li>
<li><p>Interface analysis(接口分析) </p>
</li>
<li><p>Testability analysis(可测试性分析) </p>
</li>
<li><p>Integration testing strategy analysis(集成测试策略分析) </p>
</li>
<li><p>Common integration testing fault(常见的集成测试错误)  </p>
</li>
</ul>
<h4 id="7-4-Test-Case-Design-of-Integration-Testing-集成测试的测试用例设计-P637"><a href="#7-4-Test-Case-Design-of-Integration-Testing-集成测试的测试用例设计-P637" class="headerlink" title="7.4 Test Case Design of Integration Testing(集成测试的测试用例设计, P637)"></a>7.4 Test Case Design of Integration Testing(集成测试的测试用例设计, P637)</h4><ul>
<li><p>For the operation of the system design test cases.(为系统的操作设计测试用例)</p>
</li>
<li><p>Design test cases for positive testing.(设计正向测试测试用例)</p>
</li>
<li><p>Design test cases for reverse testing.(设计反向测试测试用例)</p>
</li>
<li><p>Design test cases for special requirement.(根据特殊要求设计测试用例)</p>
</li>
<li><p>Design test case for meet coverage.(设计符合覆盖率的测试用例)</p>
</li>
<li><p>Test cases complement.(测试用例补充)</p>
</li>
</ul>
<h4 id="7-5-Integration-Testing-Process-P649"><a href="#7-5-Integration-Testing-Process-P649" class="headerlink" title="7.5 Integration Testing Process(P649)"></a>7.5 Integration Testing Process(P649)</h4><ul>
<li>The process of integration testing can be divided into four stages</li>
</ul>
<h4 id="7-6-Integration-Testing-Environment-集成测试环境-P650"><a href="#7-6-Integration-Testing-Environment-集成测试环境-P650" class="headerlink" title="7.6 Integration Testing Environment(集成测试环境, P650)"></a>7.6 Integration Testing Environment(集成测试环境, P650)</h4><ul>
<li>In considering integration testing environment, follow several aspects</li>
</ul>
<h4 id="7-7-Principle-of-Integration-Testing-集成测试原则-P654"><a href="#7-7-Principle-of-Integration-Testing-集成测试原则-P654" class="headerlink" title="7.7 Principle of Integration Testing(集成测试原则, P654)"></a>7.7 Principle of Integration Testing(集成测试原则, P654)</h4><hr>
<h3 id="CH8-System-Testing-系统测试"><a href="#CH8-System-Testing-系统测试" class="headerlink" title="CH8 System Testing(系统测试)"></a>CH8 System Testing(系统测试)</h3><h4 id="8-1-System-Testing-Concepts-P657"><a href="#8-1-System-Testing-Concepts-P657" class="headerlink" title="8.1 System Testing Concepts(P657)"></a>8.1 System Testing Concepts(P657)</h4><ul>
<li><p>System Testing</p>
</li>
<li><p>Why system testing is necessary?</p>
</li>
<li><p>System testing process</p>
</li>
</ul>
<h4 id="8-2-System-Testing-Methods-P666"><a href="#8-2-System-Testing-Methods-P666" class="headerlink" title="8.2 System Testing Methods(P666)"></a>8.2 System Testing Methods(P666)</h4><ul>
<li><p>GUI software testing(GUI测试)</p>
</li>
<li><p>Usability testing(可用性测试)</p>
</li>
<li><p>Performance testing(性能测试)</p>
</li>
<li><p>Stress testing(压力测试)</p>
</li>
<li><p>Volume testing(容量测试)</p>
</li>
<li><p>Load testing(负载测试)</p>
</li>
<li><p>Compatibility testing(兼容性测试)</p>
</li>
<li><p>Recovery testing(恢复测试)</p>
</li>
</ul>
<h4 id="8-3-System-Testing-process-P696"><a href="#8-3-System-Testing-process-P696" class="headerlink" title="8.3 System Testing process(P696)"></a>8.3 System Testing process(P696)</h4><ul>
<li>Deming Cycle(戴明环, 也叫PDCA)</li>
</ul>
<hr>
<h3 id="CH9-Performance-Testing-性能测试"><a href="#CH9-Performance-Testing-性能测试" class="headerlink" title="CH9 Performance Testing(性能测试)"></a>CH9 Performance Testing(性能测试)</h3><h4 id="9-1-What-is-performance-什么是性能-P705"><a href="#9-1-What-is-performance-什么是性能-P705" class="headerlink" title="9.1 What is performance?(什么是性能, P705)"></a>9.1 What is performance?(什么是性能, P705)</h4><ul>
<li><p>Performance(性能)</p>
</li>
<li><p>Commonly used performance indicators(常用的性能指标)</p>
<ul>
<li>Latency(延迟)</li>
<li>Transaction processing time:(事务处理时间)</li>
<li>Maximum transaction processing time(最大事务处理时间)</li>
<li>Transaction operating time(事务操作时间)</li>
<li>Database performance (数据库性能)</li>
<li>The largest consumption of memory (最大内存消耗)</li>
<li>Resource consumption(资源消耗)</li>
<li>Peak time of memory(高峰内存时间)</li>
<li>Response time(响应时间)</li>
<li>System response time(系统响应时间)</li>
<li>Present time(呈现时间)</li>
<li>Concurrent users(并发用户数)</li>
<li>Throughput(吞吐量)</li>
<li>Performance counters and resource utilization(性能计数器和资源利用率)</li>
<li>Dormancy time(休眠时间)</li>
</ul>
</li>
</ul>
<h4 id="9-2-What-is-performance-testing-什么是性能测试-P737"><a href="#9-2-What-is-performance-testing-什么是性能测试-P737" class="headerlink" title="9.2 What is performance testing?(什么是性能测试, P737)"></a>9.2 What is performance testing?(什么是性能测试, P737)</h4><ul>
<li><p>performance testing</p>
</li>
<li><p>Performance testing profiles(性能测试的配置)</p>
</li>
<li><p>Load Testing(负载测试)</p>
</li>
<li><p>Load testing loading mode(负载测试的加载模式)</p>
<ul>
<li>One-time loading(一次性加载)</li>
<li>Increasing loading(递增加载)</li>
<li>High and low mutation loading(高低突变加载)</li>
<li>Random loading method(随机加载方式)</li>
</ul>
</li>
<li><p>Stress Testing(压力测试)</p>
</li>
</ul>
<h4 id="9-3-What-are-the-types-of-performance-tests-性能测试的种类-P751"><a href="#9-3-What-are-the-types-of-performance-tests-性能测试的种类-P751" class="headerlink" title="9.3 What are the types of performance tests?(性能测试的种类, P751)"></a>9.3 What are the types of performance tests?(性能测试的种类, P751)</h4><ul>
<li>The three most common types of software performance testing include(最常见的三个类型的软件性能测试包括)</li>
</ul>
<h4 id="9-4-How-to-conduct-performance-testing-如何进行性能测试-P753"><a href="#9-4-How-to-conduct-performance-testing-如何进行性能测试-P753" class="headerlink" title="9.4 How to conduct performance testing?(如何进行性能测试, P753)"></a>9.4 How to conduct performance testing?(如何进行性能测试, P753)</h4><ul>
<li><p>The process of performance testing?(性能测试过程：计划，记录，修改，执行，分析)</p>
</li>
<li><p>Step1:Planning</p>
<ul>
<li>Understanding load(了解系统的负载情况)</li>
<li>Load (Operational) Profile(建立负载概况)</li>
<li>Test Sample Sizes(测试样本的大小)</li>
<li>Sampling Errors(抽样误差)</li>
<li>Number and types of users(用户的数量和类型)</li>
<li>The number of users on the site will vary based on many factors(网站中用户数量的变化基于很多要素)</li>
<li>Testing types and metrics needed(需要的测试的类型和量度)</li>
</ul>
</li>
<li><p>Step2-Step4</p>
<ul>
<li>An abstract architecture for performance testing tools(一个性能测试工具抽象的结构包括：控制器，负载生成器，性能监视器，分析器，虚拟用户生成器)</li>
<li>profiler(检验器)</li>
<li>Virtual users generator (虚拟用户生成器)</li>
<li>Controller (控制器)</li>
<li>Load Generator(负载生成器)</li>
<li>Analysis(分析器)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="CH11-Testing-Management"><a href="#CH11-Testing-Management" class="headerlink" title="CH11 Testing Management"></a>CH11 Testing Management</h3><h4 id="11-1-Test-Metrics-测试指标-P776"><a href="#11-1-Test-Metrics-测试指标-P776" class="headerlink" title="11.1 Test Metrics(测试指标, P776)"></a>11.1 Test Metrics(测试指标, P776)</h4><ul>
<li><p>A classification of various types of metrics(度量标准的分类)</p>
</li>
<li><p>Four general core areas that assist in the design of metrics(协助度量标准设计的四个通用核心领域)</p>
</li>
<li><p>Organization metrics(组织度量)</p>
</li>
<li><p>Project metrics(项目指标)</p>
</li>
<li><p>Process metrics(过程度量)</p>
</li>
<li><p>Product metrics: Generic(产品度量：一般)</p>
</li>
<li><p>Product metrics: OO software(产品度量：OO软件)</p>
</li>
<li><p>Testability(可测试性)</p>
</li>
</ul>
<h4 id="11-2-Defect-Management-缺陷测试-P787"><a href="#11-2-Defect-Management-缺陷测试-P787" class="headerlink" title="11.2 Defect Management(缺陷测试, P787)"></a>11.2 Defect Management(缺陷测试, P787)</h4><ul>
<li><p>Defect management(缺陷管理)</p>
</li>
<li><p>Status associated with a defect(与缺陷相关的状态)</p>
</li>
<li><p>The structure of report a defect(报告缺陷的结构)</p>
<ul>
<li>Title</li>
<li>Description</li>
<li>Repro Steps(重现步骤)</li>
<li>Actual Results(实际结果)</li>
<li>Expected Results(预期结果)</li>
<li>Test Environment(测试环境)</li>
</ul>
</li>
<li><p>Defect Life Cycle(缺陷生命周期)</p>
</li>
<li><p>Defect Life Cycle Paths(缺陷生命周期路径)</p>
</li>
</ul>
<h4 id="11-3-Software-Testing-Life-Cycle-软件测试生命周期-P802"><a href="#11-3-Software-Testing-Life-Cycle-软件测试生命周期-P802" class="headerlink" title="11.3 Software Testing Life Cycle(软件测试生命周期, P802)"></a>11.3 Software Testing Life Cycle(软件测试生命周期, P802)</h4><ul>
<li><p>Test planning(测试计划)</p>
<ul>
<li>Parts of Test Planning</li>
</ul>
</li>
<li><p>Test design(测试设计)</p>
<ul>
<li>Test design techniques(测试设计技巧)</li>
<li>Categories of test design techniques(测试设计技巧分类)</li>
</ul>
</li>
<li><p>Test development(测试开发)</p>
</li>
<li><p>Test execution(测试执行)</p>
</li>
<li><p>Test evaluation(测试评价)</p>
</li>
</ul>
<h4 id="11-4-Basic-Knowledge-about-Software-Testing-Automation-自动化测试基础知识-P811"><a href="#11-4-Basic-Knowledge-about-Software-Testing-Automation-自动化测试基础知识-P811" class="headerlink" title="11.4 Basic Knowledge about Software Testing Automation(自动化测试基础知识, P811)"></a>11.4 Basic Knowledge about Software Testing Automation(自动化测试基础知识, P811)</h4><ul>
<li><p>What is test automation?(什么是自动化测试)</p>
</li>
<li><p>Automated testing(自动化测试)</p>
</li>
<li><p>Which type of test can be automated(什么样的测试可以被自动化)</p>
</li>
<li><p>The advantages of automated testing(自动化测试的优点)</p>
</li>
<li><p>Disadvantages of automated testing(自动化测试的缺点)</p>
</li>
<li><p>Manual Testing vs Automated Testing(手工测试 vs 自动化测试)</p>
</li>
</ul>
<h4 id="11-5-Automated-Testing-Tools-自动化测试工具-P824"><a href="#11-5-Automated-Testing-Tools-自动化测试工具-P824" class="headerlink" title="11.5 Automated Testing Tools(自动化测试工具, P824)"></a>11.5 Automated Testing Tools(自动化测试工具, P824)</h4><ul>
<li><p>Automated Test Lifecycle Methodology(自动化测试生命周期方法)</p>
</li>
<li><p>Process Of Test Tools Import(导入测试工具的过程)</p>
</li>
<li><p>Misconceptions(对于自动化测试的误解) </p>
</li>
<li><p>Choosing Automation Tools(选择自动化工具)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
