<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/24/MyBatis源码-3-映射文件的解析过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/24/MyBatis源码-3-映射文件的解析过程/" itemprop="url">[MyBatis源码][3][映射文件的解析过程]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-24T11:13:07+08:00">
                2020-03-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/24/MyBatis源码-3-映射文件的解析过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/24/MyBatis源码-3-映射文件的解析过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章-映射文件解析"><a href="#第三章-映射文件解析" class="headerlink" title="第三章 映射文件解析"></a>第三章 映射文件解析</h2><h3 id="3-1-映射文件解析入口"><a href="#3-1-映射文件解析入口" class="headerlink" title="3.1 映射文件解析入口"></a>3.1 映射文件解析入口</h3><p><strong>映射文件的解析</strong>过程是<strong>配置文件解析</strong>过程的<strong>一部分</strong>， MyBatis会在解析配置文件的过程中对映射文件进行解析。解析逻辑封装在<code>mapperElement()</code>方法中，我们把这个方法作为本章的总入口方法。</p>
<p>这个方法主要对<code>&lt;mappers&gt;</code>的每个子节点，按照不同的类型和属性，进行不同方式的解析，具体分派过程我放在源代码的注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.0</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//一、解析&lt;package&gt;子节点</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">                String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">                configuration.addMappers(mapperPackage);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//二、解析&lt;mapper&gt;子节点</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//获取&lt;mapper&gt;节点的resource、url、mapperClass属性</span></span><br><span class="line">                String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">                String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">                String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//根据读取到的属性哪几个为空，来选择不同的解析方式，总共有4条路</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//① 根据resource解析</span></span><br><span class="line">                <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    ErrorContext.instance().resource(resource);</span><br><span class="line">                    InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">                    </span><br><span class="line">                    XMLMapperBuilder mapperParser </span><br><span class="line">                        = <span class="keyword">new</span> XMLMapperBuilder(inputStream, </span><br><span class="line">                                             configuration, </span><br><span class="line">                                             resource,</span><br><span class="line">                                             configuration.getSqlFragments());</span><br><span class="line">                    </span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//② 根据url解析    </span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">                </span><br><span class="line">                    ErrorContext.instance().resource(url);</span><br><span class="line">                    InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">                    </span><br><span class="line">                    XMLMapperBuilder mapperParser </span><br><span class="line">                        = <span class="keyword">new</span> XMLMapperBuilder(inputStream,</span><br><span class="line">                                               configuration,</span><br><span class="line">                                               url,</span><br><span class="line">                                               configuration.getSqlFragments());</span><br><span class="line">                    </span><br><span class="line">                    mapperParser.parse();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//③ 根据mapperClass解析</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    </span><br><span class="line">                    Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">                    configuration.addMapper(mapperInterface);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//④ 都没有就直接报错    </span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only"</span></span><br><span class="line">                                               + <span class="string">"specify a url, resource or class,"</span> </span><br><span class="line">                                               + <span class="string">"but not more than one."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码段<code>3.0</code>中，我们可以看出，对于某个节点的解析逻辑，主要放在<code>XMLMapperBuilder</code>的<code>parse()</code>方法中，这个<code>parse()</code>方法主要包含如下几步</p>
<ol>
<li><code>mapper</code>节点的具体解析过程</li>
<li>将这个节点设置为已加载</li>
<li>通过命名空间绑定<code>Mapper</code>接口</li>
<li>处理各个未完成解析的节点</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.1</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="comment">//Mapper的解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//如果配置文件没有被加载过，就开始对这个XMLMapperBuilder进行解析</span></span><br><span class="line">    <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//① mapper节点的具体解析过程</span></span><br><span class="line">        configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//② 将资源设置为已经加载</span></span><br><span class="line">        configuration.addLoadedResource(resource);</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//③ 通过命名空间绑定Mapper接口</span></span><br><span class="line">        bindMapperForNamespace();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//④ 解析各个未完成解析的节点</span></span><br><span class="line">    parsePendingResultMaps();</span><br><span class="line">    parsePendingCacheRefs();</span><br><span class="line">    parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-解析映射文件"><a href="#3-2-解析映射文件" class="headerlink" title="3.2 解析映射文件"></a>3.2 解析映射文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.2</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="comment">//对于单个mapper节点的具体解析过程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//① 获得mapper命名空间</span></span><br><span class="line">        String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//② 判断命名空间是否为空，为空报异常</span></span><br><span class="line">        <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//③ 设置当前命名空间</span></span><br><span class="line">        builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//④ 解析&lt;cache-ref&gt;节点</span></span><br><span class="line">        cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑤ 解析&lt;cache&gt;节点</span></span><br><span class="line">        cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑥ 解析所有&lt;parameterMap&gt;节点，parameterMap主要考虑到可能传入sql的参数过于复杂</span></span><br><span class="line">        parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑦ 解析所有&lt;resultMap&gt;节点</span></span><br><span class="line">        resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑧ 解析所有&lt;sql&gt;节点</span></span><br><span class="line">        sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑨ 解析所有&lt;select|insert|update|delete&gt;节点</span></span><br><span class="line">        buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> </span><br><span class="line">                                   + resource </span><br><span class="line">                                   + <span class="string">"'. Cause: "</span> </span><br><span class="line">                                   + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上述代码段，我们可以得知，<code>configurationElement()</code>主要对单个<code>&lt;mapper&gt;</code>节点的各个类型的子节点进行解析，包括<code>&lt;cache&gt;</code>、<code>&lt;cache-ref&gt;</code>、<code>&lt;parameterMap&gt;</code>、<code>&lt;resultMap&gt;</code>、<code>&lt;sql&gt;</code>、<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>等子节点。在本节的剩余部分，我们将挑选几个有特点的<code>&lt;mapper&gt;</code>节点的子节点进行解析。</p>
<h4 id="3-2-1-解析-lt-cache-gt-节点"><a href="#3-2-1-解析-lt-cache-gt-节点" class="headerlink" title="3.2.1 解析&lt;cache&gt;节点"></a>3.2.1 解析<code>&lt;cache&gt;</code>节点</h4><p>MyBatis提供了一、二级缓存，其中一级缓存是<code>SqlSession</code>级别的，默认为开启状态。二级缓存配置在映射文件中，使用者需要显式配置才能开启。</p>
<p>下面的代码段给出了一个配置二级缓存的例子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.3--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span> </span></span><br><span class="line"><span class="tag">       <span class="attr">eviction</span>=<span class="string">"FIFO"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">flushInterval</span>=<span class="string">"60000"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">"512"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么我们废话少说，从代码块<code>3.2</code>的22行<code>cacheElement(context.evalNode(&quot;cache&quot;));</code>向下，具体分析<code>cacheElement()</code>方法的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.4</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//① 取得&lt;cache&gt;节点的各个属性</span></span><br><span class="line">        String type = context.getStringAttribute(<span class="string">"type"</span>, <span class="string">"PERPETUAL"</span>);</span><br><span class="line">        Class&lt;? extends Cache&gt; typeClass = typeAliasRegistry.resolveAlias(type);</span><br><span class="line">        </span><br><span class="line">        String eviction = context.getStringAttribute(<span class="string">"eviction"</span>, <span class="string">"LRU"</span>);</span><br><span class="line">        Class&lt;? extends Cache&gt; evictionClass =	</span><br><span class="line">            typeAliasRegistry.resolveAlias(eviction);</span><br><span class="line">        </span><br><span class="line">        Long flushInterval = context.getLongAttribute(<span class="string">"flushInterval"</span>);</span><br><span class="line">        </span><br><span class="line">        Integer size = context.getIntAttribute(<span class="string">"size"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> readWrite = !context.getBooleanAttribute(<span class="string">"readOnly"</span>, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> blocking = context.getBooleanAttribute(<span class="string">"blocking"</span>, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//② 取得各个节点的子节点配置，其实还是一些属性</span></span><br><span class="line">        Properties props = context.getChildrenAsProperties();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//③ 调用MapperBuilderAssistant这个助手类，构建一个新的缓存，并存入Configuration中</span></span><br><span class="line">        builderAssistant.useNewCache(typeClass,</span><br><span class="line">                                     evictionClass,</span><br><span class="line">                                     flushInterval,</span><br><span class="line">                                     size,</span><br><span class="line">                                     readWrite,</span><br><span class="line">                                     blocking,</span><br><span class="line">                                     props);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cacheElement</code>方法的逻辑还是比较简单的，它从<code>&lt;cache&gt;</code>节点上读取各种配置，然后使用这些配置。调用<code>Mapper</code>建造助手来构建一个新的缓存。下面我们从这个代码段的27行<code>builderAssistant.useNewCache(typeClass,evictionClass,flushInterval,size,readWrite,blocking,props);</code>向下，具体分析缓存的构造过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.5</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder;</span></span><br><span class="line"><span class="comment">//MapperBuilderAssistant</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">useNewCache</span><span class="params">(Class&lt;? extends Cache&gt; typeClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Class&lt;? extends Cache&gt; evictionClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Long flushInterval,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Integer size,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> readWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">boolean</span> blocking,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Properties props)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//① 使用CacheBuilder，它是一个Cache的建造者，来一步一步建造一个Cache</span></span><br><span class="line">    Cache cache = <span class="keyword">new</span> CacheBuilder(currentNamespace)</span><br><span class="line">        .implementation(valueOrDefault(typeClass, PerpetualCache.class))</span><br><span class="line">        .addDecorator(valueOrDefault(evictionClass, LruCache.class))</span><br><span class="line">        .clearInterval(flushInterval)</span><br><span class="line">        .size(size)</span><br><span class="line">        .readWrite(readWrite)</span><br><span class="line">        .blocking(blocking)</span><br><span class="line">        .properties(props)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//② 将这个新建好的Cache加入Configuration的Cache池中存放</span></span><br><span class="line">    configuration.addCache(cache);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//③ 没啥用</span></span><br><span class="line">    currentCache = cache;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在我们继续深入源代码之前，首先我想介绍一个Mybatis的<code>Cache</code>接口极其实现类的设计。它使用一个装饰器模式。首先<code>Cache</code>接口有一个普通实现，<code>PerpetualCache</code>，它仅提供最基本的缓存功能，如果还需要其他功能，就需要将这个类作为<code>delegate</code>，包装到<code>Cache</code>接口的其他装饰器，例如，若我们想让<code>Cache</code>具有日志功能，就使用<code>LoggingCache</code>。下图展示了<code>Cache</code>接口的大量实现。</p>
<p><img src="https://i.loli.net/2020/03/21/AHKVodpUer1SyZ5.png" alt=""></p>
<p>在了解了<code>Cache</code>接口的设计后，我们从<code>3.5</code>代码段的第21行<code>CacheBuilder.build()</code>向下，看看<code>build()</code>具体做了什么工作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.6</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//CacheBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cache <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//① 设置默认的缓存类型和缓存装饰器</span></span><br><span class="line">    setDefaultImplementations();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//② 通过反射的方式，根据Class类的实例implementation来选择Cache接口合适的实现类来创建Cache</span></span><br><span class="line">    Cache cache = newBaseCacheInstance(implementation, id);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//③ 根据用户定义，设置这个cache的属性</span></span><br><span class="line">    setCacheProperties(cache);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// issue #352, do not apply decorators to custom caches</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//④ 若这个cache是PropertualCache(Cache的默认实现，没有任何装饰器)，则为它配置默认装饰器</span></span><br><span class="line">    <span class="keyword">if</span> (PerpetualCache.class.equals(cache.getClass())) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;? extends Cache&gt; decorator : decorators) &#123;</span><br><span class="line">            cache = newCacheDecoratorInstance(decorator, cache);</span><br><span class="line">            setCacheProperties(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        cache = setStandardDecorators(cache);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//⑤. 如果这个cache没有使用任何日志装饰器，则加一个日志装饰器</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!LoggingCache.class.isAssignableFrom(cache.getClass())) &#123;</span><br><span class="line">        cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第13行的<code>setCacheProperties(cache);</code>主要将<code>&lt;cache&gt;</code>节点的各个<code>&lt;property&gt;</code>子节点设置进<code>Cache</code>的具体实现中，这个没什么可分析的，跳过它。这里，我们继续分析23行的<code>cache = setStandardDecorators(cache);</code>看看<code>PerpetualCache</code>都会被设置哪些标准装饰器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.7</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//CacheBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Cache <span class="title">setStandardDecorators</span><span class="params">(Cache cache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//① 将size属性设置进PerpetualCache实例中</span></span><br><span class="line">        MetaObject metaCache = SystemMetaObject.forObject(cache);</span><br><span class="line">        <span class="keyword">if</span> (size != <span class="keyword">null</span> &amp;&amp; metaCache.hasSetter(<span class="string">"size"</span>)) &#123;</span><br><span class="line">            metaCache.setValue(<span class="string">"size"</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//② 如果前面代码清单3.4传入的clearInterval不为空，则加一个ScheduledCache`</span></span><br><span class="line">        <span class="keyword">if</span> (clearInterval != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> ScheduledCache(cache);</span><br><span class="line">            ((ScheduledCache) cache).setClearInterval(clearInterval);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//③ 如果readWrite标志开启，也就是读写锁功能开启，则加一个SerializedCache</span></span><br><span class="line">        <span class="keyword">if</span> (readWrite) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> SerializedCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//④ 加一个LoggingCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> LoggingCache(cache);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑤ 加一个SynchronizedCache</span></span><br><span class="line">        cache = <span class="keyword">new</span> SynchronizedCache(cache);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//⑥ 如果blocking标记开启，加一个BlockingCache</span></span><br><span class="line">        <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            cache = <span class="keyword">new</span> BlockingCache(cache);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//⑦ 返回这个装饰过后的cache</span></span><br><span class="line">        <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合上述代码，这里画一个图，来表示标准装饰器的装饰顺序</p>
<p><img src="https://i.loli.net/2020/03/21/AWavRPJoXM6Tpt7.png" alt=""></p>
<h4 id="3-2-2-解析-lt-resultMap-gt-节点"><a href="#3-2-2-解析-lt-resultMap-gt-节点" class="headerlink" title="3.2.2 解析&lt;resultMap&gt;节点"></a>3.2.2 解析<code>&lt;resultMap&gt;</code>节点</h4><p>对于<code>resultMap</code>，引用官方文档的一段话，来说明其强大作用。</p>
<blockquote>
<p>resultMap元素是MyBatis中最重要最强大的元素。它可以让你从90%的 JDBC ResultSet数据提取代码中解放出来，并在一些情形下允许你做一些JBC不支持的事情。实际上，在对复杂语句进行联合映射的时候，它很可能可以代替数千行的同等功能的代码。 ResultMap的设计思想是，简单的语句不需要明确的结果映射，而复杂一点的语句只需要描述它们的关系就行了。</p>
</blockquote>
<p>在分析源代码之前我们使用一个复杂的<code>resultMap</code>的例子来展示它的强大功能</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.8--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resulpMap</span> <span class="attr">type</span>=<span class="string">"com.edu.neu.pojo.Employee"</span> <span class="attr">id</span>=<span class="string">"employee"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">javaType</span>=<span class="string">"int"</span> <span class="attr">jdbcType</span>=<span class="string">"INT"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"real_name"</span> <span class="attr">property</span>=<span class="string">"realName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"real_name"</span> <span class="attr">property</span>=<span class="string">"realName"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"sex"</span> <span class="attr">property</span>=<span class="string">"sex"</span> <span class="attr">typeHandler</span>=<span class="string">"com.edu.neu.Handler.SexTypeHandler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"workCard"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"com.edu.neu.mapper.WorkCardMapper.getWorkCardByEmpId"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"employeeTaskList"</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">select</span>=<span class="string">"com.edu.neu.mapper.EmployeeTaskMapper.getEmployeeTaskByEmpId"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resulpMap</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这个例子几乎把<code>&lt;resultMap&gt;</code>的子节点演示遍了。下面解释一下这些子节点的作用</p>
<ul>
<li><code>constructor</code>元素：用来配置一个构造方法。MyBatis会根据这个配置找到合适的构造方法对这个类实例化</li>
<li><code>result</code>元素：配置的是POJO成员变量到SQL列的映射关系，<code>column</code>代表SQL列名，<code>property</code>代表属性名</li>
<li><code>id</code>元素：除了具有<code>result</code>元素的功能，还表示了哪个列是主键，其实就是唯一标识列，不一定非要是主键。</li>
<li><code>association</code>元素：用来配置一个一对一的级联，例如上述代码段：当使用这个<code>resultMap</code>时，还会顺便把<code>WorkCard</code>也根据<code>id</code>从数据库中取出</li>
<li><code>collection</code>元素：与<code>association</code>元素类似，也是完成级联，但是它用于一对多级联，它将返回一个<code>java.util.List</code></li>
<li>其他子节点并不常见，这里就不介绍了。</li>
</ul>
<p>在正式分析解析逻辑之前，我们先看看存储结构，所有解析完成的<code>ResultMap</code>都将存放在<code>Configuration</code>的成员变量<code>resultMaps</code>中，这个<code>Map</code>的键为我们为<code>&lt;resultMap&gt;</code>节点指定的<code>id</code>属性，例如代码清单<code>3.8</code>的<code>employee</code>就将成为这个<code>resultMap</code>的<code>key</code>。而值为一个<code>org.apache.ibatis.mapping.ResultMap</code>的实例，这个类存储了单个<code>&lt;resultMap&gt;</code>的解析结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.9</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.session;</span></span><br><span class="line"><span class="comment">//Configuration</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps </span><br><span class="line">      = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Result Maps collection"</span>);</span><br></pre></td></tr></table></figure>
<p>下面我们再看看上文中提到的<code>org.apache.ibatis.mapping.ResultMap</code>中都存放了什么吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.10</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//ResultMap</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个configuration的引用，主要用来操作configuration来存放解析结果</span></span><br><span class="line">  	<span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个&lt;resultMap&gt;的id属性，唯一标识符</span></span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个&lt;resultMap&gt;的type属性，被解析为了一个Class对象</span></span><br><span class="line">  	<span class="keyword">private</span> Class&lt;?&gt; type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于存放&lt;resultMap&gt;的各个&lt;result&gt;、&lt;id&gt;节点、以及&lt;contructor&gt;中的&lt;idArg&gt;、&lt;arg&gt;节点的解析结果</span></span><br><span class="line">  	<span class="keyword">private</span> List&lt;ResultMapping&gt; resultMappings;</span><br><span class="line">  	</span><br><span class="line">    <span class="comment">//用于存放&lt;resultMap&gt;中&lt;id&gt;节点的解析结果</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; idResultMappings;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来存放&lt;resultMap&gt;中&lt;constructor&gt;节点的所有解析结果</span></span><br><span class="line">  	<span class="keyword">private</span> List&lt;ResultMapping&gt; constructorResultMappings;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用于存放&lt;resultMap&gt;中&lt;result&gt;节点的解析结果</span></span><br><span class="line">  	<span class="keyword">private</span> List&lt;ResultMapping&gt; propertyResultMappings;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来存放SQL表所有被映射的列的列名</span></span><br><span class="line">  	<span class="keyword">private</span> Set&lt;String&gt; mappedColumns;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//用来存放POJO所有被映射的属性的属性名</span></span><br><span class="line">  	<span class="keyword">private</span> Set&lt;String&gt; mappedProperties;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个鉴别器，不常用，不分析</span></span><br><span class="line">  	<span class="keyword">private</span> Discriminator discriminator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个标志，是否有嵌套的ResultMap</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个标志，是否有嵌套的查询</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedQueries;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个标志，是否开启了自动映射</span></span><br><span class="line">  	<span class="keyword">private</span> Boolean autoMapping;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，说白了，就是把单个<code>&lt;result&gt;</code>、<code>&lt;id&gt;</code>的解析结果，按照不同的类型，在不同的<code>List</code>中存放了起来，仅此而已。下图是个很好的例子。</p>
<p><img src="https://i.loli.net/2020/03/22/AOcWNLmzvPgh9SY.png" alt=""></p>
<p>但是这还没完，上述代码块用到的<code>ResultMapping</code>类，它看起来是存储单个POJO-SQL映射的类，我们接着分析它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.11</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//ResultMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMapping</span> </span>&#123;</span><br><span class="line">	<span class="comment">//一个configuration的引用</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">  	<span class="comment">//这个节点的property属性，对应POJO的属性</span></span><br><span class="line">    <span class="keyword">private</span> String property;</span><br><span class="line">  	<span class="comment">//这个节点的column属性，对应SQL的列名</span></span><br><span class="line">    <span class="keyword">private</span> String column;</span><br><span class="line">  	<span class="comment">//POJO属性的JavaType，java类型</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; javaType;</span><br><span class="line">  	<span class="comment">//SQL列对应的JDBCType，JDBC类型</span></span><br><span class="line">    <span class="keyword">private</span> JdbcType jdbcType;</span><br><span class="line">  	<span class="comment">//用来处理这个javaType和这个JDBCType的互相转换的类型处理器</span></span><br><span class="line">    <span class="keyword">private</span> TypeHandler&lt;?&gt; typeHandler;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String nestedResultMapId;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String nestedQueryId;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; notNullColumns;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String columnPrefix;</span><br><span class="line">  	<span class="comment">//标志这个列是否为主键、或者是否在`&lt;contructor&gt;`中存在等</span></span><br><span class="line">    <span class="comment">//ResultFlag就是一个简单的枚举类，这没啥可说的</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultFlag&gt; flags;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMapping&gt; composites;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String resultSet;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String foreignColumn;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lazy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么<code>resultMap</code>的存储结构就分析完了，我们继续看源码，从代码清单3.2的28行<code>resultMapElements(context.evalNodes(&quot;/mapper/resultMap&quot;));</code>向下，详细分析<code>resultMap</code>的解析过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.12</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultMapElements</span><span class="params">(List&lt;XNode&gt; list)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode resultMapNode : list) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            resultMapElement(resultMapNode);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            <span class="comment">// ignore, it will be retried</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resultMapElement(resultMapNode, Collections.emptyList(), <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   List&lt;ResultMapping&gt; additionalResultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Class&lt;?&gt; enclosingType)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"processing "</span> +</span><br><span class="line">                                     resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从&lt;resultMap&gt;节点上读取属性值type</span></span><br><span class="line">    <span class="comment">//若type不存在就寻找ofType，以此类推地寻找resultType和javaType</span></span><br><span class="line">    String type = resultMapNode.getStringAttribute(<span class="string">"type"</span>, </span><br><span class="line">                resultMapNode.getStringAttribute(<span class="string">"ofType"</span>,</span><br><span class="line">                resultMapNode.getStringAttribute(<span class="string">"resultType"</span>,</span><br><span class="line">                resultMapNode.getStringAttribute(<span class="string">"javaType"</span>))));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据找到的type字符串，生成type对应的Class对象</span></span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">if</span> (typeClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">      typeClass = inheritEnclosingType(resultMapNode, enclosingType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    Discriminator discriminator = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//ResultMapping负责存在单个pojo-Sql映射，比如&lt;id&gt;、&lt;result&gt;节点中包含的映射信息</span></span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历这个&lt;resultMap&gt;的所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode resultChild : resultChildren) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理&lt;constructor&gt;节点</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"constructor"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">            processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理&lt;discriminator&gt;节点    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"discriminator"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">            discriminator </span><br><span class="line">                = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理其他节点    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果这个节点是&lt;id&gt;，则添加一个主键标志</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"id"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//&lt;id&gt;、&lt;result&gt;等节点的具体解析过程</span></span><br><span class="line">            resultMappings.</span><br><span class="line">                add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取这个&lt;resultMap&gt;的id属性</span></span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>,</span><br><span class="line">                resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取这个&lt;resultMap&gt;的extend属性</span></span><br><span class="line">    String extend = resultMapNode.getStringAttribute(<span class="string">"extends"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取这个&lt;resultMap&gt;是否开启自动映射</span></span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">"autoMapping"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据前面获取的各种信息创建ResultMap解析器</span></span><br><span class="line">    ResultMapResolver resultMapResolver </span><br><span class="line">        = <span class="keyword">new</span> ResultMapResolver(builderAssistant, id, typeClass, extend,</span><br><span class="line">                                discriminator, resultMappings, autoMapping);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过这些信息，解析并返回ResultMap对象</span></span><br><span class="line">        <span class="keyword">return</span> resultMapResolver.resolve();</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IncompleteElementException  e) &#123;</span><br><span class="line">    	<span class="comment">//如果解析出错了就假如到Configuration的未成功解析列表中</span></span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述<code>resultMapElement</code>解析过程还是挺复杂的，这里总结一下，它完成的几项工作</p>
<ol>
<li>获取<code>&lt;resultMap&gt;</code>节点的各种属性</li>
<li>解析<code>&lt;resultMap&gt;</code>的所有子节点，并把返回结果存起来</li>
<li>用第1步和第2步获取的信息构造一个<code>ResultMap</code>对象</li>
<li>若第3步构造失败，则添加到未成功解析列表并抛出异常</li>
</ol>
<p>第1步比较简单，大家一看就懂。第2步将在3.2.2.1中展开分析。第3步将在3.2.2.2中展开分析。</p>
<h5 id="3-2-2-1-解析-lt-resultMap-gt-节点中的-lt-id-gt-节点和-lt-result-gt-节点"><a href="#3-2-2-1-解析-lt-resultMap-gt-节点中的-lt-id-gt-节点和-lt-result-gt-节点" class="headerlink" title="3.2.2.1 解析&lt;resultMap&gt;节点中的&lt;id&gt;节点和&lt;result&gt;节点"></a>3.2.2.1 解析<code>&lt;resultMap&gt;</code>节点中的<code>&lt;id&gt;</code>节点和<code>&lt;result&gt;</code>节点</h5><p>本节以<code>&lt;id&gt;</code>节点和<code>&lt;result&gt;</code>节点为例，分析<code>&lt;resultMap&gt;</code>节点的子节点是如何解析的。那我们从代码清单<code>3.12</code>的71行<code>resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</code>向下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.13</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    </span><br><span class="line">    String property;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      	property = context.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	property = context.getStringAttribute(<span class="string">"property"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    </span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    </span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    </span><br><span class="line">    String nestedSelect = context.getStringAttribute(<span class="string">"select"</span>);</span><br><span class="line">    </span><br><span class="line">    String nestedResultMap = context.getStringAttribute(<span class="string">"resultMap"</span>,</span><br><span class="line">        processNestedResultMappings(context, Collections.emptyList(), resultType));</span><br><span class="line">    </span><br><span class="line">    String notNullColumn = context.getStringAttribute(<span class="string">"notNullColumn"</span>);</span><br><span class="line">    </span><br><span class="line">    String columnPrefix = context.getStringAttribute(<span class="string">"columnPrefix"</span>);</span><br><span class="line">    </span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    </span><br><span class="line">    String resultSet = context.getStringAttribute(<span class="string">"resultSet"</span>);</span><br><span class="line">    </span><br><span class="line">    String foreignColumn = context.getStringAttribute(<span class="string">"foreignColumn"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">boolean</span> lazy = <span class="string">"lazy"</span>.equals(</span><br><span class="line">        context.getStringAttribute(</span><br><span class="line">            <span class="string">"fetchType"</span>, configuration.isLazyLoadingEnabled() ? <span class="string">"lazy"</span> : <span class="string">"eager"</span>));</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    </span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = resolveClass(typeHandler);</span><br><span class="line">    </span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildResultMapping(</span><br><span class="line">        resultType,</span><br><span class="line">        property,</span><br><span class="line">        column,</span><br><span class="line">        javaTypeClass,</span><br><span class="line">        jdbcTypeEnum,</span><br><span class="line">        nestedSelect,</span><br><span class="line">        nestedResultMap,</span><br><span class="line">        notNullColumn,</span><br><span class="line">        columnPrefix,</span><br><span class="line">        typeHandlerClass,</span><br><span class="line">        flags,</span><br><span class="line">        resultSet,</span><br><span class="line">        foreignColumn,</span><br><span class="line">        lazy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法实在乏善可陈，它只是从<code>&lt;result&gt;</code>或者<code>&lt;id&gt;</code>节点上获取了各种属性，然后将这些获取到的属性统统传递给<code>builderAssistant.buildResultMapping()</code>，然后这个助手类完成真正的解析工作并返回<code>ResultMapping</code>对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.13</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder;</span></span><br><span class="line"><span class="comment">//MapperBuilderAssistant</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultMapping <span class="title">buildResultMapping</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">      String property,</span></span></span><br><span class="line"><span class="function"><span class="params">      String column,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; javaType,</span></span></span><br><span class="line"><span class="function"><span class="params">      JdbcType jdbcType,</span></span></span><br><span class="line"><span class="function"><span class="params">      String nestedSelect,</span></span></span><br><span class="line"><span class="function"><span class="params">      String nestedResultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">      String notNullColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">      String columnPrefix,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandler,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;ResultFlag&gt; flags,</span></span></span><br><span class="line"><span class="function"><span class="params">      String resultSet,</span></span></span><br><span class="line"><span class="function"><span class="params">      String foreignColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">boolean</span> lazy)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Class&lt;?&gt; javaTypeClass = </span><br><span class="line">        resolveResultJavaType(resultType, property, javaType);</span><br><span class="line">    </span><br><span class="line">    TypeHandler&lt;?&gt; typeHandlerInstance = </span><br><span class="line">        resolveTypeHandler(javaTypeClass, typeHandler);</span><br><span class="line">    </span><br><span class="line">    List&lt;ResultMapping&gt; composites = parseCompositeColumnName(column);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResultMapping.Builder(configuration, property, column, javaTypeClass)</span><br><span class="line">        .jdbcType(jdbcType)</span><br><span class="line">        .nestedQueryId(applyCurrentNamespace(nestedSelect, <span class="keyword">true</span>))</span><br><span class="line">        .nestedResultMapId(applyCurrentNamespace(nestedResultMap, <span class="keyword">true</span>))</span><br><span class="line">        .resultSet(resultSet)</span><br><span class="line">        .typeHandler(typeHandlerInstance)</span><br><span class="line">        .flags(flags == <span class="keyword">null</span> ? <span class="keyword">new</span> ArrayList&lt;&gt;() : flags)</span><br><span class="line">        .composites(composites)</span><br><span class="line">        .notNullColumns(parseMultipleColumnNames(notNullColumn))</span><br><span class="line">        .columnPrefix(columnPrefix)</span><br><span class="line">        .foreignColumn(foreignColumn)</span><br><span class="line">        .lazy(lazy)</span><br><span class="line">        .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于这个<code>ResultMapping.Builder</code>就不继续深入了，它是一个简单的建造者负责建造<code>ResultMapping</code>。其实就是通过各种方法调用，为<code>ResultMapping</code>的实例设置属性而已。设置完成后，调用<code>build()</code>直接返回这个实例。</p>
<p>下面总结一下，对于<code>&lt;id&gt;</code>和<code>&lt;result&gt;</code>这种代表单个POJO-SQL映射的标签，MyBatis会将标签携带的属性进行解析，并全部存放在一个<code>ResultMapping</code>实例中返回。</p>
<h5 id="3-2-2-2-构建ResultMap对象的过程"><a href="#3-2-2-2-构建ResultMap对象的过程" class="headerlink" title="3.2.2.2 构建ResultMap对象的过程"></a>3.2.2.2 构建<code>ResultMap</code>对象的过程</h5><p>我们从代码清单<code>3.12</code>的93行<code>return resultMapResolver.resolve();</code>，看看这个解析器是如何构建<code>ResultMap</code>的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.13</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder;</span></span><br><span class="line"><span class="comment">//ResultMapResolver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">resolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> assistant.addResultMap(<span class="keyword">this</span>.id,</span><br><span class="line">                                  <span class="keyword">this</span>.type,</span><br><span class="line">                                  <span class="keyword">this</span>.extend,</span><br><span class="line">                                  <span class="keyword">this</span>.discriminator,</span><br><span class="line">                                  <span class="keyword">this</span>.resultMappings,</span><br><span class="line">                                  <span class="keyword">this</span>.autoMapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码清单<code>3.13</code>实际上调用了建造器助手的<code>addResultMap</code>方法，我们继续向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.14</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder;</span></span><br><span class="line"><span class="comment">//MapperBuilderAssistant</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(String id,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">                              String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">                              List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Boolean autoMapping)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理继承情况，不展开了</span></span><br><span class="line">    <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(</span><br><span class="line">                <span class="string">"Could not find a parent resultmap with id '"</span> </span><br><span class="line">                + extend + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ResultMap resultMap </span><br><span class="line">            = configuration.getResultMap(extend);</span><br><span class="line">        </span><br><span class="line">        List&lt;ResultMapping&gt; extendedResultMappings </span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">        </span><br><span class="line">        extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Remove parent constructor if this resultMap declares a constructor.</span></span><br><span class="line">        <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">            <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">                declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">            extendedResultMappings.removeIf(</span><br><span class="line">                resultMapping -&gt; resultMapping.</span><br><span class="line">				getFlags().contains(ResultFlag.CONSTRUCTOR)</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用建造者构造ResultMap</span></span><br><span class="line">    ResultMap resultMap = </span><br><span class="line">        <span class="keyword">new</span> ResultMap.Builder(configuration,</span><br><span class="line">                              id,</span><br><span class="line">                              type,</span><br><span class="line">                              resultMappings,</span><br><span class="line">                              autoMapping)</span><br><span class="line">      						.discriminator(discriminator)</span><br><span class="line">      						.build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将得到的ResultMap保存到configuration的resultMaps中</span></span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法实际上做了这几件事</p>
<ol>
<li>处理<code>resultMap</code>的继承(<code>extend</code>属性)</li>
<li>通过<code>ResultMap</code>的建造者构造<code>ResultMap</code>实例</li>
<li>将这个<code>ResultMap</code>实例保存到<code>configuration</code>的<code>resultMaps</code>中</li>
</ol>
<p>下面我们继续看看这个建造者是怎么完成建造工作的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.15</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//ResultMap.Builder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResultMap <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果这个resultMap没有id，也就是唯一标识符，直接报错</span></span><br><span class="line">    <span class="keyword">if</span> (resultMap.id == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"ResultMaps must have an id"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把这个resultMap需要使用但没有传入的List和Set初始化</span></span><br><span class="line">    resultMap.mappedColumns = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    resultMap.mappedProperties = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    resultMap.idResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    resultMap.constructorResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    resultMap.propertyResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//初始化构造器参数名列表</span></span><br><span class="line">    <span class="keyword">final</span> List&lt;String&gt; constructorArgNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有Mapping</span></span><br><span class="line">    <span class="keyword">for</span> (ResultMapping resultMapping : resultMap.resultMappings) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置&lt;association&gt;和&lt;collection&gt;标记</span></span><br><span class="line">        resultMap.hasNestedQueries = </span><br><span class="line">            resultMap.hasNestedQueries || resultMapping.getNestedQueryId() != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//同上</span></span><br><span class="line">        resultMap.hasNestedResultMaps = </span><br><span class="line">            resultMap.hasNestedResultMaps ||</span><br><span class="line">            (resultMapping.getNestedResultMapId() != <span class="keyword">null</span></span><br><span class="line">             &amp;&amp; resultMapping.getResultSet() == <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取SQL列名</span></span><br><span class="line">        <span class="keyword">final</span> String column = resultMapping.getColumn();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将列名加入mappedColumns集合</span></span><br><span class="line">        <span class="comment">//列名不为空的情况</span></span><br><span class="line">        <span class="keyword">if</span> (column != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultMap.mappedColumns.add(column.toUpperCase(Locale.ENGLISH));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//Mapping是复合结构的情况</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultMapping.isCompositeResult()) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (ResultMapping compositeResultMapping :</span><br><span class="line">                 resultMapping.getComposites())&#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">final</span> String compositeColumn = compositeResultMapping.getColumn();</span><br><span class="line">                <span class="keyword">if</span> (compositeColumn != <span class="keyword">null</span>) &#123;</span><br><span class="line">               		resultMap.mappedColumns.</span><br><span class="line">                        add(compositeColumn.toUpperCase(Locale.ENGLISH));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//获取POJO属性名</span></span><br><span class="line">        <span class="keyword">final</span> String property = resultMapping.getProperty();</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//将属性名加入mappedProperties集合</span></span><br><span class="line">        <span class="keyword">if</span> (property != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultMap.mappedProperties.add(property);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//将带有构造器标记的mapping加入constructorResultMappings列表</span></span><br><span class="line">        <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">            resultMap.constructorResultMappings.add(resultMapping);</span><br><span class="line">            <span class="keyword">if</span> (resultMapping.getProperty() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                constructorArgNames.add(resultMapping.getProperty());</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将不带构造器标记的mapping加入propertyResultMappings列表  </span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            resultMap.propertyResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将带有主键标记的mapping加入idResultMappings列表</span></span><br><span class="line">        <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.ID)) &#123;</span><br><span class="line">            resultMap.idResultMappings.add(resultMapping);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果这个resultMap没有主键，就让所有人做主键</span></span><br><span class="line">    <span class="keyword">if</span> (resultMap.idResultMappings.isEmpty()) &#123;</span><br><span class="line">        resultMap.idResultMappings.addAll(resultMap.resultMappings);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果前面获取的参数名列表不为空，则通过反射按照这个列表获取参数的实际名列表</span></span><br><span class="line">    <span class="comment">//并按照获取的参数实际名称列表对constructorResultMappings进行排序(也就是传参要按顺序)</span></span><br><span class="line">    <span class="keyword">if</span> (!constructorArgNames.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">final</span> List&lt;String&gt; actualArgNames = </span><br><span class="line">            argNamesOfMatchingConstructor(constructorArgNames);</span><br><span class="line">        <span class="keyword">if</span> (actualArgNames == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error in result map '"</span> + resultMap.id</span><br><span class="line">                + <span class="string">"'. Failed to find a constructor in '"</span></span><br><span class="line">                + resultMap.getType().getName() + <span class="string">"' by arg names "</span> </span><br><span class="line">                + constructorArgNames</span><br><span class="line">                + <span class="string">". There might be more info in debug log."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.constructorResultMappings.sort((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> paramIdx1 = actualArgNames.indexOf(o1.getProperty());</span><br><span class="line">            <span class="keyword">int</span> paramIdx2 = actualArgNames.indexOf(o2.getProperty());</span><br><span class="line">            <span class="keyword">return</span> paramIdx1 - paramIdx2;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将resultMappings等一干集合类冻结为不能修改的状态</span></span><br><span class="line">    <span class="comment">// lock down collections</span></span><br><span class="line">    resultMap.resultMappings </span><br><span class="line">        = Collections.unmodifiableList(resultMap.resultMappings);</span><br><span class="line">    resultMap.idResultMappings </span><br><span class="line">        = Collections.unmodifiableList(resultMap.idResultMappings);</span><br><span class="line">    resultMap.constructorResultMappings </span><br><span class="line">        = Collections.unmodifiableList(resultMap.constructorResultMappings);</span><br><span class="line">    resultMap.propertyResultMappings </span><br><span class="line">        = Collections.unmodifiableList(resultMap.propertyResultMappings);</span><br><span class="line">    resultMap.mappedColumns </span><br><span class="line">        = Collections.unmodifiableSet(resultMap.mappedColumns);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码比较长，但实际上就如代码清单<code>3.10</code>所示，它将传入的<code>resultMappings</code>列表中的元素，按照不同的特点放入了不同的列表和集合中，仅此而已。</p>
<p>到此，我们就完成了<code>ResultMap</code>对象的构建，并且将构建完的结果以<code>id</code>做键、<code>ResultMap</code>做值的形式存放到了configuration的<code>resultMaps</code>映射中。本节比较值得学习的就是MyBatis对于建造者模式的使用。</p>
<h4 id="3-2-3-解析-lt-sql-gt-节点"><a href="#3-2-3-解析-lt-sql-gt-节点" class="headerlink" title="3.2.3 解析&lt;sql&gt;节点"></a>3.2.3 解析<code>&lt;sql&gt;</code>节点</h4><p><code>&lt;sql&gt;</code>节点用来定义一些可重用的SQL语句片段，比如表名，或表的列名等。在映射文件中，我们可以通过 <code>&lt;include&gt;</code>节点引用<code>&lt;sql&gt;</code>节点定义的内容。</p>
<p>在分析源码之前，先来演示一下<code>&lt;sql&gt;</code>节点的使用方式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.16--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">	article</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOne"</span> <span class="attr">resultType</span>=<span class="string">"Article"</span>&gt;</span></span><br><span class="line">	SELECT id, title </span><br><span class="line">    FROM <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"table"</span>/&gt;</span> </span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"Article"</span>&gt;</span></span><br><span class="line">	UPDATE <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"table"</span>/&gt;</span> </span><br><span class="line">    SET title = #&#123;title&#125; </span><br><span class="line">    WHERE id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们从代码清单<code>3.2</code>的32行<code>sqlElement(context.evalNodes(&quot;/mapper/sql&quot;));</code>继续向下，看看对于<code>&lt;sql&gt;</code>节点的解析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.17</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用于存放解析完毕的&lt;sql&gt;节点，从configuration中取得的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代码清单3.2的32行调用此方法</span></span><br><span class="line"><span class="comment">//它先解析所有databaseId与当前数据库匹配的&lt;sql&gt;节点</span></span><br><span class="line"><span class="comment">//然后解析所有不带databaseId的&lt;sql&gt;节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sqlElement(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    sqlElement(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sqlElement</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历所有&lt;sql&gt;节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取databaseId</span></span><br><span class="line">        String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line">        <span class="comment">//获取这个&lt;sql&gt;节点的id属性</span></span><br><span class="line">        String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//在这个id属性的前面加上当前的命名空间</span></span><br><span class="line">        <span class="comment">//例如:table -&gt; com.edu.neu.zady.dao.ProductDao.table</span></span><br><span class="line">        id = builderAssistant.applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果数据库id符合，则将这个&lt;sql&gt;节点直接添加到sqlFragment映射中</span></span><br><span class="line">        <span class="keyword">if</span> (databaseIdMatchesCurrent(id, databaseId, requiredDatabaseId)) &#123;</span><br><span class="line">            sqlFragments.put(id, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&lt;sql&gt;</code>节点的解析非常简单，它只不过是完成了以下几件事</p>
<ol>
<li><p>通过<code>databaseId</code>筛选符合当前数据库的<code>&lt;sql&gt;</code>节点</p>
</li>
<li><p>将符合要求的节点加入<code>sqlFragment</code>映射，这个映射将在解析SQL语句节点时使用</p>
</li>
</ol>
<p>并且，其实这个<code>sqlFragement</code>也是存储在<code>Configuration</code>中的，方便后面的使用。</p>
<h4 id="3-2-4-解析SQL语句节点"><a href="#3-2-4-解析SQL语句节点" class="headerlink" title="3.2.4 解析SQL语句节点"></a>3.2.4 解析SQL语句节点</h4><p>下面是本章的重头戏，<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>等SQL语句节点的解析。这些节点的用处都是存储SQL语句，所以解析过程是相同的。</p>
<p>在分析之前，我们还是先看看在<code>Configuration</code>中解析完的信息是怎么储存的。对于每个SQL语句节点，MyBatis都会解析成一个<code>MappedStatement</code>的实例。然后在<code>Configuration</code>中，是通过以<code>id</code>为键，以<code>MappedStatement</code>本身为值存储在了一个<code>Map</code>中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements </span><br><span class="line">    = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>);</span><br></pre></td></tr></table></figure>
<p>接下来我们看看，上面提到的<code>MappedStatement</code>都存储了那些信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.18</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//MappedStatement</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MappedStatement</span> </span>&#123;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String resource;</span><br><span class="line">    <span class="comment">//一个Configuration的引用</span></span><br><span class="line">    <span class="keyword">private</span> Configuration configuration;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> Integer fetchSize;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> Integer timeout;</span><br><span class="line">    <span class="comment">//STATEMENT, PREPARED, CALLABLE</span></span><br><span class="line">    <span class="keyword">private</span> StatementType statementType;</span><br><span class="line">    <span class="comment">//DEFAULT, FORWARD_ONLY, SCROLL_INSENSITIVE, SCROLL_SENSITIVE;</span></span><br><span class="line">    <span class="keyword">private</span> ResultSetType resultSetType;</span><br><span class="line">    <span class="comment">//存放具体的SQL语句，还有参数列表等</span></span><br><span class="line">    <span class="keyword">private</span> SqlSource sqlSource;</span><br><span class="line">    <span class="comment">//这个Statement使用的二级缓存</span></span><br><span class="line">    <span class="keyword">private</span> Cache cache;</span><br><span class="line">    <span class="comment">//存放使用的参数</span></span><br><span class="line">    <span class="keyword">private</span> ParameterMap parameterMap;</span><br><span class="line">    <span class="comment">//存放使用的一些ResultMap</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;ResultMap&gt; resultMaps;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flushCacheRequired;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> useCache;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> resultOrdered;</span><br><span class="line">    <span class="comment">//UNKNOWN, INSERT, UPDATE, DELETE, SELECT, FLUSH</span></span><br><span class="line">    <span class="keyword">private</span> SqlCommandType sqlCommandType;</span><br><span class="line">    <span class="comment">//用来自增主键</span></span><br><span class="line">    <span class="keyword">private</span> KeyGenerator keyGenerator;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String[] keyProperties;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String[] keyColumns;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> hasNestedResultMaps;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String databaseId;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> Log statementLog;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> LanguageDriver lang;</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> String[] resultSets;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>让我们详细展开上一个代码清单的20行<code>private SqlSource sqlSource;</code>看看<code>SqlSource</code>是什么</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.18</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//SqlSource</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SqlSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">BoundSql <span class="title">getBoundSql</span><span class="params">(Object parameterObject)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它是个接口，这个接口传入<code>parameter</code>，然后返回一个<code>BoundSql</code>实例。那我们接着看看<code>BoundSql</code>的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.19</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.mapping;</span></span><br><span class="line"><span class="comment">//BoundSql</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoundSql</span> </span>&#123;</span><br><span class="line">	<span class="comment">//真.SQL语句</span></span><br><span class="line">  	<span class="keyword">private</span> <span class="keyword">final</span> String sql;</span><br><span class="line">  	<span class="comment">//参数的列表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">  	<span class="comment">//略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object parameterObject;</span><br><span class="line">  	<span class="comment">//额外参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; additionalParameters;</span><br><span class="line">  	<span class="comment">//参数的元数据信息</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MetaObject metaParameters;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，和SQL语句有关的存储结构算是分析完了。</p>
<p>我们下面从代码清单<code>3.2</code>的34行<code>buildStatementFromContext(context.evalNodes(&quot;select|insert|update|delete&quot;));</code>继续向下，看看<code>MappedStatement</code>是怎么构建的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.20</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (configuration.getDatabaseId() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      buildStatementFromContext(list, configuration.getDatabaseId());</span><br><span class="line">    &#125;</span><br><span class="line">    buildStatementFromContext(list, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildStatementFromContext</span><span class="params">(List&lt;XNode&gt; list, String requiredDatabaseId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//遍历每个&lt;select|insert|update|delete&gt;节点</span></span><br><span class="line">    <span class="keyword">for</span> (XNode context : list) &#123;</span><br><span class="line">        <span class="keyword">final</span> XMLStatementBuilder statementParser = </span><br><span class="line">            <span class="keyword">new</span> XMLStatementBuilder(configuration,</span><br><span class="line">                                    builderAssistant,</span><br><span class="line">                                    context,</span><br><span class="line">                                    requiredDatabaseId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//每个节点的实际解析逻辑</span></span><br><span class="line">            statementParser.parseStatementNode();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IncompleteElementException e) &#123;</span><br><span class="line">            configuration.addIncompleteStatement(statementParser);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法其实什么也没干，它制作遍历每个节点，然后把具体每个节点的解析交给<code>XMLstatementBuilder</code>的<code>parseStatementNode()</code>来处理，具体的解析逻辑都在这个方法里，那我们继续向下看看这个方法。</p>
<p>在看源码之前，先大体描述这个方法进行的几步操作</p>
<ol>
<li>解析SQL语句中的<code>&lt;include&gt;</code>节点，第34行</li>
<li>解析SQL语句中的<code>&lt;selectKey&gt;</code>节点，第46行</li>
<li>解析SQL语句， 第67行</li>
<li>构建<code>MappedStatement</code>，第93行</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.20</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLStatementBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parseStatementNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取&lt;select|insert|update|delete&gt;节点的id</span></span><br><span class="line">    String id = context.getStringAttribute(<span class="string">"id"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取&lt;select|insert|update|delete&gt;节点的dataBaseId</span></span><br><span class="line">    String databaseId = context.getStringAttribute(<span class="string">"databaseId"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果dataBaseId与当前数据库不匹配，则不解析这个节点，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (!databaseIdMatchesCurrent(id, databaseId, <span class="keyword">this</span>.requiredDatabaseId)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取这个节点的名称，select、insert、update还是delete</span></span><br><span class="line">    String nodeName = context.getNode().getNodeName();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//通过节点的名称创建一个SqlCommandType</span></span><br><span class="line">    SqlCommandType sqlCommandType </span><br><span class="line">        = SqlCommandType.valueOf(nodeName.toUpperCase(Locale.ENGLISH));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据节点的属性来设置一些标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line">    <span class="keyword">boolean</span> flushCache = context.getBooleanAttribute(<span class="string">"flushCache"</span>, !isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> useCache = context.getBooleanAttribute(<span class="string">"useCache"</span>, isSelect);</span><br><span class="line">    <span class="keyword">boolean</span> resultOrdered = context.getBooleanAttribute(<span class="string">"resultOrdered"</span>, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析SQL语句中的&lt;include&gt;节点</span></span><br><span class="line">    <span class="comment">//例如代码清单3.16的第8行、第13行</span></span><br><span class="line">    <span class="comment">// Include Fragments before parsing</span></span><br><span class="line">    XMLIncludeTransformer includeParser </span><br><span class="line">        = <span class="keyword">new</span> XMLIncludeTransformer(configuration, builderAssistant);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    includeParser.applyIncludes(context.getNode());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取节点的parameterType属性</span></span><br><span class="line">    String parameterType = context.getStringAttribute(<span class="string">"parameterType"</span>);</span><br><span class="line">    Class&lt;?&gt; parameterTypeClass = resolveClass(parameterType);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取节点的语言属性</span></span><br><span class="line">    String lang = context.getStringAttribute(<span class="string">"lang"</span>);</span><br><span class="line">    LanguageDriver langDriver = getLanguageDriver(lang);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//解析&lt;selectKey&gt;节点</span></span><br><span class="line">    <span class="comment">// Parse selectKey after includes and remove them.</span></span><br><span class="line">    processSelectKeyNodes(id, parameterTypeClass, langDriver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the SQL (pre: &lt;selectKey&gt; and &lt;include&gt; were parsed and removed)</span></span><br><span class="line">    KeyGenerator keyGenerator;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据命名空间等信息，为这个Statement(也就是这个&lt;select|update|delete|insert&gt;节点)起名</span></span><br><span class="line">    String keyStatementId = id + SelectKeyGenerator.SELECT_KEY_SUFFIX;</span><br><span class="line">    keyStatementId = builderAssistant.applyCurrentNamespace(keyStatementId, <span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理id重名的情况</span></span><br><span class="line">    <span class="keyword">if</span> (configuration.hasKeyGenerator(keyStatementId)) &#123;</span><br><span class="line">      keyGenerator = configuration.getKeyGenerator(keyStatementId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      keyGenerator = </span><br><span class="line">          context.getBooleanAttribute(<span class="string">"useGeneratedKeys"</span>,</span><br><span class="line">          configuration.isUseGeneratedKeys() &amp;&amp;</span><br><span class="line">                                      SqlCommandType.INSERT.equals(sqlCommandType))</span><br><span class="line">          ? Jdbc3KeyGenerator.INSTANCE : NoKeyGenerator.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//生成sqlSource</span></span><br><span class="line">    SqlSource sqlSource =</span><br><span class="line">        langDriver.createSqlSource(configuration, context, parameterTypeClass);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成statementType，比如:Statement、PreparedStatement、CallableStatement</span></span><br><span class="line">    StatementType statementType =</span><br><span class="line">        StatementType.valueOf(context.getStringAttribute(</span><br><span class="line">            <span class="string">"statementType"</span>, StatementType.PREPARED.toString()));</span><br><span class="line">    </span><br><span class="line">   	<span class="comment">//继续获取一些属性 </span></span><br><span class="line">    Integer fetchSize = context.getIntAttribute(<span class="string">"fetchSize"</span>);</span><br><span class="line">    Integer timeout = context.getIntAttribute(<span class="string">"timeout"</span>);</span><br><span class="line">    String parameterMap = context.getStringAttribute(<span class="string">"parameterMap"</span>);</span><br><span class="line">    String resultType = context.getStringAttribute(<span class="string">"resultType"</span>);</span><br><span class="line">    Class&lt;?&gt; resultTypeClass = resolveClass(resultType);</span><br><span class="line">    String resultMap = context.getStringAttribute(<span class="string">"resultMap"</span>);</span><br><span class="line">    String resultSetType = context.getStringAttribute(<span class="string">"resultSetType"</span>);</span><br><span class="line">    ResultSetType resultSetTypeEnum = resolveResultSetType(resultSetType);</span><br><span class="line">    String keyProperty = context.getStringAttribute(<span class="string">"keyProperty"</span>);</span><br><span class="line">    String keyColumn = context.getStringAttribute(<span class="string">"keyColumn"</span>);</span><br><span class="line">    String resultSets = context.getStringAttribute(<span class="string">"resultSets"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将前面获取的各种信息，全都传递给builderAssistant.addMappedStatement方法，</span></span><br><span class="line">    <span class="comment">//这个方法将完成MappedStatement的生成操作，并添加到Configuration中</span></span><br><span class="line">    builderAssistant.addMappedStatement(</span><br><span class="line">        id,</span><br><span class="line">        sqlSource,</span><br><span class="line">        statementType,</span><br><span class="line">        sqlCommandType,</span><br><span class="line">        fetchSize,</span><br><span class="line">        timeout,</span><br><span class="line">        parameterMap,</span><br><span class="line">        parameterTypeClass,</span><br><span class="line">        resultMap,</span><br><span class="line">        resultTypeClass,</span><br><span class="line">        resultSetTypeEnum,</span><br><span class="line">        flushCache,</span><br><span class="line">        useCache, </span><br><span class="line">        resultOrdered,</span><br><span class="line">        keyGenerator,</span><br><span class="line">        keyProperty,</span><br><span class="line">        keyColumn,</span><br><span class="line">        databaseId,</span><br><span class="line">        langDriver,</span><br><span class="line">        resultSets);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的4小节，将分别展开这四个步骤</p>
<h5 id="3-2-4-1-解析-lt-include-gt-节点"><a href="#3-2-4-1-解析-lt-include-gt-节点" class="headerlink" title="3.2.4.1 解析&lt;include&gt;节点"></a>3.2.4.1 解析<code>&lt;include&gt;</code>节点</h5><p>注：下面的解析过程比较难，看不懂可以先看后面的例子。如果实在看不懂，这里讲一下这方法执行后的结果。它将<code>XNODE</code>树上的<code>&lt;include&gt;</code>节点替换成了包含对应<code>sql</code>语句的普通文本节点。也就是说，经过这一步的处理，<code>&lt;include&gt;</code>节点在<code>XNODE</code>树中消失了。我们在<code>mapper</code>文件的层次上举个不太恰切的例子。</p>
<p>在没进行解析时，<code>XNODE</code>树是这样的</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.21--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"xyz.coolblog.dao.ArticleDao"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">		$&#123;table_name&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOne"</span> <span class="attr">resultType</span>=<span class="string">"xyz.coolblog.dao.Article"</span>&gt;</span></span><br><span class="line">		SELECT id, title</span><br><span class="line">		FROM </span><br><span class="line">        <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"table_name"</span> <span class="attr">value</span>=<span class="string">"article"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">		WHERE id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>完成解析之后，它变成了一个再普通不过的sql</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.22--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"xyz.coolblog.dao.ArticleDao"</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"table"</span>&gt;</span></span><br><span class="line">		$&#123;table_name&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findOne"</span> <span class="attr">resultType</span>=<span class="string">"xyz.coolblog.dao.Article"</span>&gt;</span></span><br><span class="line">		SELECT id, title</span><br><span class="line">		FROM article</span><br><span class="line">		WHERE id = #&#123;id&#125;</span><br><span class="line">	<span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>只不过上面的解析，不是在mapper文件的层面上进行的，而是在<code>XNODE</code>的层面进行的。大家体会理解意思即可。</p>
<p>然后我们从代码清单<code>3.20</code>第37行<code>includeParser.applyIncludes(context.getNode());</code>向下，看看<code>&lt;include&gt;</code>节点的解析过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.21</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLIncludeTransformer</span></span><br><span class="line"><span class="comment">//这个方法不要按顺序读，看不懂先看看后面的例子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">applyIncludes</span><span class="params">(Node source, </span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">final</span> Properties variablesContext,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> included)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//第一个分支，用于处理&lt;include&gt;节点</span></span><br><span class="line">    <span class="keyword">if</span> (source.getNodeName().equals(<span class="string">"include"</span>)) &#123;</span><br><span class="line">    	<span class="comment">//获取&lt;sql&gt;节点，如果refid中包含属性占位符$&#123;&#125;</span></span><br><span class="line">        <span class="comment">//则需先将属性占位符替换为对应的属性</span></span><br><span class="line">        Node toInclude =</span><br><span class="line">            findSqlFragment(getStringAttribute(source, <span class="string">"refid"</span>), variablesContext);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获得&lt;include&gt;节点的所有&lt;property&gt;子节点，并将结果与variablesContext混合</span></span><br><span class="line">        Properties toIncludeContext = getVariablesContext(source, variablesContext);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//递归调用，对&lt;sql&gt;节点执行applyIncludes，替换其中的$&#123;&#125;</span></span><br><span class="line">        applyIncludes(toInclude, toIncludeContext, <span class="keyword">true</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//处理&lt;sql&gt;节点在其他文件的情况</span></span><br><span class="line">        <span class="keyword">if</span> (toInclude.getOwnerDocument() != source.getOwnerDocument()) &#123;</span><br><span class="line">            toInclude = source.getOwnerDocument().importNode(toInclude, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将&lt;include&gt;节点替换为&lt;sql&gt;节点</span></span><br><span class="line">        source.getParentNode().replaceChild(toInclude, source);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将解析完成的&lt;sql&gt;节点里的Text内容插入到&lt;sql&gt;节点之前</span></span><br><span class="line">        <span class="keyword">while</span> (toInclude.hasChildNodes()) &#123;</span><br><span class="line">            toInclude.getParentNode().</span><br><span class="line">                insertBefore(toInclude.getFirstChild(), toInclude);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//前面插入的Text内容节点是解析好的，已经可以完全代替&lt;sql&gt;节点了</span></span><br><span class="line">        <span class="comment">//那么我们直接将&lt;sql&gt;节点也移除掉</span></span><br><span class="line">        toInclude.getParentNode().removeChild(toInclude);</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//第二个条件分支，用来处理&lt;select|insert|update|delete&gt;节点或者&lt;sql&gt;节点</span></span><br><span class="line">    <span class="comment">//总之就是除了&lt;include&gt;节点之外的所有普通节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source.getNodeType() == Node.ELEMENT_NODE) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (included &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// replace variables in attribute values</span></span><br><span class="line">        	</span><br><span class="line">            <span class="comment">//获取这个节点的所有属性</span></span><br><span class="line">        	NamedNodeMap attributes = source.getAttributes();</span><br><span class="line">        </span><br><span class="line">            <span class="comment">//遍历这些属性，将属性中的$&#123;&#125;替换为具体的值</span></span><br><span class="line">        	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; attributes.getLength(); i++) &#123;</span><br><span class="line">          		Node attr = attributes.item(i);</span><br><span class="line">          		attr.setNodeValue(PropertyParser.parse(</span><br><span class="line">                  	attr.getNodeValue(), variablesContext));</span><br><span class="line">        	&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//获取这个节点的所有子节点</span></span><br><span class="line">        NodeList children = source.getChildNodes();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对每个子节点执行applyIncludes</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">            applyIncludes(children.item(i), variablesContext, included);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//处理所有TEXT节点    </span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">        included </span><br><span class="line">        &amp;&amp; source.getNodeType() == Node.TEXT_NODE </span><br><span class="line">        &amp;&amp; !variablesContext.isEmpty()) &#123;</span><br><span class="line">      	<span class="comment">// replace variables in text node</span></span><br><span class="line">        <span class="comment">//将节点中的$&#123;&#125;替换为具体的值</span></span><br><span class="line">        source.setNodeValue(</span><br><span class="line">            PropertyParser.parse(</span><br><span class="line">                source.getNodeValue(), variablesContext));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们以代码清单<code>3.21</code>从8-12行的<code>&lt;select&gt;</code>节点的解析为例，详细看看<code>&lt;include&gt;</code>是怎么被替换的。</p>
<p>但是这里还要插入一个先序知识：在<code>XNODE</code>树中，所有的<code>&lt;xxx&gt;</code>标签会被解析为<code>ELEMENT_NODE</code>，而所有<code>&lt;xxx&gt;</code>和<code>&lt;/xxx&gt;</code>间的文本将被解析为<code>TEXT_NODE</code>，除此之外还有<code>ATTRIBUTE_NODE</code>、<code>COMMENT_NODE</code>等很多节点类型，有兴趣可以查看<code>org.w3c.dom.Node</code>接口</p>
<p>那么这个<code>&lt;select&gt;</code>节点的类型为<code>ELEMENT_NODE</code>，它有三个子节点，如下表</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>子节点</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><code>SELECT id,title FROM</code></td>
<td><code>TEXT_NODE</code></td>
<td>文本节点</td>
</tr>
<tr>
<td>2</td>
<td><code>&lt;include refid=&quot;table&quot;/&gt;</code></td>
<td><code>ELEMENT_NODE</code></td>
<td>普通节点</td>
</tr>
<tr>
<td>3</td>
<td><code>WHERE id= #{id}</code></td>
<td><code>TEXT_NODE</code></td>
<td>文本节点</td>
</tr>
</tbody>
</table>
<p>那么调用的入口代码清单<code>3.20</code>第34行<code>includeParser.applyIncludes(context.getNode());</code>传入的<code>XNode</code>显然是<code>&lt;select&gt;</code>节点。它会进入第二个条件，遍历自己的3个孩子节点。第一个节点和第二个节点的调用栈如下图</p>
<p><img src="https://i.loli.net/2020/03/22/Js3PGbzmCI6yRux.png" alt=""></p>
<p><img src="https://i.loli.net/2020/03/22/pwUle9y8631tfkr.png" alt=""></p>
<h5 id="3-2-4-2-解析-lt-selectKey-gt-节点"><a href="#3-2-4-2-解析-lt-selectKey-gt-节点" class="headerlink" title="3.2.4.2 解析&lt;selectKey&gt;节点"></a>3.2.4.2 解析<code>&lt;selectKey&gt;</code>节点</h5><p>对于一些不支持自增主键的数据库来说，我们在插入数据时，需要明确指定主键数据。例如</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:3.22--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"saveAuthor"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"int"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">		select author_seq.nextval from dual</span><br><span class="line">	<span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">	insert into Author</span><br><span class="line">		(id, name, password)</span><br><span class="line">	values</span><br><span class="line">		(#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这部分的源码就不展开解析了。当Mybatis完成解析后，也会将<code>&lt;selectKey&gt;</code>节点从<code>XNODE</code>树中去掉</p>
<h5 id="3-2-4-3-解析SQL语句生成SqlSource"><a href="#3-2-4-3-解析SQL语句生成SqlSource" class="headerlink" title="3.2.4.3 解析SQL语句生成SqlSource"></a>3.2.4.3 解析SQL语句生成<code>SqlSource</code></h5><p>经过上两节的解析，MyBatis已经把<code>&lt;select|insert|delete|create&gt;</code>中所有的<code>&lt;include&gt;</code>和<code>&lt;selectKey&gt;</code>子孙节点全部都替换并删除掉了。现在<code>XNODE</code>树中只有<code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>等普通的<code>ELEMENT</code>节点和文本节点。这一步，我们将分析MyBatis是如何解析<code>&lt;select|insert|delete|create&gt;</code>节点的<code>XNODE</code>树，来生成<code>SqlSource</code>。当处理用户的实际调用时，MyBatis将通过<code>SqlSource</code>来解析出具体的SQL语句。</p>
<p>我们从代码清单<code>3.20</code> 的70行<code>SqlSource sqlSource = langDriver.createSqlSource(configuration, context, parameterTypeClass);</code>继续向下。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.23</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.scripting.xmltags;</span></span><br><span class="line"><span class="comment">//XMLLanguageDriver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">createSqlSource</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Configuration configuration,</span></span></span><br><span class="line"><span class="function"><span class="params">    XNode script,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; parameterType)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    XMLScriptBuilder builder </span><br><span class="line">        = <span class="keyword">new</span> XMLScriptBuilder(configuration, script, parameterType);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> builder.parseScriptNode();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法，只是通过调用<code>XMLScriptBuilder</code>的<code>parseScriptNode()</code>来实现生成<code>SqlSource</code>的具体逻辑而已，因此我们继续向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.24</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.scripting.xmltags;</span></span><br><span class="line"><span class="comment">//XMLScriptBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSource <span class="title">parseScriptNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将context这个XNODE的所有子孙节点解析成一个MixedSqlNode（也就是一个SqlNode节点的列表）</span></span><br><span class="line">    <span class="comment">//并且设置isDynamic标志位，来表示这个sqlSource是否需要是动态的</span></span><br><span class="line">    MixedSqlNode rootSqlNode = parseDynamicTags(context);</span><br><span class="line">    </span><br><span class="line">    SqlSource sqlSource;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据是否是动态的创建不同的SqlSource实例</span></span><br><span class="line">    <span class="keyword">if</span> (isDynamic) &#123;</span><br><span class="line">      	sqlSource = <span class="keyword">new</span> DynamicSqlSource(configuration, rootSqlNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      	sqlSource = <span class="keyword">new</span> RawSqlSource(configuration, rootSqlNode, parameterType);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sqlSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里首先解释一下什么是动态SQL什么是静态SQL，动态SQL指的包含<code>${}</code>占位符或者<code>&lt;if&gt;</code>、<code>&lt;where&gt;</code>等动态语句节点的SQL。注意：只包含<code>#{}</code>并不算动态SQL。</p>
<p>在继续分析主要逻辑之前，我们先看看<code>MixSqlNode</code>是什么。对于每个<code>XNODE</code>片段，在经过解析后都会变成一个<code>SqlNode</code>节点，比如<code>TEXT</code>节点将被解析为一个<code>StaticTextSqlNode</code>，而<code>&lt;if&gt;</code>节点将被解析为一个<code>IfSqlNode</code>。比较特殊的是<code>MixSqlNode</code>，它存储一个<code>SqlNode</code>类型的列表。类图如下面两张图。</p>
<p><img src="https://i.loli.net/2020/03/24/RwCIX1W248Hht6g.png" alt=""></p>
<p><img src="https://i.loli.net/2020/03/24/oAYu5OQvDWMeGUm.png" alt=""></p>
<p>在大致了解了<code>SqlNode</code>之后，我们从代码清单<code>3.24</code>的第7行继续向下，看看<code>&lt;select|insert|delete|update&gt;</code>这个<code>XNode</code>是怎么被解析为一个<code>MixedSqlNode</code>的。下面源码的逻辑如下</p>
<ol>
<li>遍历<code>&lt;select|insert|delete|update&gt;</code>节点的所有子节点</li>
<li>如果子节点是TEXT类型的，则根据是动态还是静态，解析<code>TextSqlNode</code>或者<code>StaticTextSqlNode</code>，并将解析结果放入<code>contents</code>列表</li>
<li>如果子节点是ELEMENT类型的，那么根据标签名称来选取合适的<code>NodeHandler</code>解析，解析结果也会被放入<code>contents</code>列表</li>
<li>最后通过第2步和第3步得到的<code>contents</code>列表，生成一个<code>MixedSqlNode</code>，并作为<code>SqlNode</code>树的根节点返回</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.25</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.scripting.xmltags;</span></span><br><span class="line"><span class="comment">//XMLScriptBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MixedSqlNode <span class="title">parseDynamicTags</span><span class="params">(XNode node)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//一个SqlNode类型的列表，用来存储所有被解析成SqlNode的XNode</span></span><br><span class="line">    List&lt;SqlNode&gt; contents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取&lt;select|insert|update|delete&gt;节点的各个子SQL节点</span></span><br><span class="line">    NodeList children = node.getNode().getChildNodes();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历所有子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; children.getLength(); i++) &#123;</span><br><span class="line">        XNode child = node.newXNode(children.item(i));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//1.如果子节点是TEXT类型的</span></span><br><span class="line">        <span class="keyword">if</span> (child.getNode().getNodeType() == Node.CDATA_SECTION_NODE </span><br><span class="line">            || child.getNode().getNodeType() == Node.TEXT_NODE) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1-1.获取节点中的具体SQL语句</span></span><br><span class="line">            String data = child.getStringBody(<span class="string">""</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1-2.通过data来创建一个TextSqlNode节点</span></span><br><span class="line">            TextSqlNode textSqlNode = <span class="keyword">new</span> TextSqlNode(data);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1-3.如果动态，则添加到第2行定义的contents中</span></span><br><span class="line">            <span class="keyword">if</span> (textSqlNode.isDynamic()) &#123;</span><br><span class="line">                contents.add(textSqlNode);</span><br><span class="line">                isDynamic = <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//1-4.如果是静态的，则创建一个StaticTextSqlNode，并放入到contents中    </span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                contents.add(<span class="keyword">new</span> StaticTextSqlNode(data));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//2.如果子节点是ELEMENT类型的，也就是一&lt;xxx&gt;的节点    </span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (child.getNode().getNodeType() == Node.ELEMENT_NODE) &#123; <span class="comment">// issue #628</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2-1.获取标签的名称，例如:trim、where、if等</span></span><br><span class="line">            String nodeName = child.getNode().getNodeName();</span><br><span class="line">            </span><br><span class="line">           	<span class="comment">//2-2.根据名称获取不同的节点处理器</span></span><br><span class="line">            NodeHandler handler = nodeHandlerMap.get(nodeName);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2-3.处理没有获取到处理器的情况</span></span><br><span class="line">            <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Unknown element &lt;"</span> </span><br><span class="line">                                           + nodeName </span><br><span class="line">                                           + <span class="string">"&gt; in SQL statement."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2-4.调用处理器处理节点</span></span><br><span class="line">            handler.handleNode(child, contents);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//2-5.设置为动态</span></span><br><span class="line">            isDynamic = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//它是一个组合型节点，它会按顺序存储一个节点的列表</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MixedSqlNode(contents);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们从上面代码清单的53行<code>handler.handleNode(child, contents);</code>向下，以一个<code>If</code>类型的<code>NodeHandler</code>为例，看看<code>ELEMENT</code>节点是怎么被解析的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.26</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.scripting.xmltags;</span></span><br><span class="line"><span class="comment">//XMLScriptBuilder.IfHandler</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">IfHandler</span> <span class="keyword">implements</span> <span class="title">NodeHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">IfHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Prevent Synthetic Access</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNode</span><span class="params">(XNode nodeToHandle, List&lt;SqlNode&gt; targetContents)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对它的子节点再次调用parseDynamicTags，来生成一个MixSqlNode(相当于子节点列表)</span></span><br><span class="line">      	MixedSqlNode mixedSqlNode = parseDynamicTags(nodeToHandle);</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//从&lt;if&gt;节点(XNODE)上获取test属性</span></span><br><span class="line">        String test = nodeToHandle.getStringAttribute(<span class="string">"test"</span>);</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//创建一个IF类型的SQLNODE节点</span></span><br><span class="line">        IfSqlNode ifSqlNode = <span class="keyword">new</span> IfSqlNode(mixedSqlNode, test);</span><br><span class="line">      	</span><br><span class="line">        <span class="comment">//将这个节点添加到List中，也就是这个节点父节点的子节点列表</span></span><br><span class="line">        targetContents.add(ifSqlNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，就是对于<code>&lt;select|create|insert|delete&gt;</code>节点来说，它们的所有子节点内容将被解析为一棵节点类型为<code>SqlNode</code>的树，例如下图：这棵树储存在<code>MappedStatement.SqlSource.rootSqlNode</code>中，当运行时，用户调用传入具体参数，MyBatis就可以通过这棵树来生成具体的SQL语句了。至此，我们详细了解了SqlSource的生成过程，以及SqlSource的某些内部存储方式。</p>
<p><img src="https://i.loli.net/2020/03/24/xW2ROFrvbgfpXAl.png" alt=""></p>
<h5 id="3-2-4-4-构建MappedStatement"><a href="#3-2-4-4-构建MappedStatement" class="headerlink" title="3.2.4.4 构建MappedStatement"></a>3.2.4.4 构建<code>MappedStatement</code></h5><p>接着，我们从代码清单<code>3.20</code>的93行<code>builderAssistant.addMappedStatement(xxx)</code>向下，看一下存储SQL语句节点解析结果的<code>MappedStatement</code>是如何构建的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.27</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.scripting.xmltags;</span></span><br><span class="line"><span class="comment">//XMLScriptBuilder.IfHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MappedStatement <span class="title">addMappedStatement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    String id,</span></span></span><br><span class="line"><span class="function"><span class="params">    SqlSource sqlSource,</span></span></span><br><span class="line"><span class="function"><span class="params">    StatementType statementType,</span></span></span><br><span class="line"><span class="function"><span class="params">    SqlCommandType sqlCommandType,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer fetchSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    Integer timeout,</span></span></span><br><span class="line"><span class="function"><span class="params">    String parameterMap,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; parameterType,</span></span></span><br><span class="line"><span class="function"><span class="params">    String resultMap,</span></span></span><br><span class="line"><span class="function"><span class="params">    Class&lt;?&gt; resultType,</span></span></span><br><span class="line"><span class="function"><span class="params">    ResultSetType resultSetType,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> flushCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> useCache,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">boolean</span> resultOrdered,</span></span></span><br><span class="line"><span class="function"><span class="params">    KeyGenerator keyGenerator,</span></span></span><br><span class="line"><span class="function"><span class="params">    String keyProperty,</span></span></span><br><span class="line"><span class="function"><span class="params">    String keyColumn,</span></span></span><br><span class="line"><span class="function"><span class="params">    String databaseId,</span></span></span><br><span class="line"><span class="function"><span class="params">    LanguageDriver lang,</span></span></span><br><span class="line"><span class="function"><span class="params">    String resultSets)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理有没有找到的缓存引用的情况</span></span><br><span class="line">    <span class="keyword">if</span> (unresolvedCacheRef) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Cache-ref not yet resolved"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给id加上命名空间做前缀，以保证id的唯一性</span></span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//这个Sql语句是否为select语句</span></span><br><span class="line">    <span class="keyword">boolean</span> isSelect = sqlCommandType == SqlCommandType.SELECT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用建造者，并传入很多参数</span></span><br><span class="line">    MappedStatement.Builder statementBuilder </span><br><span class="line">        = <span class="keyword">new</span> MappedStatement.Builder(configuration, id, sqlSource, sqlCommandType)</span><br><span class="line">        .resource(resource)</span><br><span class="line">        .fetchSize(fetchSize)</span><br><span class="line">        .timeout(timeout)</span><br><span class="line">        .statementType(statementType)</span><br><span class="line">        .keyGenerator(keyGenerator)</span><br><span class="line">        .keyProperty(keyProperty)</span><br><span class="line">        .keyColumn(keyColumn)</span><br><span class="line">        .databaseId(databaseId)</span><br><span class="line">        .lang(lang)</span><br><span class="line">        .resultOrdered(resultOrdered)</span><br><span class="line">        .resultSets(resultSets)</span><br><span class="line">        .resultMaps(getStatementResultMaps(resultMap, resultType, id))</span><br><span class="line">        .resultSetType(resultSetType)</span><br><span class="line">        .flushCacheRequired(valueOrDefault(flushCache, !isSelect))</span><br><span class="line">        .useCache(valueOrDefault(useCache, isSelect))</span><br><span class="line">        .cache(currentCache);</span><br><span class="line"></span><br><span class="line">    ParameterMap statementParameterMap </span><br><span class="line">        = getStatementParameterMap(parameterMap, parameterType, id);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (statementParameterMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">        statementBuilder.parameterMap(statementParameterMap);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//建造</span></span><br><span class="line">    MappedStatement statement = statementBuilder.build();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将建造好的MappedStatement存储到Configuration中</span></span><br><span class="line">    configuration.addMappedStatement(statement);</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-2-4-5-总结"><a href="#3-2-4-5-总结" class="headerlink" title="3.2.4.5 总结"></a>3.2.4.5 总结</h5><p>下面总结下本大节的内容。本节主要完成<code>&lt;select|insert|delete|update&gt;</code>节点的解析工作。每一个这类型节点通过解析后都会生成一个<code>MappedStatement</code>实例，储存具体的信息。对于它的<code>&lt;inculde&gt;</code>和<code>&lt;selectKey&gt;</code>子节点，将被解析替换为正常的SQL节点。然后在完成了替换后<code>&lt;inculde&gt;</code>和<code>&lt;selectKey&gt;</code>子节点将被从<code>XNode</code>树中删除。这之后，会解析这个干净的<code>XNode</code>树，每个具体的SQL语句节点将被转义并存储到可以一颗<code>SqlNode</code>类型的树中，在运行时，我们通过解析这棵树将获取具体的SQL语句。然后，我们把<code>MappedStatement</code>节点存储到<code>Configuration</code>中。一个<code>&lt;select|insert|delete|update&gt;</code>节点的解析工作就完成了。</p>
<h3 id="3-3-Mapper接口绑定过程"><a href="#3-3-Mapper接口绑定过程" class="headerlink" title="3.3 Mapper接口绑定过程"></a>3.3 Mapper接口绑定过程</h3><p>当我们完成 了<code>&lt;mapper&gt;</code>文件的解析后，还需要通过绑定，将<code>&lt;mapper&gt;</code>文件中的每个SQL语句节点与java代码中对应<code>mapper</code>接口的对应方法绑定起来，存放到<code>Configuration.MapperRegistry</code>的<code>Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = new HashMap&lt;&gt;();</code>中，它也一个<code>Class</code>对象为键，以<code>MapperProxyFactory</code>为值，这个工厂可以通过反射为给类型的<code>mapper</code>接口生成实例。</p>
<p>这部分也不展开解释了，假如可以看懂第4章的sql执行过程，这个绑定过程也不在话下。</p>
<p>下面的代码是从代码清单<code>3.1</code>的17行<code>bindMapperForNamespace();</code>向下，完成具体的绑定过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.28</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;</span></span><br><span class="line"><span class="comment">//XMLMapperBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bindMapperForNamespace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取这个&lt;mapper&gt;的命名空间</span></span><br><span class="line">    String namespace = builderAssistant.getCurrentNamespace();</span><br><span class="line">    <span class="keyword">if</span> (namespace != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Class&lt;?&gt; boundType = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过命名空间找到对应的java类的Class对象</span></span><br><span class="line">            boundType = Resources.classForName(namespace);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">//ignore, bound type is not required</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (boundType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果这个java类还没有被解析过</span></span><br><span class="line">            <span class="keyword">if</span> (!configuration.hasMapper(boundType)) &#123;</span><br><span class="line">                <span class="comment">// Spring may not know the real resource name so we set a flag</span></span><br><span class="line">                <span class="comment">// to prevent loading again this resource from the mapper interface</span></span><br><span class="line">                <span class="comment">// look at MapperAnnotationBuilder#loadXmlResource</span></span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将这个类加入已解析列表</span></span><br><span class="line">                configuration.addLoadedResource(<span class="string">"namespace:"</span> + namespace);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//将解析好的</span></span><br><span class="line">                configuration.addMapper(boundType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，我们从上述代码清单的26行<code>configuration.addMapper(boundType);</code>向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:3.29</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.binding;</span></span><br><span class="line"><span class="comment">//MapperRegistry</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> </span><br><span class="line">                                       + type </span><br><span class="line">                                       + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//下面是用来处理注解的</span></span><br><span class="line">            <span class="comment">// It's important that the type is added before the parser is run</span></span><br><span class="line">            <span class="comment">// otherwise the binding may automatically be attempted by the</span></span><br><span class="line">            <span class="comment">// mapper parser. If the type is already known, it won't try.</span></span><br><span class="line">            MapperAnnotationBuilder parser </span><br><span class="line">                = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">            parser.parse();</span><br><span class="line">            loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">                knownMappers.remove(type);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/21/MyBatis源码-2-配置文件的解析过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/21/MyBatis源码-2-配置文件的解析过程/" itemprop="url">[MyBatis源码][2][配置文件的解析过程]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-21T14:14:37+08:00">
                2020-03-21
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MyBatis/" itemprop="url" rel="index">
                    <span itemprop="name">MyBatis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/21/MyBatis源码-2-配置文件的解析过程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/21/MyBatis源码-2-配置文件的解析过程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第二章-配置文件的解析过程"><a href="#第二章-配置文件的解析过程" class="headerlink" title="第二章 配置文件的解析过程"></a>第二章 配置文件的解析过程</h2><p>首先我们从一个入口的例程开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.0</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Logger logger = Logger.getLogger(MyApp.class);</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(<span class="string">"mybatis.xml"</span>);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = </span><br><span class="line">            <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        ProductDao productDao = sqlSession.getMapper(ProductDao.class);</span><br><span class="line">        Product product= productDao.getProduct(<span class="number">12</span>);</span><br><span class="line">        logger.info(product);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从这个例程我们可以看出：</p>
<ol>
<li>首先我们通过MyBatis提供的<code>Resources</code>类读取了配置文件。</li>
<li>然后使用<code>SqlSessionFactoryBuilder</code>，来建造一个<code>SqlSessionFactory</code></li>
<li>接着通过这个工厂获取<code>SqlSession</code>实例，就可以使用<code>SqlSession</code>执行各种数据库操作</li>
</ol>
<p>接下来详细分析<code>SqlSessionFactoryBuilder</code>的<code>build()</code>方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.1</span></span><br><span class="line"><span class="comment">// package org.apache.ibatis.session;</span></span><br><span class="line"><span class="comment">// SqlSessionFactoryBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 String environment, </span></span></span><br><span class="line"><span class="function"><span class="params">                                 Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      XMLConfigBuilder parser = </span><br><span class="line">          <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">      <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ErrorContext.instance().reset();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        inputStream.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，主要逻辑是，使用<code>XMLConfigBulider</code>的<code>parse()</code>方法生成一个<code>Configuration</code>对象，<code>Configuration</code>类存放了Mybatis的所有全局配置，根据这个类中的配置，我们就可以使用建造者模式建造一个<code>SqlSessionFactory</code>了。</p>
<p>我们再跟随第九行代码的调用栈向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.2</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parsed = <span class="keyword">true</span>;</span><br><span class="line">    parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这个方法的逻辑极其简单，首先通过一个标识<code>parsed</code>判断这个配置文件是否已经被解析过了，解析过则直接返回。否则调用<code>parseConfiguration()</code>进行解析。</p>
<p>我们再跟随第8行代码的调用栈向下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.3</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      	<span class="comment">//issue #117 read properties first</span></span><br><span class="line">     	propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">        </span><br><span class="line">      	Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">      </span><br><span class="line">      	loadCustomVfs(settings);</span><br><span class="line">      	loadCustomLogImpl(settings);</span><br><span class="line">      </span><br><span class="line">      	typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">      </span><br><span class="line">      	pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">      </span><br><span class="line">        objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">      </span><br><span class="line">        objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">      </span><br><span class="line">        reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">      </span><br><span class="line">        settingsElement(settings);</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">      </span><br><span class="line">        environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">      </span><br><span class="line">        databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">      </span><br><span class="line">        typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">      </span><br><span class="line">        mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> </span><br><span class="line">                                 + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到这个方法按照顺序，从<code>XNode</code>根节点出发，解析了不同的配置文件节点。这里简单解释一下什么是<code>XNode</code>，它是一颗类似DOM结构的树，这棵树存放了XML的初步解析结果。</p>
<p>上述调用栈如下图</p>
<p><img src="https://i.loli.net/2020/03/21/5HmuiwlYjrStg4a.png" alt=""></p>
<p>接下来我们将具体分析<code>&lt;properties&gt;</code>节点、<code>&lt;settings&gt;</code>节点、<code>&lt;typeAliases&gt;</code>节点和<code>&lt;typeHandler&gt;</code>节点的解析过程，注意：这些节点的解析结果最终都将存放在<code>Configuration</code>中</p>
<h3 id="2-1-lt-properties-gt-节点解析过程"><a href="#2-1-lt-properties-gt-节点解析过程" class="headerlink" title="2.1 &lt;properties&gt;节点解析过程"></a>2.1 <code>&lt;properties&gt;</code>节点解析过程</h3><p><code>&lt;properties&gt;</code>节点的主要作用是定义一些在后面的节点会使用的变量，如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--id:2.4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/cosmetic_store?serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbc.password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"biz.t0ugh.Model.Product"</span> <span class="attr">alias</span>=<span class="string">"product"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"ProductMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到，我们在<code>&lt;dataSource&gt;</code>中引用了<code>&lt;properties&gt;</code>节点定义的变量</p>
<p>接下来我们从编号<code>2.3</code>的代码段第7行<code>propertiesElement(root.evalNode(&quot;properties&quot;));</code>向下，详细分析这个方法。</p>
<p>首先我们知道，<code>properties</code>的内容由两部分构成</p>
<ol>
<li>可以在子节点<code>&lt;property&gt;</code>中，通过键值对的方式定义，如<code>2.4</code>代码段中从4-7行所示</li>
<li>也可以通过<code>&lt;properties&gt;</code>节点上的<code>resource</code>属性或者<code>url</code>属性，从其他文件中读入一些<code>properties</code></li>
</ol>
<p>那么这个方法实际上也只是做了这项工作</p>
<ol>
<li>遍历所有<code>&lt;property&gt;</code>子节点，将得到的k-v对存入一个<code>Properties</code>的实例</li>
<li>从其他文件中读取，将得到的所有k-v对存入第一步的<code>Properties</code>实例。注意：若第二步中某些配置与第一步重名，第一步的这个配置将被覆盖</li>
<li>最后将得到的<code>Properties</code>实例存入到<code>Configuration</code>中，这样以后MyBatis的其他部分使用这些属性时直接读取即可</li>
</ol>
<p>源代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.5</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">propertiesElement</span><span class="params">(XNode context)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        </span><br><span class="line">      	<span class="comment">//1. 首先解析所有子节点并放入defaults</span></span><br><span class="line">      	Properties defaults = context.getChildrenAsProperties();</span><br><span class="line">      </span><br><span class="line">        <span class="comment">//2. 读取文件中的property，也放入defaults</span></span><br><span class="line">       	String resource = context.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">      	String url = context.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">      	<span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	<span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"xxxx"</span>);</span><br><span class="line">      	&#125;</span><br><span class="line">      	<span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	defaults.putAll(Resources.getResourceAsProperties(resource));</span><br><span class="line">      	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (url != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	defaults.putAll(Resources.getUrlAsProperties(url));</span><br><span class="line">      	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.读取Configuration中原本的property，放入defaults</span></span><br><span class="line">      	Properties vars = configuration.getVariables();</span><br><span class="line">      	<span class="keyword">if</span> (vars != <span class="keyword">null</span>) &#123;</span><br><span class="line">        	defaults.putAll(vars);</span><br><span class="line">      	&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.将default存入Configuration</span></span><br><span class="line">      	parser.setVariables(defaults);</span><br><span class="line">      	configuration.setVariables(defaults);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-lt-settings-gt-节点解析过程"><a href="#2-2-lt-settings-gt-节点解析过程" class="headerlink" title="2.2 &lt;settings&gt;节点解析过程"></a>2.2 <code>&lt;settings&gt;</code>节点解析过程</h3><p><code>&lt;settings&gt;</code>节点的主要作用是定义一些MyBatis运行时的行为，如代码块<code>2.4</code>的9-11行中，定义了是否开启缓存</p>
<p>接下来我们从编号<code>2.3</code>的代码段第9行<code>Properties settings = settingsAsProperties(root.evalNode(&quot;settings&quot;));</code>向下，详细分析这个方法。</p>
<p>首先我们思考<code>settings</code>解析与<code>properties</code>解析的区别是什么？答案是<code>&lt;setting&gt;</code>节点中的<code>name</code>属性必须是mybatis支持的配置，要言之有物才行。假如我们如下代码定义一个名为<code>hello</code>的节点，mybatis一定会报错，因为它没有<code>hello</code>这个设置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--下面这个设置是不存在的，肯定会报错--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">value</span>=<span class="string">"world"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>那么我们接着思考，如何验证一个设置是否存在呢？最简单的方法是维护一个常量表，它存储所有存在的设置。但是这很不灵活还会造成冗余。Mybatis使用了Java的放射机制，它有一个工具类叫做<code>MataClass</code>，可以读取<code>Configuration</code>中的所有<code>setxxx()</code>方法。这样我们每读取一个设置，就通过<code>MataClass</code>来检查<code>Configuration</code>中是否有对应的<code>setter</code>，没有就报错。</p>
<p>具体步骤如下</p>
<ol>
<li>解析<code>settings</code>子节点的内容，并将解析结果转成<code>Properties</code>对象</li>
<li>为<code>Configuration</code>创建元信息对象<code>MetaClass</code></li>
<li>通过<code>MetaClass</code>检测<code>Configuration</code>中是否存在某个属性的<code>setter</code>方法</li>
<li>若通过<code>MetaClass</code>的检测，则返回<code>Properties</code>对象。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.5</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Properties <span class="title">settingsAsProperties</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> Properties();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 解析settings子节点的内容，并将解析结果转成Properties对象</span></span><br><span class="line">    Properties props = context.getChildrenAsProperties();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.生成元数据对象</span></span><br><span class="line">    <span class="comment">// Check that all settings are known to the configuration class</span></span><br><span class="line">    MetaClass metaConfig = </span><br><span class="line">        MetaClass.forClass(Configuration.class, localReflectorFactory);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3.对每个设置项进行检查</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : props.keySet()) &#123;</span><br><span class="line">      	<span class="keyword">if</span> (!metaConfig.hasSetter(String.valueOf(key))) &#123;</span><br><span class="line">      		<span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"The setting "</span> + key + <span class="string">" is not known."</span>);</span><br><span class="line">      	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.返回</span></span><br><span class="line">    <span class="keyword">return</span> props;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样我们就取得了包含所有设置项的<code>Properties</code>对象，接下来还需要将这个对象中的内容存储到<code>Configuration</code>中，源代码如下，逻辑很简单，就是调用各种<code>setter</code>而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.6</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">settingsElement</span><span class="params">(Properties props)</span> </span>&#123;</span><br><span class="line">   		configuration.setAutoMappingBehavior(AutoMappingBehavior.valueOf(props.getProperty(<span class="string">"autoMappingBehavior"</span>, <span class="string">"PARTIAL"</span>)));</span><br><span class="line">    <span class="comment">//...其他省略，都是这种setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-lt-typeAliases-gt-节点解析过程"><a href="#2-3-lt-typeAliases-gt-节点解析过程" class="headerlink" title="2.3 &lt;typeAliases&gt;节点解析过程"></a>2.3 <code>&lt;typeAliases&gt;</code>节点解析过程</h3><p>我们都知道，MyBatis提供一个很方便的功能：我们可以给自己写的类定义别名(aliases)，这样当我们在MyBatis中需要使用类名时，只需要写这个别名，而不需要写冗长的全限定类名。</p>
<p>MyBatis中的别名配置方式有两种</p>
<ol>
<li><p>配置包名，这个包下的所有类都会被扫描并且根据类名生成别名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.edu.neu.zady.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过手动的方式，明确为某个类型配置别名</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">package</span> <span class="attr">alias</span>=<span class="string">"product"</span> <span class="attr">type</span>=<span class="string">"com.edu.neu.zady.dao.Product"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>除了这些自定义的别名，MyBatis还在<code>Configuration</code>中为一些常用类生成了别名。</p>
<p>在<code>Configuration</code>中，自定义的别名和预定义的别名都存放在了<code>TypeAliasRegister</code>中，它提供注册别名和获取别名的功能。</p>
<p>具体源代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.7</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeAliasesElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">// 1. 解析使用package配置的别名-类型映射</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          String typeAliasPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          configuration.getTypeAliasRegistry().registerAliases(typeAliasPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 2. 解析使用typeAlias配置的别名-类型映射</span></span><br><span class="line">          String alias = child.getStringAttribute(<span class="string">"alias"</span>);</span><br><span class="line">          String type = child.getStringAttribute(<span class="string">"type"</span>);</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Resources.classForName(type);</span><br><span class="line">            <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">              typeAliasRegistry.registerAlias(clazz);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              typeAliasRegistry.registerAlias(alias, clazz);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error registering typeAlias for '"</span> + alias + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>由上源码可见，对于别名的解析，主要是使用<code>Configuration</code>中的<code>typeAliasRegister</code>属性的各种重载的<code>registerAlias()</code>方法，这些重载比较多。我们挑选代码段<code>2.7</code>的第19行<code>typeAliasRegistry.registerAlias(alias, clazz);</code>作为入口，继续向下，分析一个具体的注册过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.8</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.type;</span></span><br><span class="line"><span class="comment">//TypeAliasRegistry</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//成员变量，一个Map，用来实际存放别名-类型映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; typeAliases = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerAlias</span><span class="params">(String alias, Class&lt;?&gt; value)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (alias == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The parameter alias cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//1. 首先将名称alias转化为小写</span></span><br><span class="line">    <span class="comment">// issue #748</span></span><br><span class="line">    String key = alias.toLowerCase(Locale.ENGLISH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 判断这个alias是否已经注册过了，注册过了就报错</span></span><br><span class="line">    <span class="keyword">if</span> (typeAliases.containsKey(key) </span><br><span class="line">        &amp;&amp; typeAliases.get(key) != <span class="keyword">null</span> </span><br><span class="line">        &amp;&amp; !typeAliases.get(key).equals(value)) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> TypeException(<span class="string">"The alias '"</span> + </span><br><span class="line">                              alias + </span><br><span class="line">                              <span class="string">"' is already mapped to the value '"</span> +</span><br><span class="line">                              typeAliases.get(key).getName() +</span><br><span class="line">                              <span class="string">"'."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3. 存入Map中</span></span><br><span class="line">    typeAliases.put(key, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>解析<code>&lt;package&gt;</code>的过程与此类似，这里就不再赘述。</p>
<h3 id="2-4-lt-typeHandler-gt-节点解析过程"><a href="#2-4-lt-typeHandler-gt-节点解析过程" class="headerlink" title="2.4 &lt;typeHandler&gt;节点解析过程"></a>2.4 <code>&lt;typeHandler&gt;</code>节点解析过程</h3><p>在向数据库存储或读取数据时，我们需要将数据库字段类型和java类型进行一个转换。比如数据库中有<code>CHAR</code>和 <code>VARCHAR</code>等类型，但java中没有这些类型，不过java有<code>String</code>类型。所以我们在从数据库中读取<code>CHAR</code>和 <code>VARCHAR</code>类型的数据时，就可以把它们转成<code>String</code>。在 MyBatis中，数据库类型和java类型之间的转换任务是委托给类型处理器<code>TypeHandler</code>去处理的。<code>MyBatis</code>提供了一些常见类型的类型处理器，除此之外，我们还可以自定义类型处理器以非常见类型转换的需求。</p>
<p>了解完<code>TypeHandler</code>的用途，我们继续探究它是如何注册到<code>Configuration</code>的。我们从代码段<code>2.3</code>的32行<code>typeHandlerElement(root.evalNode(&quot;typeHandlers&quot;));</code>继续向下，查看<code>typeHandlerElement</code>方法，这个方法主要有三步</p>
<ol>
<li>读取javaType、jdbcType、handlerType的字符串形式，也就是类名</li>
<li>将这些类名解析为具体的Class对象</li>
<li>根据前两步的解析结果选择不同的解析方法，也是一堆register的重载方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.9</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.builder.xml;  </span></span><br><span class="line"><span class="comment">//XMLConfigBuilder </span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">typeHandlerElement</span><span class="params">(XNode parent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">        <span class="comment">//使用指定的包来注册TypeHandler</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">          String typeHandlerPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">          typeHandlerRegistry.register(typeHandlerPackage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//使用typeHandlers的typeHandler子节点来注册TypeHandler</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//1. 读取javaType、jdbcType、handlerType的字符串形式，也就是类名</span></span><br><span class="line">          String javaTypeName = child.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">          String jdbcTypeName = child.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">          String handlerTypeName = child.getStringAttribute(<span class="string">"handler"</span>);</span><br><span class="line">            </span><br><span class="line">          <span class="comment">//2. 将这些类名解析为具体的Class对象</span></span><br><span class="line">          Class&lt;?&gt; javaTypeClass = resolveClass(javaTypeName);</span><br><span class="line">          JdbcType jdbcType = resolveJdbcType(jdbcTypeName);</span><br><span class="line">          Class&lt;?&gt; typeHandlerClass = resolveClass(handlerTypeName);</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//3. 根据前两步的解析结果选择不同的解析方法，也是一堆register的重载方法</span></span><br><span class="line">          <span class="keyword">if</span> (javaTypeClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (jdbcType == <span class="keyword">null</span>) &#123;</span><br><span class="line">              typeHandlerRegistry.register(javaTypeClass, typeHandlerClass);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            typeHandlerRegistry.register(typeHandlerClass);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>我们现在知道了，实际的解析过程是通过<code>Configuration</code>的成员变量<code>TypeHandlerRegistry</code>的各种名为<code>register</code>的重载方法进行的。我们从代码段<code>2.9</code>的28行继续向下<code>typeHandlerRegistry.register(javaTypeClass, jdbcType, typeHandlerClass);</code>，这个方法的具体分析我放到了注释中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//id:2.10</span></span><br><span class="line"><span class="comment">//package org.apache.ibatis.type;</span></span><br><span class="line"><span class="comment">//TypeHandlerRegister</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这个Map&lt;Type, Map&gt;实际保存了JavaType到JdbcType的映射，并且还保存了JdbcType到TypeHandler的映射</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Type, Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt;&gt; typeHandlerMap </span><br><span class="line">    = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//register的一个重载方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Type javaType, JdbcType jdbcType, TypeHandler&lt;?&gt; handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (javaType != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//1. 在typeHandlerMap(映射保存实际使用的数据结构)中，使用javaType作为key查询，返回一个保存了这个javaType所有映射的Map</span></span><br><span class="line">      Map&lt;JdbcType, TypeHandler&lt;?&gt;&gt; map = typeHandlerMap.get(javaType);</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//2.如果为空，则创建</span></span><br><span class="line">      <span class="keyword">if</span> (map == <span class="keyword">null</span> || map == NULL_TYPE_HANDLER_MAP) &#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        typeHandlerMap.put(javaType, map);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">//3.将通过参数传入的这个新的类型处理器加入map</span></span><br><span class="line">      map.put(jdbcType, handler);</span><br><span class="line">    &#125;</span><br><span class="line">    allTypeHandlersMap.put(handler.getClass(), handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由代码段<code>2.10</code>可知，注册过程其实就是把这个新的类型处理器放到<code>Map</code>中，仅此而已。不过，值得注意的是，这个<code>Map</code>是一个两层嵌套结构，例子如下图所示。这也启示我们，如果要存储三元组，可以使用<code>Map</code>嵌套<code>Map</code>的方式。</p>
<p><img src="https://i.loli.net/2020/03/21/ahi8fSrn53BZQ9w.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/09/微服务设计-5-分解单块系统/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/09/微服务设计-5-分解单块系统/" itemprop="url">[微服务设计][5][分解单块系统]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-09T20:35:13+08:00">
                2020-03-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/微服务设计/" itemprop="url" rel="index">
                    <span itemprop="name">微服务设计</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/09/微服务设计-5-分解单块系统/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/09/微服务设计-5-分解单块系统/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-5-章-分解单块系统"><a href="#第-5-章-分解单块系统" class="headerlink" title="第 5 章 分解单块系统"></a>第 5 章 分解单块系统</h2><h3 id="5-1-关键是接缝"><a href="#5-1-关键是接缝" class="headerlink" title="5.1 关键是接缝"></a>5.1 关键是接缝</h3><p>服务应该是高内聚、低耦合的。</p>
<p>在《修改代码的艺术》这本书中定义了<strong>接缝</strong>的概念，从接缝处可以抽取出相对独立的一部分代码，对这部分代码进行修改不会影响系统的其他部分。识别出接缝不仅仅能够清理代码库，更重要的是，这些被识别出的接缝可以成为服务的边界。<strong>限界上下文</strong>就是一个非常好的接缝。</p>
<h3 id="5-2-分解MusicCorp"><a href="#5-2-分解MusicCorp" class="headerlink" title="5.2 分解MusicCorp"></a>5.2 分解MusicCorp</h3><p>首先，我们应该<strong>识别</strong>出组织中的<strong>高层限界上下文</strong>。然后，尝试将这个<strong>单块</strong>系统的各部分代码<strong>映射</strong>到这些限界上下文中。</p>
<p>举例说明，想象一下，现在有一个巨大的后台单块服务，其中包含了 MusicCorp在线音乐系统所需要的所有行为。假设一开始我们识别出这个单块后台系统包含以下四个上下文。</p>
<ul>
<li>产品目录：与正在销售的商品相关的元数据。</li>
<li>财务：账户、支付、退款等项目的报告。</li>
<li>仓库：分发客户订单、处理退货、管理库存等。</li>
<li>推荐：该系统的算法正在申请专利。它是革命性的推荐系统，代码非常复杂。该团队中博士的比例，比一般科学实验室的还要高。</li>
</ul>
<p>首先创建<strong>包结构</strong>来表示这些上下文，然后把已有的代码移动到相应的位置。当移动之后，就可以看到哪些代码很好地找到了自己的位置，而哪些代码找不到合适的位置。这些剩下的代码很有可能就是我们遗漏掉的限界上下文。</p>
<p>接着我们分析<strong>包之间的交互</strong>。代码应该与组织相匹配，所以表示限界上下文的这些包之间的交互，也应该与组织中不同部分的实际交互方式一致。举个例子，如果发现仓库包依赖于财务包中的代码，而真实的组织中并不存在这样的依赖，那么就需要看看到底是什么问题，并想办法解决它。</p>
<h3 id="5-3-分解单块系统的原因"><a href="#5-3-分解单块系统的原因" class="headerlink" title="5.3 分解单块系统的原因"></a>5.3 分解单块系统的原因</h3><p>分解单块系统最好遵循增量模式，一步一步分解。把单块系统想象成为一块大理石，我们可以把整块石头炸开，但这样做的结果通常不好。增量开凿的方式更合理。增量的方式可以让你在进行的过程中学习微服务，同时也可以限制出错所造成的影响。</p>
<h3 id="5-4-杂乱的依赖"><a href="#5-4-杂乱的依赖" class="headerlink" title="5.4 杂乱的依赖"></a>5.4 杂乱的依赖</h3><p>略</p>
<h3 id="5-5-数据库"><a href="#5-5-数据库" class="headerlink" title="5.5 数据库"></a>5.5 数据库</h3><p>前面详细讨论了使用数据库作为服务之间集成方式的做法。而且我已经非常明确地表示我不喜欢这么做！这意味着需要找到数据库中的接缝，这样就可以把它们分离干净。然而数据库是一个棘手的怪物。</p>
<h3 id="5-6-找到问题的关键"><a href="#5-6-找到问题的关键" class="headerlink" title="5.6 找到问题的关键"></a>5.6 找到问题的关键</h3><p>第一步是看看代码中对数据库进行读写的部分，通常这部分代码会存在于一个仓储层中。其中会使用某种框架，比如 Hibernate，来把代码和数据库进行绑定。对于数据库访问相关的代码来说，也应该做类似的事情，所以需要把仓储层的代码分成几部分，如下图所示。</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_0.png" alt=""></p>
<p>把数据库映射相关的代码和功能代码放在同一个上下文中，可以帮助我们理解哪些代码用到了数据库中的哪些部分。</p>
<p>当将持久层分包完毕后，你会发现，有的数据库表横跨不同的限界上下文；而不同上下文之间的表还保持着外键关系；甚至数据库事务也被分离到了不同的包中完成。下面我们来探讨如何解决这些问题</p>
<h3 id="5-7-例子：打破外键关系"><a href="#5-7-例子：打破外键关系" class="headerlink" title="5.7 例子：打破外键关系"></a>5.7 例子：打破外键关系</h3><p>假设出于某些业务，财务的总账表有指向产品目录的外键。</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_1.png" alt=""></p>
<p>我们现在要拆分数据库，怎么处理这个外键呢？事实上修改分为两步。</p>
<ol>
<li>首先要去除财务部分的代码对行条目表的访问。快速的修改方式是，让财务部分的代码通过产品目录服务暴露的API来访问数据，而不是直接访问数据库。这个API调用会成为微服务化的第一步，如下图所示。但是，这样做会导致一件事：原本只需要访问一次数据库就可以完成的业务，现在可能要访问多次了。好在Mysql数据库目前建立和断开连接的速度很快，所以也许多次数据库访问不是问题。</li>
</ol>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_2.png" alt=""></p>
<ol start="2">
<li>那外键关联怎么办？我们也只能放弃它了。所以你可能需要把这个约束从数据库移到代码中来实现。这也就意味着，我们可能需要实现跨服务的一致性检査，或者周期性触发清理数据的任务。</li>
</ol>
<h3 id="5-8-例子：共享静态数据"><a href="#5-8-例子：共享静态数据" class="headerlink" title="5.8 例子：共享静态数据"></a>5.8 例子：共享静态数据</h3><p>静态数据指的是：代码中很少更改的数据。我们可以理解为在业务中它们是只读的。例如：我们有一个表记录了本软件支持的国家。这个表通常很少通过代码进行写操作，更多是后台人员对它进行写维护。但是会有很多服务都用到国家表这种静态数据，如下图</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_3.png" alt=""></p>
<p>有这么几个解决方案可供选择。第一个是为每个包复制一份该表的内容，也就是说，未来每个服务也都会保存这样一份副本。当然这会导致一个潜在的一致性问题。比如说，当澳大利亚东海岸新成立了一个国家叫作 Newmantopia，你有可能会漏修改掉一些服务中的表。</p>
<p>第二个方法是，把这些共享的静态数据放入代码，比如放在属性文件中，或者简单地放在个枚举中。数据一致性的问题仍然存在，虽然从经验上看，修改配置文件比修改在线数据库要简单得多。通常这是比较合理的办法。</p>
<p>第三个方法有些极端，即把这些静态数据放入一个单独的服务中。</p>
<h3 id="5-9-例子：共享数据"><a href="#5-9-例子：共享数据" class="headerlink" title="5.9 例子：共享数据"></a>5.9 例子：共享数据</h3><p>前面我们讨论的是静态数据，那如果数据不是静态的呢？现在来考虑一个更为复杂的例子，共享的可变数据对于分离系统来说通常是一个大麻烦。<br>财务代码会追踪客户产生的订单信息，同时也会追踪退货和退款。仓库代码也会在客户订单被分发或者接受之后更新订单信息。它们都会依赖于客户信息表。如下所示</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_4.png" alt=""></p>
<p>所以，无论是财务相关的代码还是仓库相关的代码，都会向同一个表写入数据，有时还会从中读取数据。在这种情况下应如何做分离？这种情况，可能提醒我们：缺少客户这个限界上下文。如下图所示。我们可以创建一个新的包，叫作Customer。然后让财务和仓库这些包，通过API来访问此新创建的包。</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_5.png" alt=""></p>
<h3 id="5-10-例子：共享表"><a href="#5-10-例子：共享表" class="headerlink" title="5.10 例子：共享表"></a>5.10 例子：共享表</h3><p>下图展示了一个示例。产品目录需要存储记录的名字和价格，而仓库需要保存存储的电子记录。最初我们把这两部分数据全都存储在产品条目表中。但是现在仓储服务和产品服务都要访问这张表</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_6.png" alt=""></p>
<p>这里的答案是分成两个表。可以对仓库创建库存项表，对产品目录详情创建产品目录项表。</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_7.png" alt=""></p>
<h3 id="5-11-重构数据库"><a href="#5-11-重构数据库" class="headerlink" title="5.11 重构数据库"></a>5.11 重构数据库</h3><p>我们已经找到了应用程序中的接缝，按照限界上下文对它们进行分组，并且也找到了数据库中的接缝，尽量对其进行了分离。然后呢？你想要在一次发布中把单块服务直接变成两个服务，并且每个服务有各自的数据库结构吗？事实上，我会推荐你先分离数据库结构，暂时不对服务进行分离，如下图所示</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_8.png" alt=""></p>
<p>表结构分离后</p>
<ol>
<li>对于原先的某个动作而言，对数据库访问的次数可能会变多。以前简单地用一个 SELECT语句就能得到所有的数据，现在则需要分别从不同的地方拿到数据，然后在内存中进行连接。</li>
<li>分成两个表结构会破坏事务完整性，这会对应用程序造成很大的影响</li>
</ol>
<h3 id="5-12-事务边界"><a href="#5-12-事务边界" class="headerlink" title="5.12 事务边界"></a>5.12 事务边界</h3><p>事务是很有用的东西，它可以保证一些事件要么都发生，要么都不发生。在插入数据库时这点非常有用，因为它允许我们对多个表同时进行修改，而且一旦发生任何错误，所有的操作都会被回退，从而保证数据库不会处于一个不一致的状态。</p>
<p>使用单块表结构时，所有的创建或者更新操作都可以在一个事务边界内完成。例如，可以在同一个事务中进行订单的插入和仓库记录的插入操作</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_9.png" alt=""></p>
<p>但是，分离数据库之后，我们就很难以如此简单的方式实现事务了。我们已经把表结构分成了两部分，其中一个与客户相关，其余的与仓库相关，那么就无法获得事务所能提供的安全性。下订单操作现在跨越了两个事务边界，如下图</p>
<p><img src="/2020/03/09/微服务设计-5-分解单块系统/200309_10.png" alt=""></p>
<h4 id="5-12-1-再试一次"><a href="#5-12-1-再试一次" class="headerlink" title="5.12.1 再试一次"></a>5.12.1 再试一次</h4><p>其实，对我们来说知道订单被捕获并被处理就足够了。我们可以把对仓库的提取表的操作放在一个队列或者日志文件中，之后再尝试对其进行触发。我们把这种形式叫作最终一致性。相对于使用事务来保证系统处于一致的状态，最终一致性可以接受系统在未来的某个时间达到一致。</p>
<h4 id="5-12-2-终止整个操作"><a href="#5-12-2-终止整个操作" class="headerlink" title="5.12.2 终止整个操作"></a>5.12.2 终止整个操作</h4><p>另一个选择是拒绝整个操作。我们需要通过多个补偿事务，把系统重置到某种一致的状态。</p>
<h4 id="5-12-3-分布式事务"><a href="#5-12-3-分布式事务" class="headerlink" title="5.12.3 分布式事务"></a>5.12.3 分布式事务</h4><p>我们还使用分布式事务。分布式事务会横跨多个事务，然后使用一个叫作事务管理器的工具来统一编配其他底层系统中运行的事务。就像普通的事务一样，一个分布式的事务会保证整个系统处于一致的状态。唯一不同的是，这里的事务会运行在不同系统的不同进程中，通常它们之间使用网络进行通信。</p>
<p>处理分布式事务常用的算法是两阶段提交。</p>
<ol>
<li>首先是投票阶段。在这个阶段，每个参与者会告诉事务管理器它是否应该继续。</li>
<li>如果事务管理器收到的所有投票都是成功，则会告知它们进行提交操作。</li>
<li>只要收到一个否定的投票，事务管理器就会让所有的参与者回退。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/Redis-20-Lua脚本/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/08/Redis-20-Lua脚本/" itemprop="url">[Redis][20][Lua脚本]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-08T18:37:42+08:00">
                2020-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/08/Redis-20-Lua脚本/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/08/Redis-20-Lua脚本/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-20-章-Lua脚本"><a href="#第-20-章-Lua脚本" class="headerlink" title="第 20 章 Lua脚本"></a>第 20 章 Lua脚本</h2><p>通过在服务器中嵌入Lua环境，Redis客户端可以使用Lua脚本，直接在服务器端原子地执行多个Redis命令。</p>
<ul>
<li>使用EVAL命令可以直接对输入的脚本进行求值</li>
<li>使用EVALSHA命令则可以根据脚本的SHA1校验和来对脚本进行求值</li>
<li>使用SCRIPT LOAD命令可以载入这个校验和对应的脚本</li>
</ul>
<p>本章的安排</p>
<ol>
<li>介绍Redis服务器初始化Lua环境的整个过程</li>
<li>介绍与Lua环境进行协作的两个组件，它们分别是负责执行Lua脚本中包含的Redis命令的伪客户端以及负责保存传入服务器的Lua脚本的脚本字典</li>
<li>介绍EVAL和EVALSHA命令的实现原理</li>
<li>介绍管理脚本的四个命令：SCRIPT FLUSH命令、SCRIPT EXISTS命令、SCRIPT LOAD命令和SCRIPT KILL命令的实现原理</li>
<li>介绍Redis在主从服务器之间复制Lua脚本的方法</li>
</ol>
<h3 id="20-1-创建并修改Lua环境"><a href="#20-1-创建并修改Lua环境" class="headerlink" title="20.1 创建并修改Lua环境"></a>20.1 创建并修改Lua环境</h3><p>Redis在服务器内嵌了一个Lua环境并对这个Lua环境进行了一系列修改，</p>
<h4 id="20-1-1-创建Lua环境"><a href="#20-1-1-创建Lua环境" class="headerlink" title="20.1.1 创建Lua环境"></a>20.1.1 创建Lua环境</h4><p>在最开始的这一步，服务器首先调用Lua的<code>C API</code>函数<code>lua_open()</code>，创建一个新的Lua环境</p>
<h4 id="20-1-2-载入函数库"><a href="#20-1-2-载入函数库" class="headerlink" title="20.1.2 载入函数库"></a>20.1.2 载入函数库</h4><p>Redis修改Lua环境的第一步，就是将以下函数库载入到Lua环境里面：</p>
<ul>
<li>基础库</li>
<li>表格库</li>
<li>字符串库</li>
<li>数学库</li>
<li>调试库</li>
<li>Lua CJSON库</li>
<li>Struct库</li>
<li>Lua cmsgpack库</li>
</ul>
<p>通过使用这些功能强大的函数库，Lua脚本可以直接对执行Redis命令获得的数据进行复杂的操作。</p>
<h4 id="20-1-3-创建Redis全局表格"><a href="#20-1-3-创建Redis全局表格" class="headerlink" title="20.1.3 创建Redis全局表格"></a>20.1.3 创建Redis全局表格</h4><p>在这一步，服务器将在Lua环境中创建一个Redis表格，并将它设为全局变量。这个Redis表格主要包含各种对Redis中的数据进行操作的函数，使得Lua脚本具有操作Redis数据库的能力</p>
<ul>
<li>用于执行Redis命令的<code>redis.call</code>和<code>redis.pca11</code>函数。</li>
<li>用于记录Redis日志的<code>redis.1og</code>函数</li>
<li>用于计算SHA1校验和的<code>redis.sha1hex</code>函数。</li>
<li>用于返回错误信息的<code>redis.error_rep1y</code>函数和<code>redis.status_reply</code>函数。</li>
</ul>
<p>在这些函数里面，最常用也最重要的要数<code>redis.ca11</code>函数和<code>redis.pca11</code>函数，通过这两个函数，用户可以直接在Lua脚本中执行Redis命令</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; EVAL <span class="string">"return redis.call('PING')"</span> 0</span><br><span class="line">PONG</span><br></pre></td></tr></table></figure>
<h4 id="20-1-4-使用Redis自制的随机函数来替换Lua原有的随机函数"><a href="#20-1-4-使用Redis自制的随机函数来替换Lua原有的随机函数" class="headerlink" title="20.1.4 使用Redis自制的随机函数来替换Lua原有的随机函数"></a>20.1.4 使用Redis自制的随机函数来替换Lua原有的随机函数</h4><p>为了保证<strong>相同的脚本</strong>可以在<strong>不同的机器</strong>上产生<strong>相同的结果</strong>， Redis要求所有传入服务器的Lua脚本，以及Lua环境中的所有函数，都必须是无副作用的纯函数。</p>
<p>因为这个原因，Redis使用<strong>自制的函数</strong>替换了<code>math</code>库中原有的<code>math.random</code>函数和<code>math.randomseed</code>函数，替换之后的两个函数有以下特征</p>
<ul>
<li>对于相同的<code>seed</code>来说，<code>math.random</code>总产生相同的随机数序列，这个函数是纯函数。</li>
<li>除非在脚本中使用<code>math.randomseed</code>显式地修改<code>seed</code>，否则每次运行脚本时Lua环境都使用固定的<code>math.randomseed(0)</code>语句来初始化<code>seed</code>。</li>
</ul>
<h4 id="20-1-5-创建排序辅助函数"><a href="#20-1-5-创建排序辅助函数" class="headerlink" title="20.1.5 创建排序辅助函数"></a>20.1.5 创建排序辅助函数</h4><p>对于一个集合键来说，因为集合元素的排列是无序的，所以即使两个集合的元素完全相同，它们的输出结果也可能并不相同。</p>
<p>为了消除这些命令带来的不确定性，服务器创建一个排序辅助函数<code>redis_compare_helper</code>，当Lua脚本执行完一个带有不确定性的命令之后，程序会使用<code>redis_compare_helper</code>作为对比函数，自动调用<code>table.sort</code>函数对命令的返回值做一次排序，以此来保证相同的数据集总是产生相同的输出。</p>
<h4 id="20-1-6-创建redis-pcall函数的错误报告辅助函数"><a href="#20-1-6-创建redis-pcall函数的错误报告辅助函数" class="headerlink" title="20.1.6 创建redis.pcall函数的错误报告辅助函数"></a>20.1.6 创建redis.pcall函数的错误报告辅助函数</h4><p>在这一步，服务器将为Lua环境创建一个名为<code>redis_err_handler</code>的错误处理函数，当脚本调用<code>redis.pcall</code>函数执行Redis命令，并且被执行的命令出现错误时<code>redis_err_handler</code>就会打印出错代码的来源和发生错误的行数，为程序的调试提供方便。</p>
<h4 id="20-1-7-保护Lua的全局环境"><a href="#20-1-7-保护Lua的全局环境" class="headerlink" title="20.1.7 保护Lua的全局环境"></a>20.1.7 保护Lua的全局环境</h4><p>在这一步，服务器将对Lua环境中的全局环境进行保护，确保传人服务器的脚本不会因为忘记使用1oca1关键字而将额外的全局变量添加到Lua环境里面，当一个脚本试图创建一个全局变量时，服务器将报告一个错误</p>
<h4 id="20-1-8-将Lua环境保存到服务器状态的lua属性里面"><a href="#20-1-8-将Lua环境保存到服务器状态的lua属性里面" class="headerlink" title="20.1.8 将Lua环境保存到服务器状态的lua属性里面"></a>20.1.8 将Lua环境保存到服务器状态的lua属性里面</h4><p>在最后的这一步，服务器会将Lua环境和服务器状态的lua属性关联起来，如下图所示。</p>
<p><img src="/2020/03/08/Redis-20-Lua脚本/200308_4.png" alt=""></p>
<p>因为Redis使用串行化的方式来执行Redis命令，所以在任何特定时间里，最多都只会有一个脚本能够被放进Lua环境里面运行，因此，整个Redis服务器只需要创建一个Lua环境即可。</p>
<h3 id="20-2-Lua环境协作组件"><a href="#20-2-Lua环境协作组件" class="headerlink" title="20.2 Lua环境协作组件"></a>20.2 Lua环境协作组件</h3><p>Redis还创建了与Lua环境进行协作的两个组件，它们分别是负责执行Lua脚本中包含的Redis命令的伪客户端以及负责保存传入服务器的Lua脚本的脚本字典</p>
<h4 id="20-2-1-伪客户端"><a href="#20-2-1-伪客户端" class="headerlink" title="20.2.1 伪客户端"></a>20.2.1 伪客户端</h4><p>因为执行Reds命令必须有相应的客户端状态，所以为了执行Lua脚本中包含的 Redis命令， Redis服务器专门为Lua环境创建了一个伪客户端</p>
<p>下图展示了Lua脚本在调用redis.call函数时，Lua环境、伪客户端、命令执行器之间的通信过程</p>
<p><img src="/2020/03/08/Redis-20-Lua脚本/200308_5.png" alt=""></p>
<h4 id="20-2-2-lua-script字典"><a href="#20-2-2-lua-script字典" class="headerlink" title="20.2.2 lua_script字典"></a>20.2.2 lua_script字典</h4><p> Redis服务器为Lua环境创建的另一个协作组件是<code>lua_scripts</code>字典，这个字典的键为某个Lua脚本的SHA1校验和，而字典的值则是SHA1校验和对应的Lua脚本，例子如下图</p>
<p><img src="/2020/03/08/Redis-20-Lua脚本/200308_6.png" alt=""></p>
<h3 id="20-3-EVAL命令的实现"><a href="#20-3-EVAL命令的实现" class="headerlink" title="20.3 EVAL命令的实现"></a>20.3 EVAL命令的实现</h3><p>EVAL命令的执行过程可以分为以下三个步骤：</p>
<ol>
<li>根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数</li>
<li>将客户端给定的脚本保存到<code>lua_scripts</code>字典，等待将来进一步使用。</li>
<li>执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本。</li>
</ol>
<h4 id="20-3-1-定义脚本函数"><a href="#20-3-1-定义脚本函数" class="headerlink" title="20.3.1 定义脚本函数"></a>20.3.1 定义脚本函数</h4><p>当客户端向服务器发送EVAL命令，要求执行某个Lua脚本的时候，服务器首先要做的就是在Lua环境中，为传入的脚本定义一个与这个脚本相对应的Lua函数，其中，Lua函数的名字由f前缀加上脚本的SHA1校验和组成，而函数的体则是脚本本身。</p>
<p>例如<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</span><span class="params">()</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello, world'</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>使用函数来保存客户端传入的脚本有以下好处：</p>
<ul>
<li>执行脚本的步骤非常简单，只要调用与脚本相对应的函数即可。</li>
<li>通过函数的局部性来让Lua环境保持清洁，减少了垃圾回收的工作量，并且避免了使用全局变量。</li>
<li>只要记得这个脚本的SHA1校验和，服务器就可以直接通过调用Lua函数来执行脚本，这是EVALSHA命令的实现原理</li>
</ul>
<h4 id="20-3-2-将脚本保存到lua-script字典"><a href="#20-3-2-将脚本保存到lua-script字典" class="headerlink" title="20.3.2 将脚本保存到lua_script字典"></a>20.3.2 将脚本保存到lua_script字典</h4><p>EVAL命令要做的第二件事是将客户端传人的脚本保存到服务器的<code>1ua_scripts</code>字典里面。</p>
<h4 id="20-3-3-执行脚本函数"><a href="#20-3-3-执行脚本函数" class="headerlink" title="20.3.3 执行脚本函数"></a>20.3.3 执行脚本函数</h4><p>整个执行步骤如下</p>
<ol>
<li>将<code>EVAL</code>命令中传人的键名参数和脚本参数分别作为全局变量传入到Lua环境里面。</li>
<li>为Lua环境装载超时处理钩子</li>
<li>执行脚本函数</li>
<li>移除之前装载的超时钩子</li>
<li>将执行脚本函数所得的结果保存到客户端状态的输出缓冲区里面，等待服务器将结果返回给客户端。</li>
<li>对Lua环境执行垃圾回收操作。</li>
</ol>
<h3 id="20-4-EVALSHA命令的实现"><a href="#20-4-EVALSHA命令的实现" class="headerlink" title="20.4 EVALSHA命令的实现"></a>20.4 EVALSHA命令的实现</h3><p>每个被EVAL命令成功执行过的Lua脚本，在Lua环境里面都有一个与这个脚本相对应的Lua函数，函数的名字由f前缀加上40个字符长的SHA1校验和组成，例如<code>f_5332031c6b470dc5a0dd9b4bf2030dea6d65de91</code>。</p>
<p>只要脚本对应的函数曾经在Lua环境里面定义过，那么即使不知道脚本的内容本身，客户端也可以根据脚本的SHA1校验和来调用脚本对应的函数，从而达到执行脚本的目的，这就是EVALSHA命令的实现原理。</p>
<p>伪代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EVALSHA</span><span class="params">(sha1)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拼接出函数的名字</span></span><br><span class="line">    func_name = <span class="string">"f_"</span> + sha1</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 查看这个函数在Lua环境中是否存在</span></span><br><span class="line">    <span class="keyword">if</span> function_exists_in_lua_env(func_name):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果函数存在，那么执行它</span></span><br><span class="line">        execute_lua_function(func_name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 否则，返回一个错误信息</span></span><br><span class="line">        send_script_error(<span class="string">"SCRIPT NOT FOUND"</span>)</span><br></pre></td></tr></table></figure></p>
<h3 id="20-5-脚本管理命令的实现"><a href="#20-5-脚本管理命令的实现" class="headerlink" title="20.5 脚本管理命令的实现"></a>20.5 脚本管理命令的实现</h3><h4 id="20-5-1-SCRIPT-FLUSH"><a href="#20-5-1-SCRIPT-FLUSH" class="headerlink" title="20.5.1 SCRIPT FLUSH"></a>20.5.1 SCRIPT FLUSH</h4><p>SCRIPT FLUSH命令用于清除服务器中所有和Lua脚本有关的信息，这个命令会释放并重建<code>lua_scripts</code>字典，关闭现有的Lua环境并重新创建一个新的Lua环境。</p>
<p>伪代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SCRIPT_FLUSH</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 释放脚本字典</span></span><br><span class="line">    dictRelease(server.lua_scripts)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重建脚本字典</span></span><br><span class="line">    server.lua_script = dictCreate()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭Lua环境</span></span><br><span class="line">    lua_close(server.lua)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化一个新的Lua环境</span></span><br><span class="line">    server.lua = init_lua_env()</span><br></pre></td></tr></table></figure></p>
<h4 id="20-5-2-SCRIPT-EXISTS"><a href="#20-5-2-SCRIPT-EXISTS" class="headerlink" title="20.5.2 SCRIPT EXISTS"></a>20.5.2 SCRIPT EXISTS</h4><p>SCRIPT EXSTS命令根据输入的SHA1校验和，检查校验和对应的脚本是否存在于服务器中。</p>
<p>SCRIPT EXSTS命令是通过检查给定的校验和是否存在于<code>lua_scripts</code>字典来实现的，以下是该命令的实现伪代码<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">SCRIPT_EXISTS</span><span class="params">(*sha1_list)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 结果列表</span></span><br><span class="line">    result_list = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历输入的说有SHA1校验和</span></span><br><span class="line">    <span class="keyword">for</span> sha1 <span class="keyword">in</span> sha1_list:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> sha1 <span class="keyword">in</span> server.lua_scripts:</span><br><span class="line">            result_list.append(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result_list.append(<span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    send_list_reply(result_list)</span><br></pre></td></tr></table></figure></p>
<h4 id="20-5-3-SCRIPT-LOAD"><a href="#20-5-3-SCRIPT-LOAD" class="headerlink" title="20.5.3 SCRIPT LOAD"></a>20.5.3 SCRIPT LOAD</h4><p>SCRIPT LOAD命令所做的事情和EVAL命令执行脚本时所做的前两步完全一样：</p>
<ol>
<li>命令首先在Lua环境中为脚本创建相对应的函数</li>
<li>然后再将脚本保存到<code>lua_scripts</code>字典里面。</li>
<li>最后将命令的sha1码返回给客户端</li>
</ol>
<h4 id="20-5-4-SCRIPT-KILL"><a href="#20-5-4-SCRIPT-KILL" class="headerlink" title="20.5.4 SCRIPT KILL"></a>20.5.4 SCRIPT KILL</h4><p>如果服务器设置了<code>1ua-time-limit</code>配置选项，那么在每次执行Lua脚本之前，服务器都会在Lua环境里面设置一个超时处理钩子</p>
<p>超时处理钩子在脚本运行期间，会定期检查脚本已经运行了多长时间，一旦钩子发现脚本的运行时间已经超过了<code>1ua-time-1imit</code>选项设置的时长，钩子将定期在脚本运行的间隙中，查看是否有SCRIPT KILL命令或者SHUTDOWM命令到达服务器。</p>
<p>流程如下<br><img src="/2020/03/08/Redis-20-Lua脚本/200308_7.png" alt=""></p>
<h3 id="20-6-脚本复制"><a href="#20-6-脚本复制" class="headerlink" title="20.6 脚本复制"></a>20.6 脚本复制</h3><p>与其他普通Redis命令一样，当服务器运行在复制模式之下时，具有写性质的脚本命令也会被复制到从服务器</p>
<h4 id="20-6-1-复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令"><a href="#20-6-1-复制EVAL命令、SCRIPT-FLUSH命令和SCRIPT-LOAD命令" class="headerlink" title="20.6.1 复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令"></a>20.6.1 复制EVAL命令、SCRIPT FLUSH命令和SCRIPT LOAD命令</h4><p>Redis复制EVAL、SCRIPT FLUSH、SCRIPT LOAD三个命令的方法和复制其他普通Redis命令的方法一样，当主服务器执行完以上三个命令的其中一个时，主服务器会直接将被执行的命令传播给所有从服务器，如下图所示</p>
<p><img src="/2020/03/08/Redis-20-Lua脚本/200308_8.png" alt=""></p>
<h4 id="20-6-2-复制EVALSHA命令"><a href="#20-6-2-复制EVALSHA命令" class="headerlink" title="20.6.2 复制EVALSHA命令"></a>20.6.2 复制EVALSHA命令</h4><p>对于一个在主服务器被成功执行的EVALSHA命令来说，相同的EVALSHA命令在从服务器执行时却可能会出现脚本未找到错误。因为从服务器可能并没有载入这个脚本</p>
<p>因此Redis采取了如下的策略，来保证EVALSHA命令的安全</p>
<p>Redis要求主服务器在传播EVALSHA命令的时候，必须确保EVALSHA命令要执行的脚本已经被所有从服务器载入过，如果不能确保这一点的话，主服务器会将EVALSHA命令转换成一个等价的EVAL命令，然后通过传播EVAL命令来代替 EVALSHA命令。</p>
<h5 id="20-6-2-1-判断传播EVALSHA命令是否安全的方法"><a href="#20-6-2-1-判断传播EVALSHA命令是否安全的方法" class="headerlink" title="20.6.2.1 判断传播EVALSHA命令是否安全的方法"></a>20.6.2.1 判断传播EVALSHA命令是否安全的方法</h5><p>主服务器使用服务器状态的<code>repl_scriptcache_dict</code>字典记录自己已经将哪些脚本传播给了所有从服务器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    dict *repl_scriptcache_dict;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>repl_scriptcache_dict</code>字典的键是一个个Lua脚本的SHA1校验和，而字典的值则全部都是<code>NULL</code>，当一个校验和出现在<code>repl_scriptcache_dict</code>字典时，说明这个校验和对应的Lua脚本已经传播给了所有从服务器，这种情况下，主服务器可以直接向从服务器传播包含这个SHA1校验和的EVALSHA命令</p>
<p>例如下图<br><img src="/2020/03/08/Redis-20-Lua脚本/200308_9.png" alt=""></p>
<h5 id="20-6-2-2-清空repl-scriptcache-dict字典"><a href="#20-6-2-2-清空repl-scriptcache-dict字典" class="headerlink" title="20.6.2.2 清空repl_scriptcache_dict字典"></a>20.6.2.2 清空repl_scriptcache_dict字典</h5><p>每当主服务器添加一个新的从服务器时，主服务器都会清空自己的<code>repl_scriptcache_dict</code>字典，这是因为随着新从服务器的出现，<code>repl_scriptcache_dict</code>字典里面记录的脚本已经不再被所有从服务器载入过</p>
<h5 id="20-6-2-3-EVALSHA命令转换为EVAL命令的方法"><a href="#20-6-2-3-EVALSHA命令转换为EVAL命令的方法" class="headerlink" title="20.6.2.3 EVALSHA命令转换为EVAL命令的方法"></a>20.6.2.3 EVALSHA命令转换为EVAL命令的方法</h5><p>通过使用EVALSHA命令指定的SHA1校验和，以及<code>lua_scripts</code>字典保存的Lua脚本，服务器总可以将一个EVALSHA命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVALSHA &lt;sha1&gt; &lt;numkeys&gt; [key..] [arg..] I</span><br></pre></td></tr></table></figure></p>
<p>转换成一个等价的EVAL命令：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &lt;script&gt; &lt;numkeys&gt; [key..] [arg..]</span><br></pre></td></tr></table></figure></p>
<h5 id="20-6-2-4-传播EVALSHA命令的方法"><a href="#20-6-2-4-传播EVALSHA命令的方法" class="headerlink" title="20.6.2.4 传播EVALSHA命令的方法"></a>20.6.2.4 传播EVALSHA命令的方法</h5><p>当主服务器在传播完EVAL命令之后，会将被传播脚本的sha1校验和添加到<code>repl_scriptcache_dict</code>字典里面，如果之后EVALSHA命令再次指定这个SHA1校验和，主服务器就可以直接传播EVALSHA命令，而不必再次对EVALSHA命令进行转换。</p>
<p>传播EVALSHA命令的流程图如下<br><img src="/2020/03/08/Redis-20-Lua脚本/200308_10.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/08/Redis-19-事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/08/Redis-19-事务/" itemprop="url">[Redis][19][事务]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-08T10:29:47+08:00">
                2020-03-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/08/Redis-19-事务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/08/Redis-19-事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-19-章-事务"><a href="#第-19-章-事务" class="headerlink" title="第 19 章 事务"></a>第 19 章 事务</h2><p>Redis通过<code>MULTI</code>、<code>EXEC</code>、<code>WATCH</code>等命令来实现事务功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求。</p>
<p>以下是一个事务执行的过程，该事务首先以一个MULTI命令为开始，接着将多个命令放入事务当中，最后由EXEC命令将这个事务提交给服务器执行：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; SET <span class="string">"name"</span> <span class="string">"Practical Common Lisp"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="string">"name"</span></span><br><span class="line"></span><br><span class="line">redis&gt; SET <span class="string">"author"</span> <span class="string">"Peter Seibel"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; GET <span class="string">"author"</span></span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; EXEC</span><br><span class="line">1) OK</span><br><span class="line">2) <span class="string">"Practical Common Lisp"</span></span><br><span class="line">3) OK</span><br><span class="line">4) <span class="string">"Peter Seibel"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="19-1-事务的实现"><a href="#19-1-事务的实现" class="headerlink" title="19.1 事务的实现"></a>19.1 事务的实现</h3><p>一个事务从开始到结東通常会经历以下三个阶段</p>
<ol>
<li>事务开始</li>
<li>命令人队</li>
<li>事务执行</li>
</ol>
<h4 id="19-1-1-事务开始"><a href="#19-1-1-事务开始" class="headerlink" title="19.1.1 事务开始"></a>19.1.1 事务开始</h4><p>MULTI命令的执行标志着事务的开始</p>
<p>MULTI命令可以将执行该命令的客户端从非事务状态切换至事务状态，这一切换是通过在客户端状态的flags属性中打开REDIS MULTI标识来完成的，如下伪代码<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MULTI</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开事务标志</span></span><br><span class="line">    client.flags |= REDIS_MULTI</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 返回OK回复</span></span><br><span class="line">    replyOK()</span><br></pre></td></tr></table></figure></p>
<h4 id="19-1-2-命令入队"><a href="#19-1-2-命令入队" class="headerlink" title="19.1.2 命令入队"></a>19.1.2 命令入队</h4><p>当一个客户端处于非事务状态时，这个客户端发送的命令会立即被服务器执行，当一个客户端切换到事务状态之后，则不一定，它会根据不同的命令见机行事：</p>
<ul>
<li>如果客户端发送的命令为<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>、<code>MULTI</code>四个命令的其中一个，那么服务器立即执行这个命令。</li>
<li>与此相反，如果客户端发送的命令是<code>EXEC</code>、<code>DISCARD</code>、<code>WATCH</code>、<code>MULTI</code>四个命令以外的其他命令，那么服务器并不立即执行这个命令，而是将这个命令放入一个事务队列里面，然后向客户端返回<code>QUEUED</code>回复。</li>
</ul>
<p>如下流程图所示<br><img src="/2020/03/08/Redis-19-事务/200308_0.png" alt=""></p>
<h4 id="19-1-3-事务队列"><a href="#19-1-3-事务队列" class="headerlink" title="19.1.3 事务队列"></a>19.1.3 事务队列</h4><p>每个Redis客户端都有自己的事务状态，这个事务状态保存在客户端状态的<code>mstate</code>属性中，它包括一个事务队列和一个已入队命令的计数器<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务状态</span></span><br><span class="line">    multiState mstate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">multiState</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务队列，FIFO顺序</span></span><br><span class="line">    multiCmd *command;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已入队命令计数</span></span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">&#125;multiState;</span><br></pre></td></tr></table></figure></p>
<p>事务队列以先进先出的方式保存入队的命令，较先人队的命令会被放到数组的前面，而较后入队的命令则会被放到数组的后面，例如下图<br><img src="/2020/03/08/Redis-19-事务/200308_1.png" alt=""></p>
<h4 id="19-1-4-执行事务"><a href="#19-1-4-执行事务" class="headerlink" title="19.1.4 执行事务"></a>19.1.4 执行事务</h4><p>当一个处于事务状态的客户端向服务器发送EXEC命令时，这个EXEC命令将立即被服务器执行。服务器会遍历这个客户端的事务队列，执行队列中保存的所有命令，最后将执行命令所得的结果全部返回给客户端</p>
<p><code>EXEC</code>命令的伪代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">EXEC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    # 创建空白的回复队列</span></span><br><span class="line">    reply_queue = []</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 遍历事务队列中的每个项</span></span><br><span class="line">    <span class="comment"># 读取命令的参数，参数的个数，以及要执行的命令</span></span><br><span class="line">    <span class="keyword">for</span> argv, argc, cmd <span class="keyword">in</span> client.mstate.commands:</span><br><span class="line">    </span><br><span class="line">        <span class="comment"># 执行命令，并取得命令的返回值</span></span><br><span class="line">        reply = execute_command(cmd, argv, argc)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将返回值追加到回复队列末尾</span></span><br><span class="line">        reply_queue.append(reply)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 移除REDIS_MULTI标识，让客户端回到非事务状态</span></span><br><span class="line">    client.flags &amp;= ~REDIS_MULTI</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 清空客户端的事务状态，包括</span></span><br><span class="line">    <span class="comment"># 1)清零入队命令计数器</span></span><br><span class="line">    <span class="comment"># 2)释放事务队列</span></span><br><span class="line">    </span><br><span class="line">    client.state.count = <span class="number">0</span></span><br><span class="line">    release_transaction_queue(client.mstate.commands)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 将事务的执行结果返回给客户端</span></span><br><span class="line">    send_reply_to_client(client, reply_queue)</span><br></pre></td></tr></table></figure></p>
<h3 id="19-2-WATCH命令的实现"><a href="#19-2-WATCH命令的实现" class="headerlink" title="19.2 WATCH命令的实现"></a>19.2 WATCH命令的实现</h3><p>WATCH命令是一个乐观锁，它可以在EXEC命令执行之前，监视任意数量的数据库键，并在EXEC命令执行时，检查被监视的键是否至少有一个已经被修改过了，如果是的话，服务器将拒绝执行事务，并向客户端返回代表事务执行失败的空回复。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; WATCH &quot;name&quot;</span><br></pre></td></tr></table></figure>
<h4 id="19-2-1-使用WATCH命令监视数据库键"><a href="#19-2-1-使用WATCH命令监视数据库键" class="headerlink" title="19.2.1 使用WATCH命令监视数据库键"></a>19.2.1 使用WATCH命令监视数据库键</h4><p>每个Redis数据库都保存着一个<code>watched_keys</code>字典，这个字典的键是某个被<code>WATCH</code>命令监视的数据库键，而字典的值则是一个链表，链表中记录了所有监视相应数据库键的客户端<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正在被WATCH命令监视的键</span></span><br><span class="line">    dict *watched_keys</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>watched_keys</code>字典，服务器可以清楚地知道哪些数据库键正在被监视，以及哪些客户端正在监视这些数据库键。</p>
<p>下图就是一个<code>watched_keys</code>字典的例子<br><img src="/2020/03/08/Redis-19-事务/200308_2.png" alt=""></p>
<h4 id="19-2-2-监视机制的触发"><a href="#19-2-2-监视机制的触发" class="headerlink" title="19.2.2 监视机制的触发"></a>19.2.2 监视机制的触发</h4><p>所有对数据库进行修改的命令，在执行之后都会调用<code>multi.c/touchWatchKey</code>函数对<code>watched_keys</code>字典进行检查，查看是否有客户端正在监视刚刚被命令修改过的数据库键，如果有的话，那么<code>touchWatchKey</code>函数会将监视被修改键的客户端的<code>REDIS_DIRTY_CAS</code>标识打开，表示该客户端的事务安全性已经被破坏。</p>
<p>伪代码描述如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">touchWatchKey</span><span class="params">(db, key)</span>:</span></span><br><span class="line">    <span class="comment"># 如果键key存在于数据库的watched_keys字典中</span></span><br><span class="line">    <span class="comment"># 那么说明至少有一个客户端在监视这个key</span></span><br><span class="line">    <span class="keyword">if</span> key <span class="keyword">in</span> db.watched_keys:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 遍历所有监视键key的客户端</span></span><br><span class="line">        <span class="keyword">for</span> client <span class="keyword">in</span> db.watched_keys[key]</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 打开标志</span></span><br><span class="line">            client.flags |= REDIS_DIRTY_CAS</span><br></pre></td></tr></table></figure></p>
<h4 id="19-2-3-判断事务是否安全"><a href="#19-2-3-判断事务是否安全" class="headerlink" title="19.2.3 判断事务是否安全"></a>19.2.3 判断事务是否安全</h4><p>当服务器接收到一个客户端发来的EXEC命令时，服务器会根据这个客户端是否打开了<code>REDIS_DIRTY_CAS</code>标识来决定是否执行事务：<br><img src="/2020/03/08/Redis-19-事务/200308_3.png" alt=""></p>
<h3 id="19-3-事务的ACID性质"><a href="#19-3-事务的ACID性质" class="headerlink" title="19.3 事务的ACID性质"></a>19.3 事务的ACID性质</h3><p>在Redis中，事务总是具有原子性、一致性和隔离性，并且当Redis运行在某种特定的持久化模式下时，事务也具有耐久性</p>
<h4 id="19-3-1-原子性"><a href="#19-3-1-原子性" class="headerlink" title="19.3.1 原子性"></a>19.3.1 原子性</h4><p>对于Redis的事务功能来说，事务队列中的命令要么就全部都执行，要么就一个都不执行，因此，Redis的事务是具有原子性的。</p>
<p>Redis的事务和传统的关系型数据库事务的最大区别在于，Redis不支持事务回滚机制，即使事务队列中的某个命令在执行期间出现了错误，整个事务也会继续执行下去，直到将事务队列中的所有命令都执行完毕为止</p>
<h4 id="19-3-2-一致性"><a href="#19-3-2-一致性" class="headerlink" title="19.3.2 一致性"></a>19.3.2 一致性</h4><p>事务具有一致性指的是，如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该仍然是一致的。</p>
<h4 id="19-3-3-隔离性"><a href="#19-3-3-隔离性" class="headerlink" title="19.3.3 隔离性"></a>19.3.3 隔离性</h4><p>事务的隔离性指的是，即使数据库中有多个事务并发地执行，各个事务之间也不会互相影响，并且在并发状态下执行的事务和串行执行的事务产生的结果完全相同。</p>
<p>因为Redis使用单线程的方式来执行事务，并且服务器保证，在执行事务期间不会对事务进行中断，因此，Redis的事务总是以串行的方式运行的，并且事务也总是具有隔离性的。</p>
<h4 id="19-3-4-耐久性"><a href="#19-3-4-耐久性" class="headerlink" title="19.3.4 耐久性"></a>19.3.4 耐久性</h4><p>只有当服务器运行在AOF持久性模式下，并且<code>appendfsync</code>选项的值为<code>always</code>时，程序总会在执行命令之后调用同步函数，将命令数据真正的保存到硬盘里面，因此这种配置下的事务是具有耐久性的</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/07/Redis-17-集群/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/07/Redis-17-集群/" itemprop="url">[Redis][17][集群]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-07T21:03:38+08:00">
                2020-03-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/07/Redis-17-集群/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/07/Redis-17-集群/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-17-章-集群"><a href="#第-17-章-集群" class="headerlink" title="第 17 章 集群"></a>第 17 章 集群</h2><p><strong>Redis集群</strong>是Redis提供的<strong>分布式数据库</strong>方案，集群通过<strong>分片</strong>来进行数据共享，并提供<strong>复制</strong>和<strong>故障转移功能</strong></p>
<h3 id="17-1-节点"><a href="#17-1-节点" class="headerlink" title="17.1 节点"></a>17.1 节点</h3><p>一个Redis集群通常由多个节点组成，在刚开始的时候，<strong>每个节点</strong>都是相互独立的，它们都<strong>处于一个只包含自己的集群当中</strong>，要组建一个真正可工作的集群，我们<strong>必须将各个独立的节点连接起来</strong>，构成一个包含多个节点的集群。</p>
<p>连接各个节点的工作可以使用<code>CLUSTER MEET</code>命令来完成，该命令的格式如下：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt;</span><br></pre></td></tr></table></figure></p>
<p>向一个节点发送<code>CLUSTER MEET</code>命令，可以让该节点与<code>ip+port</code>所指定的节点进行<strong>握手</strong>，当握手成功时，该节点就会将<code>ip+port</code>所指定的节点添加到该节点当前所在的集群中。</p>
<p>下面的例子演示了如何构件一个有3个节点的集群<br><img src="/2020/03/07/Redis-17-集群/200307_01.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_02.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_03.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_04.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_05.png" alt=""></p>
<h4 id="17-1-1-启动节点"><a href="#17-1-1-启动节点" class="headerlink" title="17.1.1 启动节点"></a>17.1.1 启动节点</h4><p>个节点就是一个运行在集群模式下的Redis服务器， Redis服务器在启动时会根据<code>cluster- enabled</code>配置选项是否为<code>yes</code>来决定是否开启服务器的集群模式，流程如下图所示。</p>
<p><img src="/2020/03/07/Redis-17-集群/200307_06.png" alt=""></p>
<p>节点会继续使用所有在单机模式中使用的服务器组件，比如说：文件事件处理器、时间事件处理器、使用数据库保存键值对数据、使用RDB和AOF来持久化</p>
<h4 id="17-1-2-集群数据结构"><a href="#17-1-2-集群数据结构" class="headerlink" title="17.1.2 集群数据结构"></a>17.1.2 集群数据结构</h4><p>节点会继续使用<code>redisServer</code>结构来保存服务器的状态，使用<code>redisClient</code>结构来保存客户端的状态，至于那些只有在集群模式下才会用到的数据，节点将它们保存到了<code>cluster.h/clusterNode</code>结构、<code>cluster.h/clusterLink</code>结构，以及<code>cluster.h/clusterState</code>结构里面。</p>
<p>每个节点都会使用一个<code>clusterNode</code>结构来记录自己的状态，并为集群中的所有其他节点都创建一个相应的<code>clusterNode</code>结构，以此来记录其他节点的状态，状态如下所示<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点状态</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建节点的时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime; <span class="comment">/* Node object creation time. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的名字，由 40 个十六进制字符组成</span></span><br><span class="line">    <span class="comment">// 例如 68eef66df23420a5862208ef5b1a7005b806f2ff</span></span><br><span class="line">    <span class="keyword">char</span> name[REDIS_CLUSTER_NAMELEN]; <span class="comment">/* Node name, hex string, sha1-size */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点标识</span></span><br><span class="line">    <span class="comment">// 使用各种不同的标识值记录节点的角色（比如主节点或者从节点），</span></span><br><span class="line">    <span class="comment">// 以及节点目前所处的状态（比如在线或者下线）。</span></span><br><span class="line">    <span class="keyword">int</span> flags;      <span class="comment">/* REDIS_NODE_... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点当前的配置纪元，用于实现故障转移</span></span><br><span class="line">    <span class="keyword">uint64_t</span> configEpoch; <span class="comment">/* Last configEpoch observed for this node */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的 IP 地址</span></span><br><span class="line">    <span class="keyword">char</span> ip[REDIS_IP_STR_LEN];  <span class="comment">/* Latest known IP address of this node */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 节点的端口号</span></span><br><span class="line">    <span class="keyword">int</span> port;                   <span class="comment">/* Latest known port of this node */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存连接节点所需的有关信息</span></span><br><span class="line">    clusterLink *link;          <span class="comment">/* TCP/IP link with this node */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p><code>clusterNode</code>结构的<code>link</code>属性是一个 <code>clusterLink</code>结构，该结构保存了连接节点所需的有关信息，比如套接字描述符，输人缓冲区和输出缓冲区：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterLink</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接的创建时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> ctime;             <span class="comment">/* Link creation time */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TCP 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;                     <span class="comment">/* TCP socket file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出缓冲区，保存着等待发送给其他节点的消息（message）。</span></span><br><span class="line">    sds sndbuf;                 <span class="comment">/* Packet send buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入缓冲区，保存着从其他节点接收到的消息。</span></span><br><span class="line">    sds rcvbuf;                 <span class="comment">/* Packet reception buffer */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 与这个连接相关联的节点，如果没有的话就为 NULL</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span> *<span class="title">node</span>;</span>   <span class="comment">/* Node related to this link if any, or NULL */</span></span><br><span class="line"></span><br><span class="line">&#125; clusterLink;</span><br></pre></td></tr></table></figure>
<p>在<code>redisServer</code>中会保存一个<code>clusterState</code>结构，这个结构记录了集群的相关信息，例：集群是在线还是下线，集群包含多少个节点，集群当前的配置纪元，诸如此类<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//指向自己节点结构的指针</span></span><br><span class="line">    clusterNode *myself</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群当前的配置单元</span></span><br><span class="line">    <span class="keyword">uint64_t</span> currentEpoch;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群当前的状态：是上线还是下线</span></span><br><span class="line">    <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群中至少处理着一个槽的节点的数量</span></span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集群节点名单</span></span><br><span class="line">    <span class="comment">//字典的键为节点的名字，字典的值为节点对应的clusterNode结构</span></span><br><span class="line">    dict *nodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下图是一个<code>clusterState</code>状态的例子<br><img src="/2020/03/07/Redis-17-集群/200307_07.png" alt=""></p>
<h4 id="17-1-3-CLUSTER-MEET命令的实现"><a href="#17-1-3-CLUSTER-MEET命令的实现" class="headerlink" title="17.1.3 CLUSTER MEET命令的实现"></a>17.1.3 CLUSTER MEET命令的实现</h4><p>下面我们来解释本节开头说的<code>CLUSTER MEET</code>的具体执行步骤，假设现在客户端向节点A发送命令，要求A加入节点B的集群中，假设节点A收到了命令，它会接着做这些事情：</p>
<ol>
<li>节点A会为节点B创建一个<code>clusterNode</code>结构，并将该结构添加到自己的<code>cluterState.nodes</code>字典里面。</li>
<li>之后，节点A将根据<code>CLUSTER MEET</code>命令给定的IP地址和端口号，向节点B发送一条<code>MEET</code>消息</li>
<li>如果一切顺利，节点B将接收到节点A发送的<code>MEET</code>消息，节点B会为节点A创建一个<code>clusterNode</code>结构，并将该结构添加到自己的<code>clusterState.nodes</code>字典里面。</li>
<li>之后，节点B将向节点A返回一条<code>PONG</code>消息。</li>
<li>如果一切顺利，节点A将接收到节点B返回的<code>PONG</code>消息，通过这条<code>PONG</code>消息节点A可以知道节点B已经成功地接收到了自己发送的<code>MEET</code>消息。</li>
<li>之后，节点A将向节点B返回一条<code>PING</code>消息。</li>
<li>如果一切顺利，节点B将接收到节点A返回的<code>PING</code>消息，通过这条<code>PING</code>消息节点B可以知道节点A已经成功地接收到了自己返回的<code>PONG</code>消息，握手完成。</li>
</ol>
<p>下图展示了上面步骤描述的握手过程<br><img src="/2020/03/07/Redis-17-集群/200307_08.png" alt=""></p>
<p>之后，节点A会将节点B的信息会通过Gossip协议传播给集群中的其他节点，让其他节点也与节点B握手</p>
<h3 id="17-2-槽指派"><a href="#17-2-槽指派" class="headerlink" title="17.2 槽指派"></a>17.2 槽指派</h3><p>Redis集群通过<strong>分片</strong>的方式来<strong>保存数据库中的键值对</strong>：集群的整个数据库被<strong>分为16384个槽</strong>，数据库中的<strong>每个键都属于这16384个槽的其中一个</strong>，集群中的每个节点可以处理0个或最多16384个槽。</p>
<p>当数据库中的16384个槽都有节点在处理时，集群处于<strong>上线</strong>状态；相反地，如果数据库中有任何一个槽没有得到处理，那么集群处于下线状态。</p>
<p>我们可以通过<code>CLUSTER INFO</code>命令查看集群相关的信息<br><img src="/2020/03/07/Redis-17-集群/200307_09.png" alt=""></p>
<p>如果想要把槽指派给某个节点负责，可以使用下面的命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS 0 1 2 3 4 ... 5000</span><br></pre></td></tr></table></figure></p>
<h4 id="17-2-1-记录节点的槽指派信息"><a href="#17-2-1-记录节点的槽指派信息" class="headerlink" title="17.2.1 记录节点的槽指派信息"></a>17.2.1 记录节点的槽指派信息</h4><p><code>clusterNode</code>结构的<code>slots</code>属性和<code>numslot</code>属性记录了这个节点负责处理哪些槽：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> slots[<span class="number">16384</span>/<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">int</span> numslots;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>s1ots</code>属性是一个二进制位数组，这个数组的长度为<code>16384/8=2048</code>个字节，共包含<code>16384</code>个二进制位。</p>
<p>Redis以<code>0</code>为起始索引，<code>16383</code>为终止索引，对<code>s1ots</code>数组中的<code>16384</code>个二进制位进行编号，并根据索引<code>i</code>上的二进制位的值来判断节点是否负责处理槽<code>i</code></p>
<p>下图展示了一个<code>slots</code>数组的实例<br><img src="/2020/03/07/Redis-17-集群/200307_10.png" alt=""></p>
<p>因为取出和设置<code>s1ots</code>数组中的任意一个二进制位的值的复杂度仅为<code>O(1)</code>，所以对于一个给定节点的<code>s1ots</code>数组来说，程序检查节点是否负责处理某个槽，又或者将某个槽指派给节点负责，这两个动作的复杂度都是<code>O(1)</code>。</p>
<h4 id="17-2-2-传播节点的槽指派信息"><a href="#17-2-2-传播节点的槽指派信息" class="headerlink" title="17.2.2 传播节点的槽指派信息"></a>17.2.2 传播节点的槽指派信息</h4><p>这个节点不光会存储自己的槽指派信息，还将把它通过消息发送给其他节点，以此告诉其他节点自己目前负责哪些槽。事实上，我们要达到的是，让每个节点都知道所有16384个槽目前被谁处理。</p>
<p>下图是一个例子<br><img src="/2020/03/07/Redis-17-集群/200307_11.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_12.png" alt=""><br><img src="/2020/03/07/Redis-17-集群/200307_13.png" alt=""></p>
<h4 id="17-2-3-记录集群所有槽的指派信息"><a href="#17-2-3-记录集群所有槽的指派信息" class="headerlink" title="17.2.3 记录集群所有槽的指派信息"></a>17.2.3 记录集群所有槽的指派信息</h4><p>我们除了将槽指派信息存储在<code>cluterNode</code>结构的<code>slots</code>属性中，还会在全局的<code>clusterState</code>结构的<code>slots</code>指针数组中记录所有16384个槽的指派信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterNode</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//存储槽指派信息的指针数组</span></span><br><span class="line">    clusterNode *slot[<span class="number">16384</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterNode;</span><br></pre></td></tr></table></figure></p>
<p>通过这种存储方式，我们可以以<code>O(1)</code>的复杂度得知指定槽目前被哪个节点负责</p>
<p>一个例子如下</p>
<p><img src="/2020/03/07/Redis-17-集群/200307_14.png" alt=""></p>
<h4 id="17-2-4-CLUSTER-ADDSLOTS命令的实现"><a href="#17-2-4-CLUSTER-ADDSLOTS命令的实现" class="headerlink" title="17.2.4 CLUSTER ADDSLOTS命令的实现"></a>17.2.4 CLUSTER ADDSLOTS命令的实现</h4><p><code>CLUSTER ADDSLOTS</code>命令接受一个或多个槽作为参数，并将所有输入的槽指派给接受该命令的节点负责，它的实现如下伪码</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cluster_addslots</span><span class="params">(*all input slots)</span>:</span></span><br><span class="line">    <span class="comment"># 遍历所有输入槽，检查它们是否都是未指派槽</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all input slots:</span><br><span class="line">    <span class="comment"># 如果有哪怕一个槽已经被指派给了某个节点排那么向客户端返回错误，并终止命令执行</span></span><br><span class="line">    <span class="keyword">if</span> clusterState.slots[i] != NULL:</span><br><span class="line">        reply_error()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 如果所有输入槽都是未指派槽</span></span><br><span class="line">    <span class="comment"># 那么再次遍历所有输入槽，将这些槽指派给当前节点</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> all input slots: </span><br><span class="line">        <span class="comment"># 设置clusterState结构的slots数组</span></span><br><span class="line">        <span class="comment"># 将s1ots[i]的指针指向代表当前节点的clusterNode结构</span></span><br><span class="line">        clusterState.slots[i] = clusterstate.myself</span><br><span class="line">        <span class="comment"># 访问代表当前节点的clusterNode结构的slots数组</span></span><br><span class="line">        <span class="comment"># 将数组在索引i上的二进制位设置为1</span></span><br><span class="line">        setSlotBit(clusterState.myself.slots, i)</span><br></pre></td></tr></table></figure>
<p>下面我们举个例子，下图是一个节点，这个集群没有任何指派<br><img src="/2020/03/07/Redis-17-集群/200307_15.png" alt=""></p>
<p>接着我们执行槽指派<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER ADDSLOTS 1 2</span><br></pre></td></tr></table></figure></p>
<p>槽指派后会变成如下结构<br><img src="/2020/03/07/Redis-17-集群/200307_16.png" alt=""></p>
<p>最后，在<code>CLUSTER ADDSLOTS</code>命令执行完毕之后，节点会通过发送消息告知集群中的其他节点，自己目前正在负责处理哪些槽。</p>
<h3 id="17-3-在集群中执行命令"><a href="#17-3-在集群中执行命令" class="headerlink" title="17.3 在集群中执行命令"></a>17.3 在集群中执行命令</h3><p>在<strong>对数据库中的16384个槽都进行了指派之后，集群就会进入上线状态</strong>，这时客户端就可以向集群中的节点发送数据命令了。</p>
<p>当客户端向节点发送与数据库键有关的命令时，接收命令的节点会计算出命令要处理的数据库键属于哪个槽，并检查这个槽是否指派给了自己</p>
<ul>
<li>如果键所在的槽正好就指派给了当前节点，那么节点直接执行这个命令。</li>
<li>如果键所在的槽并没有指派给当前节点，那么节点会向客户端返回一个MOVED错误，指引客户端转向至正确的节点，并再次发送之前想要执行的命令。</li>
</ul>
<p>流程如下图<br><img src="/2020/03/07/Redis-17-集群/200307_17.png" alt=""></p>
<h4 id="17-3-1-节点数据库的实现"><a href="#17-3-1-节点数据库的实现" class="headerlink" title="17.3.1 节点数据库的实现"></a>17.3.1 节点数据库的实现</h4><p>节点和单机服务器在数据库方面的一个区别是，<strong>节点只能使用0号数据库</strong>，而单机Redis服务器则没有这一限制。</p>
<p>此外，除了将键值对保存在数据库里面之外，节点还会用<code>clusterState</code>结构中的<code>slots_to_keys</code>跳跃表来保存槽和键之间的关系：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">clusterState</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    zskiplist *slots_to_key;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; clusterState;</span><br></pre></td></tr></table></figure></p>
<p><code>slots_to_keys</code>跳跃表每个节点的<strong>分值</strong>都是一个<strong>槽号</strong>，而每个节点的<strong>成员</strong>都是一个<strong>数据库键</strong>。通过在<code>slots_to_keys</code>跳跃表中记录各个数据库键所属的槽，节点可以很<strong>方便</strong>地对属于某个或某些槽的所有数据库键进行<strong>批量</strong>操作。</p>
<p>下面是一个跳跃表的例子<br><img src="/2020/03/07/Redis-17-集群/200307_18.png" alt=""></p>
<h3 id="17-4-重新分片"><a href="#17-4-重新分片" class="headerlink" title="17.4 重新分片"></a>17.4 重新分片</h3><p>Redis集群的重新分片操作可以<strong>将任意数量已经指派给某个节点</strong>（源节点）的槽改为<strong>指派给另一个节点</strong>（目标节点），并且相关槽所属的键值对也会从源节点被移动到目标节点。</p>
<p>Redis集群的重新分片操作是由Redis的集群管理软件<code>redis-trib</code>负责执行的，Redis提供了进行重新分片所需的所有命令，而<code>redis-trib</code>则通过向源节点和目标节点发送命令来进行重新分片操作。重新分片步骤如下</p>
<ol>
<li><code>redis-trib</code>对目标节点发送<code>CLUSTER SETSLOT &lt;slot&gt; IMPORTING &lt;source_id&gt;</code>命令，让目标节点准备好从源节点导人属于槽<code>slot</code>的键值对。</li>
<li><p><code>redis-trib</code>对源节点发送<code>CLUSTER SETSLOT &lt;slot&gt; MIGRATING &lt;target_id&gt;</code>命令，让源节点准备好将属于槽<code>slot</code>的键值对迁移至目标节点。</p>
</li>
<li><p><code>redis-trib</code>向源节点发送<code>CLUSTER GETKEYSINSLOT &lt;s1ot&gt; &lt;count&gt;</code>命令，获得最多<code>count</code>个属于槽<code>slot</code>的键值对的键名</p>
</li>
<li><p>对于步骤3获得的每个键名，<code>redis-trib</code>都向源节点发送一个<code>MIGRATE &lt;target Ip&gt; &lt;target port&gt; &lt;key name&gt; 0 &lt;timeout&gt;</code>命令，将被选中的键原子地从源节点迁移至目标节点</p>
</li>
<li><p>重复执行步骤3和步骤4，直到源节点保存的所有属于槽s1ot的键值对都被迁移至目标节点为止。每次迁移键的过程下图所示<br><img src="/2020/03/07/Redis-17-集群/200307_19.png" alt=""></p>
</li>
<li><p>redis-trib向集群中的任意一个节点发送<code>CLUSTER SETSLOT &lt;slot&gt; NODE &lt;target_id&gt;</code>命令，将槽<code>slot</code>指派给目标节点，这一指派信息会通过消息发送至整个集群最终集群中的所有节点都会知道槽<code>s1ot</code>已经指派给了目标节点。</p>
</li>
</ol>
<p>流程图如下<br><img src="/2020/03/07/Redis-17-集群/200307_20.png" alt=""></p>
<h3 id="17-5-ASK错误"><a href="#17-5-ASK错误" class="headerlink" title="17.5 ASK错误"></a>17.5 ASK错误</h3><p>在进行重新分片期间，源节点向目标节点迁移一个槽的过程中，可能会出现这样一种情况：属于被迁移槽的<strong>一部分键值对</strong>保存在<strong>源节点</strong>里面，而<strong>另一部分键值对</strong>则保存在<strong>目标节点</strong>里面。</p>
<p>当客户端向源节点发送某个与数据库键有关的命令，并且<strong>命令要处理的数据库键恰好就属于正在被迁移的槽</strong>时：</p>
<ul>
<li><strong>源节点</strong>会先在<strong>自己</strong>的数据库里面<strong>查找指定的键</strong>，如果找到的话，就直接执行客户端发送的命令。</li>
<li>相反地，如果源节点<strong>没能</strong>在自己的数据库里面<strong>找到</strong>指定的键，那么这个键有可能已经被迁移到了目标节点，<strong>源节点</strong>将向客户端<strong>返回</strong>一个<code>ASK</code><strong>错误</strong>，<strong>指引客户端转向正在导入槽的目标节点</strong>，并再次发送之前想要执行的命令。</li>
</ul>
<p>流程图如下<br><img src="/2020/03/07/Redis-17-集群/200307_21.png" alt=""></p>
<h3 id="17-6-复制与故障转移"><a href="#17-6-复制与故障转移" class="headerlink" title="17.6 复制与故障转移"></a>17.6 复制与故障转移</h3><p>Redis集群中的节点分为<strong>主节点</strong>和<strong>从节点</strong>，其中<strong>主节点</strong>用于<strong>处理槽</strong>，而<strong>从节点</strong>则用于<strong>复制某个主节点</strong>，并在被复制的主节点下线时，代替下线主节点继续处理命令请求。</p>
<p>下面我们举一个发生故障的例子</p>
<ol>
<li><p>首先集群中包含如下6个节点<br><img src="/2020/03/07/Redis-17-集群/200307_22.png" alt=""></p>
</li>
<li><p>如果这时，节点7000进入下线状态，那么集群中仍在正常运作的几个主节点将在节点7000的两个从节点中选出一个节点作为新的主节点，这个新的主节点将接管原来节点7000负责处理的槽，并继续处理客户端发送的命令请求。<br><img src="/2020/03/07/Redis-17-集群/200307_23.png" alt=""></p>
</li>
</ol>
<p>如果在故障转移完成之后，下线的节点7000重新上线，那么它将成为节点7004的从节点，如下图<br><img src="/2020/03/07/Redis-17-集群/200307_24.png" alt=""></p>
<h4 id="17-6-1-设置从节点"><a href="#17-6-1-设置从节点" class="headerlink" title="17.6.1 设置从节点"></a>17.6.1 设置从节点</h4><p>向一个节点发送如下命令可以让接收命令的节点成为<code>node_id</code>所指定节点的从节点，并开始对主节点进行复制<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CLUSTER REPLICATE &lt;node_id&gt;</span><br></pre></td></tr></table></figure></p>
<p>这个命令的执行步骤如下</p>
<ul>
<li>接收到该命令的节点首先会在自己的<code>clusterState.nodes</code>字典中找到 <code>node_id</code>所对应节点的<code>clusterNode</code>结构，并将自己的<code>clusterState.myself.slaveof</code>指针指向这个结构，以此来记录这个节点正在复制的主节点</li>
<li>然后节点会修改自己在<code>cluterState.myself.flags</code>中的属性，关闭原本的<code>REDIS_NODE_MASTER</code>标识，打开<code>REDIS_NODE_SLAVE</code>标识，表示这个节点已经由原来的主节点变成了从节点。</li>
<li>最后，节点会调用复制代码，并根据<code>clusterState.myself.slaves</code>指向的<code>clusterNode</code>结构所保存的IP地址和端口号，对主节点进行复制。</li>
</ul>
<p>某个节点成为从节点，并开始复制某个主节点这一信息会通过gossip协议消息发送给集群中的其他节点，最终集群中的所有节点都会知道某个从节点隶属于了某个主节点</p>
<h4 id="17-6-2-故障检测"><a href="#17-6-2-故障检测" class="headerlink" title="17.6.2 故障检测"></a>17.6.2 故障检测</h4><p>集群中的<strong>每个节点</strong>都会<strong>定期</strong>地向集群中的其他节点发送<strong>PING消息</strong>，以此来检测对方是否在线，如果接收PING消息的节点没有在规定的时间内，向发送PING消息的节点返回PONG消息，那么发送PING消息的节点就会将接收PING消息的节点标记为疑似下线</p>
<p>此外，PING和PONG消息还用于集群内节点以gossip的方式互相交换各个节点的状态，详见下一节</p>
<p>当一个主节点A通过互发消息的方式得知了主节点B也认为主节点C进入了疑似下线，它会将主节点B的下线报告加入到<strong>下线报告链表</strong>中</p>
<p>举个例子，如果主节点7001在收到主节点7002、主节点7003发送的消息后得知，主节点7002和主节点7003都认为主节点7000进入了疑似下线状态，那么主节点7001将为主节点7000创建下图所示的下线报告。</p>
<p><img src="/2020/03/07/Redis-17-集群/200307_25.png" alt=""></p>
<p>如果节点A发现自己积累了<strong>超过半数以上</strong>的<strong>关于节点C的下线报告</strong>，也就是半数以上的节点都认为C下线了，它就会将C设置为<strong>已下线</strong>，并<strong>广播</strong>给所有节点一条<strong>FAIL消息</strong>，所有节点收到FAIL后，会立刻设置C为已下线状态</p>
<p>例如下图<br><img src="/2020/03/07/Redis-17-集群/200307_26.png" alt=""></p>
<h4 id="17-6-3-故障转移"><a href="#17-6-3-故障转移" class="headerlink" title="17.6.3 故障转移"></a>17.6.3 故障转移</h4><p>当一个<strong>从节点发现</strong>自己正在复制的<strong>主节点</strong>进入了<strong>已下线状态</strong>时，从节点将开始对下线主节点进行<strong>故障转移</strong>，以下是故障转移的执行步骤</p>
<ol>
<li>复制下线主节点的所有从节点里面，会有一个从节点被选中。</li>
<li>被选中的从节点会执行<code>SLAVEOF no one</code>命令，成为新的主节点。</li>
<li>新的主节点会撤销所有对已下线主节点的槽指派，并将这些槽全部指派给自己。</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽，新的主节点开始接收和自己负责处理的槽有关的命令请求，故障转移完成。</li>
</ol>
<h4 id="17-6-4-选举新的主节点"><a href="#17-6-4-选举新的主节点" class="headerlink" title="17.6.4 选举新的主节点"></a>17.6.4 选举新的主节点</h4><p>新的主节点是通过<strong>选举</strong>产生的，选举采用<strong>Raft算法</strong>的领头选举，类似于第16章选举哨兵主节点</p>
<ol>
<li>集群的配置纪元是一个自增计数器，它的初始值为0.当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被增一</li>
<li>对于每个配置纪元，集群里每个负责处理槽的主节点都有一次投票的机会，而第一个向主节点要求投票的从节点将获得主节点的投票。</li>
<li>当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群广播一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>如果一个主节点具有投票权，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>每个参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，并根据自己收到了多少条这种消息来统计自己获得了多少主节点的支持。</li>
<li>如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于<code>N/2+1</code>张支持票时，这个从节点就会当选为新的主节点</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ol>
<h3 id="17-7-消息"><a href="#17-7-消息" class="headerlink" title="17.7 消息"></a>17.7 消息</h3><p>节点发送的消息主要有以下五种</p>
<ul>
<li><p><strong>MEET消息</strong>：当发送者接到客户端发送的<code>CLUSTER MEET</code>命令时，发送者会向接收者发送MEET消息，请求接收者加入到发送者当前所处的集群里面。</p>
</li>
<li><p><strong>PING消息</strong>：集群里的每个节点默认每隔一秒钟就会从已知节点列表中随机选出五个节点，然后对这五个节点中最长时间没有发送过PING消息的节点发送PING消息，以此来检测被选中的节点是否在线。</p>
</li>
<li><p><strong>PONG消息</strong>：当接收者收到发送者发来的MEET消息或者PONG消息时，为了向发送者确认这条MEET消息或者PING消息已到达，接收者会向发送者返回一条PONG消息。</p>
</li>
<li><p><strong>FAIL消息</strong>：当一个主节点A判断另一个主节点B已经进入FAIL状态时，节点A会向集群广播一条关于节点B的FAIL消息，所有收到这条消息的节点都会立即将节点B标记为已下线。</p>
</li>
<li><p><strong>PUBLISH消息</strong>：当节点接收到一个PUBLISH命令时，节点会执行这个命令，并向集群广播一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。</p>
</li>
</ul>
<p>其实，在Redis集群中，关于消息的发送有两种方式</p>
<ol>
<li><strong>直接广播</strong>：这种方式比较快捷暴力，它直接将消息广播给集群中所有节点，这样所有节点都快速得知了这条消息中的内容，例如<code>FAIL</code>和<code>PUBLISH</code>就是使用这个方式</li>
<li><strong>基于Gossip协议的消息传播</strong>：Gossip协议是一个基于传染病模型的分布式通信协议，所有节点不会立即都收到这条消息，但是它可以保证在一定的时间范围内，所有节点都收到了这个消息，它可以节省通信成本，因为不用一次通知所有节点。关于Gossip协议，可以继续查看<a href="https://zhuanlan.zhihu.com/p/41228196" target="_blank" rel="noopener">这篇文章</a>。下面使用图片举例。</li>
</ol>
<p><img src="/2020/03/07/Redis-17-集群/200307_36.gif" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/06/Redis-16-Sentinel/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/06/Redis-16-Sentinel/" itemprop="url">[Redis][16][Sentinel]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-06T16:27:36+08:00">
                2020-03-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/06/Redis-16-Sentinel/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/06/Redis-16-Sentinel/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-16-章-Sentinel"><a href="#第-16-章-Sentinel" class="headerlink" title="第 16 章 Sentinel"></a>第 16 章 Sentinel</h2><p>Sentinel（哨兵）是Redis的高可用性解决方案</p>
<ul>
<li>由一个或多个Sentinel实例组成的Sentinel系统可以监视任意多个主服务器，以及这些主服务器属下的所有从服务器</li>
<li>并在被监视的主服务器进入下线状态时，自动将下线主服务器属下的某个从服务器升级为新的主服务器，</li>
</ul>
<p>下面举个例子说明为什么Sentinal可以保证高可用</p>
<p>首先，我们假设有这样一个系统，如下图，它由sentinel系统、一个主服务器和三个从服务器组成<br><img src="/2020/03/06/Redis-16-Sentinel/200305_26.png" alt=""></p>
<p>假设这时，主服务下线，则Sentinel系统可以察觉到它的下线<br><img src="/2020/03/06/Redis-16-Sentinel/200305_27.png" alt=""></p>
<p>当主服务器下线事件过长，Sentinel系统就会进行故障转移操作</p>
<ul>
<li>首先，Sentinel系统会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li>
<li>之后，Sentinel系统会向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li>
<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。<br><img src="/2020/03/06/Redis-16-Sentinel/200305_28.png" alt=""></li>
</ul>
<p>之后，如果server1重新上线的话，它将被Sentinel系统降级为server2的从服务器</p>
<h3 id="16-1-启动并初始化Sentinel"><a href="#16-1-启动并初始化Sentinel" class="headerlink" title="16.1 启动并初始化Sentinel"></a>16.1 启动并初始化Sentinel</h3><p>使用下面的命令，可以启动一个Sentinel<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /path/to/your/sentinel.conf --sentinel</span><br></pre></td></tr></table></figure></p>
<p>当一个Sentinel启动时，它需要执行下面几步</p>
<ol>
<li><p>初始化服务器：这一步只是初始化一个普通的Redis服务器</p>
</li>
<li><p>将普通Redis服务器使用的代码替换成Sentinel专用代码：例如，普通Redis的命令表与Sentinel的命令表区别很大，这一步要使用Sentinel专用的命令表替换Redis命令表</p>
</li>
<li><p>初始化Sentinel状态：它会创建一个<code>sentinelState</code>结构来保存与sentinel功能相关的一些状态</p>
</li>
<li><p>初始化Sentinel的监视主服务器列表：它会根据配置文件，创建Sentinel要监控的一些主服务器</p>
</li>
<li><p>创建连向主服务器的网络连接，对于每个被监视的主服务器，Sentinel会创建两个连接</p>
<ul>
<li>一个是命令连接，这个连接专门用于向主服务器发送命令，并接收命令回复。</li>
<li>另一个是订阅连接，这个连接专门用于订阅主服务器的<code>__sentinel__:he11o</code>频道。</li>
</ul>
</li>
</ol>
<h3 id="16-2-获取主服务器信息"><a href="#16-2-获取主服务器信息" class="headerlink" title="16.2 获取主服务器信息"></a>16.2 获取主服务器信息</h3><p>Sentinel默认会以<strong>每十秒一次</strong>的频率，通过命令连接向被监视的<strong>主服务器</strong>发送<strong>INFO</strong>命令，并通过分析INFO命令的回复来获取主服务器本身的信息以及与主服务器关联的从服务器信息。</p>
<h3 id="16-3-获取从服务器信息"><a href="#16-3-获取从服务器信息" class="headerlink" title="16.3 获取从服务器信息"></a>16.3 获取从服务器信息</h3><p>通过上一步，Sentinel就可以得知主服务器下属的从服务器，然后Sentinel不但会保存这些从服务器信息，还会创建到从服务器的命令连接和订阅连接<br><img src="/2020/03/06/Redis-16-Sentinel/200305_29.png" alt=""></p>
<p>在建立连接之后，Sentinel也会按照每十秒一次的频率向从服务器发送INFO命令，根据回复来维护从服务器的状态</p>
<h3 id="16-4-订阅连接的作用"><a href="#16-4-订阅连接的作用" class="headerlink" title="16.4 订阅连接的作用"></a>16.4 订阅连接的作用</h3><p>每当建立起订阅连接之后，Sentinel就会发送下面的命令，来监听主服务的<code>__sentinel__:hello</code>频道。</p>
<p>Sentinel会每隔两秒钟向这个频道发送下面格式的消息，这条消息主要包含了sentinel节点自身的信息和主服务器信息<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUBLISH __sentinel__:hello <span class="string">"&lt;s_ip&gt;,&lt;s_port&gt;,&lt;s_runid&gt;,&lt;s_epoch&gt;,&lt;m_name&gt;,&lt;m_ip&gt;,&lt;m_port&gt;,&lt;m_epoch&gt;"</span></span><br></pre></td></tr></table></figure></p>
<p>然后以主服务器为跳板，其他Sentinel节点也会收到这个消息，因为所有的监视这个主服务器的Sentinel节点都会订阅这个频道，如下图<br><img src="/2020/03/06/Redis-16-Sentinel/200305_30.png" alt=""></p>
<p>然后通过这种机制，监听同一个主服务器的Sentinel节点就可以自动发现对方了</p>
<p>当某个Sentinel节点通过接收到<code>__sentinel__:hello</code>频道发送的消息发现了其他节点，它就会存储这个节点的信息，并且建立与这个节点的命令连接，如下图。实际上Sentinel系统中的所有Sentinel节点之间都有命令连接，它们可以互相通信<br><img src="/2020/03/06/Redis-16-Sentinel/200305_31.png" alt=""></p>
<h3 id="16-6-检测主观下线状态"><a href="#16-6-检测主观下线状态" class="headerlink" title="16.6 检测主观下线状态"></a>16.6 检测主观下线状态</h3><p>每一秒，Sentinel都会向所有与它创建了连接的节点（包括主服务器、从服务器、其他Sentinel）发送<strong>PING</strong>命令，来判断对方是否在线。</p>
<p>若一段时间内，某个节点始终没有有效回应，它就会被标记为下线，<code>flags</code>属性将开启<code>SRI_S_DOWN</code>标记，表示这个实例进入了主观下线状态</p>
<h3 id="16-7-检查客观下线状态"><a href="#16-7-检查客观下线状态" class="headerlink" title="16.7 检查客观下线状态"></a>16.7 检查客观下线状态</h3><p>当Sentinel节点将一个主服务器判断为主观下线，它就会向其他Sentinel节点发送询问，看看其他节点是否也同样认为主服务器下线。</p>
<p>Sentinel使用下面的命令询问其他Sentinel节点的意见<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SENTINEL is-master-down-by-addr &lt;ip&gt;&lt;port&gt;&lt;current_epoch&gt;&lt;runid&gt;</span><br></pre></td></tr></table></figure></p>
<p>然后这个Sentinel节点就会接受其他节点的返回结果，如果有超过N个节点也这么认为，那么这个Sentinel节点就会将主服务器标注为客观下线，并开始选举领头Sentinel。</p>
<h3 id="16-8-选举领头Sentinel"><a href="#16-8-选举领头Sentinel" class="headerlink" title="16.8 选举领头Sentinel"></a>16.8 选举领头Sentinel</h3><p>当一个主服务器被判定为客观下线后，Sentinel节点就会开始协商，选举出一个领头Sentinel，由它来进行故障转移</p>
<p>以下是选举规则</p>
<ol>
<li>所有在线的Sentinel节点都由被选为领头Sentinel的资格</li>
<li>每次进行领头Sentinel选举之后，所有Sentinel节点的配置纪元(epoch)就会自增一位，它是个计数器，用来判断选举的轮次</li>
<li>在每个选举轮次中，也就是在每个配置纪元中，每个发现主服务器客观下线的Sentinel节点都会要求其他节点将自己设置为局部领头节点，我们称这些要当领头节点的节点为源节点</li>
<li>然后根据先到先得的原则，假设有源节点A、源节点B都发送了选举信息给目标节点C，则C会设置先到达的为局部领头节点，并告知这两个源节点自己的想法</li>
<li>这样每个源节点都会得知目标节点们的意见，如果有个源节点发现自己获得了半数以上的支持，它就会从局部领头节点变为领头节点，然后执行故障转移</li>
<li>若本轮没有一个源节点得到半数支持，那么隔一段时间重新选举</li>
</ol>
<h3 id="16-9-故障转移"><a href="#16-9-故障转移" class="headerlink" title="16.9 故障转移"></a>16.9 故障转移</h3><p>然后领头Sentinel节点将，进行故障转移操作</p>
<ul>
<li>首先，领头Sentinel节点会挑选server1属下的其中一个从服务器，并将这个被选中的从服务器升级为新的主服务器。</li>
<li>之后，领头Sentinel节点向server1属下的所有从服务器发送新的复制指令，让它们成为新的主服务器的从服务器，当所有从服务器都开始复制新的主服务器时，故障转移操作执行完毕。</li>
<li>另外，Sentinel还会继续监视已下线的server1，并在它重新上线时，将它设置为新的主服务器的从服务器。</li>
</ul>
<h3 id="16-10-重点回顾"><a href="#16-10-重点回顾" class="headerlink" title="16.10 重点回顾"></a>16.10 重点回顾</h3><ul>
<li>Sentinel只是一个运行在特殊模式下的Redis服务器，它使用了和普通模式不同的命令表</li>
<li>Sentinel会读入用户指定的配置文件，为每个要被监视的主服务器创建相应的实例结构，并创建连向主服务器的命令连接和订阅连接</li>
<li>Sentinel通过向主服务器发送INFO命令来获得主服务器属下所有从服务器的地址信息，然后与从服务器建立连接</li>
<li>对于监视同一个主服务器和从服务器的多个Sentinel来说，它们会以每两秒一次的频率，通过向被监视服务器的<code>__sentinel__:he11o</code>频道发送消息来向其他Sentinel宣告自己的存在。</li>
<li>每个Sentinel也会从<code>__sentinel__:he11o</code>频道中接收其他Sentinel发来的信息，并根据这些信息为其他Sentinel创建相应的实例结构，以及命令连接。</li>
<li>Sentinel以每秒一次的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送PING命令，并根据实例对PING命令的回复来判断实例是否在线，当一个实例在指定的时长中连续向Sentinel发送无效回复时， Sentinel会将这个实例判断为主观下线。</li>
<li>当Sentinel将一个主服务器判断为主观下线时，它会向同样监视这个主服务器的其他Sentinel进行询问，看它们是否同意这个主服务器已经进入主观下线状态。</li>
<li>当Sentinel收集到足够多的主观下线投票之后，它会将主服务器判断为客观下线，并发起一次针对主服务器的故障转移操作。</li>
</ul>
<p>此外，Sentinel系统选举领头节点的方法是对Raft算法的领头选举方法的实现</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/Redis-15-复制/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/05/Redis-15-复制/" itemprop="url">[Redis][15][复制]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-05T20:56:33+08:00">
                2020-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/05/Redis-15-复制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/05/Redis-15-复制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-15-章-复制"><a href="#第-15-章-复制" class="headerlink" title="第 15 章 复制"></a>第 15 章 复制</h2><p>在Redis中，用户可以通过执行<code>SLAVEOF</code>命令或者设置<code>slaveof</code>选项，让一个服务器去复制另一个服务器，我们称呼被复制的服务器为<strong>主服务器</strong>(master)，而对主服务器进行复制的服务器叫做<strong>从服务器</strong>（slave）</p>
<p>例如下面的命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:12345&gt;SLAVEOF 127.0.0.1:6379</span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p>
<p>然后12345就成了6379的从服务器</p>
<p>进行复制的主从服务器双方的数据库将保存相同的数据，这称为数据库状态一致</p>
<h3 id="15-1-旧版复制功能的实现"><a href="#15-1-旧版复制功能的实现" class="headerlink" title="15.1 旧版复制功能的实现"></a>15.1 旧版复制功能的实现</h3><p>Redis的<strong>复制</strong>功能分为<strong>同步</strong>（sync）和<strong>命令传播</strong>（command propagate）两个操作</p>
<ul>
<li><strong>同步</strong>操作用于将<strong>从服务器</strong>的<strong>数据库状态**</strong>更新<strong>至</strong>主服务器当前所处的数据库状态**。</li>
<li><strong>命令传播</strong>操作则用于在主服务器的数据库状态被修改，导致主从服务器的数据库状态出现<strong>不一致时</strong>，让主从服务器的数据库<strong>重新回到一致状态</strong>。</li>
</ul>
<h4 id="15-1-1-同步"><a href="#15-1-1-同步" class="headerlink" title="15.1.1 同步"></a>15.1.1 同步</h4><p>当客户端发送<code>SLAVEOF</code>命令给从服务器时，要求从服务器复制主服务器，从服务器会首先执行<strong>同步</strong>操作。</p>
<p>从服务器对主服务器的<strong>同步操作</strong>需要通过向主服务器发送<strong>SYNC命令</strong>来完成</p>
<ol>
<li><strong>从</strong>服务器向<strong>主</strong>服务器发送<strong>SYNC命令</strong></li>
<li>收到SYNC命令的<strong>主服务器</strong>执行<strong>BGSAVE</strong>命令，在后台生成一个RDB文件，并使用一个<strong>缓冲区记录</strong>从现在开始执行的所有<strong>写命令</strong>。</li>
<li>当主服务器的BGSAVE命令<strong>执行完毕</strong>时，主服务器会将BGSAVE命令生成的<strong>RDB文件发送</strong>给从服务器，从服务器接收并<strong>载入</strong>这个<strong>RDB文件</strong>，将自己的数据库状态<strong>更新至主服务器执行BGSAVE命令时的数据库状态</strong>。</li>
<li>主服务器将记录在<strong>缓冲区</strong>里面的所有<strong>写命令</strong>发送给从服务器，从服务器执行这些写命令，将自己的数据库状态<strong>更新至主服务器数据库当前所处的状态</strong>。</li>
</ol>
<p>步骤如下图所示<br><img src="/2020/03/05/Redis-15-复制/200305_7.png" alt=""></p>
<p>下表是一个主从服务器进行同步的例子<br><img src="/2020/03/05/Redis-15-复制/200305_8.png" alt=""></p>
<h4 id="15-1-2-命令传播"><a href="#15-1-2-命令传播" class="headerlink" title="15.1.2 命令传播"></a>15.1.2 命令传播</h4><p>每当<strong>主服务器</strong>执行客户端发送的<strong>写命令</strong>时，主服务器的数据库就有可能会被修改，并导致主从服务器状态<strong>不一致</strong>。</p>
<p>为了让主从服务器<strong>再次一致</strong>，主服务器需要对从服务器执行<strong>命令传播</strong>操作</p>
<ul>
<li>主服务器会将自己执行的写命令，也即是<strong>造成</strong>主从服务器<strong>不一致</strong>的那条<strong>写命令</strong>，<strong>发送给从服务器</strong>执行</li>
<li>当从服务器<strong>执行了相同的写命令</strong>之后，主从服务器将<strong>再次回到一致</strong>状态</li>
</ul>
<p>例如下面几张图<br><img src="/2020/03/05/Redis-15-复制/200305_9.png" alt=""><br><img src="/2020/03/05/Redis-15-复制/200305_10.png" alt=""><br><img src="/2020/03/05/Redis-15-复制/200305_11.png" alt=""></p>
<h3 id="15-2-旧版复制功能的缺陷"><a href="#15-2-旧版复制功能的缺陷" class="headerlink" title="15.2 旧版复制功能的缺陷"></a>15.2 旧版复制功能的缺陷</h3><p>在旧版，复制主要应用于以下两种场景</p>
<ol>
<li><strong>初次复制</strong>：从服务器之前没有复制过主服务器</li>
<li><strong>断线后重复制</strong>：处于命令传播阶段的主从服务器因为网络问题而中断，但从服务器之后重连了主服务器。这时，发生了数据不一致。Redis旧版中面对这个情况，直接执行复制操作，将主服务器当前状态打包为RDB传送给从服务器</li>
</ol>
<p>例子如下表<br><img src="/2020/03/05/Redis-15-复制/200305_12.png" alt=""></p>
<p><strong>问题的关键</strong>就在于：断线之后，从服务器只不过少执行了几条写指令而已。为了恢复一致性，却大动干戈地<strong>重新执行了全部的复制操作</strong>，这会浪费大量资源。</p>
<h3 id="15-3-新版复制功能的实现"><a href="#15-3-新版复制功能的实现" class="headerlink" title="15.3 新版复制功能的实现"></a>15.3 新版复制功能的实现</h3><p>为了解决旧版复制功能在处理断线重复制情况时的低效问题，Redis从2.8版本开始，使用<code>PSYNC</code>命令代替<code>SYNC</code>命令来执行复制时的同步操作</p>
<p>PSYNC命令具有完整重同步和部分重同步两种模式</p>
<ul>
<li><strong>完整重同步</strong>类似于<code>SYNC</code>命令，它会将主服务器状态打包为RDB发送</li>
<li><strong>部分重同步</strong>则用于<strong>断线重连</strong>的情况。主服务器可以将主从服务器连接<strong>断开期间执行的写命令</strong>发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态。</li>
</ul>
<p>上一节的例子在新版会如下表方式执行<br><img src="/2020/03/05/Redis-15-复制/200305_13.png" alt=""></p>
<p>下图展示了主从服务器执行部分重同步时的通信过程<br><img src="/2020/03/05/Redis-15-复制/200305_14.png" alt=""></p>
<h3 id="15-4-部分重同步的实现"><a href="#15-4-部分重同步的实现" class="headerlink" title="15.4 部分重同步的实现"></a>15.4 部分重同步的实现</h3><p>部分重同步的功能由下面三部分组成</p>
<ul>
<li>主服务器的<strong>复制偏移量</strong>和从服务器的复制偏移量</li>
<li>主服务器的<strong>复制积压缓冲区</strong></li>
<li>服务器的<strong>运行ID</strong></li>
</ul>
<h4 id="15-4-1-复制偏移量"><a href="#15-4-1-复制偏移量" class="headerlink" title="15.4.1 复制偏移量"></a>15.4.1 复制偏移量</h4><p>主服务器和从服务器会<strong>分别</strong>维护一个<strong>复制偏移量</strong></p>
<ul>
<li>主服务器每次向从服务器<strong>传播N个字节</strong>的数据时，就将自己的复制偏移量的值<strong>加上N</strong></li>
<li>从服务器每次<strong>收到</strong>主服务器传播来的<strong>N个字节</strong>的数据时，就将自己的复制偏移量的值<strong>加上N</strong></li>
</ul>
<p>下面举例说明</p>
<p>刚开始主从服务器有相同的偏移量<code>10086</code><br><img src="/2020/03/05/Redis-15-复制/200305_15.png" alt=""></p>
<p>此时，主服务器传播长度为33字节的数据，假如所有从服务器正常，如下图<br><img src="/2020/03/05/Redis-15-复制/200305_16.png" alt=""></p>
<p>假如有一个从服务器掉线<br><img src="/2020/03/05/Redis-15-复制/200305_17.png" alt=""></p>
<p>从上例，通过对比主从服务器的复制偏移量，程序可以很容易的直到主从服务器是否处于一致状态</p>
<h4 id="15-4-2-复制积压缓冲区"><a href="#15-4-2-复制积压缓冲区" class="headerlink" title="15.4.2 复制积压缓冲区"></a>15.4.2 复制积压缓冲区</h4><p>复制积压缓冲区是由主服务器维护的一个固定长度先进先出队列，默认大小为1MB。</p>
<p>当主服务器进行命令传播时，它不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面，如下图<br><img src="/2020/03/05/Redis-15-复制/200305_18.png" alt=""></p>
<p>复制积压缓冲区会保存最近传播的写命令，且缓冲区中的<strong>每个字节</strong>都<strong>对应</strong>一个<strong>复制偏移量</strong>，例如下图<br><img src="/2020/03/05/Redis-15-复制/200305_19.png" alt=""></p>
<p>当从服务器重新连上主服务器时，从服务器会通过<code>PSYNC</code>命令将自己的复制偏移量<code>offset</code>发送给主服务器，主服务器会<strong>根据</strong>这个<strong>复制偏移量</strong>来<strong>决定</strong>对从服务器执行<strong>何种同步</strong></p>
<ul>
<li><p>如果<code>offset</code>偏移量之后的数据<strong>仍然存在</strong>于<strong>复制积压缓冲区</strong>里面，那么主服务器将对从服务器执行<strong>部分重同步</strong>操作。</p>
</li>
<li><p><strong>否则</strong>主服务器将对从服务器执行<strong>完整重同步</strong>操作。</p>
</li>
</ul>
<p>回到上面的例子，当掉线的从服务器上线后，发送<code>PSYNC</code>命令并附上自己的复制偏移量<code>10086</code>，然后主服务器发现10086之后的字节都在缓冲区，直接取出并发送给从服务器<br><img src="/2020/03/05/Redis-15-复制/200305_20.png" alt=""></p>
<h4 id="15-4-3-服务器运行ID"><a href="#15-4-3-服务器运行ID" class="headerlink" title="15.4.3 服务器运行ID"></a>15.4.3 服务器运行ID</h4><p>每个Redis服务器，无论主从，都拥有一个自己的运行ID，它在服务器启动时自动生成，由40个随机的十六进制字符组成</p>
<p>当从服务器对主服务器进行初次复制时，主服务器会将自己的运行ID传送给从服务器保存。</p>
<p>当从服务器掉线重连时，会发送这个ID。若ID相同，说明掉线之前的主服务器就是这个主服务器，则尝试执行部分重同步；若不相同，则执行完整重同步</p>
<h3 id="15-5-PSYNC命令"><a href="#15-5-PSYNC命令" class="headerlink" title="15.5 PSYNC命令"></a>15.5 PSYNC命令</h3><p>本节将详细介绍<code>PSYNC</code>命令的完整细节</p>
<p><code>PSYNC</code>命令的调用方法有两种</p>
<ul>
<li>如果从服务器以前没有复制过任何主服务器，那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC ? -1</code>命令，主动请求主服务器进行完整重同步</li>
<li>如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送<code>PSYNC &lt;runid&gt; &lt;offset&gt;</code>命令：其中<code>runid</code>是上一次复制的主服务器的运行ID，而<code>offset</code>则是从服务器当前的复制偏移量</li>
</ul>
<p>根据情况，接收到<code>PSYNC</code>命令的主服务器会向从服务器返回以下三种回复的其中一种：</p>
<ul>
<li>如果主服务器返回<code>+FULLRESYNC &lt;runid&gt; &lt;offset&gt;</code>回复，那么表示主服务器将与从服务器执行完整重同步操作：其中<code>runid</code>是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送<code>PSYNC</code>命令时使用；而<code>offset</code>则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量。</li>
<li>如果主服务器返回<code>+CONTINUE</code>回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了。</li>
<li>如果主服务器返回<code>-ERR</code>回复，那么表示主服务器的版本过低，它识别不了<code>PSYNC</code>命令，从服务器将向主服务器发送<code>SYNC</code>命令，并与主服务器执行完整同步操作。</li>
</ul>
<p>流程图如下<br><img src="/2020/03/05/Redis-15-复制/200305_21.png" alt=""></p>
<h3 id="15-6-复制的实现"><a href="#15-6-复制的实现" class="headerlink" title="15.6 复制的实现"></a>15.6 复制的实现</h3><p>本节将按顺序介绍服务器收到客户端发送的<code>SLAVEOF</code>命令后的全部操作</p>
<h4 id="15-6-1-设置主服务器的地址和端口"><a href="#15-6-1-设置主服务器的地址和端口" class="headerlink" title="15.6.1 设置主服务器的地址和端口"></a>15.6.1 设置主服务器的地址和端口</h4><p>从服务器首先要做的就是将客户端给定的主服务器IP地址以及端口保存到服务器状态的<code>masterhost</code>属性和<code>masterport</code>属性里面</p>
<p><code>SLAVEOF</code>命令是一个异步命令，在完成<code>masterhost</code>属性和<code>masterport</code>属性的设置工作之后，从服务器将向发送<code>SLAVEOF</code>命令的客户端返回<code>OK</code>，表示复制指令已经被接收，而实际的复制工作将在<code>OK</code>返回之后才真正开始执行。</p>
<h4 id="15-6-2-建立套接字连接"><a href="#15-6-2-建立套接字连接" class="headerlink" title="15.6.2 建立套接字连接"></a>15.6.2 建立套接字连接</h4><p>在<code>SLAVEOF</code>命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接</p>
<p>然后，从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类。</p>
<p>而主服务器在接受从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器看作是一个连接到主服务器的客户端来对待，</p>
<h4 id="15-6-3-发送PING命令"><a href="#15-6-3-发送PING命令" class="headerlink" title="15.6.3 发送PING命令"></a>15.6.3 发送PING命令</h4><p>从服务器成为主服务器的客户端之后，做的第一件事就是向主服务器发送一个PING命令，它有两个作用</p>
<ul>
<li>通过发送PING命令可以检查套接字的读写状态是否正常。</li>
<li>通过发送PING命令可以检查主服务器能否正常处理命令请求。</li>
</ul>
<p>从服务器发送PING命令后会遇到如下三种情况</p>
<ul>
<li>如果主服务器向从服务器返回了一个命令回复，但从服务器却不能在规定的时限内读取出命令回复的内容，那么表示主从服务器之间的网络连接状态不佳。这时，从服务器断开并重新创建连向主服务器的套接字</li>
<li>如果主服务器向从服务器返回一个错误，那么表示主服务器暂时没办法处理从服务器的命令请求，不能继续执行复制工作的后续步骤。这时，从服务器断开并重新创建连向主服务器的套接字</li>
<li>如果从服务器读取到<code>PONG</code>回复，那么表示连接正常，在这种情况下从服务器可以继续执行复制工作的下个步骤。</li>
</ul>
<h4 id="15-6-4-身份验证"><a href="#15-6-4-身份验证" class="headerlink" title="15.6.4 身份验证"></a>15.6.4 身份验证</h4><p>下一步，从服务器决定是否向主服务器发送身份验证，流程如下<br><img src="/2020/03/05/Redis-15-复制/200305_22.png" alt=""></p>
<h4 id="15-6-5-发送端口信息"><a href="#15-6-5-发送端口信息" class="headerlink" title="15.6.5 发送端口信息"></a>15.6.5 发送端口信息</h4><p>在身份验证步骤之后，从服务器将执行命令<code>REPLCONF listening-port &lt;port-number&gt;</code>向主服务器发送从服务器的监听端口号</p>
<p>主服务器接收到这个命令后，会将端口号记录在从服务器所对应对的客户端状态的<code>slave_listening_port</code>属性中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//从服务器的监听端口号</span></span><br><span class="line">    <span class="keyword">int</span> slave_listening_port;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; redisClient</span><br></pre></td></tr></table></figure>
<h4 id="15-6-6-同步"><a href="#15-6-6-同步" class="headerlink" title="15.6.6 同步"></a>15.6.6 同步</h4><p>在这一步，从服务器将向主服务器发送<code>PSYC</code>命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。</p>
<p><code>PSYC</code>的详细过程请参加上一节</p>
<p>值得一提的是，在同步操作执行之后，主服务器也会成为从服务器的客户端。正因为主服务器成为了从服务器的客户端，所以主服务器才能通过发送写命令来改变从服务器的数据库状态</p>
<p>如下图<br><img src="/2020/03/05/Redis-15-复制/200305_23.png" alt=""></p>
<h4 id="15-6-7-命令传播"><a href="#15-6-7-命令传播" class="headerlink" title="15.6.7 命令传播"></a>15.6.7 命令传播</h4><p>当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了。</p>
<h3 id="15-7-心跳检测"><a href="#15-7-心跳检测" class="headerlink" title="15.7 心跳检测"></a>15.7 心跳检测</h3><p>在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>replication_offset</code>命令是从服务器当前的复制偏移量</p>
<p>发送<code>REPLCONF ACK</code>命令对于主服务器有三个作用</p>
<ul>
<li>检测主从服务器的网络连接状态</li>
<li>辅助实现<code>min-slaves</code>选项</li>
<li>检测命令丢失</li>
</ul>
<h4 id="15-7-1-检测主从服务器的网络连接状态"><a href="#15-7-1-检测主从服务器的网络连接状态" class="headerlink" title="15.7.1 检测主从服务器的网络连接状态"></a>15.7.1 检测主从服务器的网络连接状态</h4><p>主从服务器可以通过发送和接收<code>REPLCONF ACK</code>命令来检查两者之间的网络连接是否正常：如果主服务器超过一秒钟没有收到从服务器发来的 <code>REPLCONF ACK</code>命令，那么主服务器就知道主从服务器之间的连接出现问题了。</p>
<h4 id="15-7-2-辅助事件min-slaves配置选项"><a href="#15-7-2-辅助事件min-slaves配置选项" class="headerlink" title="15.7.2 辅助事件min-slaves配置选项"></a>15.7.2 辅助事件min-slaves配置选项</h4><p>Redis的<code>min-s1aves-to-write</code>和<code>min-slaves-max-1ag</code>两个选项可以防止主服务器在不安全的情况下执行写命令。</p>
<p>假设我们向主服务器提供如下设置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3</span><br><span class="line">min-slaves-max-lag 10</span><br></pre></td></tr></table></figure></p>
<p>这个设置是指，如果从服务器的数量小于3，或者3个服务器的延迟值都大于或等于10秒时，主服务器将拒绝执行写命令</p>
<h4 id="15-7-3-检测命令丢失"><a href="#15-7-3-检测命令丢失" class="headerlink" title="15.7.3 检测命令丢失"></a>15.7.3 检测命令丢失</h4><p>如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送<code>REPLCONF ACK</code>命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p>
<p>例如下图<br><img src="/2020/03/05/Redis-15-复制/200305_24.png" alt=""><br><img src="/2020/03/05/Redis-15-复制/200305_25.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/05/Redis-14-服务器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/05/Redis-14-服务器/" itemprop="url">[Redis][14][服务器]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-05T11:05:34+08:00">
                2020-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/05/Redis-14-服务器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/05/Redis-14-服务器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-14-章-服务器"><a href="#第-14-章-服务器" class="headerlink" title="第 14 章 服务器"></a>第 14 章 服务器</h2><p>Redis服务器负责与多个客户端建立<strong>网络连接</strong>，<strong>处理</strong>客户端发送的<strong>命令请求</strong>，在<strong>数据库</strong>中<strong>保存</strong>客户端执行命令所产生的数据，并通过<strong>资源管理</strong>来维持服务器自身的运转。</p>
<h3 id="14-1-命令请求的执行过程"><a href="#14-1-命令请求的执行过程" class="headerlink" title="14.1 命令请求的执行过程"></a>14.1 命令请求的执行过程</h3><p>下面我们将以<code>SET</code>命令为例子，详细描述命令请求的执行全过程</p>
<h4 id="14-1-1-发送命令请求"><a href="#14-1-1-发送命令请求" class="headerlink" title="14.1.1 发送命令请求"></a>14.1.1 发送命令请求</h4><p>Redis服务器的命令请求来自Redis客户端，当用户在客户端中键入一个命令请求时，客户端会将这个命令请求转换成<strong>协议格式</strong>，然后通过连接到服务器的套接字，将协议格式的命令请求<strong>发送给服务器</strong></p>
<p><img src="/2020/03/05/Redis-14-服务器/200305_0.png" alt=""></p>
<h4 id="14-1-2-读取命令请求"><a href="#14-1-2-读取命令请求" class="headerlink" title="14.1.2 读取命令请求"></a>14.1.2 读取命令请求</h4><p>当客户端与服务器之间的<strong>连接套接字</strong>因为客户端的写入而变得<strong>可读</strong>时，服务器将调用<strong>命令请求处理器</strong>来执行以下操作</p>
<ol>
<li><strong>读取</strong>套接字中协议格式的命令请求，并将其保存到客户端状态的<strong>输入缓冲区</strong>中，如下图<br><img src="/2020/03/05/Redis-14-服务器/200305_1.png" alt=""></li>
<li>对输入缓冲区中的命令请求进行<strong>分析</strong>，<strong>提取</strong>命令请求中包含的<strong>命令参数</strong>，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的<code>argv</code>属性和<code>argc</code>属性中<br><img src="/2020/03/05/Redis-14-服务器/200305_2.png" alt=""></li>
<li>调用<strong>命令执行器</strong>，执行客户端指定的命令</li>
</ol>
<h4 id="14-1-3-命令执行器：查找命令实现"><a href="#14-1-3-命令执行器：查找命令实现" class="headerlink" title="14.1.3 命令执行器：查找命令实现"></a>14.1.3 命令执行器：查找命令实现</h4><p>首先，命令执行器根据客户端状态的<code>argv[0]</code>参数，在命令表中查找参数指定的命令，并将找到的命令保存到客户端状态的<code>cmd</code>属性中</p>
<p>命令表是一个<strong>字典</strong>，字典的键是命令的名字，而字典的值是<code>redisCommand</code>结构，这个结构的源代码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Redis 命令</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令名字</span></span><br><span class="line">    <span class="keyword">char</span> *name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现函数</span></span><br><span class="line">    redisCommandProc *proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数个数，如果是-N，则说明参数的数量大于等于N</span></span><br><span class="line">    <span class="keyword">int</span> arity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字符串表示的 FLAG</span></span><br><span class="line">    <span class="keyword">char</span> *sflags; <span class="comment">/* Flags as string representation, one char per flag. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际 FLAG</span></span><br><span class="line">    <span class="keyword">int</span> flags;    <span class="comment">/* The actual flags, obtained from the 'sflags' field. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Use a function to determine keys arguments in a command line.</span></span><br><span class="line"><span class="comment">     * Used for Redis Cluster redirect. */</span></span><br><span class="line">    <span class="comment">// 从命令中判断命令的键参数。在 Redis 集群转向时使用。</span></span><br><span class="line">    redisGetKeysProc *getkeys_proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* What keys should be loaded in background when calling this command? */</span></span><br><span class="line">    <span class="comment">// 指定哪些参数是 key</span></span><br><span class="line">    <span class="keyword">int</span> firstkey; <span class="comment">/* The first argument that's a key (0 = no keys) */</span></span><br><span class="line">    <span class="keyword">int</span> lastkey;  <span class="comment">/* The last argument that's a key */</span></span><br><span class="line">    <span class="keyword">int</span> keystep;  <span class="comment">/* The step between first and last key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计信息</span></span><br><span class="line">    <span class="comment">// microseconds 记录了命令执行耗费的总毫微秒数</span></span><br><span class="line">    <span class="comment">// calls 是命令被执行的总次数</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> microseconds, calls;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>下图是一个命令表的例子</p>
<p><img src="/2020/03/05/Redis-14-服务器/200305_3.png" alt=""></p>
<p>当程序在命令表中查找到了对应的命令，则会将其保存到客户端状态的<code>cmd</code>指针中，如下图</p>
<p><img src="/2020/03/05/Redis-14-服务器/200305_4.png" alt=""></p>
<h4 id="14-1-4-命令执行器：执行预备操作"><a href="#14-1-4-命令执行器：执行预备操作" class="headerlink" title="14.1.4 命令执行器：执行预备操作"></a>14.1.4 命令执行器：执行预备操作</h4><p>目前为止，命令执行需要的信息已经收集齐了，但是为了保证命令的正确执行，还需要进行一些预备工作，包括</p>
<ul>
<li><p>检查客户端状态的<code>cmd</code>指针是否指向<code>NULL</code></p>
</li>
<li><p>根据客户端<code>cmd</code>属性指向的<code>redisCommand</code>结构的<code>arity</code>属性，检查命令请求所给定的参数个数是否正确</p>
</li>
<li><p>检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行<code>AUTH</code>命令</p>
</li>
<li><p>如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的<code>SHUTDOWN nosave</code>命令和<code>SCRIPT KILL</code>命令，其他命令都会被服务器拒绝。</p>
</li>
<li><p>如果客户端正在执行事务，那么服务器只会执行客户端发来的<code>EXEC</code>、<code>DISCARD</code>、<code>MULT</code>、<code>WATCH</code>四个命令，其他命令都会被放进事务队列中。</p>
</li>
<li><p>等等</p>
</li>
</ul>
<h4 id="14-1-5-命令执行器：调用命令的实现函数"><a href="#14-1-5-命令执行器：调用命令的实现函数" class="headerlink" title="14.1.5 命令执行器：调用命令的实现函数"></a>14.1.5 命令执行器：调用命令的实现函数</h4><p>此时，我们不但准备好了执行命令所需的信息，而且还进行了预备工作，那么只要执行以下语句就可以执行命令了</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">client-&gt;cmd-&gt;proc(client)</span><br></pre></td></tr></table></figure>
<p><code>cmd-&gt;proc</code>指针指向的是之前绑定的命令实现函数，通过这个函数，就可以对指定命令进行执行，并产生对应的操作，写入到客户端的输出缓冲区中。在这之后，命令实现函数还将为客户端套接字管理命令回复处理器，然后这个处理器可以在客户端可写的时候将回复返回给客户端。</p>
<p>如下图<br><img src="/2020/03/05/Redis-14-服务器/200305_5.png" alt=""></p>
<p><img src="/2020/03/05/Redis-14-服务器/200305_6.png" alt=""></p>
<h4 id="14-1-6-命令执行器：执行后续操作"><a href="#14-1-6-命令执行器：执行后续操作" class="headerlink" title="14.1.6 命令执行器：执行后续操作"></a>14.1.6 命令执行器：执行后续操作</h4><p>在执行完实现函数后，还需要执行一些后续工作</p>
<ul>
<li>如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否执行了刚刚执行完的命令请求添加一条新的慢查询日志</li>
<li>更新被执行命令的<code>redisCommand</code>结构记录的总时长和次数</li>
<li>如果开启了AOF，则将刚执行的命令写入到AOF缓冲区</li>
<li>将刚执行的命令传播给所有从服务器</li>
</ul>
<h4 id="14-1-7-将命令回复发送给客户端"><a href="#14-1-7-将命令回复发送给客户端" class="headerlink" title="14.1.7 将命令回复发送给客户端"></a>14.1.7 将命令回复发送给客户端</h4><p>前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。</p>
<h4 id="14-1-8-客户端接收并打印命令请求"><a href="#14-1-8-客户端接收并打印命令请求" class="headerlink" title="14.1.8 客户端接收并打印命令请求"></a>14.1.8 客户端接收并打印命令请求</h4><p>当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看</p>
<h3 id="14-2-serverCron函数"><a href="#14-2-serverCron函数" class="headerlink" title="14.2 serverCron函数"></a>14.2 serverCron函数</h3><p>这个函数负责管理服务器的资源，并保持服务器自身的良好运转</p>
<h4 id="14-2-1-更新服务器时间缓存"><a href="#14-2-1-更新服务器时间缓存" class="headerlink" title="14.2.1 更新服务器时间缓存"></a>14.2.1 更新服务器时间缓存</h4><p>Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的<code>unixtime</code>属性和<code>mstime</code>属性被用作当前时间的缓存</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了秒级精度的系统当前时间戳</span></span><br><span class="line">    <span class="keyword">time_t</span> unixtime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存了毫秒级精度的系统当前UNIX时间戳</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> mstime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>serverCron</code>默认每100毫秒执行一次，所以这两个时间戳并不准确，若需要更高精度的时间，比如为键设置过期时间、添加慢查询日志等，则还是需要通过系统调用的方式。</p>
<h4 id="14-2-2-更新LRU时钟"><a href="#14-2-2-更新LRU时钟" class="headerlink" title="14.2.2 更新LRU时钟"></a>14.2.2 更新LRU时钟</h4><p>服务器状态中的<code>lruclock</code>属性保存了服务器的<code>LRU</code>时钟。每个Redis对象都有一个<code>lru</code>属性，它保存了对象最后一次被命令访问的时间。</p>
<p><code>serverCron</code>函数默认会每10秒更新一次<code>lruclock</code>属性的值，所以这个时钟精度很差，通过它计算出的对象空转时间也只是个模糊值</p>
<h4 id="14-2-3-更新服务器每秒执行命令次数"><a href="#14-2-3-更新服务器每秒执行命令次数" class="headerlink" title="14.2.3 更新服务器每秒执行命令次数"></a>14.2.3 更新服务器每秒执行命令次数</h4><p>略</p>
<h4 id="14-2-4-更新服务器内存峰值记录"><a href="#14-2-4-更新服务器内存峰值记录" class="headerlink" title="14.2.4 更新服务器内存峰值记录"></a>14.2.4 更新服务器内存峰值记录</h4><p><code>serverCron</code>还负责记录服务器运行期间的最大内存使用量</p>
<h4 id="14-2-5-处理SIGTERM信号"><a href="#14-2-5-处理SIGTERM信号" class="headerlink" title="14.2.5 处理SIGTERM信号"></a>14.2.5 处理SIGTERM信号</h4><p>在启动服务器时，Redis会为服务器进程的<code>SIGTERM</code>信号关联处理器<code>sigtermHandler</code>函数，这个信号处理器负责在服务器接到<code>SIGTERM</code>信号时，打开服务器状态的<code>shutdown_asap</code>标识</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigtermHandler</span><span class="params">(<span class="keyword">int</span> sig)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印日志</span></span><br><span class="line">    redisLogFromHandler(REDIS_WARNING, <span class="string">"Received SIGTERM, scheduling shutdown..."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开关闭标志</span></span><br><span class="line">    server.shutdown_asap = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每次<code>serverCron</code>函数执行时，程序都会对服务器状态的<code>shutdown_asap</code>属性进行检查，并根据属性的值来决定是否关闭服务器</p>
<h4 id="14-2-6-管理客户端资源"><a href="#14-2-6-管理客户端资源" class="headerlink" title="14.2.6 管理客户端资源"></a>14.2.6 管理客户端资源</h4><p><code>serverCron</code>每次执行都会调用<code>clientsCron</code>，它会进行如下检查</p>
<ul>
<li>如果客户端超时，则释放客户端</li>
<li>如果客户端上次执行命令请求之后，输入缓冲区大小超过了给定长度，则释放客户端当前的输入缓冲区，并新建一个输入缓冲区，以节省内存</li>
</ul>
<h4 id="14-2-7-管理服务器资源"><a href="#14-2-7-管理服务器资源" class="headerlink" title="14.2.7 管理服务器资源"></a>14.2.7 管理服务器资源</h4><p><code>serverCron</code>每次执行都会调用<code>databasesCron</code>函数，这个函数会对服务器的一部分数据库进行检查、删除其中的过期键，并在有需要的时候，对字典进行收缩操作</p>
<h4 id="14-2-8-执行被延迟的BGREWRITEAOF"><a href="#14-2-8-执行被延迟的BGREWRITEAOF" class="headerlink" title="14.2.8 执行被延迟的BGREWRITEAOF"></a>14.2.8 执行被延迟的BGREWRITEAOF</h4><p>每次<code>serverCron</code>函数执行时，函数都会检查<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令是否正在执行，如果这两个命令都没在执行，并且有之前被推延的<code>BGREWRITEAOF</code>，那么服务器就会执行它。</p>
<h4 id="14-2-9-检查持久化操作的运行状况"><a href="#14-2-9-检查持久化操作的运行状况" class="headerlink" title="14.2.9 检查持久化操作的运行状况"></a>14.2.9 检查持久化操作的运行状况</h4><p>略</p>
<h4 id="14-2-10-将AOF缓冲区中的内容写入AOF文件"><a href="#14-2-10-将AOF缓冲区中的内容写入AOF文件" class="headerlink" title="14.2.10 将AOF缓冲区中的内容写入AOF文件"></a>14.2.10 将AOF缓冲区中的内容写入AOF文件</h4><p>略</p>
<h4 id="14-2-11-关闭异步客户端"><a href="#14-2-11-关闭异步客户端" class="headerlink" title="14.2.11 关闭异步客户端"></a>14.2.11 关闭异步客户端</h4><p>服务器会关闭那些输出缓冲区大小超过限制的客户端</p>
<h4 id="14-2-12-增加cronloops计数器的值"><a href="#14-2-12-增加cronloops计数器的值" class="headerlink" title="14.2.12 增加cronloops计数器的值"></a>14.2.12 增加cronloops计数器的值</h4><p><code>cronloops</code>记录了<code>serverCron</code>的执行次数，所以<code>serverCron</code>函数还有负责更新自己的执行次数</p>
<h3 id="14-3-初始化服务器"><a href="#14-3-初始化服务器" class="headerlink" title="14.3 初始化服务器"></a>14.3 初始化服务器</h3><h4 id="14-3-1-初始化服务器状态结构"><a href="#14-3-1-初始化服务器状态结构" class="headerlink" title="14.3.1 初始化服务器状态结构"></a>14.3.1 初始化服务器状态结构</h4><p>初始化服务器的第一步是创建一个<code>redisServer</code>类型的实例变量<code>server</code>作为服务器的状态，并且为结构中的各个属性设置<strong>默认值</strong>。</p>
<p>这一步由<code>redis.c/initServerConfig</code>来完成，它设置的主要是一些常量，并且会创建<strong>命令表</strong>数据结构，但是<strong>不会创建</strong>服务器状态的<strong>其他数据结构</strong>，理由下面会解释。</p>
<h4 id="14-3-2-载入配置选项"><a href="#14-3-2-载入配置选项" class="headerlink" title="14.3.2 载入配置选项"></a>14.3.2 载入配置选项</h4><p>用户可以通过配置参数或者配置文件来修改服务器的默认配置。</p>
<p>服务器在用<code>initServerConfig</code>初始化完<code>server</code>变量之后，会载入用户自定义的配置，并且对第一步初始化的<code>server</code>变量进行修改。</p>
<p>配置的规则是</p>
<ul>
<li>如果用户自定义了新的值，那么服务器就使用用户自定义的值</li>
<li>否则沿用<code>initServerConfig</code>函数设置的默认值</li>
</ul>
<h4 id="14-3-3-初始化服务器数据结构"><a href="#14-3-3-初始化服务器数据结构" class="headerlink" title="14.3.3 初始化服务器数据结构"></a>14.3.3 初始化服务器数据结构</h4><p>这一步在<code>initServer</code>函数中执行，它主要初始如下数据结构</p>
<ul>
<li><code>server.clients</code>链表：它记录了客户端状态</li>
<li><code>server.db</code>数组：包含了服务器的所有数组</li>
<li><code>server.pubsub_channels</code>字典：与发布订阅有关</li>
<li><code>server.lua</code>用来执行lua脚本的伪客户端</li>
<li><code>server.slowlog</code>用来保存慢查询日志</li>
</ul>
<p>之所以将初始化工作分在<code>initServerConfig</code>和<code>initServer</code>两个函数，是因为如果只用一步的话，一旦用户通过配置文件更改了与数据结构相关的配置，那么服务器还要重新调整已经创建的数据结构。分为两步可以避免这种情况。</p>
<p>除此之外，<code>initServer</code>还进行了如下设置工作</p>
<ul>
<li><p>为服务器设置<strong>进程信号处理器</strong>。</p>
</li>
<li><p><strong>创建共享对象</strong>：这些对象包含Reds服务器经常用到的一些值，比如包含”oK”回复的字符串对象，包含”ERR”回复的字符串对象，包含整数1到10000的字符串对象等等，服务器通过重用这些共享对象来避免反复创建相同的对象</p>
</li>
<li><p>打开服务器的<strong>监听端口</strong>，并为监听套接字关联连接应答事件处理器，等待服务器正式运行时接受客户端的连接。</p>
</li>
<li><p>为<code>serverCron</code>函数创建<strong>时间事件</strong>，等待服务器正式运行时执行<code>servercron</code>函数。</p>
</li>
<li><p>如果AOF持久化功能已经打开，那么<strong>打开现有的AOF文件</strong>，如果AOF文件不存在，那么创建并打开一个新的AOF文件，为AOF写入做好准备。</p>
</li>
<li><p>初始化服务器的<strong>后台I/O模块</strong>，为将来的LO操作做好准备。</p>
</li>
</ul>
<h4 id="14-3-4-还原数据库状态"><a href="#14-3-4-还原数据库状态" class="headerlink" title="14.3.4 还原数据库状态"></a>14.3.4 还原数据库状态</h4><p>在完成了服务器变量的初始化工作，服务器需要载入AOF或者RDB文件来还原服务器的数据库状态</p>
<h4 id="14-3-5-执行事件循环"><a href="#14-3-5-执行事件循环" class="headerlink" title="14.3.5 执行事件循环"></a>14.3.5 执行事件循环</h4><p>在初始化的最后一步，服务器将开始事件循环的执行</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/Redis-13-客户端/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/04/Redis-13-客户端/" itemprop="url">[Redis][13][客户端]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-04T16:06:57+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/04/Redis-13-客户端/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/04/Redis-13-客户端/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-13-章-客户端"><a href="#第-13-章-客户端" class="headerlink" title="第 13 章 客户端"></a>第 13 章 客户端</h2><p>Redis服务器是典型的<strong>一对多服务器</strong>程序：一个服务器可以与多个客户端建立网络连接。</p>
<p>通过使用由<strong>I/O多路复用</strong>技术实现的文件事件处理器，Redis服务器使用<strong>单线程单进程</strong>的方式来处理命令请求，并与多个客户端进行网络通信。</p>
<p>对于每个与服务器进行连接的客户端，服务器都为这些客户端建立了相应的<code>redis.h/redisclient</code>结构（客户端状态），这个结构保存了客户端当前的<strong>状态信息</strong>，以及<strong>执行相关功能</strong>时需要用到的<strong>数据结构</strong>，具体属性本节稍后会介绍</p>
<p>Redis服务器结构中存储了一个<code>redisClient</code>类型的链表，它保存了所有与服务器连接的客户端状态结构</p>
<h3 id="13-1-客户端属性"><a href="#13-1-客户端属性" class="headerlink" title="13.1 客户端属性"></a>13.1 客户端属性</h3><p><code>redisClient</code>结构的源码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisClient</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 套接字描述符</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前正在使用的数据库的 id （号码）</span></span><br><span class="line">    <span class="keyword">int</span> dictid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的名字</span></span><br><span class="line">    robj *name;             <span class="comment">/* As set by CLIENT SETNAME */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区</span></span><br><span class="line">    sds querybuf;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查询缓冲区长度峰值</span></span><br><span class="line">    <span class="keyword">size_t</span> querybuf_peak;   <span class="comment">/* Recent (100ms or more) peak of querybuf size */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数数量</span></span><br><span class="line">    <span class="keyword">int</span> argc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 参数对象数组</span></span><br><span class="line">    robj **argv;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录被客户端执行的命令</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisCommand</span> *<span class="title">cmd</span>, *<span class="title">lastcmd</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 请求的类型：内联命令还是多条命令</span></span><br><span class="line">    <span class="keyword">int</span> reqtype;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 剩余未读取的命令内容数量</span></span><br><span class="line">    <span class="keyword">int</span> multibulklen;       <span class="comment">/* number of multi bulk arguments left to read */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命令内容的长度</span></span><br><span class="line">    <span class="keyword">long</span> bulklen;           <span class="comment">/* length of bulk argument in multi bulk request */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复链表</span></span><br><span class="line">    <span class="built_in">list</span> *reply;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回复链表中对象的总大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> reply_bytes; <span class="comment">/* Tot bytes of objects in reply list */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已发送字节，处理 short write 用</span></span><br><span class="line">    <span class="keyword">int</span> sentlen;            <span class="comment">/* Amount of bytes already sent in the current</span></span><br><span class="line"><span class="comment">                               buffer or object being sent. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> ctime;           <span class="comment">/* Client creation time */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端最后一次和服务器互动的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastinteraction; <span class="comment">/* time of the last interaction, used for timeout */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端的输出缓冲区超过软性限制的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> obuf_soft_limit_reached_time;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端状态标志</span></span><br><span class="line">    <span class="keyword">int</span> flags;              <span class="comment">/* REDIS_SLAVE | REDIS_MONITOR | REDIS_MULTI ... */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当 server.requirepass 不为 NULL 时</span></span><br><span class="line">    <span class="comment">// 代表认证的状态</span></span><br><span class="line">    <span class="comment">// 0 代表未认证， 1 代表已认证</span></span><br><span class="line">    <span class="keyword">int</span> authenticated;      <span class="comment">/* when requirepass is non-NULL */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制状态</span></span><br><span class="line">    <span class="keyword">int</span> replstate;          <span class="comment">/* replication state if this is a slave */</span></span><br><span class="line">    <span class="comment">// 用于保存主服务器传来的 RDB 文件的文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> repldbfd;           <span class="comment">/* replication DB file descriptor */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取主服务器传来的 RDB 文件的偏移量</span></span><br><span class="line">    <span class="keyword">off_t</span> repldboff;        <span class="comment">/* replication DB file offset */</span></span><br><span class="line">    <span class="comment">// 主服务器传来的 RDB 文件的大小</span></span><br><span class="line">    <span class="keyword">off_t</span> repldbsize;       <span class="comment">/* replication DB file size */</span></span><br><span class="line">    </span><br><span class="line">    sds replpreamble;       <span class="comment">/* replication DB preamble. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主服务器的复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> reploff;      <span class="comment">/* replication offset if this is our master */</span></span><br><span class="line">    <span class="comment">// 从服务器最后一次发送 REPLCONF ACK 时的偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_ack_off; <span class="comment">/* replication ack offset, if this is a slave */</span></span><br><span class="line">    <span class="comment">// 从服务器最后一次发送 REPLCONF ACK 的时间</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> repl_ack_time;<span class="comment">/* replication ack time, if this is a slave */</span></span><br><span class="line">    <span class="comment">// 主服务器的 master run ID</span></span><br><span class="line">    <span class="comment">// 保存在客户端，用于执行部分重同步</span></span><br><span class="line">    <span class="keyword">char</span> replrunid[REDIS_RUN_ID_SIZE+<span class="number">1</span>]; <span class="comment">/* master run id if this is a master */</span></span><br><span class="line">    <span class="comment">// 从服务器的监听端口号</span></span><br><span class="line">    <span class="keyword">int</span> slave_listening_port; <span class="comment">/* As configured with: SLAVECONF listening-port */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事务状态</span></span><br><span class="line">    multiState mstate;      <span class="comment">/* MULTI/EXEC state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞类型</span></span><br><span class="line">    <span class="keyword">int</span> btype;              <span class="comment">/* Type of blocking op if REDIS_BLOCKED. */</span></span><br><span class="line">    <span class="comment">// 阻塞状态</span></span><br><span class="line">    blockingState bpop;     <span class="comment">/* blocking state */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后被写入的全局复制偏移量</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> woff;         <span class="comment">/* Last write global replication offset. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被监视的键</span></span><br><span class="line">    <span class="built_in">list</span> *watched_keys;     <span class="comment">/* Keys WATCHED for MULTI/EXEC CAS */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个字典记录了客户端所有订阅的频道</span></span><br><span class="line">    <span class="comment">// 键为频道名字，值为 NULL</span></span><br><span class="line">    <span class="comment">// 也即是，一个频道的集合</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* channels a client is interested in (SUBSCRIBE) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表，包含多个 pubsubPattern 结构</span></span><br><span class="line">    <span class="comment">// 记录了所有订阅频道的客户端的信息</span></span><br><span class="line">    <span class="comment">// 新 pubsubPattern 结构总是被添加到表尾</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* patterns a client is interested in (SUBSCRIBE) */</span></span><br><span class="line">    sds peerid;             <span class="comment">/* Cached peer ID. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Response buffer */</span></span><br><span class="line">    <span class="comment">// 回复偏移量</span></span><br><span class="line">    <span class="keyword">int</span> bufpos;</span><br><span class="line">    <span class="comment">// 回复缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buf[REDIS_REPLY_CHUNK_BYTES];</span><br><span class="line"></span><br><span class="line">&#125; redisClient;</span><br></pre></td></tr></table></figure></p>
<h4 id="13-1-1-套接字描述符"><a href="#13-1-1-套接字描述符" class="headerlink" title="13.1.1 套接字描述符"></a>13.1.1 套接字描述符</h4><p>客户端状态的<code>fd</code>属性记录了客户端正在使用的套接字描述符</p>
<p>若<code>fd = -1</code>则说明这个客户端是用来执行Lua脚本或者AOF操作的伪客户端</p>
<p>可以通过<code>CLIENT list</code>命令列出目前所有连接到服务器的普通客户端<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CLIENT list</span><br><span class="line">addr=127.0.0.1:53428 fd=6 name= age=1242 idle=0</span><br><span class="line">addr=127.0.0.1:53428 fd=7 name= age=1242 idle=0</span><br></pre></td></tr></table></figure></p>
<h4 id="13-1-2-名字"><a href="#13-1-2-名字" class="headerlink" title="13.1.2 名字"></a>13.1.2 名字</h4><p>使用<code>CLIENT setname</code>命令可以为客户端设置名字，让客户端身份更加清晰</p>
<h4 id="13-1-3-标志"><a href="#13-1-3-标志" class="headerlink" title="13.1.3 标志"></a>13.1.3 标志</h4><p>客户端的标记属性<code>flags</code>记录了客户端的<strong>角色</strong>和当前所处的<strong>状态</strong></p>
<p><code>flags</code>属性的值可以是多个标志的二进制或，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flags = &lt;flag1&gt; | &lt;flag2&gt; | ...</span><br><span class="line">flags = REDIS_LUA_CLIENT | REDIS_FORCE_AOF | REDIS_FORCE_REPL</span><br></pre></td></tr></table></figure></p>
<p>一部分标志记录了客户端的角色</p>
<ul>
<li><p>在主从服务器进行复制操作时，主服务器会成为从服务器的客户端，而从服务器也会成为主服务器的客户端。<code>REDIS_MASTER</code>标志表示客户端代表的是一个主服务器，<code>REDIS SLAVE</code>标志表示客户端代表的是一个从服务器。</p>
</li>
<li><p><code>REDIS_PRE_PSYNC</code>标志表示客户端代表的是一个版本低于Redis2.8的从服务器</p>
</li>
<li><p><code>REDIS_LUA_CLIENT</code>标识表示客户端是专门用于处理Lua脚本里面包含的Redis命令的伪客户端。</p>
</li>
</ul>
<p>另外一部分标志记录了客户端目前所处的状态</p>
<ul>
<li><code>REDIS_MONITOR</code>标志表示客户端正在执行<code>MONITOR</code>命令。</li>
<li><code>REDIS_UNIX_SOCKET</code>标志表示服务器使用<code>UNIX</code>套接字来连接客户端。</li>
<li><code>REDIS_BLOCKED</code>标志表示客户端正在被<code>BRPOP</code>、<code>BLPOP</code>等命令阻塞。</li>
<li>等等</li>
</ul>
<h4 id="13-1-4-输入缓冲区"><a href="#13-1-4-输入缓冲区" class="headerlink" title="13.1.4 输入缓冲区"></a>13.1.4 输入缓冲区</h4><p>输入缓冲区是<code>querybuf</code>属性，它是一个Redis字符串结构，用于保存客户端发送的命令请求，大小可以根据输入内容动态地扩大和缩小。例子如下图</p>
<p><img src="/2020/03/04/Redis-13-客户端/200304_0.png" alt=""></p>
<h4 id="13-1-5-命令与命令参数"><a href="#13-1-5-命令与命令参数" class="headerlink" title="13.1.5 命令与命令参数"></a>13.1.5 命令与命令参数</h4><p>在服务器将客户端发送的命令请求保存到客户端状态的querybuf属性之后，服务器将对命令请求的内容进行分析，并将得到的命令参数以及命令参数的个数分别存储在客户端状态的<code>argv</code>和<code>argc</code>中。</p>
<p>例如下图，假如客户端发送的命令为<code>SET key &quot;value&quot;</code>，那么将这样保存<br><img src="/2020/03/04/Redis-13-客户端/200304_1.png" alt=""></p>
<h4 id="13-1-6-命令的实现函数"><a href="#13-1-6-命令的实现函数" class="headerlink" title="13.1.6 命令的实现函数"></a>13.1.6 命令的实现函数</h4><p>当服务器从协议内容中分析并得出<code>argv</code>属性和<code>argc</code>属性的值之后，服务器将根据项<code>argv[0]</code>的值，在命令表中查找命令所对应的命令实现函数。</p>
<p>命令表是一个字典，字典的键是一个SDS结构(Redis定义的字符串结构)，保存了命令的名字，而字典的值是命令所对应的redisCommand结构，这个结构保存了命令的实现函数、命令的标志、命令应该给定的参数个数等信息。</p>
<p>当程序成功的找到了<code>argv[0]</code>对应的<code>redisCommand</code>结构时，它会将客户端状态(<code>redisClient</code>)中的<code>cmd</code>指针指向这个命令</p>
<p>例如下图，我们在命令表中查找<code>SET</code>命令，并将<code>cmd</code>指针指向它<br><img src="/2020/03/04/Redis-13-客户端/200304_2.png" alt=""></p>
<h4 id="13-1-7-输出缓冲区"><a href="#13-1-7-输出缓冲区" class="headerlink" title="13.1.7 输出缓冲区"></a>13.1.7 输出缓冲区</h4><p>执行命令得到的命令回复将保存在客户端状态的输出缓冲区中，它有定长和变长两种选择</p>
<h4 id="13-1-8-身份验证"><a href="#13-1-8-身份验证" class="headerlink" title="13.1.8 身份验证"></a>13.1.8 身份验证</h4><p>略</p>
<h4 id="13-1-9-时间"><a href="#13-1-9-时间" class="headerlink" title="13.1.9 时间"></a>13.1.9 时间</h4><p>略</p>
<h3 id="13-2-客户端的创建与关闭"><a href="#13-2-客户端的创建与关闭" class="headerlink" title="13.2 客户端的创建与关闭"></a>13.2 客户端的创建与关闭</h3><p>服务器使用不同的方式来创建和关闭不同类型的客户端</p>
<h4 id="13-2-1-创建普通客户端"><a href="#13-2-1-创建普通客户端" class="headerlink" title="13.2.1 创建普通客户端"></a>13.2.1 创建普通客户端</h4><p>如果客户端是通过网络连接与服务器进行连接的普通客户端，那么在客户端使用<code>connect</code>函数连接到服务器时，服务器就会调用连接事件处理器，为客户端创建相应的客户端状态，并将这个新的客户端状态添加到服务器状态结构<code>client</code>链表的尾部</p>
<p>如下图所示，当客户端c3连接时<br><img src="/2020/03/04/Redis-13-客户端/200304_3.png" alt=""></p>
<h4 id="13-2-2-关闭普通客户端"><a href="#13-2-2-关闭普通客户端" class="headerlink" title="13.2.2 关闭普通客户端"></a>13.2.2 关闭普通客户端</h4><p>一个普通客户端可以因为多种原因而关闭</p>
<ul>
<li>客户端进程退出或者被杀死</li>
<li>客户端向服务器发送了不符合协议格式的数据</li>
<li>如果客户端成为<code>CLIENT KILL</code>命令的目标，它也会被关闭</li>
<li>如果设置了timeout配置项，当客户端的空转时间超过了timeout时就会被关闭</li>
<li>如果客户端发送的命令请求超过了输入缓冲区的限制大小，则它会被关闭</li>
<li>如果客户端发送的命令请求超过了输出缓冲区的限制大小，则它会被关闭</li>
</ul>
<h4 id="13-2-3-Lua脚本的伪客户端"><a href="#13-2-3-Lua脚本的伪客户端" class="headerlink" title="13.2.3 Lua脚本的伪客户端"></a>13.2.3 Lua脚本的伪客户端</h4><p>服务器在初始化时创建负责执行Lua脚本的伪客户端，并将这个伪客户端关联在服务器状态结构(<code>redisServer</code>)的<code>lua_client</code>属性中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span>&#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    redisClient *lua_client</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;redisServer</span><br></pre></td></tr></table></figure></p>
<p><code>lua_client</code>伪客户端在服务器运行的整个生命周期中都会存在</p>
<h4 id="13-2-4-AOF文件的伪客户端"><a href="#13-2-4-AOF文件的伪客户端" class="headerlink" title="13.2.4 AOF文件的伪客户端"></a>13.2.4 AOF文件的伪客户端</h4><p>服务器在<strong>载入</strong>AOF文件时，会创建用于执行存储于AOF中的<strong>写命令</strong>的伪客户端，当载入完成时，这个伪客户端就会关闭。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
