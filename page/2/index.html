<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/Redis-12-事件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/04/Redis-12-事件/" itemprop="url">[Redis][12][事件]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-04T13:49:00+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/04/Redis-12-事件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/04/Redis-12-事件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-12-章-事件"><a href="#第-12-章-事件" class="headerlink" title="第 12 章 事件"></a>第 12 章 事件</h2><p>Redis服务器是一个事件驱动程序，服务器需要处理下面两类事件</p>
<ul>
<li>文件事件：Redis服务器通过socket与客户端连接，而文件事件就是客户端与服务器之间的各种操作，例如：服务器接受并处理客户端请求删除某个键，这就是一个具体的文件事件。</li>
<li>时间事件：Redis服务器的一些操作需要在给定时间点执行，例如前面提到的<code>serverCron</code>函数，就是一种时间事件</li>
</ul>
<p>下面我们将具体介绍这两种事件，并且说明服务器如何调度这些事件</p>
<h3 id="12-1-文件事件"><a href="#12-1-文件事件" class="headerlink" title="12.1 文件事件"></a>12.1 文件事件</h3><p>文件事件交给文件事件处理器来负责。Redis的文件事件处理器基于Reactor模式，并且使用I/O多路服用，这样可以以单线程的方式运行并且监听多个不同的socket</p>
<h4 id="12-1-1-文件事件处理器的构成"><a href="#12-1-1-文件事件处理器的构成" class="headerlink" title="12.1.1 文件事件处理器的构成"></a>12.1.1 文件事件处理器的构成</h4><p>文件事件处理器的架构如下图，它包含了4个模块：socket、I/O多路复用程序、文件事件分派器、事件处理器</p>
<p><img src="/2020/03/04/Redis-12-事件/200303_5.png" alt=""></p>
<ul>
<li>文件事件是对Socket操作的抽象，每当一个Socket准备好执行连接应答、写入、读取、关闭等操作的时候，就会产生一个文件事件。这些文件事件很可能并发出现</li>
<li>I/O多路复用程序负责监听多个Socket端口，并向文件事件分派器传送那些产生了事件的Socket。这时，I/O多路复用会将这些事件都放入一个队列中，这时就把并发变成了有序的、同步的形式。如下图<br><img src="/2020/03/04/Redis-12-事件/200303_6.png" alt=""></li>
<li>文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类型，调用相应的事件处理器。</li>
<li>服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数它们定义了某个事件发生时，服务器应该执行的动作。</li>
</ul>
<h4 id="12-1-2-I-O多路复用程序的实现"><a href="#12-1-2-I-O多路复用程序的实现" class="headerlink" title="12.1.2 I/O多路复用程序的实现"></a>12.1.2 I/O多路复用程序的实现</h4><p>Redis的I/O多路复用程序的所有功能都是通过包装常见的<code>select</code>、<code>epoll</code>、<code>export</code>和<code>kqueue</code>这些I/O多路复用函数库来实现的，因为 Redis为每个IO多路复用函数库都实现了相同的API，所以I/O多路复用程序的底层实现是可以互换的，如下图</p>
<p><img src="/2020/03/04/Redis-12-事件/200303_7.png" alt=""></p>
<h4 id="12-1-3-事件的类型"><a href="#12-1-3-事件的类型" class="headerlink" title="12.1.3 事件的类型"></a>12.1.3 事件的类型</h4><p>文件事件其实只有两种类型，<code>AE_READABLE</code>事件和<code>AE_WRITABLE</code>事件</p>
<ul>
<li>当套接字变得可读时（客户端对套接字执行<code>write</code>操作，或者执行<code>close</code>操作），或者有新的可应答套接字出现时（客户端对服务器的监听套接字执行<code>connect</code>操作），套接字产生<code>AE_READABLE</code>事件。<br>当套接字变得可写时（客户端对套接字执行<code>read</code>操作），套接字产生<code>AE_WRITABLE</code>事件。</li>
</ul>
<p>客户端写，则服务器可读。客户端读，则服务器可写。</p>
<h4 id="12-1-4-文件事件的处理器"><a href="#12-1-4-文件事件的处理器" class="headerlink" title="12.1.4 文件事件的处理器"></a>12.1.4 文件事件的处理器</h4><p>Redis为文件事件编写了多个处理器，这些事件处理器分别用于实现不同的网络通信需求，比如说：</p>
<ul>
<li>为了对连接服务器的各个客户端进行应答，服务器要为监听套接字关联连接应答处理器。</li>
<li>为了接收客户端传来的命令请求，服务器要为客户端套接字关联命令请求处理器。</li>
<li>为了向客户端返回命令的执行结果，服务器要为客户端套接字关联命令回复处理器。</li>
<li>当主服务器和从服务器进行复制操作时，主从服务器都需要关联特别为复制功能编写的复制处理器。</li>
</ul>
<h5 id="1-连接应答处理器"><a href="#1-连接应答处理器" class="headerlink" title="1 连接应答处理器"></a>1 连接应答处理器</h5><p>当 Redis服务器进行初始化的时候，程序会将这个连接应答处理器和服务器监听套接字的<code>AE_READABLE</code>事件关联起来，当有客户端连接服务器监听套接字的时候，套接字就会产生AE_READABLE事件，引发连接应答处理器执行，并执行相应的套接字应答操作，如下图</p>
<p><img src="/2020/03/04/Redis-12-事件/200303_8.png" alt=""></p>
<h5 id="2-命令请求处理器"><a href="#2-命令请求处理器" class="headerlink" title="2 命令请求处理器"></a>2 命令请求处理器</h5><p>当一个客户端通过连接应答处理器成功连接到服务器之后，服务器会将客户端套接字的<code>AE_READABLE</code>事件和命令请求处理器关联起来，当客户端向服务器发送命令请求的时候，套接字就会产生<code>AE_READABLE</code>事件，引发命令请求处理器执行，命令请求处理器负责执行命令。</p>
<p>在客户端连接服务器的整个过程中，服务器将会一直为客户端套接字的<code>AE_READABLE</code>事件关联命令请求处理器</p>
<p><img src="/2020/03/04/Redis-12-事件/200303_9.png" alt=""></p>
<h5 id="3-命令回复处理器"><a href="#3-命令回复处理器" class="headerlink" title="3 命令回复处理器"></a>3 命令回复处理器</h5><p>这个处理器负责将服务器执行命令后得到的命令回复通过套接字返回给客户端</p>
<p>当服务器有命令回复需要传送给客户端的时候，服务器会将客户端套接字的<code>AE_WRITABLE</code>事件与命令回复处理器关联起来。</p>
<p>当命令回复发送完毕之后，服务器会解除命令回复处理器与客户端套接字的<code>AE_WRITABLE</code>的关联</p>
<p><img src="/2020/03/04/Redis-12-事件/200303_10.png" alt=""></p>
<h5 id="4-一次完整的客户端与服务器连接事件示例"><a href="#4-一次完整的客户端与服务器连接事件示例" class="headerlink" title="4 一次完整的客户端与服务器连接事件示例"></a>4 一次完整的客户端与服务器连接事件示例</h5><ol>
<li>假设一个Redis服务器正在运作，那么这个服务器的<strong>监听套接字</strong>的<strong>AE_READABLE事件</strong>应该正处于监听状态之下，而该事件所对应的处理器为<strong>连接应答处理器</strong>。</li>
<li>如果这时有一个Redis客户端向服务器发起<strong>连接</strong>，那么监听套接字将<strong>产生AE_READABLE事件</strong>，<strong>触发连接应答处理器执行</strong>。处理器会对客户端的连接请求进行应答，然后<strong>创建客户端套接字</strong>，以及客户端状态，并将<strong>客户端套接字</strong>的AE_READABLE事件与<strong>命令请求处理器</strong>进行关联，使得客户端可以向主服务器发送命令请求。</li>
<li>之后，假设客户端向主服务器发送一个命令请求，那么客户端套接字将<strong>产生AE_READABLE事件</strong>，引发<strong>命令请求处理器</strong>执行，处理器读取客户端的命令内容，然后通知相关程序去执行。</li>
<li>执行结束后，当客户端尝试读取命令回复时，就会产生<code>AE_WRITABLE</code>事件，服务器将回复发回给客户端</li>
</ol>
<h3 id="12-2-时间事件"><a href="#12-2-时间事件" class="headerlink" title="12.2 时间事件"></a>12.2 时间事件</h3><p>服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p>
<p>例如下图<br><img src="/2020/03/04/Redis-12-事件/200303_11.png" alt=""></p>
<p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由<code>redis.c/serverCron</code>函数负责执行，它的主要工作包括：</p>
<ul>
<li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li>
<li>清理数据库中的过期键值对。</li>
<li>关闭和清理连接失效的客户端。</li>
<li>尝试进行AOF或RDB持久化操作。</li>
<li>如果服务器是主服务器，那么对从服务器进行定期同步口如果处于集群模式，对集群进行定期同步和连接测试</li>
</ul>
<h3 id="12-3-事件的调度与执行"><a href="#12-3-事件的调度与执行" class="headerlink" title="12.3 事件的调度与执行"></a>12.3 事件的调度与执行</h3><p>因为服务器中同时存在文件事件和时间事件两种事件类型，所以服务器必须对这两种事件进行调度，决定何时应该处理文件事件，何时又应该处理时间事件，以及花多少时间来处理它们等等。</p>
<p>事件的调度和执行由<code>ae.c/aeProcessEvents</code>函数负责，伪代码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aeProcessEvents</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获得到达时间离当前时间最接近的时间事件</span></span><br><span class="line">    time_event = aeSearchNearestTimer()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算最接近的时间事件距离到达还有多少毫秒</span></span><br><span class="line">    remaind_ms = time_event.when - unix_ts_now()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 若事件已到达，remaind_ms将会是一个负数，这里将负数重设为0</span></span><br><span class="line">    <span class="keyword">if</span> remaind_ms &lt; <span class="number">0</span>:</span><br><span class="line">        remaind_ms = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 使用remaind_ms创建一个timeval结构体，以传给aeApiPoll函数</span></span><br><span class="line">    timeval = create_timeval_with_ms(remaind_ms)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 阻塞并等待文件事件的产生</span></span><br><span class="line">    <span class="comment"># 这个函数会产生阻塞并监听所有连接，当任何一个连接产生了文件事件，这个方法会返回；此外，若到达了timeval规定的时间，方法也会返回</span></span><br><span class="line">    aeApiPoll(timeval)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行文件事件</span></span><br><span class="line">    processFileEvents()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行时间事件</span></span><br><span class="line">    processTimeEvents()</span><br></pre></td></tr></table></figure></p>
<p>将aeProcessEvents函数置于一个循环中，再加上初始化和清理函数，就构成了Redis服务器的主函数，伪码如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    init_server()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 循环执行aeProcessEvents()以处理各种事件</span></span><br><span class="line">    <span class="keyword">while</span> server_is_not_shutdown():</span><br><span class="line">        aeProcessEvents()</span><br><span class="line"></span><br><span class="line">    close_server()</span><br></pre></td></tr></table></figure></p>
<p>整个过程的流程图如下<br><img src="/2020/03/04/Redis-12-事件/200303_12.png" alt=""></p>
<p>事件的调度和规则如下</p>
<ol>
<li><code>aeApiPoll</code>函数的最大阻塞时间由到达时间最接近当前时间的时间事件决定，这既避免了服务器对时间事件进行频繁的轮询（忙等待），也确保了<code>aeApiPoll</code>函数不会阻塞太长时间</li>
<li>对文件事件和时间事件的处理是同步、有序、原子地执行</li>
<li>因为时间事件在文件事件之后执行，并且事件之间不会出现抢占，所以时间事件的实际处理时间通常比预设的时间要晚一点</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/04/Redis-11-AOF持久化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/04/Redis-11-AOF持久化/" itemprop="url">[Redis][11][AOF持久化]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-04T13:46:38+08:00">
                2020-03-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/04/Redis-11-AOF持久化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/04/Redis-11-AOF持久化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-11-章-AOF持久化"><a href="#第-11-章-AOF持久化" class="headerlink" title="第 11 章 AOF持久化"></a>第 11 章 AOF持久化</h2><p>AOF持久化是通过<strong>保存</strong>Redis服务器所执行的<strong>写命令</strong>来记录数据库状态的。服务器在<strong>启动</strong>时，可以通过<strong>载入和执行</strong>AOF文件中保存的<strong>命</strong>令来<strong>还原</strong>服务器关闭之前的数据库状态。</p>
<h3 id="11-1-AOF持久化的实现"><a href="#11-1-AOF持久化的实现" class="headerlink" title="11.1 AOF持久化的实现"></a>11.1 AOF持久化的实现</h3><p>AOF持久化功能的实现可以分为<strong>命令追加</strong>、<strong>文件写入</strong>、<strong>文件同步</strong>三个步骤。</p>
<h4 id="11-1-1-命令追加"><a href="#11-1-1-命令追加" class="headerlink" title="11.1.1 命令追加"></a>11.1.1 命令追加</h4><p>当AOF持久化功能处于打开状态时，服务器在执行完一个<strong>写命令</strong>之后，会以协议格式将被执行的写命令<strong>追加</strong>到服务器状态的<code>aof_buf</code><strong>缓冲区的末尾</strong></p>
<h4 id="11-1-2-AOF文件的写入与同步"><a href="#11-1-2-AOF文件的写入与同步" class="headerlink" title="11.1.2 AOF文件的写入与同步"></a>11.1.2 AOF文件的写入与同步</h4><p>Redis的服务器进程就是一个<strong>事件循环</strong>，这个循环中的<strong>文件事件</strong>负责接收客户端的命令请求，以及向客户端发送命令回复，而<strong>时间事件</strong>则负责执行像<code>serveCron</code>函数这样需要定时运行的函数。下一章将解释这些内容</p>
<p>因为服务器在处理文件事件时可能会执行写命令，使得一些内容被追加到<code>aof_buf</code>缓冲区里面，所以在服务器<strong>每次结束一个事件循环</strong>之前，它都会调用<code>flushAppendonlyFile</code>函数，考虑<strong>是否</strong>需要将<code>aof_buf</code>缓冲区中的内容<strong>写入和保存到AOF文件</strong>里面</p>
<p>伪代码大概如下<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eventLoop</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理文件请求，处理请求时可能会把新内容追加到aof_buf缓冲区</span></span><br><span class="line">        processFileEvents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 处理时间请求</span></span><br><span class="line">        processTimeEvents()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 考虑是否将aof_buf中的内容写入和保存到AOF文件中</span></span><br><span class="line">        flushAppendOnlyFile()</span><br></pre></td></tr></table></figure></p>
<p><code>flushAppendOnlyFile()</code>函数的策略由服务器配置的<code>appendfsync</code>选项的值来决定</p>
<table>
<thead>
<tr>
<th>配置</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>always</td>
<td>将aof_buf缓冲区中的所有内容<strong>写入</strong>并<strong>同</strong>步到AOF文件</td>
</tr>
<tr>
<td>everysec</td>
<td>将aof_buf缓冲区中的所有内容<strong>写入</strong>到AOF文件，如果上次同步AOF文件的时间距离现在<strong>超过了1秒</strong>，那么再次对AOF文件进行<strong>同步</strong></td>
</tr>
<tr>
<td>no</td>
<td>将aof_buf缓冲区中的所有内容<strong>写入</strong>到AOF文件，但并不对AOF文件进行同步，<strong>同步由系统决定</strong></td>
</tr>
</tbody>
</table>
<p>下面解释什么是文件的<strong>写入</strong>和<strong>同步</strong></p>
<ul>
<li>为了提高文件的写入效率，在现代操作系统中，当用户调用<code>write</code>函数，将一些数据写入到文件的时候，操作系统通常会将写入数据<strong>暂时保存</strong>在一个内存缓冲区里面，</li>
<li>等到缓冲区的空间被填满、或者超过了指定的时限之后，才真正地将缓冲区中的数据<strong>写入到磁盘</strong>里面。</li>
<li>用户将数据写入到内存缓冲区的过程叫做<strong>写入</strong></li>
<li>系统将内存缓冲区的内容写入到磁盘对应的文件的过程叫做<strong>同步</strong></li>
</ul>
<h3 id="11-2-AOF文件的载入与数据还原"><a href="#11-2-AOF文件的载入与数据还原" class="headerlink" title="11.2 AOF文件的载入与数据还原"></a>11.2 AOF文件的载入与数据还原</h3><p>服务器只要<strong>读入并重新执行</strong>一遍AOF文件里面保存的<strong>写命令</strong>，就可以<strong>还原</strong>服务器关闭之前的数据库状态。</p>
<p>Redis读取AOF文件并还原数据库状态的步骤如下</p>
<ol>
<li><strong>创建</strong>一个不带网络连接的<strong>伪客户端</strong>，因为Redis的命令只能在客户端上下文中执行</li>
<li>从AOF文件中<strong>分析并读取</strong>出一条写命令。</li>
<li>使用<strong>伪客户端执行</strong>被读出的写命令。</li>
<li>一直执行步骤2和步骤3，直到AOF文件中的所有写命令都被处理完毕为止。</li>
</ol>
<p>流程图如下</p>
<p><img src="/2020/03/04/Redis-11-AOF持久化/200303_1.png" alt=""></p>
<h3 id="11-3-AOF重写"><a href="#11-3-AOF重写" class="headerlink" title="11.3 AOF重写"></a>11.3 AOF重写</h3><p>因为AOF持久化是通过保存被执行的写命令来记录数据库状态的，所以随着服务器<strong>运行时间</strong>的流逝，AOF文件中的<strong>内容</strong>会越来越<strong>多</strong>。</p>
<p>为了<strong>解决AOF文件体积膨胀</strong>的问题， Redis提供了<strong>AOF文件重写</strong>功能。通过该功能，Redis服务器可以创建一个新的AOF文件来替代现有的AOF文件，新旧两个AOF文件所保存的<strong>数据库状态相同</strong>，但新文件中不包括冗余指令</p>
<h4 id="11-3-1-AOF文件重写的实现"><a href="#11-3-1-AOF文件重写的实现" class="headerlink" title="11.3.1 AOF文件重写的实现"></a>11.3.1 AOF文件重写的实现</h4><p>其实AOF文件的重写策略十分简单，它并<strong>不查看旧文件</strong>的任何内容。它直接<strong>根据当前的数据库状态</strong>生成一份新的AOF文件。</p>
<p>例如，假设我们对一个<code>list</code>进行了如下操作<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list <span class="string">"A"</span> <span class="string">"B"</span> <span class="string">"C"</span></span><br><span class="line">RPUSH list <span class="string">"C"</span></span><br><span class="line">RPUSH list <span class="string">"D"</span> <span class="string">"E"</span></span><br><span class="line">LPOP list</span><br><span class="line">LPOP list</span><br><span class="line">RPUSH list <span class="string">"F"</span> <span class="string">"G"</span></span><br></pre></td></tr></table></figure></p>
<p>那么其实，在此时的数据库状态中，<code>list</code>键的值只有<code>{&quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;}</code>而已</p>
<p>在执行AOF重写时，Redis直接查看<code>list</code>键的当前值，然后将当前的这五个值用同一条<code>RPUSH</code>命令存储，仅此而已<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RPUSH list <span class="string">"C"</span> <span class="string">"D"</span> <span class="string">"E"</span> <span class="string">"F"</span> <span class="string">"G"</span></span><br></pre></td></tr></table></figure></p>
<p>假设我们要对下面这个数据库状态进行AOF重写<br><img src="/2020/03/04/Redis-11-AOF持久化/200303_2.png" alt=""></p>
<p>重写后的AOF文件包含如下命令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SELECT 0</span><br><span class="line"></span><br><span class="line">RPUSH alphabet <span class="string">"a"</span> <span class="string">"b"</span> <span class="string">"c"</span></span><br><span class="line"></span><br><span class="line">EXPIREAT alphabet 1385877600000</span><br><span class="line"></span><br><span class="line">HSET book <span class="string">"name"</span> <span class="string">"Redisin Action"</span> <span class="string">"author"</span> <span class="string">"Josiah L.Carlson"</span></span><br><span class="line"></span><br><span class="line">EXPIREAT book 1385877600000</span><br><span class="line"></span><br><span class="line">SET message <span class="string">"hello, world"</span></span><br></pre></td></tr></table></figure></p>
<h4 id="11-3-2-AOF后台重写"><a href="#11-3-2-AOF后台重写" class="headerlink" title="11.3.2 AOF后台重写"></a>11.3.2 AOF后台重写</h4><p>Redis<strong>不希望</strong>AOF<strong>重写</strong>造成服务器<strong>无法处理请求</strong>，所以Redis决定将AOF重写程序放到<strong>子进</strong>程里执行，这样子进程进行AOF重写期间，服务器进程（父进程）可以继续处理命令请求。</p>
<p>不过，子进程在进行AOF重写期间，服务器进程还需要继续处理命令请求，而<strong>新的命令</strong>可能会对<strong>现有的数据库状态</strong>进行<strong>修改</strong>，从而使得服务器当前的数据库状态和重写后的AOF文件所保存的数据库状态不一致。例子如下表所示</p>
<p><img src="/2020/03/04/Redis-11-AOF持久化/200303_3.png" alt=""></p>
<p>为了解决这种数据不一致问题，Redis服务器设置了一个<strong>AOF重写缓冲区</strong>，这个缓冲区在服务器创建子进程之后开始使用，当Redis服务器执行完一个写命令之后，它会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区，如下图</p>
<p><img src="/2020/03/04/Redis-11-AOF持久化/200303_4.png" alt=""></p>
<p>这样，当子进程完成AOF重写工作后，它会给父进程<strong>发送一个信号</strong>，父进程接到这个信号后，会<strong>阻塞所有请求</strong>，并执行如下操作</p>
<ol>
<li>将<strong>AOF重写缓冲区</strong>中的内容<strong>写入到AOF文件</strong>中，这时新AOF文件所保存的数据库状态将与服务器状态完全相同</li>
<li>对新的AOF文件进行<strong>改名</strong>，原子的<strong>覆盖</strong>现有的AOF文件，完成两个文件的替换</li>
</ol>
<h3 id="11-4-重点回顾"><a href="#11-4-重点回顾" class="headerlink" title="11.4 重点回顾"></a>11.4 重点回顾</h3><p>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/03/Redis-10-RDB持久化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/Redis-10-RDB持久化/" itemprop="url">[Redis][10][RDB持久化]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-03T15:35:14+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/03/Redis-10-RDB持久化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/03/Redis-10-RDB持久化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-10-章-RDB持久化"><a href="#第-10-章-RDB持久化" class="headerlink" title="第 10 章 RDB持久化"></a>第 10 章 RDB持久化</h2><p>Redis是一个键值对数据库服务器，服务器中通常包含着任意个非空数据库，而每个非空数据库中又可以包含任意个键值对，为了方便起见，我们将服务器中的<strong>非空数据库</strong>以及它的<strong>键值对</strong>统称为<strong>数据库状态</strong>。</p>
<p>一个数据库状态如下图所示</p>
<p><img src="/2020/03/03/Redis-10-RDB持久化/200302_0.png" alt=""></p>
<p>Redis是<strong>内存数据库</strong>，它将自己的数据库状态储存在内存里面，一旦服务器进程退出，服务器中的数据库状态也会消失不见。为了解决这个问题， Redis提供了<strong>RDB持久化</strong>功能，这个功能可以将Redis在内存中的数据库状态<strong>保存到磁盘</strong>里面，避免数据意外丢失</p>
<h3 id="10-1-RDB文件的创建与载入"><a href="#10-1-RDB文件的创建与载入" class="headerlink" title="10.1 RDB文件的创建与载入"></a>10.1 RDB文件的创建与载入</h3><p>RDB文件的<strong>创建</strong>命令有两个</p>
<ul>
<li><strong>SAVE</strong>命令会<strong>阻塞</strong>Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器<strong>不能处理任何命令请求</strong></li>
<li><strong>BGSAVE</strong>命令会派生出一个<strong>子进程</strong>，然后由子进程负责创建RDB文件，<strong>服务器进程（父进程）继续</strong>处理命令请求</li>
</ul>
<p>Redis并没有专门用于<strong>载入</strong>RDB文件的命令，只要Redis服务器在<strong>启动时</strong>检测到RDB文件存在，它就会<strong>自动载入</strong>RDB文件。</p>
<p>值得一提的是，因为AOF文件的更新频率更快，所以通常优先使用AOF文件来还原数据库状态，当没有开启AOF功能时，才使用RDB文件，判断流程如下<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_1.png" alt=""></p>
<p>此外</p>
<ul>
<li>当运行<strong>SAVE</strong>时，会<strong>阻塞所有命令</strong></li>
<li>当运行<strong>BGSAVE</strong>时，<strong>SAVE</strong>和<strong>BGSAVE</strong>命令会<strong>被服务器拒绝</strong>；<strong>BGREWRITEAOF</strong>命令会被服务器<strong>阻塞</strong>，直到BGSAVE完成；<strong>其他命令</strong>则由父进程<strong>正常</strong>处理</li>
<li>当<strong>载入RDB文件</strong>时，会<strong>阻塞所有命令</strong></li>
</ul>
<h3 id="10-2-自动间隔性保存"><a href="#10-2-自动间隔性保存" class="headerlink" title="10.2 自动间隔性保存"></a>10.2 自动间隔性保存</h3><p>Redis允许用户通过<strong>设置</strong>服务器配置的<strong>save选项</strong>，让服务器每隔一段时间<strong>自动执行</strong>一次<strong>BGSAVE</strong>命令。<br>用户可以通过save选项设置<strong>多个保存条件</strong>，但只要其中<strong>任意一个</strong>条件被满足，服务器就会执行BGSAVE命令。</p>
<p>例如条件如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br></pre></td></tr></table></figure></p>
<p>这两个条件的解释是</p>
<ul>
<li>若服务器在<strong>900秒</strong>内，对数据库进行了<strong>1次修改</strong>，则执行BGSAVE</li>
<li>若服务器在<strong>300秒</strong>内，对数据库进行了<strong>10次修改</strong>，则执行BGSAVE</li>
</ul>
<h4 id="10-2-1-设置保存条件"><a href="#10-2-1-设置保存条件" class="headerlink" title="10.2.1 设置保存条件"></a>10.2.1 设置保存条件</h4><p>运行时，通过配置文件或者传入参数设置的保存条件会被加载到<code>redisServer</code>结构的<code>saveParams</code>属性中，结构如下图<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_2.png" alt=""></p>
<p>此外，服务器状态还维持着一个<code>dirty</code>计数器，以及一个<code>lastsave</code>属性</p>
<ul>
<li><strong>dirty计数器</strong>记录距离<strong>上一次</strong>成功保存之后，服务器对数据库状态进行了<strong>多少次修改</strong>。</li>
<li><strong>lastsave属性</strong>是一个UNIX时间戳，记录了服务器<strong>上一次</strong>成功保存的<strong>时间</strong>。</li>
</ul>
<h4 id="10-2-2-检查保存条件是否满足"><a href="#10-2-2-检查保存条件是否满足" class="headerlink" title="10.2.2 检查保存条件是否满足"></a>10.2.2 检查保存条件是否满足</h4><p>Redis的服务器<strong>周期性操作函数</strong><code>serverCron</code>默认每隔100毫秒就会执行一次，该函数用于对正在运行的服务器进行维护，它的其中一项工作就是<strong>检查</strong><code>save</code>选项所设置的<strong>保存条件</strong>是否已经满足，如果满足的话，就<strong>执行BGSAVE</strong>命令</p>
<p>下面的伪代码展示了<code>serverCron</code>函数检查保存条件的过程<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">serverCron</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历所有保存条件</span></span><br><span class="line">    <span class="keyword">for</span> saveparam <span class="keyword">in</span> server.saveparams:</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算距离上次执行保存操作有多少秒</span></span><br><span class="line">        save_interval = unixtime_now() - server.lastsave</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果数据库状态的修改次数超过条件所设置的次数</span></span><br><span class="line">        <span class="comment"># 并且距离上次保存的时间超过了条件所设置的时间</span></span><br><span class="line">        <span class="comment"># 就执行保存操作</span></span><br><span class="line">        <span class="keyword">if</span> server.dirty &gt;= saveparam.changes <span class="keyword">and</span> save_interval &gt; saveparam.seconds:</span><br><span class="line">            BGSAVE()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></p>
<h3 id="10-3-RDB文件结构"><a href="#10-3-RDB文件结构" class="headerlink" title="10.3 RDB文件结构"></a>10.3 RDB文件结构</h3><p>一个完整的RDB文件包含下图所示的部分<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_3.png" alt=""></p>
<ul>
<li>最开头是五个字符”REDIS”，占5字节，用来标记这个文件是RDB文件</li>
<li><code>db_version</code>长度为4字节，记录这个文件的版本号</li>
<li><code>databases</code>部分包含了某个时间的数据库状态，也就是说它是数据部分</li>
<li><code>EOF</code>是终止符，表示<code>databases</code>部分的结束，占1字节</li>
<li><code>check_sum</code>是一个校验和，占8字节</li>
</ul>
<h4 id="10-3-1-databases部分"><a href="#10-3-1-databases部分" class="headerlink" title="10.3.1 databases部分"></a>10.3.1 databases部分</h4><p>一个RDB文件的<code>databases</code>部分包含多个非空数据库，按顺序存储</p>
<p>每个非空数据库被保存为三部分</p>
<ul>
<li><code>SELECTDB</code>占1字节，当程序读到这个字节，它就直到下面要读的是一个数据库号码</li>
<li><code>db_numbers</code>保存着一个数据库号码，载入程序读取后，会调用<code>SELECT</code>命令切换到指定数据库，然后再加载键值对</li>
<li><code>key_value_pairs</code>实际保存了数据库中的所有键值对数据，如果键值对有过期时间，也会保存在一起</li>
</ul>
<p>一个完整的RDB结构如下所示，假设0号和3号数据库是非空数据库<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_4.png" alt=""></p>
<h4 id="10-3-2-key-value-pairs部分"><a href="#10-3-2-key-value-pairs部分" class="headerlink" title="10.3.2 key_value_pairs部分"></a>10.3.2 key_value_pairs部分</h4><p>每个key_value_pair结构如下<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_6.png" alt=""></p>
<ul>
<li><code>EXPIRETIME_MS</code>表示接下来要读的是一个时间戳</li>
<li><code>ms</code>保存了过期时间，占8字节</li>
<li><code>TYPE</code>保存了键值对的类型，对于不同的类型，RDB采用了不同的存储方式</li>
<li><code>key</code>实际保存键对象</li>
<li><code>value</code>实际保存了值对象</li>
</ul>
<p>例如下图<br><img src="/2020/03/03/Redis-10-RDB持久化/200302_5.png" alt=""></p>
<h4 id="10-3-3-value的编码"><a href="#10-3-3-value的编码" class="headerlink" title="10.3.3 value的编码"></a>10.3.3 value的编码</h4><p>不同类型的值对象在RDB文件中的保存结构不同，这里不展开介绍，但是对于<code>intset</code>和实际编码为<code>ziplist</code>的对象，都会被转化为字符串对象再存储。</p>
<h4 id="10-3-4-分析RDB文件"><a href="#10-3-4-分析RDB文件" class="headerlink" title="10.3.4 分析RDB文件"></a>10.3.4 分析RDB文件</h4><p>可以使用Redis自带的RDB文件检查工具redis-check-dump来检查RDB文件</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/02/MySQL-6-查询性能优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/02/MySQL-6-查询性能优化/" itemprop="url">[MySQL][6][查询性能优化]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-02T17:06:57+08:00">
                2020-03-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/02/MySQL-6-查询性能优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/02/MySQL-6-查询性能优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-6-章-查询性能优化"><a href="#第-6-章-查询性能优化" class="headerlink" title="第 6 章 查询性能优化"></a>第 6 章 查询性能优化</h2><p><strong>查询优化</strong>、<strong>索引优化</strong>、<strong>库表结构优化</strong>需要齐头并进，一个不落。如果查询写得很糟糕，即使库表结构再合理、索引再合适，也无法实现高性能。</p>
<h3 id="6-1-为什么查询速度会慢"><a href="#6-1-为什么查询速度会慢" class="headerlink" title="6.1 为什么查询速度会慢"></a>6.1 为什么查询速度会慢</h3><p>真正重要是<strong>响应时间</strong>。如果把查询看作是一个任务，那么它由一系列<strong>子任务</strong>组成，每个子任务都会消耗一定的时间。如果要优化查询，实际上要优化其子任务，要么<strong>消除</strong>其中一些子任务，要么<strong>减少</strong>子任务的执行<strong>次数</strong>，要么让子任务<strong>运行</strong>得更<strong>快</strong>。</p>
<p>査询的<strong>生命周期</strong>大致可以按照顺序来看</p>
<ul>
<li>从客户端，到服务器</li>
<li>然后在服务器上进行<strong>解析</strong></li>
<li>生成<strong>执行计划</strong></li>
<li><strong>执行</strong></li>
<li>并<strong>返回结果</strong>给客户端。</li>
</ul>
<p>其中<strong>执行</strong>可以认为是整个生命周期中最<strong>重要</strong>的阶段，这其中包括了大量为了检索数据到<strong>存储引擎的调用</strong>以及<strong>调用后的数据处理</strong>，包括排序、分组等。</p>
<p>在完成这些任务的时候，查询需要在不同的地方<strong>花费时间</strong>，包括<strong>网络</strong>，<strong>CPU计算</strong>，生成<strong>统计信息</strong>和<strong>执行计划</strong>、<strong>锁等待</strong>（互斥等待）等操作。</p>
<p>在每一个消耗大量时间的查询案例中，我们都能看到一些<strong>不必要的额外操作</strong>、某些操作被额外地重复了很多次、某些操作执行得太慢等。优化查询的目的就是<strong>减少和消除</strong>这些操作所花费的时间。</p>
<h3 id="6-2-慢查询基础：优化数据访问"><a href="#6-2-慢查询基础：优化数据访问" class="headerlink" title="6.2 慢查询基础：优化数据访问"></a>6.2 慢查询基础：优化数据访问</h3><p>大部分性能低下的查询都可以通过<strong>减少访问的数据量</strong>的方式进行<strong>优化</strong>。对于低效的查询，我们发现通过下面两个步骤来分析总是很有效：</p>
<ol>
<li>确认应用程序是否在检索大量<strong>超过需要的数据</strong>。这通常意味着访问了<strong>太多的行</strong>，但有时候也可能是访问了<strong>太多的列</strong>。</li>
<li>确认MySQL<strong>服务器层</strong>是否在<strong>分析大量</strong>超过需要的数据<strong>行</strong></li>
</ol>
<h4 id="6-2-1-是否向数据库请求了不需要的数据"><a href="#6-2-1-是否向数据库请求了不需要的数据" class="headerlink" title="6.2.1 是否向数据库请求了不需要的数据"></a>6.2.1 是否向数据库请求了不需要的数据</h4><p>有些查询会请求超过实际需要的数据，然后这些<strong>多余</strong>的数据会被应用程序<strong>丢弃</strong>。</p>
<p><strong>这里有几种典型情况</strong></p>
<ol>
<li>查询<strong>不需要</strong>的记录：例如在新闻网站中取出100条记录但是只是在页面上显示前面10条，这时要使用<code>limit</code></li>
<li>多表关联时返回<strong>全部列</strong>：我们应该只取出需要的列</li>
<li>总是取出<strong>全部列</strong><ul>
<li>每次看到<code>SELECT*</code>的时候都需要用怀疑的眼光审视，是不是真的需要返回<strong>全部的列</strong>？取出全部列，会让优化器<strong>无法</strong>完成<strong>索引覆盖</strong>扫描这类优化，</li>
<li>查询返回超过需要的数据也<strong>不总是坏事</strong>，这种有点浪费数据库资源的方式可以<strong>简化开发</strong>，因为能提高相同代码片段的<strong>复用性</strong>。</li>
</ul>
</li>
<li><strong>重复查询</strong>相同的数据<ul>
<li>例如，在用户评论的地方需要查询用户头像的URL，那么用户多次评论的时候，可能就会反复查询这个数据。比较好的方案是，当<strong>初次查询</strong>的时候将这个数据<strong>缓存</strong>起来，需要的时候从缓存中取出，这样<strong>性能</strong>显然会更好。</li>
</ul>
</li>
</ol>
<h4 id="6-2-2-MySQL是否在扫描额外的记录"><a href="#6-2-2-MySQL是否在扫描额外的记录" class="headerlink" title="6.2.2 MySQL是否在扫描额外的记录"></a>6.2.2 MySQL是否在扫描额外的记录</h4><p>对于MySQL，最简单的<strong>衡量查询开销</strong>的三个指标如下</p>
<ul>
<li><strong>响应时间</strong></li>
<li><strong>扫描的行数</strong></li>
<li><strong>返回的行数</strong></li>
</ul>
<p>这三个指标都会记录到MySQL的<strong>慢日志</strong>中，所以检查慢日志记录是<strong>找出扫描行数过多的查询</strong>的好办法。</p>
<h5 id="6-2-2-1-响应时间"><a href="#6-2-2-1-响应时间" class="headerlink" title="6.2.2.1 响应时间"></a>6.2.2.1 响应时间</h5><p>响应时间是两个部分之和：<strong>服务时间</strong>和<strong>排队时间</strong>。<strong>服务时间</strong>是指数据库处理这个查询<strong>真正</strong>花了多长时间。<strong>排队时间</strong>是指服务器因为<strong>等待某些资源</strong>而没有真正执行查询的时间——可能是等I/O操作完成，也可能是等待行锁，等等。</p>
<h5 id="6-2-2-2-扫描的行数和返回的行数"><a href="#6-2-2-2-扫描的行数和返回的行数" class="headerlink" title="6.2.2.2 扫描的行数和返回的行数"></a>6.2.2.2 扫描的行数和返回的行数</h5><p><strong>理想情况</strong>下扫描的行数和返回的行数应该是<strong>相同</strong>的。扫描的行数对返回的行数的<strong>比率</strong>通常很<strong>小</strong>，一般在1:1和10:1之间，不过有时候这个值也可能非常非常大</p>
<h5 id="6-2-2-3-扫描的行数和访问类型"><a href="#6-2-2-3-扫描的行数和访问类型" class="headerlink" title="6.2.2.3 扫描的行数和访问类型"></a>6.2.2.3 扫描的行数和访问类型</h5><p>在<code>EXPLAIN</code>语句中的<code>type</code>列反应了<strong>访问类型</strong>。访问类型有很多种，从<strong>全表扫描</strong>到<strong>索引扫描</strong>、<strong>范围扫描</strong>、<strong>唯一索引査询</strong>、<strong>常数引用</strong>等。这里列的这些，速度是从慢到快，扫描的行数也是从小到大。</p>
<p>如果査询<strong>没有办法找到合适的访问类型</strong>，那么解决的最好办法通常就是<strong>增加一个合适的索引</strong></p>
<p>如果发现查询需要扫描大量的数据但只返回少数的行，那么通常可以尝试下面的<strong>技巧</strong>去<strong>优化</strong>它</p>
<ul>
<li><p>使用<strong>索引覆盖扫描</strong>，把所有需要用的列都放到索引中，这样存储引擎<strong>无须回表</strong>获取对应行就可以返回结果了</p>
</li>
<li><p>改变库表结构。例如使用<strong>单独的汇总表</strong></p>
</li>
<li><strong>重写</strong>这个复杂的查询，让<strong>MySQL优化器</strong>能够以更优化的方式执行这个查询</li>
</ul>
<h3 id="6-3-重构查询的方式"><a href="#6-3-重构查询的方式" class="headerlink" title="6.3 重构查询的方式"></a>6.3 重构查询的方式</h3><p>在优化有问题的查询时，目标应该是找到一个更优的方法获得<strong>实际需要的结果</strong>，而<strong>不</strong>定总是需要从MySQL获取<strong>一模一样的结果集</strong>。</p>
<h4 id="6-3-1-一个复杂查询还是多个简单查询"><a href="#6-3-1-一个复杂查询还是多个简单查询" class="headerlink" title="6.3.1 一个复杂查询还是多个简单查询"></a>6.3.1 一个复杂查询还是多个简单查询</h4><p>设计查询的时候一个需要考虑的重要问题是，是否需要<strong>将一个复杂的查询分成多个简单的查询</strong>。在<strong>传统实现</strong>中，总是强调需要<strong>数据库层</strong>完成尽可能<strong>多的工作</strong>，这样做的逻辑在于<strong>以前</strong>总是认为<strong>网络通信</strong>、<strong>査询解析</strong>和优化是一件<strong>代价很高</strong>的事情。</p>
<p>但是这样的想法对于MySQL并<strong>不适用</strong>，MySQL从设计上让<strong>连接和断开连接</strong>都很<strong>轻量级</strong>，在返回一个小的查询结果方面很高效。<strong>现代的网络速度</strong>比以前要<strong>快</strong>很多，无论是带宽还是延迟。</p>
<h4 id="6-3-2-切分耗时的大查询"><a href="#6-3-2-切分耗时的大查询" class="headerlink" title="6.3.2 切分耗时的大查询"></a>6.3.2 切分耗时的大查询</h4><p>有时候对于一个<strong>大查询</strong>我们需要<strong>分而治之</strong>，将大查询<strong>切分</strong>成小查询，每个查询<strong>功能完全一样</strong>，只扫描一<strong>小部分行</strong>，每次只返回一小部分查询结果。</p>
<p><strong>删除旧的数据</strong>就是一个很好的例子。定期地清除大量数据时，如果用一个大的语句<strong>一次性完成</strong>的话，则可能需要一次<strong>锁住很多数据</strong>、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。将一个大的 <code>DELETE</code>语句<strong>切分</strong>成多个<strong>较小的查询</strong>可以尽可能小地影响MySQL<strong>性能</strong>，同时还可以减少MySQL<strong>复制的延迟</strong>。</p>
<p>例如下面的方法采用一次删除10000行来切分删除操作<br><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = <span class="number">0</span></span><br><span class="line">do &#123;</span><br><span class="line">    rows_affected = do_query(<span class="string">"DELETE FROM messages WHERE created &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000"</span>)</span><br><span class="line">&#125;(<span class="keyword">while</span> rows_affected &gt; <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="6-3-3-分解关联查询（这个思想挺厉害的）"><a href="#6-3-3-分解关联查询（这个思想挺厉害的）" class="headerlink" title="6.3.3 分解关联查询（这个思想挺厉害的）"></a>6.3.3 分解关联查询（这个思想挺厉害的）</h4><p>很多高性能的应用都会对<strong>关联查询</strong>进行<strong>分解</strong>。可以对每一个表进行一次<strong>单表查询</strong>，然后将结果在<strong>应用程序中</strong>进行<strong>关联</strong>。</p>
<p>举例说明，例如下面的查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id=tag_id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id=post.id</span><br><span class="line"><span class="keyword">WHERE</span> tag.tag=<span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure></p>
<p>那个这个复杂的<strong>关联查询</strong>可以被<strong>分解</strong>为3个<strong>单表查询</strong>，可以达到与上面的查询<strong>相同的效果</strong><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">"mysql"</span></span><br><span class="line">//此时查询出tag=<span class="string">"mysql"</span>的项，假设只有一个且tag_id=<span class="number">1234</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line">//tag_post是tag表和post表的关联表，从其中查找到tag_id=1234的所有项，假设这些项的post_id为(123, 456, 567, 1024, 2048)</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post_id <span class="keyword">in</span> (<span class="number">123</span>, <span class="number">456</span>, <span class="number">567</span>, <span class="number">1024</span>, <span class="number">2048</span>)</span><br></pre></td></tr></table></figure></p>
<p>用分解关联查询的方式重构查询有如下的优势：</p>
<ul>
<li>让<strong>缓存的效</strong>率更高。许多应用程序可以<strong>方便地缓存单表查询</strong>对应的结果对象。但MySQL的查询缓存对<strong>关联缓存</strong>的<strong>支持并不太好</strong>，如果关联中的某个表发生了变化，那么就无法使用查询缓存了</li>
<li>将查询分解后，执行单个查询可以<strong>减少锁的竞争</strong>。</li>
<li>在应用层做关联，可以更容易对<strong>数据库进行拆分</strong>，更容易做到<strong>高性能</strong>和<strong>可扩展</strong>。</li>
<li><strong>查询本身效率</strong>也可能会有所提升。</li>
<li>更进一步，这样做相当于在应用中实现了<strong>哈希关联</strong>，而<strong>不</strong>是使用MySQL的<strong>嵌套循环关联</strong>。某些场景哈希关联的效率要高很多</li>
</ul>
<h3 id="6-4-查询执行的基础"><a href="#6-4-查询执行的基础" class="headerlink" title="6.4 查询执行的基础"></a>6.4 查询执行的基础</h3><p>下图显示了MySQL执行一个查询的过程。<br><img src="/2020/03/02/MySQL-6-查询性能优化/200302_0.png" alt=""></p>
<p>具体步骤如下</p>
<ol>
<li>客户端<strong>发送一条查询</strong>给服务器。</li>
<li>服务器先检查查询<strong>缓存</strong>，如果命中了缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段。</li>
<li>服务器端进行<strong>SQL解析</strong>、<strong>预处理</strong>，再由<strong>优化器</strong>生成对应的<strong>执行计划</strong>。</li>
<li>MySQL根据优化器生成的执行计划，调用<strong>存储引擎的API</strong>来执行<strong>查询</strong>。</li>
<li>将<strong>结果返回</strong>给客户端。</li>
</ol>
<h4 id="6-4-1-MySQL客户端-服务器通信协议"><a href="#6-4-1-MySQL客户端-服务器通信协议" class="headerlink" title="6.4.1 MySQL客户端/服务器通信协议"></a>6.4.1 MySQL客户端/服务器通信协议</h4><p>MySQL客户端和服务器之间的<strong>通信协议</strong>是<strong>半双工</strong>的，这意味着在<strong>任何一个时刻</strong>，要么是由服务器向客户端发送数据，要么是由客户端向服务器发送数据，这两个动作<strong>不能同时</strong>发生。</p>
<p>这种协议让MySQL<strong>通信简单</strong>快速，但也意味着<strong>没法</strong>进行<strong>流量控制</strong>。当服务器开始响应客户端请求时，客户端<strong>必须完整地接收</strong>整个返回结果，而不能简单地只取前面几条结果，然后让服务器停止发送数据。这也是在必要的时候一定要在查询中加上<strong>LIMIT限制</strong>的原因。</p>
<p>多数连接MySQL的<strong>客户端</strong>库函数都可以从服务器获得<strong>全部结果集</strong>并<strong>缓存</strong>到内存里，还可以从服务器<strong>逐行获取</strong>需要的数据。默认一般是客户端获得全部结果集并缓存到内存中。MySQL<strong>服务器</strong>通常需要等<strong>所有的数据</strong>都已经发送给<strong>客户端</strong>才能<strong>释放</strong>这条查询所占用的资源，所以接收全部结果并缓存通常可以减少服务器的压力，让查询能够早点结束、早点释放相应的资源。</p>
<p>当使用多数连接MySQL的<strong>客户端库函数</strong>从MySQL获取数据时，其结果看起来都像是从MySQL服务器获取数据，而实际上都是从这个客户端库函数的<strong>缓存获取数据</strong>。</p>
<p>对于一个<strong>MySQL连接</strong>，<strong>任何时刻</strong>都有一个<strong>状态</strong>，该状态表示了MySQL当前正在做什么。使用<code>SHOW FULL PROCESSLIST</code>命令能查看当前的状态</p>
<ul>
<li><code>Sleep</code>：线程正在<strong>等待</strong>客户端发送<strong>新的请求</strong>。</li>
<li><code>Query</code>：线程正在<strong>执行查询</strong>或者正在将结果发送给客户端</li>
<li><code>Locked</code>：在MySQL服务器层，该线程正在<strong>等待表锁</strong>。</li>
<li><code>Analyzing and statistics</code>：线程正在收集存储引擎的<strong>统计信息</strong>，并生成查询的<strong>执行计划</strong>。</li>
<li><code>Copying to tmp table [on disk]</code>：线程正在执行查询，并且将其<strong>结果集</strong>都<strong>复制</strong>到一个临时表中</li>
<li><code>Sorting result</code>：线程正在对<strong>结果集</strong>进行<strong>排序</strong></li>
<li><code>Sending data</code>：这表示多种情况：线程可能在多个状态之间<strong>传送数据</strong>，或者在<strong>生成结果集</strong>，或者在向客户端<strong>返回数据</strong>。</li>
</ul>
<h4 id="6-4-2-查询缓存"><a href="#6-4-2-查询缓存" class="headerlink" title="6.4.2 查询缓存"></a>6.4.2 查询缓存</h4><p>MySQL会优先检查这个查询是否<strong>命中査询缓存</strong>中的数据。这个检查是通过一个对<strong>大小写敏感</strong>的<strong>哈希查找</strong>实现的。之后MySQL会检查一次<strong>用户权限</strong>。如果权限没有问题，MySQL会跳过所有其他阶段，直接从缓存中拿到结果并返回给客户端。</p>
<h4 id="6-4-3-查询优化处理"><a href="#6-4-3-查询优化处理" class="headerlink" title="6.4.3 查询优化处理"></a>6.4.3 查询优化处理</h4><p>查询的生命周期的下一步是将一个<strong>SQ</strong>L转换成一个<strong>执行计划</strong>，这包括多个子阶段：<strong>解析SQL</strong>、<strong>预处理</strong>、<strong>优化SQL</strong>、<strong>生成执行计划</strong>。</p>
<h5 id="6-4-3-1-语法解析器和处理器"><a href="#6-4-3-1-语法解析器和处理器" class="headerlink" title="6.4.3.1 语法解析器和处理器"></a>6.4.3.1 语法解析器和处理器</h5><p>首先，MySQL语法解析器通过关键字将<strong>SQL语句</strong>进行<strong>解析</strong>，并生成一棵对应的<strong>解析树</strong>。</p>
<p>然后，预处理器根据一些MySQL规则<strong>检查解析树</strong>是否<strong>合法</strong>，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义</p>
<p>下一步预处理器会<strong>验证权限</strong>。</p>
<h5 id="6-4-3-2-查询优化器"><a href="#6-4-3-2-查询优化器" class="headerlink" title="6.4.3.2 查询优化器"></a>6.4.3.2 查询优化器</h5><p>现在语法树被认为是合法的了，然后<strong>优化器要将语法树转化成执行计划</strong>。一条查询可以有很多种执行方式，最后都返回相同的结果。优化器的作用就是<strong>找到</strong>这其中<strong>最好的执行计划</strong>。MySQL使用<strong>基于成本</strong>的优化器，它将尝试预测一个查询使用某种执行计划时的成本并选择其中成本最小的一个。</p>
<p><strong>优化策略</strong>可以简单地分为两种</p>
<ul>
<li><strong>静态优化</strong>可以直接对解析树进行分析，并完成优化。静态优化<strong>不依赖于特别的运行状况</strong>或者参数值。静态优化在第一次完成后就一直有效，即使使用不同的参数重复执行查询也不会发生变化。可以认为这是一种<strong>编译时优化</strong>。</li>
<li><strong>动态优化</strong>则和<strong>查询的上下文</strong>有关，需要在每次查询的时候都重新评估，可以认为这是<strong>运行时优化</strong>。</li>
</ul>
<p>下面是MySQL能够处理的一些优化类型</p>
<ul>
<li>重新定义<strong>关联表的顺序</strong><ul>
<li>数据表的关联并不总是按照在查询中指定的顺序进行。</li>
<li>优化器会试图寻找一种最好的关联顺序</li>
</ul>
</li>
<li>将<strong>外连接转化为内连接</strong><ul>
<li>并不是所有的<code>OUTER JOIN</code>语句都必须以外连接的方式执行。例如<code>WHERE</code>条件、库表结构都可能会让<strong>外连接**</strong>等价<strong>于一个</strong>内连接**。 </li>
<li>MySQL能够<strong>识别</strong>这点并<strong>重写查询</strong>，让其可以调整关联顺序。</li>
</ul>
</li>
<li>使用<strong>等价变换</strong>规则<ul>
<li>MySQL可以使用一些等价变换来<strong>简化并规范表达式</strong>。</li>
<li>它可以<strong>合并</strong>和减少一些<strong>比较</strong>，还可以<strong>移除</strong>一些<strong>恒成立</strong>和一些<strong>恒不成立</strong>的判断。</li>
</ul>
</li>
<li>优化<code>COUNT()</code>、<code>MIN()</code>和<code>MAX()</code><ul>
<li><strong>索引</strong>通常可以帮助MySQL优化这类表达式。</li>
<li>要找到<strong>某一列的最小值</strong>，只需要查询对应<code>B-Tree</code>索引<strong>最左端的记录</strong>，MySQL可以直接获取索引的第一行记录。</li>
</ul>
</li>
<li>预估并<strong>转化表达式为常数</strong><ul>
<li>优化器会试图将一些表达式转化为常数</li>
</ul>
</li>
<li><strong>覆盖索引扫描</strong><ul>
<li>当索引中的列<strong>包含所有查询中需要使用的列</strong>的时候，MySQL就可以使用索引返回需要的数据，而<strong>无须查询对应的数据行</strong></li>
</ul>
</li>
<li>子查询优化</li>
<li><strong>提前终止</strong>查询<ul>
<li>在发现已经满足查询需求的时候，MySQL总是能够<strong>立刻终止</strong>查询。</li>
<li>一个典型的例子就是当使用了<strong>LIMIT子句</strong>的时候。</li>
<li>此外，假如发现了一个<strong>不成立</strong>的条件，这时MySQL可以立刻返回一个空结果。</li>
</ul>
</li>
<li>等值传播</li>
<li>列表<code>IN()</code>的比较</li>
</ul>
<p>最后，我们要明白一点，<strong>不要以为自己比优化器聪明</strong></p>
<h5 id="6-4-3-3-数据和索引的统计信息"><a href="#6-4-3-3-数据和索引的统计信息" class="headerlink" title="6.4.3.3 数据和索引的统计信息"></a>6.4.3.3 数据和索引的统计信息</h5><p>服务器层没有任何统计信息，所以MySQL查询优化器在生成查询的执行计划时需要向<strong>存储引擎</strong>获取相应的<strong>统计信息</strong>。存储引擎则提供给优化器对应的统计信息</p>
<h5 id="6-4-3-4-MySQL如何执行关联查询"><a href="#6-4-3-4-MySQL如何执行关联查询" class="headerlink" title="6.4.3.4 MySQL如何执行关联查询"></a>6.4.3.4 MySQL如何执行关联查询</h5><p>MySQL认为<strong>任何一个查询</strong>都是<strong>一次关联</strong>，并不仅仅是一个查询需要到两个表匹配才叫关联。</p>
<p>MySQL<strong>关联</strong>执行的<strong>策略</strong>很简单：</p>
<ul>
<li>MySQL对任何关联都执行<strong>嵌套循环</strong>关联操作</li>
<li>MySQL先在一个表中循环取出单条数据，然后再嵌套循环到下一个表中寻找匹配的行，依次下去，直到找到所有表中匹配的行为止。</li>
<li>然后根据各个表匹配的行，返回查询中需要的各个列。</li>
<li>MySQL会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行以后，MySQL返回到上一层次关联表，看是否能够找到更多的匹配记录，依此类推迭代执行。</li>
</ul>
<p>上面的描述极其拗口，难以理解，下面用伪代码来说明</p>
<p>假设我们要执行下面这个关联查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tbl1.col1, tbl2.col2</span><br><span class="line"><span class="keyword">FROM</span> tbl1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tbl2 <span class="keyword">USING</span>(col3)</span><br><span class="line"><span class="keyword">WHERE</span> tbl1.col1 <span class="keyword">IN</span>(<span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个查询会被以下面伪代码的方式执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">outer_iter = iterator over tbl1 where col1 IN(5, 6)</span><br><span class="line">outer_row = outer_iter.next</span><br><span class="line">while outer_row</span><br><span class="line">    inner_iter = iterator over tbl2 where col3 = outer_row.col3</span><br><span class="line">    inner_row = inner_iter.next</span><br><span class="line">    while inner_row</span><br><span class="line">        output[ outer_row.col1, inner_row.col2]</span><br><span class="line">        inner_row = inner_iter.next</span><br><span class="line">    end</span><br><span class="line">    outer_row = outer_iter.next</span><br><span class="line">end</span><br></pre></td></tr></table></figure></p>
<p>上面这种查询的泳道图如下<br><img src="/2020/03/02/MySQL-6-查询性能优化/200302_1.png" alt=""></p>
<p>上面的执行计划对于单表查询和多表关联查询都适用，如果是一个<strong>单表查询</strong>，那么只需完成上面<strong>外层的基本操作</strong>。</p>
<h5 id="6-4-3-5-执行计划"><a href="#6-4-3-5-执行计划" class="headerlink" title="6.4.3.5 执行计划"></a>6.4.3.5 执行计划</h5><p>MySQL并<strong>不会</strong>生成<strong>查询字节码</strong>来执行查询。 MySQL生成査询的一棵<strong>指令树</strong>，然后通过存储引擎执行完成这棵指令树并返回结果。</p>
<p>MySQL的执行计划总是如下图所示，是一棵<strong>左侧深度优先的树</strong>。<br><img src="/2020/03/02/MySQL-6-查询性能优化/200302_2.png" alt=""></p>
<h5 id="6-4-3-6-关联查询优化器"><a href="#6-4-3-6-关联查询优化器" class="headerlink" title="6.4.3.6 关联查询优化器"></a>6.4.3.6 关联查询优化器</h5><p>通常多表关联的时候，可以有多种<strong>不同的关联顺序</strong>来获得<strong>相同的执行结果</strong>。<strong>关联查询优化器</strong>则通过评估不同顺序时的成本来选择一个<strong>代价最小</strong>的关联顺序。</p>
<p>当关联顺序的选择<strong>非常多</strong>的时候，优化器不可能逐一评估每一种关联顺序的成本。这时，优化器选择使用<strong>贪婪搜索</strong>的方式查找<strong>最优</strong>的关联顺序。</p>
<h5 id="6-4-3-7-排序优化"><a href="#6-4-3-7-排序优化" class="headerlink" title="6.4.3.7 排序优化"></a>6.4.3.7 排序优化</h5><p>当<strong>不能使用索引</strong>生成排序结果的时候，MySQL需要自己进行排序，如果<strong>数据量小</strong>则在<strong>内存</strong>中进行，如果<strong>数据量大</strong>则需要使用<strong>磁盘</strong>，MySQL将这个过程统一称为<strong>文件排序</strong>（filesort）</p>
<p>如果需要排序的数据量小于<strong>排序缓冲区</strong>， MySQL使用<strong>内存</strong>进行<strong>快速排序</strong>操作。如果内存不够排序，那么MySQL会先将<strong>数据分块</strong>，对每个独立的<strong>块</strong>使用<strong>快速排序</strong>进行排序，并将各个块的排序结果存放在磁盘上，然后将各个<strong>排好序的块</strong>进行<strong>合并</strong>（merge），最后返回排序结果。</p>
<p>MySQL有如下两种排序算法：</p>
<ul>
<li><strong>两次传输排序</strong><ul>
<li>读取行指针和<strong>需要排序的字段</strong>，对其进行排序，然后<strong>再</strong>根据排序结果读取所需要的<strong>数据行</strong>。</li>
<li>这需要进行<strong>两次数据传输</strong>，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是<strong>读取排序列进行排序后的需要的其他行结构</strong>。</li>
<li>这样做的优点是，在<strong>排序</strong>的时候<strong>存储尽可能少的数据</strong>，这就让排序缓冲区中可能容纳尽可能多的行数进行排序。</li>
</ul>
</li>
<li><strong>单次传输排序</strong><ul>
<li>先读取<strong>查询所需要的所有列</strong>，然后再根据给定列进行排序，最后直接返回排序结果。</li>
<li>相比两次传输排序，这个算法<strong>只需要一次顺序I/O</strong>读取所有的数据，而无须任何的随机IO。</li>
<li>缺点是，如果需要返回的列非常多、非常大，会<strong>额外占用大量的空间</strong>，而这些列对排序操作本身来说是没有任何作用的。</li>
</ul>
</li>
</ul>
<p>两种算法都有各自最好和最糟的场景。当查询需要所有列的总<strong>长度不超过</strong>参数<code>max_length_for_sort_data</code>时， MySQL使用<strong>单次传输排序</strong>，可以通过调整这个参数来影响MySQL排序算法的选择。</p>
<p>在关联查询的时候如果需要排序， MySQL会分两种情况来处理这样的文件排序。</p>
<ol>
<li>如果<code>ORDER BY</code>子句中的<strong>所有列</strong>都来自关联的<strong>第一个表</strong>，那么MySQL在关联处理<strong>第一个表</strong>的时候就进行<strong>文件排序</strong>。</li>
<li><strong>除此之外</strong>的所有情况，MySQL都会先将关联的结果存放到一个临时表中，然后在<strong>所有的关联都结束后</strong>，再进行<strong>文件排序</strong>。</li>
</ol>
<h4 id="6-4-4-查询执行引擎"><a href="#6-4-4-查询执行引擎" class="headerlink" title="6.4.4 查询执行引擎"></a>6.4.4 查询执行引擎</h4><p>在解析和优化阶段，MySQL将生成查询对应的执行计划， MySQL的<strong>查询执行引擎</strong>则根据这个执行计划来<strong>完成整个查询</strong>。这里执行计划是一个<strong>数据结构</strong>，而<strong>不是</strong>和很多其他的关系型数据库那样会生成对应的<strong>字节码</strong>。</p>
<p>在执行时，大量的操作都需要调用<strong>存储引擎API</strong>。存储引擎接口有着非常丰富的功能，但是<strong>底层接口却只有几十个</strong>，这些接口像<strong>搭积木</strong>一样能够完成查询的大部分操作。这种简单的接口模式，让MySQL的<strong>存储引擎插件式架构</strong>成为可能，但是正如前面的讨论，也给优化器带来了一定的限制。</p>
<h4 id="6-4-5-返回结果给客户端"><a href="#6-4-5-返回结果给客户端" class="headerlink" title="6.4.5 返回结果给客户端"></a>6.4.5 返回结果给客户端</h4><p>查询执行的最后一个阶段是将<strong>结果返回</strong>给客户端。即使查询<strong>不需要返回</strong>结果集给客户端， MySQL仍然会返回这个查询的一些信息，如<strong>该查询影响到的行数</strong></p>
<p>如果查询可以被缓存，那么MySQL在这个阶段也会将<strong>结果存放</strong>到查询<strong>缓存</strong>中。</p>
<p>MySQL将结果集返回客户端是一个<strong>增量</strong>、<strong>逐步返回</strong>的过程。一旦服务器开始<strong>生成第一条结果</strong>时， MySQL就可以<strong>开始</strong>向客户端逐步返回结果集了。这样处理有两个好处</p>
<ol>
<li>服务器端无须存储太多的结果，也就不会因为要返回太多结果而消耗太多内存。</li>
<li>这样的处理也让 MySQL客户端第一时间获得返回的结果</li>
</ol>
<p>结果集中的<strong>每一行</strong>都会以一个满足MySQL客户端/服务器通信协议的<strong>封包发送</strong></p>
<h3 id="6-5-MySQL查询优化器的局限性"><a href="#6-5-MySQL查询优化器的局限性" class="headerlink" title="6.5 MySQL查询优化器的局限性"></a>6.5 MySQL查询优化器的局限性</h3><p>略</p>
<h3 id="6-6-查询优化器的提示"><a href="#6-6-查询优化器的提示" class="headerlink" title="6.6 查询优化器的提示"></a>6.6 查询优化器的提示</h3><p>如果对优化器选择的<strong>执行计划不满意</strong>，可以使用优化器提供的几个<strong>提示</strong>（hint）来<strong>控制</strong>最终的执行计划。</p>
<h4 id="6-6-1-HIGH-PRIORITY-和-LOW-PRIORITY"><a href="#6-6-1-HIGH-PRIORITY-和-LOW-PRIORITY" class="headerlink" title="6.6.1 HIGH_PRIORITY 和 LOW_PRIORITY"></a>6.6.1 HIGH_PRIORITY 和 LOW_PRIORITY</h4><p>这个提示告诉MySQL，当多个语句同时访问某一个表的时候，哪些语句的<strong>优先级</strong>相对高些、哪些语句的优先级相对低些。</p>
<p>这两个提示<strong>只对使用表锁的存储引擎</strong>有效，千万不要在 InnoDB或者其他有细粒度锁机制和并发控制的引擎中使用。</p>
<h4 id="6-6-2-DELAYED"><a href="#6-6-2-DELAYED" class="headerlink" title="6.6.2 DELAYED"></a>6.6.2 DELAYED</h4><p>这个提示对<code>INSERT</code>和<code>REPLACE</code>有效。MySQL会将使用该提示的语句立即返回，但<strong>不会立刻执行</strong>语句，而是将插入的行数据放入到<strong>缓冲区</strong>，然后在表<strong>空闲</strong>时批量将数据写入。</p>
<h4 id="6-6-3-STRAIGHT-JOIN"><a href="#6-6-3-STRAIGHT-JOIN" class="headerlink" title="6.6.3 STRAIGHT_JOIN"></a>6.6.3 STRAIGHT_JOIN</h4><p>这个提示可以放置在<code>SELECT</code>语句的<code>SELECT</code>关键字之后，也可以放置在任何两个关联表的名字之间。第一个用法是让查询中所有的表按照<strong>在语句中出现的顺序进行关联</strong>。第二个用法则是<strong>固定其前后两个表的关联顺序</strong>。</p>
<h4 id="6-6-4-SQL-SMALL-RESULT和SQL-BIG-RESULT"><a href="#6-6-4-SQL-SMALL-RESULT和SQL-BIG-RESULT" class="headerlink" title="6.6.4 SQL_SMALL_RESULT和SQL_BIG_RESULT"></a>6.6.4 SQL_SMALL_RESULT和SQL_BIG_RESULT</h4><p><code>SQL_SMALL_RESULT</code>告诉优化器结果集会很小，可以将结果集放在内存中的索引临时表，以避免排序操作。如果是<code>SQL_BIG_RESULT</code>，则告诉优化器结果集可能会非常大，建议使用磁盘临时表做排序操作。</p>
<h4 id="6-6-5-SQL-CACHE和SQL-NO-CACHE"><a href="#6-6-5-SQL-CACHE和SQL-NO-CACHE" class="headerlink" title="6.6.5 SQL_CACHE和SQL_NO_CACHE"></a>6.6.5 SQL_CACHE和SQL_NO_CACHE</h4><p>这个结果集是否应该缓存在查询缓存中</p>
<h4 id="6-6-6-SQL-CALC-FOUND-ROWS"><a href="#6-6-6-SQL-CALC-FOUND-ROWS" class="headerlink" title="6.6.6 SQL_CALC_FOUND_ROWS"></a>6.6.6 SQL_CALC_FOUND_ROWS</h4><p>查询中加上该提示MySQL会计算除去LIMIT子句后这个查询要返回的结果集的<strong>总数</strong></p>
<h4 id="6-6-7-FOR-UPDATE-和-LOCK-IN-SHARE-MODE"><a href="#6-6-7-FOR-UPDATE-和-LOCK-IN-SHARE-MODE" class="headerlink" title="6.6.7 FOR UPDATE 和 LOCK IN SHARE MODE"></a>6.6.7 FOR UPDATE 和 LOCK IN SHARE MODE</h4><p>这两个提示主要控制<strong>SELECT</strong>语句的<strong>锁机制</strong>，但只对实现了<strong>行级锁的存储引擎</strong>有效。使用该提示会对符合査询条件的数据行加锁。</p>
<p>唯一内置的支持这两个提示的引擎就是InnoDB。另外需要记住的是，这两个提示会让某些优化无法正常使用，例如索引覆盖扫描</p>
<h4 id="6-6-8-USE-INDEX、IGNORE-INDEX和FORCE-INDEX"><a href="#6-6-8-USE-INDEX、IGNORE-INDEX和FORCE-INDEX" class="headerlink" title="6.6.8 USE INDEX、IGNORE INDEX和FORCE INDEX"></a>6.6.8 USE INDEX、IGNORE INDEX和FORCE INDEX</h4><p>这几个提示会告诉优化器使用或者不使用哪些索引来查询记录</p>
<h3 id="6-7-优化特定类型的查询"><a href="#6-7-优化特定类型的查询" class="headerlink" title="6.7 优化特定类型的查询"></a>6.7 优化特定类型的查询</h3><h4 id="6-7-1-优化COUNT-查询"><a href="#6-7-1-优化COUNT-查询" class="headerlink" title="6.7.1 优化COUNT()查询"></a>6.7.1 优化COUNT()查询</h4><p><code>COUNT()</code>主要有两个用处</p>
<ol>
<li><code>COUNT(*)</code>用来统计所有符合条件的行数</li>
<li><code>COUNT(col1)</code>用来统计所有<code>col1</code>不为空的行数</li>
</ol>
<p>MyISAM在没有任何<code>WHERE</code>条件的<code>COUNT()</code>才非常快，因为此时无须实际地去计算表的行数。MySQL可以利用存储引擎的特性直接获得这个值。</p>
<p>通常情况下，要计算<code>COUNT()</code>都需要扫描全表</p>
<p>在不需要精确的<code>COUNT()</code>值的时候，可以使用<code>EXPLAIN</code>出来的优化器估算的行数来作为近似值。</p>
<p>或者可以参照上一章的做法使用汇总表</p>
<h4 id="6-7-2-优化关联查询"><a href="#6-7-2-优化关联查询" class="headerlink" title="6.7.2 优化关联查询"></a>6.7.2 优化关联查询</h4><p>要确保<code>ON</code>或者<code>USING</code>子句中的列上有索引</p>
<h4 id="6-7-3-优化子查询"><a href="#6-7-3-优化子查询" class="headerlink" title="6.7.3 优化子查询"></a>6.7.3 优化子查询</h4><p>关于子查询优化我们给出的最重要的优化建议就是尽可能使用关联查询代替。</p>
<h4 id="6-7-4-优化GROUP-BY和DISTINCT"><a href="#6-7-4-优化GROUP-BY和DISTINCT" class="headerlink" title="6.7.4 优化GROUP BY和DISTINCT"></a>6.7.4 优化GROUP BY和DISTINCT</h4><p>在很多场景下， MySQL都使用同样的办法优化这两种查询，事实上， MySQL优化器会在内部处理的时候相互转化这两类查询。它们都可以使用索引来优化，这也是最有效的优化办法。</p>
<h4 id="6-7-5-优化LIMIT分页"><a href="#6-7-5-优化LIMIT分页" class="headerlink" title="6.7.5 优化LIMIT分页"></a>6.7.5 优化LIMIT分页</h4><p>在系统中需要进行分页操作的时候，我们通常会使<code>LIMIT</code>加上偏移量的办法实现，同时加上合适的<code>ORDER BY</code>子句。如果有对应的索引，通常效率会不错，否则，MySQL需要做大量的文件排序操作。</p>
<p>在偏移量非常大的时候，可能效率会比较低。这样的查询可能需要访问大半个表的数据。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。</p>
<p>下面有几种优化策略</p>
<ol>
<li>优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖扫描，而不是查询所有的列。</li>
<li>如果可以使用书签记录上次取数据的位置，那么下次就可以直接从该书签记录的位置开始扫描，这样就可以避免使用OFFSET。</li>
</ol>
<h4 id="6-7-6-优化SQL-CALC-FOUND-ROWS"><a href="#6-7-6-优化SQL-CALC-FOUND-ROWS" class="headerlink" title="6.7.6 优化SQL_CALC_FOUND_ROWS"></a>6.7.6 优化SQL_CALC_FOUND_ROWS</h4><p>分页的时候，另一个常用的技巧是在<code>LIMIT</code>语句中加上<code>SQL_CALC_FDUND_ROWS</code>提示这样就可以获得去掉<code>LIMIT</code>以后满足条件的行数，因此可以作为<strong>分页的总数</strong>。加上这个提示以后，<strong>不管是否需要</strong>，MySQL都会<strong>扫描所有满足条件的行</strong>，然后<strong>再抛弃掉不需要的行</strong>，而不是在满足LIMIT的行数后就终止扫描。所以该提示的<strong>代价</strong>可能非常高。</p>
<p>下面有两种解决方法</p>
<ol>
<li>一个更好的设计是将<strong>具体的页数</strong>换成<strong>下一页</strong>按钮，假设每页显示20条记录，那么我们每次查询时都是用<code>LIMIT</code>返回<strong>21条记录</strong>并只显示20条，如果<strong>第21条存在</strong>，那么我们就<strong>显示下一页按钮</strong>，<strong>否则</strong>就说明没有更多的数据，也就<strong>无须显示</strong>下一页按钮了。</li>
<li>另一种做法是先获取并<strong>缓存较多的数据</strong>，例如，缓存1000条，然后每次分页都从这个缓存中获取。</li>
<li>也可以考虑使用<code>EXPLAIN</code>的结果中的<code>rows</code>列的值来作为结果集总数的近似值</li>
</ol>
<h4 id="6-7-7-优化UNION查询"><a href="#6-7-7-优化UNION查询" class="headerlink" title="6.7.7 优化UNION查询"></a>6.7.7 优化UNION查询</h4><p>除非确实需要服务器消除重复的行，否则就一定要使用<code>UNION ALL</code>，这一点很重要。如果没有ALL关键字， MySQL会给临时表加上<code>DISTINCT</code>选项，这会导致对整个临时表的数据做<strong>唯一性检查</strong>，这样做的<strong>代价非常高</strong>。</p>
<h4 id="6-7-8-使用用户自定义变量"><a href="#6-7-8-使用用户自定义变量" class="headerlink" title="6.7.8 使用用户自定义变量"></a>6.7.8 使用用户自定义变量</h4><p>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/01/Redis-9-数据库/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/01/Redis-9-数据库/" itemprop="url">[Redis][9][数据库]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-03-01T16:29:33+08:00">
                2020-03-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/03/01/Redis-9-数据库/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/03/01/Redis-9-数据库/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-9-章-数据库"><a href="#第-9-章-数据库" class="headerlink" title="第 9 章 数据库"></a>第 9 章 数据库</h2><p>本章将对Redis服务器的<strong>数据库实现</strong>进行详细介绍，说明<strong>服务器保存数据库的方法</strong>，<strong>客户端切换数据库</strong>的方法，<strong>数据库保存键值对</strong>的方法，以及针对<strong>数据库的添加、删除、查看更新操作的实现方法</strong>等。除此之外，本章还会说明<strong>服务器保存键的过期时间</strong>的方法，以及<strong>服务器自动删除过期键</strong>的方法，以及<strong>数据库通知功能</strong>的实现方法。</p>
<h3 id="9-1-服务器中的数据库"><a href="#9-1-服务器中的数据库" class="headerlink" title="9.1 服务器中的数据库"></a>9.1 服务器中的数据库</h3><p>Redis服务器将所有数据库都<strong>保存</strong>在服务器状态<code>redis.h/redisServer</code>结构的<code>db</code>数组中，<code>db</code>数组的每个项都是一个<code>redis.h/redisDb</code>结构，每个<code>redisDB</code>结构代表一个数据库：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据库</span></span><br><span class="line">    redisDb *db;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//服务器的数据库数量</span></span><br><span class="line">    <span class="keyword">int</span> dbnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dbnum属性决定了Redis<strong>初始化</strong>时创建数据库的<strong>数量</strong>，默认为16个，结构如下图</p>
<p><img src="/2020/03/01/Redis-9-数据库/200301_0.png" alt=""></p>
<h3 id="9-2-切换数据库"><a href="#9-2-切换数据库" class="headerlink" title="9.2 切换数据库"></a>9.2 切换数据库</h3><p>每个<code>Redis</code>客户端都有自己的<strong>目标数据库</strong>，每当客户端执行数据库操作的时候，目标数据库就会成为这些命令的<strong>操作对象</strong>。<br><strong>默认</strong>情况下，<code>Redis</code>客户端的目标数据库为<strong>0号数据库</strong>，但客户端可以通过执行<code>SELECT</code>命令来<strong>切换</strong>目标数据库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 2</span><br></pre></td></tr></table></figure>
<p>在服务器内部，客户端状态<code>redisClient</code>结构的<code>db</code>属性记录了<strong>客户端当前的目标数据库</strong>，这个属性是一个指向<code>redisDB</code>结构的<strong>指针</strong>，被指向的元素就是客户端的目标数据库。</p>
<p><img src="/2020/03/01/Redis-9-数据库/200301_1.png" alt=""></p>
<p>到目前为止，Redis仍然<strong>没有</strong>可以<strong>返回客户端目标数据库</strong>的命令。在数次切换数据库之后，你很可能会忘记自己当前正在使用的是哪个数据库。当出现这种情况时，为了避免对数据库进行误操作，在执行Redis命令特别是像<code>FLUSHDB</code>这样的<strong>危险命令</strong>之前，最好<strong>先</strong>执行一个<code>SELECT</code>命令，<strong>显式切换</strong>到指定的数据库，然后才执行别的命令。</p>
<h3 id="9-3-数据库键空间"><a href="#9-3-数据库键空间" class="headerlink" title="9.3 数据库键空间"></a>9.3 数据库键空间</h3><p>Redis是一个键值对（key-value pair）数据库服务器，<code>redis.h</code>结构的<code>dict</code><strong>字典</strong>保存了数据库中的所有<strong>键值对</strong>，我们将这个字典称为<strong>键空间</strong></p>
<ul>
<li><strong>键空间的键</strong>也就是<strong>数据库的键</strong>，每个键都是一个字符串对象。</li>
<li><strong>键空间的值</strong>也就是<strong>数据库的值</strong>，每个值可以是字符串对象、列表对象、哈希表对象、集合对象和有序集合对象中的任意一种Redis对象。</li>
</ul>
<p><img src="/2020/03/01/Redis-9-数据库/200301_2.png" alt=""></p>
<h4 id="9-3-1-添加新键"><a href="#9-3-1-添加新键" class="headerlink" title="9.3.1 添加新键"></a>9.3.1 添加新键</h4><p>添加一个新键值对到数据库，实际上就是将一个<strong>新键值对</strong>添加到<strong>键空间</strong>字典里面，其中键为字符串对象，而值则为任意一种类型的Redis对象。</p>
<h4 id="9-3-2-删除键"><a href="#9-3-2-删除键" class="headerlink" title="9.3.2 删除键"></a>9.3.2 删除键</h4><p>删除数据库中的一个键，实际上就是在<strong>键空间</strong>里面<strong>删除</strong>键所对应的键值对对象。</p>
<h4 id="9-3-3-更新键"><a href="#9-3-3-更新键" class="headerlink" title="9.3.3 更新键"></a>9.3.3 更新键</h4><p>略</p>
<h4 id="9-3-4-对键取值"><a href="#9-3-4-对键取值" class="headerlink" title="9.3.4 对键取值"></a>9.3.4 对键取值</h4><p>略</p>
<h4 id="9-3-5-其他键空间操作"><a href="#9-3-5-其他键空间操作" class="headerlink" title="9.3.5 其他键空间操作"></a>9.3.5 其他键空间操作</h4><p>用于<strong>清空</strong>整个数据库的<code>FLUSHDB</code>命令，就是通过<strong>删除</strong>键空间中的所有<strong>键值对</strong>来实现的。</p>
<p>又比如说，用于<strong>随机</strong>返回数据库中某个键的 <code>RANDOMKEY</code>命令，就是通过在键空间中随机返回一个键来实现的。</p>
<h4 id="9-3-6-读写键空间时的维护操作"><a href="#9-3-6-读写键空间时的维护操作" class="headerlink" title="9.3.6 读写键空间时的维护操作"></a>9.3.6 读写键空间时的维护操作</h4><p>当使用Redis命令对数据库进行读写时，服务器不仅会对键空间执行指定的读写操作还会<strong>执行一些额外的维护操作</strong>，其中包括</p>
<ul>
<li><p>在读取一个键之后，服务器会根据键<strong>是否存在</strong>来<strong>更新</strong>服务器的键空间<strong>命中次数</strong>或键空间不命中次数</p>
</li>
<li><p>在读取一个键之后，服务器会<strong>更新键的LRU</strong>（最后一次使用）时间，这个值可以用于计算键的闲置时间</p>
</li>
<li><p>如果服务器在读取一个键时发现该键已经<strong>过期</strong>，那么服务器会先<strong>删除</strong>这个过期键，然后才执行余下的其他操作</p>
</li>
<li><p>如果有客户端使用<code>WATCH</code>命令<strong>监视</strong>了某个键，那么服务器在对被监视的键进行<strong>修改之后</strong>，会将这个键标记为<strong>脏</strong>，从而让事务程序注意到这个键已经被修改过</p>
</li>
</ul>
<h3 id="9-4-设置键的生存时间或过期时间"><a href="#9-4-设置键的生存时间或过期时间" class="headerlink" title="9.4 设置键的生存时间或过期时间"></a>9.4 设置键的生存时间或过期时间</h3><p>客户端可以以秒或者毫秒精度为数据库中的某个<strong>键</strong>设置<strong>生存时间</strong>（Time To Live,TTL），在经过指定的秒数或者毫秒数之后，服务器就会<strong>自动删除</strong>生存时间为0的键。</p>
<h4 id="9-4-1-设置过期时间"><a href="#9-4-1-设置过期时间" class="headerlink" title="9.4.1 设置过期时间"></a>9.4.1 设置过期时间</h4><p>Redis有四个不同的命令可以用于<strong>设置</strong>键的<strong>生存时间</strong>（键可以存在多久）或<strong>过期时间</strong>（键什么时候会被删除）</p>
<ul>
<li><code>EXPIRE</code>：用于将键key的<strong>生存时间</strong>设置为xx<strong>秒</strong>。</li>
<li><code>PEXPIRE</code>：用于将键key的<strong>生存时间</strong>设置为xx<strong>毫秒</strong>。</li>
<li><code>EXPIREAT</code>：用于将键key的<strong>过期时间</strong>设置为指定的<strong>秒数时间戳</strong></li>
<li><code>PEXPIREAT</code>：用于将键key的<strong>过期时间</strong>设置为指定的<strong>毫秒数时间戳</strong></li>
</ul>
<h4 id="9-4-2-保存过期时间"><a href="#9-4-2-保存过期时间" class="headerlink" title="9.4.2 保存过期时间"></a>9.4.2 保存过期时间</h4><p><code>redisDb</code>结构的<code>expires</code>字典<strong>保存</strong>了数据库中所有键的<strong>过期时间</strong>，我们称这个字典为<strong>过期字典</strong>：</p>
<ul>
<li>过期字典的<strong>键</strong>是一个<strong>指针</strong>，这个指针<strong>指向键空间</strong>中的某个<strong>键对象</strong></li>
<li>过期字典的<strong>值</strong>是一个<code>long long</code>类型的<strong>整数</strong>，这个整数<strong>保存</strong>了键所指向的数据库键的过期时间，它是一个毫秒精度的<strong>UNIX时间戳</strong></li>
</ul>
<p>例如下图<br><img src="/2020/03/01/Redis-9-数据库/200301_3.png" alt=""></p>
<h4 id="9-4-3-移除过期时间"><a href="#9-4-3-移除过期时间" class="headerlink" title="9.4.3 移除过期时间"></a>9.4.3 移除过期时间</h4><p><code>PERSIST</code>命令可以<strong>移除</strong>一个键的过期时间</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PERSIST message</span><br></pre></td></tr></table></figure>
<h4 id="9-4-4-计算并返回剩余生存时间"><a href="#9-4-4-计算并返回剩余生存时间" class="headerlink" title="9.4.4 计算并返回剩余生存时间"></a>9.4.4 计算并返回剩余生存时间</h4><p><code>TTL</code>命令以<strong>秒</strong>为单位返回键的<strong>剩余</strong>生存时间，而<code>PTTL</code>命令则以<strong>毫秒</strong>为单位返回键的<strong>剩余</strong>生存时间：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TTL message</span><br><span class="line">PTTL message</span><br></pre></td></tr></table></figure></p>
<h4 id="9-4-5-过期键的判定"><a href="#9-4-5-过期键的判定" class="headerlink" title="9.4.5 过期键的判定"></a>9.4.5 过期键的判定</h4><p>通过过期字典，程序可以用以下步骤检查一个给定键<strong>是否过期</strong></p>
<ol>
<li>检查给定键<strong>是否存在于过期字典</strong>：如果存在，那么取得键的过期时间。</li>
<li>检查当前UNIX<strong>时间戳是否大于</strong>键的过期时间：如果是的话，那么键已经过期；否则的话，键未过期。</li>
</ol>
<h3 id="9-5-过期键删除策略"><a href="#9-5-过期键删除策略" class="headerlink" title="9.5 过期键删除策略"></a>9.5 过期键删除策略</h3><p>过期键有三种删除策略</p>
<ul>
<li><strong>定时删除</strong>：在设置键的过期时间的同时，创建一个<strong>定时器</strong>，让定时器在键的过期时间来临时，<strong>立即执行</strong>对键的删除操作。</li>
<li><strong>惰性删除</strong>：放任键过期不管，但是每次从键空间中<strong>获取键</strong>时，都<strong>检査</strong>取得的键是否<strong>过期</strong>，如果<strong>过期</strong>的话，就<strong>删除</strong>该键；如果没有过期，就返回该键。</li>
<li>定期删除：每<strong>隔一段时间</strong>，程序就对数据库进行一次<strong>检査</strong>，<strong>删除</strong>里面的<strong>过期键</strong>。至于要删除多少过期键，以及要检查多少个数据库，则由算法决定。</li>
</ul>
<p>在这三种策略中，第一种和第三种为<strong>主动删除</strong>策略，而第二种则为<strong>被动删除</strong>策略。</p>
<h4 id="9-5-1-定时删除"><a href="#9-5-1-定时删除" class="headerlink" title="9.5.1 定时删除"></a>9.5.1 定时删除</h4><p>定时删除策略对<strong>内存</strong>是最<strong>友好</strong>的：通过使用定时器，定时删除策略可以保证过期键会尽可能快地被删除，并释放过期键所占用的内存。</p>
<p>它对<strong>CPU时间</strong>是最<strong>不友好</strong>的：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU时间，</p>
<h4 id="9-5-2-惰性删除"><a href="#9-5-2-惰性删除" class="headerlink" title="9.5.2 惰性删除"></a>9.5.2 惰性删除</h4><p>惰性删除策略对<strong>CPU</strong>时间来说是最<strong>友好</strong>的：程序只会在取岀键时才对键进行过期检査这可以保证删除过期键的操作只会在<strong>非做不可的情况下</strong>进行，并且删除的<strong>目标仅限于当前处理的键</strong>，这个策略不会在删除其他无关的过期键上花费任何CPU时间。</p>
<p>惰性删除策略的缺点是，它对<strong>内存</strong>是最<strong>不友好</strong>的：如果一个键已经过期，而这个键又仍然保留在数据库中，那么只要这个过期键<strong>不被访问</strong>，它所占用的<strong>内存永远不会释放</strong>。</p>
<h4 id="9-5-3-定期删除"><a href="#9-5-3-定期删除" class="headerlink" title="9.5.3 定期删除"></a>9.5.3 定期删除</h4><p>定期删除策略是前两种策略的一种<strong>整合和折中</strong>：</p>
<ul>
<li>定期删除策略每<strong>隔一段时间</strong>执行一次<strong>删除</strong>过期键操作，并通过<strong>限制</strong>删除操作执行的<strong>时长</strong>和<strong>频率</strong>来减少删除操作对CPU时间的影响。</li>
<li>除此之外，通过定期删除过期键，定期删除策略有效地<strong>减少</strong>了因为过期键而带来的<strong>内存浪费</strong>。</li>
</ul>
<h3 id="9-6-Redis的过期删除策略"><a href="#9-6-Redis的过期删除策略" class="headerlink" title="9.6 Redis的过期删除策略"></a>9.6 Redis的过期删除策略</h3><p>Redis服务器实际使用的是<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略</p>
<h4 id="9-6-1-惰性删除策略的实现"><a href="#9-6-1-惰性删除策略的实现" class="headerlink" title="9.6.1 惰性删除策略的实现"></a>9.6.1 惰性删除策略的实现</h4><p><strong>惰性删除</strong>策略由<code>db.c/expireIfNeeded</code>函数实现，所有<strong>读写数据库</strong>的Redis命令在<strong>执行之前</strong>都会调用<code>expireIfNeeded</code>函数对<strong>输入键</strong>进行<strong>检查</strong>：</p>
<ul>
<li>如果输入键已经<strong>过期</strong>，那么<code>expireIfNeeded</code>函数将输入键从数据库中<strong>删除</strong></li>
<li>如果输入键<strong>未过期</strong>，那么<code>expireIfNeeded</code>函数<strong>不做动作</strong>。</li>
</ul>
<p>流程图如下</p>
<p><img src="/2020/03/01/Redis-9-数据库/200301_4.png" alt=""></p>
<p><img src="/2020/03/01/Redis-9-数据库/200301_5.png" alt=""></p>
<p><code>expireIfNeeded</code>源码如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 检查 key 是否已经过期，如果是的话，将它从数据库中删除。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 0 表示键没有过期时间，或者键未过期。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 返回 1 表示键已经因为过期而被删除了。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expireIfNeeded</span><span class="params">(redisDb *db, robj *key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出键的过期时间</span></span><br><span class="line">    <span class="keyword">mstime_t</span> when = getExpire(db,key);</span><br><span class="line">    <span class="keyword">mstime_t</span> now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有过期时间</span></span><br><span class="line">    <span class="keyword">if</span> (when &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* No expire for this key */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don't expire anything while loading. It will be done later. */</span></span><br><span class="line">    <span class="comment">// 如果服务器正在进行载入，那么不进行任何过期检查</span></span><br><span class="line">    <span class="keyword">if</span> (server.loading) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are in the context of a Lua script, we claim that time is</span></span><br><span class="line"><span class="comment">     * blocked to when the Lua script started. This way a key can expire</span></span><br><span class="line"><span class="comment">     * only the first time it is accessed and not in the middle of the</span></span><br><span class="line"><span class="comment">     * script execution, making propagation to slaves / AOF consistent.</span></span><br><span class="line"><span class="comment">     * See issue #1525 on Github for more information. */</span></span><br><span class="line">    now = server.lua_caller ? server.lua_time_start : mstime();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we are running in the context of a slave, return ASAP:</span></span><br><span class="line"><span class="comment">     * the slave key expiration is controlled by the master that will</span></span><br><span class="line"><span class="comment">     * send us synthesized DEL operations for expired keys.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Still we try to return the right information to the caller, </span></span><br><span class="line"><span class="comment">     * that is, 0 if we think the key should be still valid, 1 if</span></span><br><span class="line"><span class="comment">     * we think the key is expired at this time. */</span></span><br><span class="line">    <span class="comment">// 当服务器运行在 replication 模式时</span></span><br><span class="line">    <span class="comment">// 附属节点并不主动删除 key</span></span><br><span class="line">    <span class="comment">// 它只返回一个逻辑上正确的返回值</span></span><br><span class="line">    <span class="comment">// 真正的删除操作要等待主节点发来删除命令时才执行</span></span><br><span class="line">    <span class="comment">// 从而保证数据的同步</span></span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) <span class="keyword">return</span> now &gt; when;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运行到这里，表示键带有过期时间，并且服务器为主节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Return when this key has not expired */</span></span><br><span class="line">    <span class="comment">// 如果未过期，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt;= when) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    server.stat_expiredkeys++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向 AOF 文件和附属节点传播过期信息</span></span><br><span class="line">    propagateExpire(db,key);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送事件通知</span></span><br><span class="line">    notifyKeyspaceEvent(REDIS_NOTIFY_EXPIRED,</span><br><span class="line">        <span class="string">"expired"</span>,key,db-&gt;id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将过期键从数据库中删除</span></span><br><span class="line">    <span class="keyword">return</span> dbDelete(db,key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-6-2-定期删除策略的实现"><a href="#9-6-2-定期删除策略的实现" class="headerlink" title="9.6.2 定期删除策略的实现"></a>9.6.2 定期删除策略的实现</h4><p>过期键的<strong>定期删除策略</strong>由<code>redis.c/activeExpireCycle</code>函数实现，每当Redis的<strong>服务器周期性</strong>操作<code>redis.c/serverCron</code>函数执行时，<code>activeExpireCycle</code>函数就会<strong>被调用</strong>，它在<strong>规定的时间</strong>内，分<strong>多次遍历</strong>服务器中的各个数据库，从数据库的<code>expires</code>字典中<strong>随机检查</strong>一部分键的过期时间，并<strong>删除</strong>其中的过期键。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认每次检查的数据库数量</span></span><br><span class="line">DEFAULT_DB_NUMBERS = <span class="number">16</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认每个数据库检查的键数量</span></span><br><span class="line">DEFAULT_KEY_NUMBERS = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局变量，记录检查进度到哪个数据库</span></span><br><span class="line">current_db = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">activeExpireCycle</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 初始化要检查的数据库数量</span></span><br><span class="line">    <span class="comment"># 如果服务器的数据库数量比 DEFAULT_DB_NUMBERS要小那么以服务器的数据库数量为准</span></span><br><span class="line">    <span class="keyword">if</span> server.donum &lt; DEFAULT_DB_NUMBERS:</span><br><span class="line">        db_numbers = server.dbnum </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        db_numbers = DEFAULT_DB_NUMBERS</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 遍历各个数据库</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range（db numbers）</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果current_db的值等于服务器的数据库数量</span></span><br><span class="line">        <span class="comment"># 这表示检查程序已经遍历了服务器的所有数据库一次</span></span><br><span class="line">        <span class="comment">#将current_db重置为0，开始新的一轮遍历</span></span><br><span class="line">        <span class="keyword">if</span> current_db = server.dbnum current_db= <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 获取当前要处理的数据库</span></span><br><span class="line">        redisDB = server.db[current db]</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将数据库索引增1，指向下一个要处理的数据库</span></span><br><span class="line">        current_db += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 检查数据库键</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range（DEFAULT KEY NUMBERS）：</span><br><span class="line">            <span class="comment"># 如果数据库中没有一个键带有过期时间，那么跳过这个数据库</span></span><br><span class="line">            <span class="keyword">if</span> redisDb.expires.size()==<span class="number">0</span>： </span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># 随机获取一个带有过期时间的键</span></span><br><span class="line">            key_with_ttl = redisDb.expires.get_random_key()</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 检查键是否过期，如果过期就删除它</span></span><br><span class="line">            <span class="keyword">if</span> is_expired(key_with_ttl):</span><br><span class="line">                delete_key(key_with_ttl)</span><br><span class="line">                </span><br><span class="line">            <span class="comment"># 已达到时间上限，停止处理</span></span><br><span class="line">            <span class="keyword">if</span> reach_time_limit():</span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<p><code>activeExpireCycle</code>函数的<strong>工作模式</strong>可以总结为</p>
<ul>
<li>函数每次运行时，都从一定数量的数据库中取出一定数量的<strong>随机键</strong>进行<strong>检查</strong>，并<strong>删除</strong>其中的<strong>过期键</strong>。</li>
<li>全局变量<code>current_db</code>会<strong>记录</strong>当前<code>activeExpireCycle</code>函数检查的<strong>进度</strong>，并在下一次<code>activeExpireCycle</code>函数调用时，<strong>接着上一次的进度进行处理</strong></li>
<li>服务器中的<strong>所有数据库</strong>都会<strong>被检查</strong>一遍，这时函数将<code>current_db</code>变量<strong>重置为0</strong>，</li>
</ul>
<h3 id="9-7-AOP、RDB和复制功能对过期键的处理"><a href="#9-7-AOP、RDB和复制功能对过期键的处理" class="headerlink" title="9.7 AOP、RDB和复制功能对过期键的处理"></a>9.7 AOP、RDB和复制功能对过期键的处理</h3><p>在这一节，我们将探讨<strong>过期键</strong>对Redis服务器中<strong>其他模块</strong>的<strong>影响</strong></p>
<h4 id="9-7-1-生成RDB文件"><a href="#9-7-1-生成RDB文件" class="headerlink" title="9.7.1 生成RDB文件"></a>9.7.1 生成RDB文件</h4><p>在执行<code>SAVE</code>命令或者<code>BGSAVE</code>命令<strong>创建</strong>一个新的<strong>RDB文件</strong>时，程序会对数据库中的<strong>键</strong>进行<strong>检查</strong>，已<strong>过期的键</strong>将<strong>不保存</strong>到新创建的RDB文件中。</p>
<h4 id="9-7-2-载入RDB文件"><a href="#9-7-2-载入RDB文件" class="headerlink" title="9.7.2 载入RDB文件"></a>9.7.2 载入RDB文件</h4><p>在启动Redis服务器时，如果服务器开启了RDB功能，那么服务器将对<strong>RDB文件</strong>进行<strong>载入</strong></p>
<ul>
<li>如果服务器以<strong>主服务器模式</strong>运行，那么在载入RDB文件时，程序会对文件中保存的键进行检査，未过期的键会被载入到数据库中，而<strong>过期键</strong>则会被<strong>忽略</strong>，</li>
<li>如果服务器以<strong>从服务器模式</strong>运行，那么在载入RDB文件时，文件中保存的所有键，<strong>不论是否过期</strong>，<strong>都会</strong>被<strong>载入</strong>到数据库中。不过，因为主从服务器在进行<strong>数据同步</strong>的时候，<strong>从服务器</strong>的数据库就会被<strong>清空</strong>，所以一般来讲，过期键对载入RDB文件的从服务器也<strong>不会造成影响</strong>。</li>
</ul>
<h4 id="9-7-3-AOF文件写入"><a href="#9-7-3-AOF文件写入" class="headerlink" title="9.7.3 AOF文件写入"></a>9.7.3 AOF文件写入</h4><p>当服务器以<strong>AOF持久化模式</strong>运行时，如果数据库中的某个<strong>键</strong>已经<strong>过期</strong>，但它还<strong>没有</strong>被惰性删除或者定期<strong>删除</strong>，那么AOF文件<strong>不会</strong>因为这个过期键而<strong>产生</strong>任何<strong>影响</strong>。<br>当过期键<strong>被</strong>惰性<strong>删除</strong>或者定期删除之后，程序会向AOF文件<strong>追加</strong>（append）一条<strong>DEL命令</strong>，来显式地记录该键已被删除。</p>
<h4 id="9-7-4-AOF重写"><a href="#9-7-4-AOF重写" class="headerlink" title="9.7.4 AOF重写"></a>9.7.4 AOF重写</h4><p>在执行AOF重写的过程中，程序会对数据库中的键进行检查，<strong>已过期</strong>的键<strong>不会</strong>被<strong>保存</strong>到重写后的AOF文件中。</p>
<h4 id="9-7-5-复制"><a href="#9-7-5-复制" class="headerlink" title="9.7.5 复制"></a>9.7.5 复制</h4><p>当服务器运行在复制模式下时，从服务器的过期键<strong>删除</strong>动作由<strong>主服务器控制</strong>：</p>
<ul>
<li><strong>主服务器</strong>在<strong>删除</strong>一个过期键之<strong>后</strong>，会显式地向所有<strong>从服务器</strong>发送一个<strong>DEL命令</strong>，<strong>告知从服务器删除</strong>这个过期键。</li>
<li><strong>从服务器</strong>在<strong>执行客户端</strong>发送的读<strong>命令</strong>时，即使碰到过期键也<strong>不会将过期键删除</strong>，而是继续像处理未过期的键一样来处理过期键。</li>
<li>从服务器<strong>只有</strong>在<strong>接到主服务器</strong>发来的DEL<strong>命令</strong>之后，才会<strong>删除</strong>过期键。</li>
</ul>
<p>具体流程如下<br><img src="/2020/03/01/Redis-9-数据库/200301_6.png" alt=""><br><img src="/2020/03/01/Redis-9-数据库/200301_7.png" alt=""><br><img src="/2020/03/01/Redis-9-数据库/200301_8.png" alt=""><br><img src="/2020/03/01/Redis-9-数据库/200301_9.png" alt=""></p>
<h3 id="9-8-数据库通知"><a href="#9-8-数据库通知" class="headerlink" title="9.8 数据库通知"></a>9.8 数据库通知</h3><p><strong>数据库通知</strong>功能可以让客户端通过<strong>订阅</strong>给定的频道或者模式，来<strong>获知</strong>数据库中<strong>键的变化</strong>，以及数据库中<strong>命令的执行情况</strong>。</p>
<p>其中</p>
<ul>
<li>关注“某个键执行了什么命令”的通知称为<strong>键空间通知</strong></li>
<li>关注“某个命令被什么键执行了”的通知称为<strong>键事件通知</strong></li>
</ul>
<h4 id="9-8-1-发送消息"><a href="#9-8-1-发送消息" class="headerlink" title="9.8.1 发送消息"></a>9.8.1 发送消息</h4><p>发送数据库通知的功能是由<code>notify.c/notifykeyspaceEvent</code>函数实现的：</p>
<p>每当一个Redis<strong>命令</strong>需要<strong>发送</strong>数据库<strong>通知</strong>的时候，该命令的实现函数就会<strong>调用</strong><code>notifyKeyspaceEvent</code>函数，并向函数传递该命令所引发的事件的相关信息。</p>
<p>例如下面是<code>SADD</code>命令的实现函数<code>saddCommand</code>的一部分代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saddCommand</span><span class="params">(redisClient *c)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果至少有一个元素被成功添加，则执行</span></span><br><span class="line">    <span class="keyword">if</span>(added)&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送事件通知</span></span><br><span class="line">        notifyKeyspaceEvent(REDIS_NOTIFY_SET, <span class="string">"sadd"</span>, c-&gt;argv[<span class="number">1</span>], c-&gt;db-&gt;id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-8-2-发送通知的实现"><a href="#9-8-2-发送通知的实现" class="headerlink" title="9.8.2 发送通知的实现"></a>9.8.2 发送通知的实现</h4><p>下面是<code>notifyKeyspaceEvent</code>函数的伪代码实现<br><code></code>py<br>def notifykeyspaceEvent(type, event, key, dbid):</p>
<pre><code># 如果给定的通知不是服务器允许发送的通知，那么直接返回
if not (server.notify_keyspace_events &amp; type):
    return

# 发送键空间通知
if server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYSPACE:

    # 将通知发送给频道&quot;__keyspace@{dbid}__:{key}
    # 内容为键所发生的事件&lt;event&gt;

    # 构建频道名字
    chan = &quot;__keyspace@{dbid}__:{key}&quot;. format(dbid=dbid, key=key)

    # 发送通知
    pubsubPublishMessage(chan,event)

# 发送键事件通知
if server.notify_keyspace_events &amp; REDIS_NOTIFY_KEYEVENT:

    # 将通知发送给频道&quot;__keyevent@{dbid}__:{event}
    # 内容为发生事件的键&lt;key&gt;

    # 构建频道名字
    chan = &quot;__keyspace@{dbid}__:{event}&quot;. format(dbid=dbid, event=event)

    # 发送通知
    pubsubPublishMessage(chan, key)
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/29/Redis-8-对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/29/Redis-8-对象/" itemprop="url">[Redis][8][对象]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-29T16:18:26+08:00">
                2020-02-29
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/redis/" itemprop="url" rel="index">
                    <span itemprop="name">redis</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/29/Redis-8-对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/29/Redis-8-对象/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-8-章-Redis对象"><a href="#第-8-章-Redis对象" class="headerlink" title="第 8 章 Redis对象"></a>第 8 章 Redis对象</h2><p>Redis基于C语言实现了一整套底层<strong>数据结构</strong>，用于Redis上层构件使用</p>
<ul>
<li>简单动态字符串（SDS）</li>
<li>双端链表</li>
<li>跳跃表</li>
<li>字典</li>
<li>整数集合</li>
<li>压缩列表</li>
</ul>
<p>然后Redis并没有直接使用这些数据结构来实现键值对数据库，而是基于这些数据结构创建了一个<strong>对象系统</strong>，这个系统包含<strong>五种</strong>类型的对象，每种对象都用到了至少一种我们前面所介绍的数据结构。</p>
<ul>
<li>字符串对象</li>
<li>列表对象</li>
<li>哈希对象</li>
<li>集合对象</li>
<li>有序集合对象</li>
</ul>
<h3 id="8-1-对象的类型与编码"><a href="#8-1-对象的类型与编码" class="headerlink" title="8.1 对象的类型与编码"></a>8.1 对象的类型与编码</h3><p>Redis<strong>使用对象来表示数据库中的键和值</strong>，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键，另一个对象用作键值对的值。</p>
<p>Redis中的每个对象都由一个<code>redisObject</code>结构表示，该结构中和保存数据有关的三个属性分别是<code>type</code>属性、 <code>encoding</code>属性和<code>ptr</code>属性：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象最后一次被访问的时间</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:REDIS_LRU_BITS; <span class="comment">/* lru time (relative to server.lruclock) */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向实际值的指针</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line"></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其中，为了节省内存，前三个属性采用了位域，如<code>unsign type:4</code>，指定了<code>type</code>属性使用前四个<code>bit</code></li>
</ul>
<p>下面将对上面代码的属性进行解读</p>
<h4 id="8-1-1-类型"><a href="#8-1-1-类型" class="headerlink" title="8.1.1 类型"></a>8.1.1 类型</h4><p>对象的<code>type</code>属性记录了对象的类型，这个属性的值可以是下表列出的常量的其中一个。<br><img src="/2020/02/29/Redis-8-对象/200229_0.png" alt=""></p>
<p>对于Redis数据库保存的键值对来说，键总是一个字符串对象，而值则可以是这五种对象的任意一种。并且，当我们称呼一个键为“列表键”时，我们指的是“这个数据库键所对应的值为列表对象”。</p>
<p><code>TYPE</code>命令：当我们对一个数据库键执行<code>TYPE</code>命令时，命令返回的结果为数据库键对应的值对象的类型。例如，列表键将返回列表类型。</p>
<h4 id="8-1-2-编码"><a href="#8-1-2-编码" class="headerlink" title="8.1.2 编码"></a>8.1.2 编码</h4><p><code>encoding</code>属性记录了对象所使用的编码，也即是说这个对象使用了什么数据结构作为对象的底层实现。每种类型的对象都至少使用了两种不同的编码，下表列出了每种类型的对象可以使用的编码。</p>
<p><img src="/2020/02/29/Redis-8-对象/200229_1.png" alt=""></p>
<p>使用<code>OBJECT ENCODING</code>命令可以查看一个数据库键的值对象的编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; SET msg &quot;hello, world&quot;</span><br><span class="line">OK</span><br><span class="line">redis&gt; OBJECT ENCODING msg</span><br><span class="line">&quot;embstr&quot;</span><br></pre></td></tr></table></figure></p>
<p>通过<code>encoding</code>属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率。</p>
<h3 id="8-2-字符串对象"><a href="#8-2-字符串对象" class="headerlink" title="8.2 字符串对象"></a>8.2 字符串对象</h3><h4 id="8-2-1-字符串对象的编码"><a href="#8-2-1-字符串对象的编码" class="headerlink" title="8.2.1 字符串对象的编码"></a>8.2.1 字符串对象的编码</h4><p>字符串对象的编码可以是<code>int</code>、<code>raw</code>或者 <code>embstr</code></p>
<ul>
<li><p><code>int</code></p>
<ul>
<li>如果一个字符串对象保存的是整数值，并且这个整数值可以<code>long</code>类型来表示</li>
<li>那么字符串对象会直接将整数值保存在字符串对象结构的<code>ptr</code>属性里面（将<code>void*</code>转换成<code>1ong</code>）</li>
<li>并将字符串对象的编码设置为<code>int</code>。</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_3.png" alt=""></li>
</ul>
</li>
<li><p><code>raw</code></p>
<ul>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节</li>
<li>那么字符串对象将使用一个简单动态字符串（<code>SDS</code>）来保存这个字符串值</li>
<li>并将对象的编码设置为<code>raw</code></li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_2.png" alt=""></li>
</ul>
</li>
<li><p><code>embstr</code></p>
<ul>
<li>如果字符串对象保存的是一个字符串值，并且这个字符串值的长度小于等于32字节</li>
<li>那么字符串对象将使用<code>embstr</code>编码的方式来保存这个字符串值</li>
<li>这种编码和<code>raw</code>编码一样，都使用<code>redisObject</code>结构和<code>sdshdr</code>结构来表示字符串对象</li>
<li><code>embstr</code>编码只调用一次内存分配函数分配一块连续的空间，空间中依次包含 <code>redisObject</code>和<code>sdshdr</code>两个结构，</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_4.png" alt=""></li>
</ul>
</li>
</ul>
<p>使用<code>embstr</code>编码的好处如下</p>
<ul>
<li>将创建字符串对象所需的内存分配次数从<code>raw</code>编码的两次降低为一次</li>
<li>释放<code>embstr</code>编码的字符串对象只需要调用一次内存释放函数，而释放<code>raw</code>编码的字符串对象需要调用两次内存释放函数</li>
<li>所有数据都保存在一块连续的内存里面</li>
</ul>
<p>此外，<strong>浮点数</strong>在Redis中也是作为字符串值来存储的</p>
<h4 id="8-2-1-字符串对象编码转换"><a href="#8-2-1-字符串对象编码转换" class="headerlink" title="8.2.1 字符串对象编码转换"></a>8.2.1 字符串对象编码转换</h4><p><code>int</code>到<code>raw</code>的转换</p>
<ul>
<li>对于<code>int</code>编码的字符串对象来说，如果我们向对象执行了一些命令，使得这个对象保存的不再是整数值，而是一个字符串值</li>
<li>那么字符串对象的编码将从<code>int</code>变为<code>raw</code>。</li>
</ul>
<p><code>embstr</code>到<code>raw</code>的转换</p>
<ul>
<li>Redis没有为<code>embstr</code>编码的字符串对象编写任何相应的修改程序，所以<code>embstr</code>编码的字符串对象实际上是<strong>只读的</strong></li>
<li><code>embstr</code>编码的字符串对象在<strong>执行修改命令</strong>之后，总会变成一个<code>raw</code>编码的字符串对象。</li>
</ul>
<h4 id="8-2-2-字符串命令的实现"><a href="#8-2-2-字符串命令的实现" class="headerlink" title="8.2.2 字符串命令的实现"></a>8.2.2 字符串命令的实现</h4><p><img src="/2020/02/29/Redis-8-对象/200229_5.png" alt=""></p>
<h3 id="8-3-列表对象"><a href="#8-3-列表对象" class="headerlink" title="8.3 列表对象"></a>8.3 列表对象</h3><h4 id="8-3-1-列表对象的编码"><a href="#8-3-1-列表对象的编码" class="headerlink" title="8.3.1 列表对象的编码"></a>8.3.1 列表对象的编码</h4><p>列表对象的编码可以是<code>ziplist</code>或者<code>linkedlist</code></p>
<p><code>ziplist</code></p>
<ul>
<li><code>ziplist</code>编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点保存了一个列表元素</li>
<li><p>例如我们执行如下命令，创建一个包括三个元素的<code>numbers</code>列表键</p>
  <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; RPUSH numbers 1 <span class="string">"three"</span> 5</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
</li>
<li><p>结果如下图<br><img src="/2020/02/29/Redis-8-对象/200229_6.png" alt=""></p>
</li>
</ul>
<p><code>linkedlist</code></p>
<ul>
<li><code>linkedlist</code>编码的列表对象使用双端链表作为底层实现，每个链表节点都保存了一个<strong>字符串对象</strong>，而每个<strong>字符串对象</strong>都保存了一个<strong>列表元素</strong></li>
<li>还是上面的<code>numbers</code>列表，在<code>linkedlist</code>以下图结构存储<br><img src="/2020/02/29/Redis-8-对象/200229_7.png" alt=""></li>
</ul>
<h4 id="8-3-2-列表对象编码转换"><a href="#8-3-2-列表对象编码转换" class="headerlink" title="8.3.2 列表对象编码转换"></a>8.3.2 列表对象编码转换</h4><p>当列表对象可以<strong>同时满足</strong>以下两个条件时，列表对象使用<code>zip1ist</code>编码：</p>
<ul>
<li>列表对象保存的所有<strong>字符串元素的长度</strong>都小于64字节</li>
<li>列表对象保存的<strong>元素数量</strong>小于512个</li>
</ul>
<p><strong>不能</strong>满足上述两个条件的列表对象需要使用<code>linkedlist</code>编码。</p>
<p>当使用<code>ziplist</code>编码所需的两个条件的任意一个<strong>不能</strong>被满足时，对象的<strong>编码转换</strong>操作就会被执行，原本保存在<strong>压缩列表</strong>里的所有列表元素都会被<strong>转移</strong>并保存到<strong>双端链表</strong>里面，对象的<strong>编码</strong>也会从<code>zip1ist</code>变为<code>linkedlist</code></p>
<h4 id="8-3-3-列表命令的实现"><a href="#8-3-3-列表命令的实现" class="headerlink" title="8.3.3 列表命令的实现"></a>8.3.3 列表命令的实现</h4><p><img src="/2020/02/29/Redis-8-对象/200229_8.png" alt=""></p>
<h3 id="8-4-哈希对象"><a href="#8-4-哈希对象" class="headerlink" title="8.4 哈希对象"></a>8.4 哈希对象</h3><h4 id="8-4-1-哈希对象的编码"><a href="#8-4-1-哈希对象的编码" class="headerlink" title="8.4.1 哈希对象的编码"></a>8.4.1 哈希对象的编码</h4><p>哈希对象的<strong>编码</strong>可以是<code>ziplist</code>或者<code>hashtable</code></p>
<p><code>ziplist</code></p>
<ul>
<li><code>ziplist</code>编码的哈希对象使用<strong>压缩列表</strong>作为<strong>底层实现</strong></li>
<li>每当有键值对要<strong>新加入</strong>到哈希对象时<ul>
<li>程序会先将保存了<strong>键</strong>的压缩列表节点推入到压缩列表<strong>表尾</strong></li>
<li>然后再将保存了<strong>值</strong>的压缩列表节点推入到压缩列表<strong>表尾</strong></li>
</ul>
</li>
<li>保存了<strong>同一键值对</strong>的两个节点总是<strong>紧挨</strong>在一起</li>
<li><strong>先添加</strong>到哈希对象中的键值对会被放在压缩列表的<strong>表头</strong>方向，而<strong>后添加</strong>到哈希对象中的键值对会被放在压缩列表的<strong>表尾</strong>方向。</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_9.png" alt=""></li>
</ul>
<p><code>hashtable</code></p>
<ul>
<li><code>hashtable</code>编码的哈希对象使用<strong>字典</strong>作为底层实现</li>
<li>哈希对象中的每个键值对都使用一个<strong>字典键值对</strong>来保存<ul>
<li>字典的每个<strong>键</strong>都是一个<strong>字符串对象</strong>，对象中保存了键值对的键</li>
<li>字典的每个<strong>值</strong>都是一个<strong>字符串对象</strong>，对象中保存了键值对的值。</li>
</ul>
</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_10.png" alt=""></li>
</ul>
<h4 id="8-4-2-哈希对象编码转换"><a href="#8-4-2-哈希对象编码转换" class="headerlink" title="8.4.2 哈希对象编码转换"></a>8.4.2 哈希对象编码转换</h4><p>当哈希对象可以<strong>同时</strong>满足以下两个条件时，哈希对象使用<code>ziplist</code>编码：</p>
<ul>
<li>哈希对象保存的所有键值对的<strong>键和值</strong>的<strong>字符串长度</strong>都小于64字节</li>
<li>哈希对象保存的<strong>键值对数量</strong>小于512个</li>
</ul>
<p><strong>不能</strong>满足这两个条件的哈希对象需要使用<code>hashtable</code>编码。</p>
<p>当使用<code>ziplist</code>编码所需的两个条件的<strong>任意</strong>一个<strong>不能</strong>被满足时，对象的<strong>编码转换</strong>操作就会被执行，原本保存在<strong>压缩列表</strong>里的所有键值对都会被<strong>转移</strong>并保存到<strong>字典</strong>里面，对象的<strong>编码</strong>也会从<code>zip1ist</code>变为<code>hashtable</code></p>
<h4 id="8-4-2-哈希命令的实现"><a href="#8-4-2-哈希命令的实现" class="headerlink" title="8.4.2 哈希命令的实现"></a>8.4.2 哈希命令的实现</h4><p><img src="/2020/02/29/Redis-8-对象/200229_11.png" alt=""></p>
<h3 id="8-5-集合对象"><a href="#8-5-集合对象" class="headerlink" title="8.5 集合对象"></a>8.5 集合对象</h3><h4 id="8-5-1-集合对象的编码"><a href="#8-5-1-集合对象的编码" class="headerlink" title="8.5.1 集合对象的编码"></a>8.5.1 集合对象的编码</h4><p>集合对象的<strong>编码</strong>可以是<code>intset</code>或者<code>hashtable</code>。</p>
<p><code>intset</code></p>
<ul>
<li><code>intset</code>编码的集合对象使用<strong>整数集合</strong>作为底层实现，集合对象包含的所有元素都被保存在整数集合里面</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_12.png" alt=""></li>
</ul>
<p><code>hashtable</code></p>
<ul>
<li><code>hashtable</code>编码的集合对象使用<strong>字典</strong>作为底层实现</li>
<li>字典的每个<strong>键</strong>都是一个<strong>字符串对象</strong>，每个字符串对象包含了一个集合元素，而字典的<strong>值</strong>则全部被设置为<strong>NULL</strong>。</li>
</ul>
<h4 id="8-5-2-集合对象编码转换"><a href="#8-5-2-集合对象编码转换" class="headerlink" title="8.5.2 集合对象编码转换"></a>8.5.2 集合对象编码转换</h4><p>当集合对象可以<strong>同时满足</strong>以下两个条件时，对象使用<code>intset</code>编码</p>
<ul>
<li>集合对象保存的所有元素都是<strong>整数值</strong></li>
<li>集合对象保存的<strong>元素数量</strong>不超过512个</li>
</ul>
<p><strong>不能</strong>满足这两个条件的集合对象需要使用 <code>hashtable</code>编码。</p>
<h4 id="8-5-3-集合命令的实现"><a href="#8-5-3-集合命令的实现" class="headerlink" title="8.5.3 集合命令的实现"></a>8.5.3 集合命令的实现</h4><p><img src="/2020/02/29/Redis-8-对象/200229_13.png" alt=""><br><img src="/2020/02/29/Redis-8-对象/200229_14.png" alt=""></p>
<h3 id="8-6-有序集合对象"><a href="#8-6-有序集合对象" class="headerlink" title="8.6 有序集合对象"></a>8.6 有序集合对象</h3><h4 id="8-6-1-有序集合对象的编码"><a href="#8-6-1-有序集合对象的编码" class="headerlink" title="8.6.1 有序集合对象的编码"></a>8.6.1 有序集合对象的编码</h4><p>有序集合的<strong>编码</strong>可以是<code>ziplist</code>或者<code>skiplist</code></p>
<p><code>ziplist</code></p>
<ul>
<li><code>zip1ist</code>编码的压缩列表对象使用<strong>压缩列表</strong>作为底层实现</li>
<li>每个集合元素使用<strong>两个紧挨</strong>在一起的压缩列表节点来<strong>保存</strong>，第一个节点保存元素的<strong>成员</strong>（member），而第二个元素则保存元素的<strong>分值</strong>（score，作为排序的依据）</li>
<li>压缩列表内的集合元素按分值<strong>从小到大</strong>进行<strong>排序</strong></li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_15.png" alt=""></li>
</ul>
<p><code>skiplist</code></p>
<ul>
<li><code>skiplist</code>编码的有序集合对象使用<code>zset</code>结构作为底层实现，一个<code>zset</code>结构<strong>同时</strong>包含一个<strong>字典</strong>和一个<strong>跳跃表</strong></li>
<li><strong>跳跃表</strong>按分值<strong>从小到大</strong>保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：跳跃表节点的<code>object</code>属性保存了元素的<strong>成员</strong>，而跳跃表节点的<code>score</code>属性则保存了元素的<strong>分值</strong>。</li>
<li>字典为有序集合创建了一个<strong>从成员到分值的映射</strong>，字典中的每个键值对都保存了一个集合元素：<ul>
<li>字典的<strong>键</strong>保存了元素的<strong>成员</strong></li>
<li>而字典的<strong>值</strong>则保存了元素的<strong>分值</strong></li>
<li>通过这个字典，程序可以用 $O(1)$ 复杂度<strong>查找给定成员的分值</strong></li>
</ul>
</li>
<li>有序集合每个元素的<strong>成员</strong>都是一个<strong>字符串对象</strong>，而每个元素的<strong>分值</strong>都是一个<code>double</code>类型的<strong>浮点数</strong></li>
<li>这两种数据结构都会通过<strong>指针共享相同元素</strong>的成员和分值，所以同时使用跳跃表和字典来保存集合元素<strong>不会产生重复</strong>成员或者分值</li>
<li>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_16.png" alt=""></li>
</ul>
<h4 id="8-6-2-有序集合对象编码转换"><a href="#8-6-2-有序集合对象编码转换" class="headerlink" title="8.6.2 有序集合对象编码转换"></a>8.6.2 有序集合对象编码转换</h4><p>当有序集合对象可以<strong>同时</strong>满足以下两个条件时，对象使用<code>ziplist</code>编码</p>
<ul>
<li>有序集合保存的<strong>元素数量</strong>小于128个</li>
<li>有序集合保存的所有<strong>元素成员的长度</strong>都小于64字节</li>
</ul>
<p><strong>不能</strong>满足以上两个条件的有序集合对象将使用<code>skiplist</code>编码</p>
<h4 id="8-6-2-有序集合命令的实现"><a href="#8-6-2-有序集合命令的实现" class="headerlink" title="8.6.2 有序集合命令的实现"></a>8.6.2 有序集合命令的实现</h4><p><img src="/2020/02/29/Redis-8-对象/200229_17.png" alt=""></p>
<h3 id="8-7-类型检查与命令多态"><a href="#8-7-类型检查与命令多态" class="headerlink" title="8.7 类型检查与命令多态"></a>8.7 类型检查与命令多态</h3><p>Redis中用于操作键的命令可以分为两种</p>
<ol>
<li>其中一种命令可以对<strong>任何类型的键</strong>使用，例如<code>DEL</code>命令、<code>EXPIRE</code>命令、<code>RENAME</code>命令、<code>TYPE</code>命令等，这种命令背后的实现机制是<strong>命令多态</strong></li>
<li>另一种命令只能应用于<strong>特定类型</strong>的键，例如<code>SET</code>、<code>GET</code>、<code>APPEND</code>、<code>STRLEN</code>等命令只能对字符串键执行，这种命令的实现需要经过<strong>类型检查</strong></li>
</ol>
<h4 id="8-7-1-类型检查的实现"><a href="#8-7-1-类型检查的实现" class="headerlink" title="8.7.1 类型检查的实现"></a>8.7.1 类型检查的实现</h4><p>在执行一个<strong>类型特定的命令</strong>之前，Redis会先检查<strong>输入键</strong>的<strong>类型</strong>是否正确，然后再决定是否执行给定的命令。</p>
<p>类型特定命令所进行的<strong>类型检查</strong>是通过<code>redisObject</code>结构的<code>type</code>属性来实现的</p>
<ul>
<li>在执行一个类型特定命令之前，服务器会先检查输入数据库键的<strong>值对象</strong>是否为执行命令所需的类型</li>
<li>如果是的话，服务器就对键执行指定的命令；否则，服务器将<strong>拒绝</strong>执行命令，并向客户端返回一个<strong>类型错误</strong>。</li>
</ul>
<p>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_18.png" alt=""></p>
<h4 id="8-7-1-多态命令的实现"><a href="#8-7-1-多态命令的实现" class="headerlink" title="8.7.1 多态命令的实现"></a>8.7.1 多态命令的实现</h4><p>Redis除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据<strong>值对象</strong>的<strong>编码</strong>方式，选择正确的命令<strong>实现代码</strong>来执行命令。</p>
<p>如下图<br><img src="/2020/02/29/Redis-8-对象/200229_19.png" alt=""></p>
<h3 id="8-8-内存回收"><a href="#8-8-内存回收" class="headerlink" title="8.8 内存回收"></a>8.8 内存回收</h3><p>因为C语言并不具备自动内存回收功能，所以Redis在自己的对象系统中构建了一个<strong>引用计数技术</strong>实现的<strong>内存回收</strong>机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。</p>
<p>每个对象的引用计数信息由<code>redisObject</code>结构的 <code>refCount</code>属性记录（可以查看本章第一节）</p>
<p>对象的<strong>引用计数信息</strong>会随着对象的<strong>使用状态</strong>而不断变化：</p>
<ul>
<li>在<strong>创建</strong>一个新对象时，引用计数的值会被<strong>初始化</strong>为1</li>
<li>当对象被一个<strong>新程序</strong>使用时，它的引用计数值会被<strong>增一</strong></li>
<li>当对象<strong>不再</strong>被一个程序使用时，它的引用计数值会被<strong>减一</strong></li>
<li>当对象的引用计数值<strong>变为0</strong>时，对象所占用的内存会被<strong>释放</strong></li>
</ul>
<h3 id="8-9-对象共享"><a href="#8-9-对象共享" class="headerlink" title="8.9 对象共享"></a>8.9 对象共享</h3><p>除了用于实现引用计数内存回收机制之外，对象的<strong>引用计数</strong>属性还带有<strong>对象共享</strong>的作用。</p>
<p>在Redis中，让多个键共享同一个值对象需要执行以下两个步骤：</p>
<ol>
<li>将数据库键的<strong>值指针</strong>指向一个现有的<strong>值对象</strong>；</li>
<li>将被共享的<strong>值对象</strong>的<strong>引用计数增一</strong></li>
</ol>
<p>例如下图<br><img src="/2020/02/29/Redis-8-对象/200229_20.png" alt=""></p>
<p>Redis只<strong>对包含整数值的字符串对象</strong>进行<strong>共享</strong>，也就是<code>type</code>为<code>StringObject</code>，<code>encoding</code>为<code>int</code>。</p>
<p>目前来说， Redis会在<strong>初始化服务器</strong>时，<strong>创建</strong>一万个<strong>字符串对象</strong>，这些对象包含了从0到9999的所有整数值，当服务器需要用到值为0到9999的字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。</p>
<h3 id="8-10-对象的空转时长"><a href="#8-10-对象的空转时长" class="headerlink" title="8.10 对象的空转时长"></a>8.10 对象的空转时长</h3><p><code>redisObject</code>结构包含的最后一个属性为<code>lru</code>属性，该属性记录了对象<strong>最后一次被命令程序访问的时间</strong></p>
<p><code>OBJECT IDLETIME</code>命令可以打印出给定键的<strong>空转时长</strong>，这一空转时长就是通过将当前时间减去键的值对象的lru时间计算得出的：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SET msg <span class="string">"hello, world"</span></span><br><span class="line">OBJECT IDLETIME msg</span><br></pre></td></tr></table></figure></p>
<h3 id="8-11-本章重点"><a href="#8-11-本章重点" class="headerlink" title="8.11 本章重点"></a>8.11 本章重点</h3><ul>
<li>Redis数据库中的每个<strong>键值对</strong>的键和值都是一个<strong>对象</strong>。</li>
<li>Redis共有字符串、列表、哈希、集合、有序集合五种类型的<strong>对象</strong>，每种类型的对象至少都有两种或以上的<strong>编码方式</strong>，不同的编码可以在不同的使用场景上优化对象的使用效率。</li>
<li>服务器在执行某些命令之前，会先<strong>检查</strong>给定键的<strong>类型</strong>能否执行指定的命令。</li>
<li>Redis的对象系统带有<strong>引用计数</strong>实现的<strong>内存回收</strong>机制，当一个对象不再被使用时，该对象所占用的内存就会被自动释放</li>
<li>Redis会<strong>共享</strong>值为0到9999的字符串<strong>对象</strong></li>
<li>对象会记录自己的最后一次被访问的时间，这个时间可以用于计算对象的<strong>空转时间</strong>。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/27/MySQL-5-创建高性能的索引/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/27/MySQL-5-创建高性能的索引/" itemprop="url">[MySQL][5][创建高性能的索引]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-27T17:31:37+08:00">
                2020-02-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/27/MySQL-5-创建高性能的索引/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/27/MySQL-5-创建高性能的索引/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-5-章-创建高性能的索引"><a href="#第-5-章-创建高性能的索引" class="headerlink" title="第 5 章 创建高性能的索引"></a>第 5 章 创建高性能的索引</h2><p><strong>索引</strong>是存储引擎用于快速找到记录的一种数据结构。</p>
<p>索引对于良好的性能非常关键。尤其是当表中的数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但当数据量逐渐增大时，性能则会急速下降。</p>
<h3 id="5-1-索引基础"><a href="#5-1-索引基础" class="headerlink" title="5.1 索引基础"></a>5.1 索引基础</h3><p>要理解MySQL中索引是如何工作的，最简单的方法就是去看看一本书的“索引”部分如果想在一本书中找到某个特定主题，一般会先看书的“索引”，找到对应的页码，然后直接翻到那一页即可。MySQL中的索引与一本书的目录作用差不多，都是用来快速定位想要找的内容。</p>
<p>在MySQL中，存储引擎先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。例如要运行下面的查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> first_name <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>MySQL会先在索引上按值进行查找，找到<code>actor_id</code>等于<code>5</code>的索引项，这个索引项中包含数据行的地址，然后返回所有包含该值的数据行。</p>
<p>索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL只能高效地使用索引的最左前缀列。</p>
<h4 id="5-1-1-索引的类型"><a href="#5-1-1-索引的类型" class="headerlink" title="5.1.1 索引的类型"></a>5.1.1 索引的类型</h4><p>在MySQL中，索引是在存储引擎层而不是服务器层实现的。所以，并没有统一的索引标准：不同存储引擎的索引的工作方式并不一样，也不是所有的存储引擎都支持所有类型的索引。即使多个存储引擎支持同一种类型的索引，其底层的实现也可能不同。</p>
<h4 id="5-1-2-B-Tree索引"><a href="#5-1-2-B-Tree索引" class="headerlink" title="5.1.2 B-Tree索引"></a>5.1.2 B-Tree索引</h4><p>大多数 MySQL引擎都支持这种索引，它使用B-Tree数据结构来存储数据</p>
<p>B-Tree通常意味着所有的值都是按顺序存储的，并且每一个叶子页到根的距离相同。如下图所示</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_1.png" alt=""></p>
<p>B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点（图示并未画出）开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么是找到对应的值，要么该记录不存在。</p>
<p>叶子节点比较特别，它们的指针指向的是被索引的数据，而不是其他的节点页。此外，树的深度和表的大小直接相关。</p>
<p>B-Tree对索引列是顺序组织存储的，所以很适合査找范围数据。例如像“找出所有以I到K开头的名字”这样的查找效率会非常高。</p>
<h5 id="5-1-2-1-B-Tree索引的一个例子"><a href="#5-1-2-1-B-Tree索引的一个例子" class="headerlink" title="5.1.2.1 B-Tree索引的一个例子"></a>5.1.2.1 B-Tree索引的一个例子</h5><p>下面举一个B-Tree索引的例子</p>
<p>假设有如下数据表</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_2.png" alt=""></p>
<p>对于表中的每一行数据，索引中包含了<code>last_name</code>、<code>first_name</code>和<code>dob</code>列的值，下图显示了该索引是如何组织数据的存储的。</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_3.png" alt=""></p>
<p>请注意，索引对多个值进行排序的依据是<code>CREATE TABLE</code>语句中定义索引时列的顺序。看下最后两个条目，两个人的姓和名都一样，则根据他们的出生日期来排列顺序。</p>
<h5 id="5-1-2-2-可以使用B-Tree索引的查询类型"><a href="#5-1-2-2-可以使用B-Tree索引的查询类型" class="headerlink" title="5.1.2.2 可以使用B-Tree索引的查询类型"></a>5.1.2.2 可以使用B-Tree索引的查询类型</h5><ul>
<li><p>全值匹配</p>
<ul>
<li>全值匹配指的是和索引中的所有列进行匹配</li>
<li>例如前面提到的索引可用于查找姓名为Cuba Allen、出生于1960-01-01的人</li>
</ul>
</li>
<li><p>匹配最左前缀</p>
<ul>
<li>前面提到的索引可用于查找所有姓为Allen的人，即只使用索引的第一列</li>
</ul>
</li>
<li><p>匹配列前缀</p>
<ul>
<li>也可以只匹配某一列的值的开头部分。</li>
<li>例如前面提到的索引可用于查找所有以J开头的姓的人。这里也只使用了索引的列的开头。</li>
</ul>
</li>
<li><p>匹配范围值</p>
<ul>
<li>例如前面提到的索引可用于查找姓在Allen和Barrymore之间的人。这里也只使用了索引的第一列</li>
</ul>
</li>
<li><p>精确匹配某一列并范围匹配另外一列</p>
<ul>
<li>前面提到的索引也可用于查找所有姓为Allen，并且名字是字母K开头（比如Kim Karl等）的人。</li>
<li>即第一列<code>last_name</code>全匹配，第二列<code>first_name</code>范围匹配。</li>
</ul>
</li>
<li><p>只访问索引的查询</p>
<ul>
<li>B-Tree通常可以支持“只访问索引的查询”</li>
<li>它会直接读取索引中保存的数据信息，这样就无需访问数据行了</li>
</ul>
</li>
</ul>
<h5 id="5-1-2-3-B-Tree索引的其他作用"><a href="#5-1-2-3-B-Tree索引的其他作用" class="headerlink" title="5.1.2.3 B-Tree索引的其他作用"></a>5.1.2.3 B-Tree索引的其他作用</h5><p>因为索引树中的节点是有序的，所以除了按值查找之外，索引还可以用于查询中的<code>ORDER BY</code>操作。一般来说，如果B-Tree可以按照某种方式查找到值，那么也可以按照这种方式用于排序。所以，如果<code>ORDER BY</code>子句满足前面列出的几种査询类型，则这个索引也可以满足对应的排序需求</p>
<h5 id="5-1-2-4-使用B-Tree索引的限制"><a href="#5-1-2-4-使用B-Tree索引的限制" class="headerlink" title="5.1.2.4 使用B-Tree索引的限制"></a>5.1.2.4 使用B-Tree索引的限制</h5><ul>
<li><p>如果不是按照索引的最左列开始查找，则无法使用索引。例如上面例子中的索引无法用于查找名字为Bill的人，也无法查找某个特定生日的人，因为这两列都不是最左数据列。类似地，也无法查找姓氏以某个字母结尾的人。</p>
</li>
<li><p>不能跳过索引中的列。也就是说，前面所述的索引无法用于查找姓为Smith并且在某个特定日期出生的人。如果不指定名(<code>first name</code>)，则MySQL只能使用索引的第一列。</p>
</li>
<li><p>如果查询中有某个列的范围查询，则其右边所有列都无法使用索引优化查找。例如有查询 <code>WHERE last_name=&#39;Smith&#39; AND first name LIKE&#39;J%&#39; AND dob != &#39;1976-12-23&#39;</code>，这个查询只能使用索引的前两列，因为这里<code>LIKE</code>是一个范围条件</p>
</li>
</ul>
<h4 id="5-1-3-哈希索引"><a href="#5-1-3-哈希索引" class="headerlink" title="5.1.3 哈希索引"></a>5.1.3 哈希索引</h4><p>哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针</p>
<p>在MySQL中，只有Memory引擎显式支持哈希索引。这也是Memory引擎表的默认索引类型，Memory引擎同时也支持B-Tree索引。如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。</p>
<h5 id="5-1-3-4-哈希索引的限制"><a href="#5-1-3-4-哈希索引的限制" class="headerlink" title="5.1.3.4 哈希索引的限制"></a>5.1.3.4 哈希索引的限制</h5><ul>
<li><p>哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。</p>
</li>
<li><p>哈希索引数据并不是按照索引值顺序存储的，所以也就无法用于排序。</p>
</li>
<li><p>哈希索引也不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。</p>
</li>
<li><p>哈希索引只支持等值比较查询，包括<code>=</code>、<code>IN()</code>。也不支持任何范围查询，例如，<code>WHERE price &gt; 18</code></p>
</li>
<li><p>如果哈希冲突很多的话，一些索引维护操作的代价也会很高。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。</p>
</li>
</ul>
<h5 id="5-1-3-4-哈希索引与InnoDB"><a href="#5-1-3-4-哈希索引与InnoDB" class="headerlink" title="5.1.3.4 哈希索引与InnoDB"></a>5.1.3.4 哈希索引与InnoDB</h5><p>InnoDB引擎有一个特殊的功能叫做“自适应哈希索引”。当InnoDB注意到某些索引值被使用得非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这样就让B-Tree索引也具有哈希索引的一些优点，比如快速的哈希查找。这是一个完全自动的、内部的行为，用户无法控制或者配置，不过如果有必要完全可以关闭该功能。</p>
<h3 id="5-2-索引的优点"><a href="#5-2-索引的优点" class="headerlink" title="5.2 索引的优点"></a>5.2 索引的优点</h3><p>索引可以让服务器快速地定位到表的指定位置。根据创建索引的数据结构不同，索引也有一些其他的附加作用。</p>
<p>例如B-Tree索引，最常见的B-Tree索引，按照顺序存储数据，所以MySQL可以用来做<code>ORDER BY</code>和<code>GROUP BY</code>操作。因为数据是有序的，所以B-Tree也就会将相关的列值都存储在一起。最后，因为索引中存储了实际的列值，所以某些査询只使用索引就能够完成全部查询。</p>
<p>泛泛而谈，索引有如下优点</p>
<ol>
<li>索引大大减少了服务器需要扫描的数据量。</li>
<li>索引可以帮助服务器避免排序和临时表。</li>
<li>索引可以将随机I/O变为顺序I/O。</li>
</ol>
<p>Lahdenmaki和Leach在书中介绍了如何评价一个索引是否适合某个查询的“三星系统”</p>
<ul>
<li>索引将相关的记录放到一起则获得一星</li>
<li>如果索引中的数据顺序和查找中的排列顺序一致则获得二星</li>
<li>如果索引中的列包含了查询中需要的全部列则获得三星</li>
</ul>
<h3 id="5-3-高性能的索引策略"><a href="#5-3-高性能的索引策略" class="headerlink" title="5.3 高性能的索引策略"></a>5.3 高性能的索引策略</h3><p>正确地创建和使用索引是实现髙性能査询的基础。下面介绍高性能使用索引的策略。</p>
<h4 id="5-3-1-独立的列"><a href="#5-3-1-独立的列" class="headerlink" title="5.3.1 独立的列"></a>5.3.1 独立的列</h4><p>独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。如果查询中使用的不是独立的列，则MySQL不会使用索引。下面就是两个反例</p>
<p>反例1，表达式，无法使用索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> actor_id <span class="keyword">FROM</span> actor <span class="keyword">WHERE</span> actor_id + <span class="number">1</span> = <span class="number">5</span>;</span><br></pre></td></tr></table></figure></p>
<p>反例2，函数的参数，无法使用索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">WHERE</span> <span class="keyword">TO_DAYS</span>(<span class="keyword">CURRENT_DATE</span>) - <span class="keyword">TO_DAYS</span>(date_col) &lt;= <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-3-2-前缀索引和索引选择性"><a href="#5-3-2-前缀索引和索引选择性" class="headerlink" title="5.3.2 前缀索引和索引选择性"></a>5.3.2 前缀索引和索引选择性</h4><p>有时候需要索引很长的字符列，这会让索引变得大且慢。通常可以索引开始的部分字符，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>下面演示一下如何创建前缀索引<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> city_demo <span class="keyword">ADD</span> <span class="keyword">KEY</span> (city(<span class="number">7</span>));</span><br></pre></td></tr></table></figure></p>
<p>但使用前缀索引会降低索引的选择性。索引的选择性是指，不重复的索引值和数据表的记录总数的比值(T)，范围从l/T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行。无重复索引的选择性是1，这是最好的索引选择性，性能也是最好的。</p>
<p>后缀索引：有时候后缀索引（suffix index）也有用途（例如，找到某个域名的所有电子邮件地址）。MySQL原生并不支持反向索引，但是可以把宇符串反转后存储，并基于此建立前缀索引。</p>
<h4 id="5-3-3-多列索引"><a href="#5-3-3-多列索引" class="headerlink" title="5.3.3 多列索引"></a>5.3.3 多列索引</h4><p>在多个列上建立独立的单列索引大部分情况下并不能提高MySQL的查询性能。MySQL5.0和更新版本引入了一种叫“索引合并”（index merge）的策略，一定程度上可以使用表上的多个单列索引来定位指定的行。更早版本的MySQL只能使用其中某一个单列索引，然而这种情况下没有哪一个独立的单列索引是非常有效的。</p>
<p>索引合并虽然是一种很好的策略，但是有时成本比较高。如果在<code>EXPLAIN</code>中看到有索引合并，应该好好检查一下查询和表的结构，看是不是已经是最优的。</p>
<h4 id="5-3-4-选择合适的索引列顺序"><a href="#5-3-4-选择合适的索引列顺序" class="headerlink" title="5.3.4 选择合适的索引列顺序"></a>5.3.4 选择合适的索引列顺序</h4><p>正确的顺序依赖于使用该索引的查询，并且同时需要考虑如何更好地满足排序和分组的需要。</p>
<p>在一个多列B-Tree索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列，等等。所以，索引可以按照升序或者降序进行扫描，以满足精确符合列顺序的<code>ORDER BY</code>、<code>GROUP BY</code>和<code>DISTINCT</code>等子句的查询需求。</p>
<p>对于如何选择索引的列顺序有一个经验法则：将选择性最高的列放到索引最前列。</p>
<h4 id="5-3-5-聚簇索引"><a href="#5-3-5-聚簇索引" class="headerlink" title="5.3.5 聚簇索引"></a>5.3.5 聚簇索引</h4><p>当表有聚簇索引时，它的数据行实际上存放在索引的叶子页（leaf page）中。术语“聚簇”表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p>
<p>下图展示了聚簇索引中的记录是如何存放的。注意到，叶子页包含了行的全部数据，但是节点页只包含了索引列。在这个案例中，索引列包含的是整数值。</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_4.png" alt=""></p>
<p>InnoDB将通过主键聚集数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引代替。如果没有这样的索引， InnoDB会隐式定义一个主键来作为聚簇索引。</p>
<p>InnoDB只聚集在同一个页面中的记录包含相邻键值的页面可能在物理空间中相距甚远。但是通常前页会保存后页的指针，这样方便寻找。</p>
<h4 id="5-3-5-1-聚簇索引的优点和缺点"><a href="#5-3-5-1-聚簇索引的优点和缺点" class="headerlink" title="5.3.5.1  聚簇索引的优点和缺点"></a>5.3.5.1  聚簇索引的优点和缺点</h4><p>优点</p>
<ul>
<li>可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户ID来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如没有使用聚簇索引，则每封邮件都可能导致一次磁盘I/O。</li>
<li>数据访问更快。聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找要快。</li>
<li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值（这点要后面再解释，看不懂没关系）。</li>
</ul>
<p>缺点</p>
<ul>
<li>如果数据全部都放在内存中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li>
<li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。</li>
<li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置</li>
<li>聚簇索引可能导致全表扫描变慢，比如由于页分裂导致数据存储不连续的时候。</li>
<li>二级索引（非聚簇索引，也就是此表上的其他索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列</li>
<li>二级索引访问需要两次索引查找，而不是一次。因为通过二级索引査找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行。这里做了重复的工作：两次B-Tree查找而不是一次。</li>
</ul>
<h4 id="5-3-5-2-InnoDB与MyISAM数据分布对比"><a href="#5-3-5-2-InnoDB与MyISAM数据分布对比" class="headerlink" title="5.3.5.2  InnoDB与MyISAM数据分布对比"></a>5.3.5.2  InnoDB与MyISAM数据分布对比</h4><p>InnoDB是使用聚簇索引的存储引擎，而MyISAM不使用。通过它们的对比，我们将更好的理解聚簇索引的概念和存储方式。</p>
<p>这里为了方便理解，我们先写一个样例表<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> layout_test(</span><br><span class="line">    col1 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    col2 <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(col1),</span><br><span class="line">    <span class="keyword">KEY</span>(col2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>首先介绍MyISAM。</p>
<p>当插入数据时，MyISAM按照数据插入的顺序存储在磁盘上，如下图。<br><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_5.png" alt=""></p>
<p>这种分布方式下，主键索引和非主键索引其实结构上没什么区别，如下图。</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_6.png" alt=""></p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_7.png" alt=""></p>
<p>然后是InnoDB</p>
<p>首先，它的主键索引是聚簇索引，如下图结构</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_8.png" alt=""></p>
<p>它其实就是整张表，表中所有的数据都存储在这颗B-Tree中。聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。</p>
<p>InnoDB的二级索引和聚簇索引很不相同。InnoDB二级索引的叶子节点中存储的不是“行指针”，而是主键值，并以此作为指向行的“指针”这样的策略减少了当出现行移动或者数据页分裂时二级索引的维护工作。但是使用主键值当作指针会让二级索引占用更多的空间。</p>
<p>下面是一个二级索引的结构图</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_9.png" alt=""></p>
<p>最后，我们通过下图来看看InnoDB和MyISAM保存数据和索引的区别</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_10.png" alt=""></p>
<h4 id="5-3-5-3-InnoDB主键的选择"><a href="#5-3-5-3-InnoDB主键的选择" class="headerlink" title="5.3.5.3 InnoDB主键的选择"></a>5.3.5.3 InnoDB主键的选择</h4><p>如果正在使用InnoDB表并且没有什么数据需要聚集，那么可以定义一个代理键（surrogate key）作为主键，这种主键的数据应该和应用无关，最简单的方法是使用<code>AUTO_INCREMENT</code>自增列。这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。</p>
<p>原因如下图，因为主键的值是顺序的，所以InnoDB把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时，下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满。<br><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_11.png" alt=""></p>
<p>但是，假如我们选择一个相对随机无插入顺序的主键呢？</p>
<p>如下图<br><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_12.png" alt=""></p>
<p>这将造成大量的随机I/O，大量的页分裂操作，并产生很多磁盘碎片。</p>
<p>因此，尽可能使用单调增加的聚簇键的值来插入新行。</p>
<h4 id="5-3-6-覆盖索引"><a href="#5-3-6-覆盖索引" class="headerlink" title="5.3.6 覆盖索引"></a>5.3.6 覆盖索引</h4><p>如果索引的叶子节点中已经包含要查询的数据，那么就没有必要再回表查询。如果一个索引包含所有需要查询的字段的值，我们就称之为“覆盖索引”。</p>
<h5 id="5-3-6-1-覆盖索引的好处"><a href="#5-3-6-1-覆盖索引的好处" class="headerlink" title="5.3.6.1 覆盖索引的好处"></a>5.3.6.1 覆盖索引的好处</h5><ul>
<li><p>索引条目通常远小于数据行大小，所以如果只需要读取索引，那MySQL就会极大地减少数据访问量。</p>
</li>
<li><p>因为索引是按照列值顺序存储的（至少在单个页内是如此），所以对于I/O密集型的范围查询会比随机从磁盘读取每一行数据的I/O要少得多。</p>
</li>
<li><p>由于InnoDB的聚簇索引，覆盖索引对InnoDB表特别有用。InnoDB的二级索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。</p>
</li>
</ul>
<h4 id="5-3-7-使用索引扫描来做排序"><a href="#5-3-7-使用索引扫描来做排序" class="headerlink" title="5.3.7 使用索引扫描来做排序"></a>5.3.7 使用索引扫描来做排序</h4><p>MySQL可以使用同一个索引既满足排序，又用于查找行。因此，如果可能，设计索引时应该尽可能地同时满足这两种任务，这样是最好的。</p>
<p>只有当索引的列顺序和<code>ORDER BY</code>子句的顺序完全一致，并且所有列的排序方向都一样时，MySQL才能够使用索引来对结果做排序。如果查询需要关联多张表，则只有当<code>ORDER BY</code>子句引用的字段全部为第一个表时，才能使用索引做排序。<code>ORDER BY</code>子句和查找型查询的限制是一样的：需要满足索引的最左前缀的要求；否则，MySQL都需要执行排序操作，而无法利用索引排序。</p>
<p>但是同时还要注意与<code>where</code>条件的交互，假设表<code>rental</code>有索引<code>(rental_date, inventory_id, customer_id)</code>，下面举例说明</p>
<p>下面这个查询可以使用索引，因为第一列被指定为了常数<code>rental_date=&#39;2015_05_25&#39;</code>，然后使用第二列排序，将两列组合起来就形成了索引的最左前缀。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">... where rental_date = '2005-05-25' ORDER BY inventory_id;</span><br></pre></td></tr></table></figure></p>
<p>下面这个查询也没问题，因为<code>ORDER BY</code>使用的两列就是索引的最左前缀：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE rental_date &gt; '2005-05-25' ORDER BY rental_date, inventory_id;</span><br></pre></td></tr></table></figure></p>
<p>下面是一些不能使用索引做排序的查询</p>
<ul>
<li><p>下面这个查询的<code>ORDER BY</code>子句中引用了一个不在索引中的列</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE rental_date = '2005-05-25' ORDER BY inventory_id, staff_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面这个查询的<code>WHERE</code>和<code>ORDER BY</code>中的列无法组合成索引的最左前缀</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE rental_date = '2005-05-25' ORDER BY customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面这个查询在索引列的第一列上使用了范围条件，这个列倒是可以使用索引，但是会导致后面的列无法使用</p>
  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE rental_date &gt; '2005-05-25' ORDER BY inventory_id, customer_id;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面这个查询在<code>inventory_id</code>列上有多个等于条件，对于排序来说，这也是一种范围查询</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE rental_date = '2005-05-25' AND inventory_id IN(1, 2) ORDER BY customer_id</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-3-8-压缩（前缀压缩）索引"><a href="#5-3-8-压缩（前缀压缩）索引" class="headerlink" title="5.3.8 压缩（前缀压缩）索引"></a>5.3.8 压缩（前缀压缩）索引</h4><p>MyISAM使用前缀压缩来减少索引的大小，从而让更多的索引可以放入内存中，这在某些情况下能极大地提高性能。默认只压缩字符串，但通过参数设置也可以对整数做压缩。</p>
<p>MyISAM压缩每个索引块的方法是，先完全保存索引块中的第一个值，然后将其他值和第一个值进行比较得到相同前缀的字节数和剩余的不同后缀部分，把这部分存储起来即可。例如，索引块中的第一个值是<code>perform</code>，第二个值是<code>performance</code>，那么第二个值的前缀压缩后存储的是类似<code>7, ance</code>这样的形式。</p>
<h4 id="5-3-9-重复索引"><a href="#5-3-9-重复索引" class="headerlink" title="5.3.9 重复索引"></a>5.3.9 重复索引</h4><p>重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引。</p>
<p>MySQL允许在相同列上创建重复索引，但是这会大大影响性能。因为MySQL需要单独维护重复的索引，并且优化器在优化查询的时候也需要逐个地进行考虑。</p>
<p>应该避免这样创建重复索引，发现以后也应该立即移除。</p>
<p>例如下图<br><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_13.png" alt=""></p>
<p>一个经验不足的用户可能是想创建一个主键，先加上唯一限制，然后再加上索引以供查询使用。事实上，MySQL的唯一限制和主键限制都是通过索引实现的，因此，上面的写法实际上在相同的列上创建了三个重复的索引。</p>
<h4 id="5-3-10-冗余索引"><a href="#5-3-10-冗余索引" class="headerlink" title="5.3.10 冗余索引"></a>5.3.10 冗余索引</h4><p>冗余索引和重复索引有一些不同。如果创建了索引<code>(A, B)</code>，再创建索引<code>(A)</code>就是冗余索引，因为这只是前一个索引的前缀索引。但是如果再创建索引<code>(B,A)</code>，则不是冗余索引。另外，将一个索引扩展为<code>(A, ID)</code>，其中<code>ID</code>是主键，对于InnoDB来说主键列已经包含在二级索引中了，所以这也是冗余的。</p>
<p>但也有时候出于性能方面的考虑需要冗余索引，因为扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能。</p>
<p>建立过多冗余索引的缺点是导致写操作过慢</p>
<h4 id="5-3-11-未使用的索引"><a href="#5-3-11-未使用的索引" class="headerlink" title="5.3.11 未使用的索引"></a>5.3.11 未使用的索引</h4><p>可能还会有一些服务器永远不用的索引。这样的索引完全是累赘，建议考虑删除。</p>
<h4 id="5-3-12-索引和锁"><a href="#5-3-12-索引和锁" class="headerlink" title="5.3.12 索引和锁"></a>5.3.12 索引和锁</h4><p>InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行的次数，从而减少锁的数量。</p>
<p>此外，InnoDB在二级索引上使用共享（读）锁，但访问主键索引需要排他（写）锁。</p>
<h3 id="5-4-索引案例学习"><a href="#5-4-索引案例学习" class="headerlink" title="5.4 索引案例学习"></a>5.4 索引案例学习</h3><p>假设要设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色，等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许根据用户的最后在线时间、其他会员对用户的评分等对用户进行排序并对结果进行限制。如何设计索引满足上面的复杂需求呢？</p>
<h4 id="5-4-1-支持多种过滤条件"><a href="#5-4-1-支持多种过滤条件" class="headerlink" title="5.4.1 支持多种过滤条件"></a>5.4.1 支持多种过滤条件</h4><p>现在需要看看这两方面</p>
<ol>
<li>哪些列拥有很多不同的取值，在有更多不同值的列上创建索引的选择性会更好。</li>
<li>哪些列在<code>WHERE</code>子句中出现得最频繁，更频繁则用到此索引的机会越多</li>
</ol>
<p>按照这两点，我们筛选出了<code>(sex, country)</code>列作为前缀。</p>
<p><code>sex</code>的选择性很低，但是为什么要选择它呢？因为我们有方法去绕过它：</p>
<ul>
<li>如果某个査询不限制性别，那么可以通过在查询条件中新增<code>AND SEX IN(&#39;m&#39;, &#39;f&#39;)</code>来让MySQL选择该索引。</li>
<li>这样写并不会过滤任何行，和没有这个条件时返回的结果相同。</li>
<li>但是必须加上这个列的条件，MySQL才能够匹配索引的最左前缀</li>
</ul>
<p>接下来我们又选出了<code>(sex, country, age)</code>，<code>(sex, country, region, age)</code>，<code>(sex, country, city, age)</code>这样的组合。由于我们有了<code>(sex, country, age)</code>，而<code>age</code>并不会导致性能的太多下降，所以我们去掉<code>(sex, country)</code></p>
<p>我们一直把<code>age</code>放到索引的最后面，<code>age</code>有什么特殊的地方吗</p>
<ul>
<li>前面提到的列在<code>WHERE</code>子句中都是等于条件，但是<code>age</code>列则多半是范围查询（例如查找年龄在18-25岁之间的人）</li>
<li>原则上，尽可能将需要做范围查询的列放到索引的后面，以便优化器能使用尽可能多的索引列。</li>
</ul>
<h4 id="5-4-2-避免多个范围条件"><a href="#5-4-2-避免多个范围条件" class="headerlink" title="5.4.2 避免多个范围条件"></a>5.4.2 避免多个范围条件</h4><p>假设我们有一个<code>last_online</code>列并希望通过下面的查询显示在过去几周上线过的用户<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">WHERE eye_color IN('brown', 'blue', 'hazel')</span><br><span class="line">AND hair color IN（'black', 'red', 'blonde', 'brown')</span><br><span class="line">AND sex IN('M', 'F')</span><br><span class="line">AND last_online &gt; DATE_SUB(NOW(), INTERVAL 7 DAY)</span><br><span class="line">ANd age BETWEEN 18 AND 25</span><br></pre></td></tr></table></figure></p>
<p>这个查询有一个问题：它有两个范围条件，<code>last_online</code>列和<code>age</code>列，MySQL可以使用<code>last_online</code>列索引或者<code>age</code>列索引，但无法同时使用它们。</p>
<p>我们可以用下面的方法避免这个问题</p>
<ul>
<li>我们需要事先计算好一个<code>active</code>列，这个字段由定时任务来维护。当用户每次登录时，将对应值设置为1，并且定时任务定时将过去连续七天未曾登录的用户的值设置为0。</li>
<li>这个方法可以让MySQL使用<code>(active,sex, country,age)</code>索引。</li>
<li>并且我们还可以使用上面5.4.1提到的方法来绕过<code>active</code>属性</li>
</ul>
<h4 id="5-4-3-优化排序"><a href="#5-4-3-优化排序" class="headerlink" title="5.4.3 优化排序"></a>5.4.3 优化排序</h4><p>使用文件排序对小数据集是很快的，但如果一个查询匹配的结果有上百万行的话就很慢了。所以根据5.3节我们可以创建一些索引用于排序。</p>
<p>但是分页是另一个性能瓶颈，例如下面的查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1 <span class="keyword">FROM</span> <span class="keyword">profiles</span> <span class="keyword">WHERE</span> sex = <span class="string">'M'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> rating <span class="keyword">LIMIT</span> <span class="number">100000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>无论如何创建索引，这种査询都是个严重的问题。</li>
<li>因为随着偏移量的增加，MySQL需要花费大量的时间来扫描需要丢弃的数据。反范式化、预先计算和缓存可能是解决这类查询的仅有策略。</li>
</ul>
<p>优化这类索引的另一个比较好的策略是使用延迟关联，通过使用覆盖索引查询返回需要的主键，再根据这些主键关联原表获得需要的行。如下所示</p>
<p><img src="/2020/02/27/MySQL-5-创建高性能的索引/200227_14.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/26/MySQL-4-Schema与数据类型优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/26/MySQL-4-Schema与数据类型优化/" itemprop="url">[MySQL][4][Schema与数据类型优化]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-26T11:36:41+08:00">
                2020-02-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/26/MySQL-4-Schema与数据类型优化/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/26/MySQL-4-Schema与数据类型优化/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-4-章-Schema与数据类型优化"><a href="#第-4-章-Schema与数据类型优化" class="headerlink" title="第 4 章 Schema与数据类型优化"></a>第 4 章 Schema与数据类型优化</h2><p>良好的逻辑设计和物理设计是高性能的基石，应该根据系统将要执行的查询语句来设计schema，这往往需要权衡各种因素。例如，反范式的设计可以加快某些类型的查询，但同时可能使另一些类型的查询变慢。比如添加计数表和汇总表是一种很好的优化查询的方式但这些表的维护成本可能会很高。 </p>
<h3 id="4-1-选择优化的数据类型"><a href="#4-1-选择优化的数据类型" class="headerlink" title="4.1 选择优化的数据类型"></a>4.1 选择优化的数据类型</h3><p>不管存储哪种类型的数据，下面几个简单的原则都有助于做出更好的选择。</p>
<ul>
<li><p>更小的逋常更好。</p>
<ul>
<li>一般情况下，应该尽量使用可以正确存储数据的最小数据类型。更小的数据类型通常更快，因为它们占用更少的磁盘、内存和CPU缓存，并且处理时需要的CPU周期也更少。</li>
<li>但是要确保没有低估需要存储的值的范围</li>
</ul>
</li>
<li><p>简单就好</p>
<ul>
<li>简单数据类型的操作通常需要更少的CPU周期。例如，整型比字符操作代价更低，因为字符集和校对规则使字符比较比整型比较更复杂。</li>
<li>这里有两个例子：一个是应该使用MySQL内建的类型而不是字符串来存储日期和时间，另外一个是应该用整型存储IP地址。</li>
</ul>
</li>
<li><p>尽量避免NULL</p>
<ul>
<li>很多表都包含可为NULL的列，即使应用程序并不需要保存NULL也是如此，这是因为可为NULL是列的默认属性。</li>
<li>如果查询中包含可为NULL的列，对MySQL来说更难优化，因为可为NULL的列使得索引、索引统计和值比较都更复杂。</li>
</ul>
</li>
</ul>
<p>在为列选择数据类型时，要遵循如下顺序</p>
<ol>
<li>选择确定合适的大类型：数字、字符串、时间等</li>
<li><p>选择具体的类型。很多MySQL的数据类型可以存储相同类型的数据，只是存储的长度和范围不一样、允许的精度不同。</p>
<p>MySQL为了兼容性支持很多别名，例如 INTEGER、B00L，以及 NUMERIC它们都只是别名。这些别名可能令人不解，但不会影响性能。</p>
</li>
</ol>
<h4 id="4-1-1-整数类型"><a href="#4-1-1-整数类型" class="headerlink" title="4.1.1 整数类型"></a>4.1.1 整数类型</h4><p>如果存储整数，可以使用这几种整数类型：<code>TINYINT</code>,<code>SMALLINT</code>,<code>MEDIUMINT</code>,<code>INT</code>,<code>BIGINT</code>。分别使用8，<br>16,24,32,64位存储空间。</p>
<p>整数类型有可选的<code>UNSIGNED</code>属性，表示不允许负值，这大致可以使正数的上限提高一倍。</p>
<p>但是在<strong>运算</strong>时，整数计算一般使用64位的 BIGINT整数，即使在32位环境也是如此。</p>
<p>MySQL可以为整数类型指定宽度，例如<code>INT(11)</code>，对大多数应用这是没有意义的：它不会限制值的合法范围，只是规定了MySQL的一些交互工具（例如MySQL命令行客户端）用来显示字符的个数。对于存储和计算来说，<code>INT(1)</code>和<code>INT(20)</code>是相同的。</p>
<h4 id="4-1-2-实数类型"><a href="#4-1-2-实数类型" class="headerlink" title="4.1.2 实数类型"></a>4.1.2 实数类型</h4><p>实数是带有小数部分的数字。然而，它们不只是为了存储小数部分；也可以使用<code>DECIMAL</code>存储比<code>BIGINT</code>还大的整数。<code>FLOAT</code>和<code>DOUBLE</code>类型支持使用标准的浮点运算进行近似计算。<code>DECIMAL</code>类型用于存储精确的小数， DECIMAL类型支持精确计算。</p>
<p>因为CPU不支持对<code>DECIMAL</code>的直接计算，MySQL服务器自身实现了<code>DECIMAL</code>的高精度计算。相对而言，CPU直接支持原生浮点计算，所以浮点运算明显更快。</p>
<p>浮点和<code>DECIMAL</code>类型都可以指定精度。对于<code>DECIMAL</code>列，可以指定小数点前后所允许的最大位数。这会影响列的空间消耗。 MySQL将数字打包保存到一个二进制字符串中（每4个字节存9个数字）。例如，<code>DECIMAL(18,9)</code>小数点两边将各存储9个数字，一共使用9个字节：小数点前的数字用4个字节，小数点后的数字用4个字节，小数点本身占1个字节。MySQL5.0和更高版本中的<code>DECIMAL</code>类型允许最多65个数字。</p>
<p>有多种方法可以指定浮点列所需要的精度，这会使得MySQL悄悄选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义是非标准的，所以对于浮点数我们建议只指定数据类型不指定精度。</p>
<p>浮点类型在存储同样范围的值时，通常比<code>DECIMAL</code>使用更少的空间。<code>FLOAT</code>使用4个字节存储。<code>DOUBLE</code>占用8个字节，相比<code>FLOAT</code>有更高的精度和更大的范围。但是对于浮点计算，MySQL统一使用<code>DOUBLE</code>作为内部浮点计算的类型。</p>
<h4 id="4-1-3-字符串类型"><a href="#4-1-3-字符串类型" class="headerlink" title="4.1.3 字符串类型"></a>4.1.3 字符串类型</h4><p><code>VARCHAR</code>和<code>CHAR</code>是两种最主要的字符串类型。不幸的是，很难精确地解释这些值是怎么存储在磁盘和内存中的，因为这跟存储引擎的具体实现有关。</p>
<h5 id="4-1-3-1-VARCHAR类型"><a href="#4-1-3-1-VARCHAR类型" class="headerlink" title="4.1.3.1 VARCHAR类型"></a>4.1.3.1 VARCHAR类型</h5><p><code>VARCHAR</code>类型用于存储可变长字符串，是最常见的字符串数据类型。它比定长类型更节省空间，因为它仅使用必要的空间。<code>VARCHAR</code>需要使用1或2个额外字节记录字符串的长度：假设采用latin1字符集，一个<code>VARCHAR(10)</code>的列需要11个字节的存储空间。<code>VARCHAR(1000)</code>的列则需要1002个字节，因为需要2个字节存储长度信息。</p>
<p><code>VARCHAR</code>节省了存储空间，所以对性能也有帮助。但是，由于行是变长的，在<code>UPDATE</code>时可能使行变得比原来更长，这就导致需要做额外的工作。如果一个行占用的空间增长，并且在页内没有更多的空间可以存储，在这种情况下，MyISAM会将行拆成不同的片段存储，InnoDB则需要分裂页来使行可以放进页内。</p>
<p>下面这些情况下使用<code>VARCHAR</code>是合适的</p>
<ul>
<li>字符串列的最大长度比平均长度大很多</li>
<li>列的更新很少，所以碎片不是问题</li>
<li>使用了像UTF-8这样复杂的字符集，每个字符都使用不同的字节数进行存储</li>
</ul>
<p>此外</p>
<ul>
<li>MySQL在存储和检索时会保留末尾空格。</li>
<li>InnoDB则更灵活，它可以把过长的<code>VARCHAR</code>存储为<code>BLOB</code></li>
</ul>
<h5 id="4-1-3-2-CHAR类型"><a href="#4-1-3-2-CHAR类型" class="headerlink" title="4.1.3.2 CHAR类型"></a>4.1.3.2 CHAR类型</h5><p><code>CHAR</code>类型是定长的：MySQL总是根据定义的字符串长度分配足够的空间。当存储<code>CHAR</code>值时，MySQL会删除所有的末尾空格</p>
<p><code>CHAR</code>适合存储的类型</p>
<ul>
<li>所有值都接近同一个长度。例如，<code>CHAR</code>非常适合存储密码的<code>MD5</code>值，因为这是一个定长的值。</li>
<li>对于经常变更的数据，<code>CHAR</code>也比<code>VARCHAR</code>更好，因为定长的<code>CHAR</code>类型不容易产生碎片。</li>
<li>对于非常短的列，<code>CHAR</code>比<code>VARCHAR</code>在存储空间上也更有效率。例如用<code>CHAR(1)</code>来存储只有<code>Y</code>和<code>N</code>的值，只需要一个字节，但是<code>VARCHAR(1)</code>却需要两个字节，因为还有一个记录长度的额外字节。</li>
</ul>
<p>与<code>CHAR</code>和<code>VARCHAR</code>类似的类型还有<code>BINARY</code>和<code>VARBINARY</code>，它们存储的是二进制字符串二进制字符串跟常规字符串非常相似，但是二进制字符串存储的是字节码而不是字符。</p>
<p>二进制优势体现在大小写敏感上。并且二进制比较比字符比较简单很多，所以也就更快。</p>
<h5 id="4-1-3-3-BLOB和TEXT类型"><a href="#4-1-3-3-BLOB和TEXT类型" class="headerlink" title="4.1.3.3 BLOB和TEXT类型"></a>4.1.3.3 BLOB和TEXT类型</h5><p><code>BLOB</code>和<code>TEXT</code>都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。</p>
<p>实际上，它们分别属于两组不同的数据类型家族：字符类型是<code>TINYTEXT</code>,<code>SMALLTEXT</code>,<code>TEXT</code>,<code>MEDIUMTEXT</code>, <code>LONGTEXT</code>；对应的二进制类型是<code>TINYBLOB</code>,<code>SMALLBLOB</code>,<code>BLOB</code>, <code>MEDTUMBLOB</code>,<code>LONGBLOB</code>。<code>BL0B</code>是<code>SMALLBLOB</code>的同义词，<code>TEXT</code>是<code>SMALLTEXT</code>的同义词。</p>
<p>与其他类型不同， MySQL把每个<code>BLOB</code>和<code>TEXT</code>值当作一个独立的对象处理，会使用专门的外部村储区域来进行存储，此时每个值在行内需要1~4个字节存储一个指针，然后在外部存储区域存储实际的值。</p>
<p><code>BLOB</code>和<code>TEXT</code>家族之间仅有的不同是<code>BLOB</code>类型存储的是二进制数据，没有排序规则或字符集，而<code>TEXT</code>类型有字符集和排序规则。</p>
<p>MySQL对<code>BLOB</code>和<code>TEXT</code>列进行排序与其他类型是不同的：它只对每个列的最前<code>max_sort_length</code>字节而不是整个字符串做排序。</p>
<p>MySQL不能将<code>BLOB</code>和<code>TEXT</code>列全部长度的宇符串进行索引，也不能使用这些索引消除排序。</p>
<h5 id="4-1-3-4-使用枚举（ENUM）代替字符串类型"><a href="#4-1-3-4-使用枚举（ENUM）代替字符串类型" class="headerlink" title="4.1.3.4 使用枚举（ENUM）代替字符串类型"></a>4.1.3.4 使用枚举（ENUM）代替字符串类型</h5><p>有时候可以使用枚举列代替常用的字符串类型。枚举列可以把一些不重复的字符串存储成一个预定义的集合。MySQL在存储枚举时非常紧凑，会根据列表值的数量压缩到个或者两个字节中。MySQL在内部会将每个值在列表中的位置保存为整数，并且在表的<code>.frm</code>文件中保存“数字-字符串”映射关系的“查找表”。</p>
<p><img src="/2020/02/26/MySQL-4-Schema与数据类型优化/200226_0.png" alt=""></p>
<p>此外要注意</p>
<ul>
<li>如果使用数字作为<code>ENUM</code>枚举常量，这种双重性很容易导致混乱，例如<code>ENUM(&#39;1&#39;,&#39;2&#39;,&#39;3&#39;)</code>。建议尽量避免这么做。</li>
<li>另外一个让人吃惊的地方是，枚举字段是按照内部存储的整数而不是定义的字符串进行排序的</li>
<li>枚举最不好的地方是，字符串列表是固定的，添加或删除字符串必须使用<code>ALTER TABLE</code>。因此，对于一系列未来可能会改变的字符串，使用枚举不是一个好主意</li>
<li>在特定情况下，把<code>CHAR</code>/<code>VARCHAR</code>列与枚举列进行关联可能会比直接关联<code>CHAR</code>/<code>VARCHAR</code>列更慢。</li>
</ul>
<h4 id="4-1-4-日期和时间类型"><a href="#4-1-4-日期和时间类型" class="headerlink" title="4.1.4 日期和时间类型"></a>4.1.4 日期和时间类型</h4><p>MySQL可以使用许多类型来保存日期和时间值，例如<code>YEAR</code>和<code>DATE</code>。MySQL能存储的最小时间粒度为秒。</p>
<p>MySQL提供两种相似的日期类型：<code>DATETIME</code>和<code>TIMESTAMP</code>。</p>
<h4 id="4-1-4-1-DATETIME"><a href="#4-1-4-1-DATETIME" class="headerlink" title="4.1.4.1 DATETIME"></a>4.1.4.1 DATETIME</h4><p>这个类型能保存大范围的值，从1001年到999年，精度为秒。它把日期和时间封装到格式为<code>YYYYMMDDHHMMSS</code>的整数中，与时区无关。使用8个字节的存储空间。</p>
<h4 id="4-1-4-2-TIMESTAMP"><a href="#4-1-4-2-TIMESTAMP" class="headerlink" title="4.1.4.2 TIMESTAMP"></a>4.1.4.2 TIMESTAMP</h4><p>就像它的名字一样，<code>TIMETAMP</code>类型保存了从1970年1月1日午夜（格林尼治标准时间）以来的秒数，它和UNIX时间戳相同。<code>TIMESTAMP</code>只使用4个字节的存储空间因此它的范围比<code>DATETIME</code>小得多：只能表示从1970年到2038年。 MySQL提供了<code>FROM_UNIXTIME()</code>函数把Unix时间戳转换为日期，并提供了<code>UNIX_TIMESTAMP()</code>函数把日期转换为Unix时间戳。</p>
<p><code>TIMESTAMP</code>显示的值依赖于时区。MySQL服务器、操作系统，以及客户端连接都有时区设置。如果在多个时区存储或访问数据，<code>TIMESTAMP</code>和<code>DATETIME</code>的行为将很不一样。前者提供的值与时区有关系，后者则保留文本表示的日期和时间。</p>
<p><code>TIMESTAMP</code>也有<code>DATETIME</code>没有的特殊属性。默认情况下，如果插入时没有指定第一个<code>TIMESTAMP</code>列的值， MySQL则把这个列的值设置为当前时间。</p>
<p>除了特殊行为之外，通常也应该尽量使用<code>TIMESTAMP</code>，因为它比<code>DATETIME</code>空间效率更高</p>
<h4 id="4-1-5-位数据类型"><a href="#4-1-5-位数据类型" class="headerlink" title="4.1.5 位数据类型"></a>4.1.5 位数据类型</h4><p>MySQL有少数几种存储类型使用紧凑的位存储数据。所有这些位类型，不管底层存储格式和处理方式如何，从技术上来说都是字符串类型。</p>
<h5 id="4-1-5-1-BIT"><a href="#4-1-5-1-BIT" class="headerlink" title="4.1.5.1 BIT"></a>4.1.5.1 BIT</h5><p>可以使用<code>BIT</code>列在一列中存储一个或多个<code>true/false</code>值。<code>BIT(1)</code>定义一个包含单个位的字段，<code>BIT(2)</code>存储2个位，依此类推。<code>BIT</code>列的最大长度是64个位。</p>
<p>但是由于一些原因，我们认为应该谨慎使用<code>BIT</code>类型。对于大部分应用，最好避免使用这种类型。</p>
<p>如果想在一个<code>bit</code>的存储空间中存储一个<code>true/false</code>值，另一个方法是创建一个可以为空的<code>CHAR(0)</code>列。该列可以保存空值（<code>NULL</code>）或者长度为零的字符串（空字符串）。</p>
<h5 id="4-1-5-2-SET"><a href="#4-1-5-2-SET" class="headerlink" title="4.1.5.2 SET"></a>4.1.5.2 SET</h5><p>如果需要保存很多<code>true/false</code>值，可以考虑合并这些列到一个<code>SET</code>数据类型，它在<code>MySQL</code>内部是以一系列打包的位的集合来表示的。这样就有效地利用了存储空间，并且<code>MYSQL</code>有像<code>FIND_IN_SET()</code>和<code>FIELD()</code>这样的函数，方便地在查询中使用。</p>
<p><img src="/2020/02/26/MySQL-4-Schema与数据类型优化/200226_1.png" alt=""></p>
<h4 id="4-1-6-选择标识符"><a href="#4-1-6-选择标识符" class="headerlink" title="4.1.6 选择标识符"></a>4.1.6 选择标识符</h4><p>为标识符(如表中的<code>id</code>列，就是常见的标识符)选择合适的数据类型非常重要。一般来说更有可能用标识列与其他值进行比较（例如，在关联操作中），或者通过标识列寻找其他列。标识列也可能在另外的表中作为外键使用，所以为标识列选择数据类型时，应该选择跟关联表中的对应列一样的类型。</p>
<p>下面是几种标识符的选择</p>
<ul>
<li>整数类型：整数通常是标识列最好的选择，因为它们很快并且可以使用<code>AUTO_INCREMENT</code>。</li>
<li><code>ENUM</code>和<code>SET</code>类型：对于标识列来说，<code>ENUM</code>和<code>SET</code>类型通常是一个糟糕的选择，尽管对某些只包含固定状态或者类型的静态“定义表”来说可能是没有问题的</li>
<li>字符串类型：如果可能，应该避免使用字符串类型作为标识列，因为它们很消耗空间，并且通常比数字类型慢。</li>
</ul>
<h4 id="4-1-7-特殊类型数据"><a href="#4-1-7-特殊类型数据" class="headerlink" title="4.1.7 特殊类型数据"></a>4.1.7 特殊类型数据</h4><p>IPV4地址实际上是32位无符号整数，不是字符串。用小数点将地址分成四段的表示方法只是为了让人们阅读容易。所以应该用无符号整数存储IP地址。 MySQL提供<code>INET_ATON()</code>和<code>INET_NI0A()</code>函数在这两种表示方法之间转换。</p>
<h3 id="4-2-MySQL-schema-设计中的陷阱"><a href="#4-2-MySQL-schema-设计中的陷阱" class="headerlink" title="4.2 MySQL schema 设计中的陷阱"></a>4.2 MySQL schema 设计中的陷阱</h3><p>下面列举一些在MySQL中不好的设计</p>
<h4 id="4-2-1-太多的列"><a href="#4-2-1-太多的列" class="headerlink" title="4.2.1 太多的列"></a>4.2.1 太多的列</h4><p>MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将编码过的列转换成行数据结构的操作代价是非常高的。MyISAM的变长行结构和InnoDB的行结构则总是需要转换。转换的代价依赖于列的数量。当我们研究一个CPU占用非常高的案例时，发现客户使用了非常宽的表（数千个字段），然而只有一小部分列会实际用到，这时转换的代价就非常高。</p>
<h4 id="4-2-2-太多的关联"><a href="#4-2-2-太多的关联" class="headerlink" title="4.2.2 太多的关联"></a>4.2.2 太多的关联</h4><p>EAV的定义可以参看<a href="https://blog.huoding.com/2016/06/29/522" target="_blank" rel="noopener">这里</a></p>
<p>所谓的“实体-属性-值”（EAV）设计模式是一个常见的糟糕设计模式，尤其是在MySQL下不能靠谱地工作。 MySQL限制了每个关联操作最多只能有61张表，但是EAV数据库需要许多自关联。我们见过不少EAV数据库最后超过了这个限制。<br>一个粗略的经验法则，如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。</p>
<h4 id="4-2-3-全能的枚举"><a href="#4-2-3-全能的枚举" class="headerlink" title="4.2.3 全能的枚举"></a>4.2.3 全能的枚举</h4><p>注意防止过度使用枚举（ENUM）。下面是我们见过的一个例子</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...(</span><br><span class="line">    country enum(<span class="string">''</span>, <span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>,...,<span class="string">'31'</span>)</span><br></pre></td></tr></table></figure>
<p>这种模式的schema设计非常凌乱。这么使用枚举值类型也许在任何支持枚举类型的数据库都是一个有问题的设计方案，这里应该用整数作为外键关联到字典表或者查找表来查找具体值。</p>
<h4 id="4-2-4-变相的枚举"><a href="#4-2-4-变相的枚举" class="headerlink" title="4.2.4 变相的枚举"></a>4.2.4 变相的枚举</h4><p>枚举（ENUM）列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值中的一个或多个值。有时候这可能比较容易导致混乱。这是一个例子：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> ...(</span><br><span class="line">    is_default <span class="keyword">set</span>(<span class="string">'Y'</span>，<span class="string">'N'</span>)<span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'N'</span></span><br></pre></td></tr></table></figure>
<p>如果这里真和假两种情况不会同时出现，那么毫无疑问应该使用枚举列代替集合列。</p>
<h4 id="4-2-5-比NULL更差的不可能值"><a href="#4-2-5-比NULL更差的不可能值" class="headerlink" title="4.2.5 比NULL更差的不可能值"></a>4.2.5 比NULL更差的不可能值</h4><p>当确实需要表示未知值时也不要害怕使用<code>NULL</code>。在一些场景中，使用<code>NULL</code>可能会比某个神奇常数更好。从特定类型的值域中选择个不可能的值，例如用<code>-1</code>代表一个未知的整数，可能导致代码复杂很多，并容易引入bug，还可能会让事情变得一团糟。处理<code>NULL</code>确实不容易，但有时候会比它的替代方案更好。</p>
<h3 id="4-3-范式与反范式"><a href="#4-3-范式与反范式" class="headerlink" title="4.3 范式与反范式"></a>4.3 范式与反范式</h3><p>对于任何给定的数据通常都有很多种表示方法，从完全的范式化到完全的反范式化，以及两者的折中。在范式化的数据库中，每个事实数据会出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。</p>
<h4 id="4-3-1-范式的优点和缺点"><a href="#4-3-1-范式的优点和缺点" class="headerlink" title="4.3.1 范式的优点和缺点"></a>4.3.1 范式的优点和缺点</h4><p>范式化通常能够带来好处：</p>
<ul>
<li>范式化的更新操作通常比反范式化要快。</li>
<li>当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要修改更少的数据。</li>
<li>范式化的表通常更小，可以更好地放在内存里，所以执行操作会更快。</li>
<li>很少有多余的数据意味着检索列表数据时更少需要<code>DISTINCT</code>或者<code>GROUP BY</code>语句</li>
</ul>
<p>但是范式化也有缺点</p>
<ul>
<li>范式化设计的schema的缺点是通常需要关联。稍微复杂一些的查询语句在符合范式的schema上都可能需要至少一次关联，也许更多。这不但代价昂贵，也可能使一些索引策略无效。</li>
</ul>
<h4 id="4-3-2-反范式的优点与缺点"><a href="#4-3-2-反范式的优点与缺点" class="headerlink" title="4.3.2 反范式的优点与缺点"></a>4.3.2 反范式的优点与缺点</h4><p>反范式化的schema因为所有数据都在一张表中，可以很好地避免关联。</p>
<p>但这会导致信息的冗余，同样的数据可能存在于很多地方。</p>
<h4 id="4-3-3-混用范式化与反范式化"><a href="#4-3-3-混用范式化与反范式化" class="headerlink" title="4.3.3 混用范式化与反范式化"></a>4.3.3 混用范式化与反范式化</h4><p>事实是，完全的范式化和完全的反范式化 schema都是实验室里才有的东西：在真实世界中很少会这么极端地使用。在实际应用中经常需要混用，可能使用部分范式化的schema、缓存表，以及其他技巧。</p>
<h3 id="4-4-计数器表"><a href="#4-4-计数器表" class="headerlink" title="4.4 计数器表"></a>4.4 计数器表</h3><p>如果应用在表中保存计数器，则在更新计数器时可能碰到并发问题。计数器表在Web应用中很常见。可以用这种表缓存一个用户的朋友数、文件下载次数等。创建一张独立的表存储计数器通常是个好主意，这样可使计数器表小且快。使用独立的表可以帮助避免查询缓存失效，并且可以使用本节展示的一些更高级的技巧。</p>
<p>假设有一个计数器表，只有一行数据，记录网站的点击次数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter(</span><br><span class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></p>
<p>网站的每次点击都会导致对计数器进行更新：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> hit_counter <span class="keyword">SET</span> cnt = cnt + <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>问题在于，对于任何想要更新这一行的事务来说，这条记录上都有一个全局的互斥锁。这会使得这些事务只能申行执行。要获得更高的并发更新性能，也可以将计数器保存在多行中，每次随机选择一行进行更新。这样做需要对计数器表进行如下修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hit_counter(</span><br><span class="line">    slot <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span> primary <span class="keyword">key</span>,</span><br><span class="line">    cnt <span class="built_in">int</span> <span class="keyword">unsigned</span> <span class="keyword">not</span> <span class="literal">null</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br></pre></td></tr></table></figure></p>
<p>然后预先在这张表增加10行数据。现在选择一个随机的槽（slot）进行更新<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> hit_counter <span class="keyword">SET</span> cnt = cnt + <span class="number">1</span> <span class="keyword">WHERE</span> slot = <span class="keyword">RAND</span>() * <span class="number">100</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-5-更快地读，更慢地写"><a href="#4-5-更快地读，更慢地写" class="headerlink" title="4.5 更快地读，更慢地写"></a>4.5 更快地读，更慢地写</h3><p>为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧：虽然写操作变得更慢了，但更显著地提高了读操作的性能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/24/MySQL-1-MySQL架构与历史/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/24/MySQL-1-MySQL架构与历史/" itemprop="url">[MySQL][1][MySQL架构与历史]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-24T23:10:04+08:00">
                2020-02-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/24/MySQL-1-MySQL架构与历史/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/24/MySQL-1-MySQL架构与历史/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-1-章-MySQL架构与历史"><a href="#第-1-章-MySQL架构与历史" class="headerlink" title="第 1 章 MySQL架构与历史"></a>第 1 章 MySQL架构与历史</h2><p>和其他数据库系统相比， MySQL有点与众不同，它的架构可以在多种不同场景中应用并发挥好的作用。 MySQL并不完美，却足够灵活，能够适应高要求的环境。</p>
<p>MySQL最重要、最与众不同的特性是它的存储引擎架构这种架构的设计将<strong>查询</strong>处理（ Query Processing）及其他系统任务（Server Task）和数据的<strong>存储/提取</strong>相分离。这种处理和存储分离的设计可以在使用时根据性能、特性来选择数据存储的方式。</p>
<h3 id="1-1-MySQL逻辑架构"><a href="#1-1-MySQL逻辑架构" class="headerlink" title="1.1 MySQL逻辑架构"></a>1.1 MySQL逻辑架构</h3><p>MySQL的逻辑架构图如下所示</p>
<p><img src="/2020/02/24/MySQL-1-MySQL架构与历史/200224_0.png" alt=""></p>
<p>最上层的服务是大多数基于网络的客户端/服务器的工具或者服务都有类似的架构。比如连接处理、授权认证、安全等等。</p>
<p>第二层架构是包含 MySQL的大多数核心服务功能，包括査询解析、分析、优化、缓存以及所有的内置函数，所有跨存储引擎的功能都在这一层实现：存储过程、触发器、视图等。</p>
<p>第三层包含了存储引擎。存储引擎负责 MySQL中数据的存储和提取。和GNU/ Linux下的各种文件系统一样，每个存储引擎都有它的优势和劣势。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。存储引擎API包含几十个底层函数，用于执行诸如“开始一个事务”或者“根据主键提取一行记录”等操作。但存储引擎不会去解析SQL，不同存储引擎之间也不会相互通信，而只是简单地响应上层服务器的请求。</p>
<h4 id="1-1-1-连接管理与安全性"><a href="#1-1-1-连接管理与安全性" class="headerlink" title="1.1.1 连接管理与安全性"></a>1.1.1 连接管理与安全性</h4><p>每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询只会在这个单独的线程中执行。</p>
<p>当客户端连接到 MySQL服务器时，服务器需要对其进行认证。认证基于用户名原始主机信息和密码。一旦客户端连接成功，服务器会继续验证该客户端是否具有执行某个特定查询的权限。</p>
<h4 id="1-1-2-优化与执行"><a href="#1-1-2-优化与执行" class="headerlink" title="1.1.2 优化与执行"></a>1.1.2 优化与执行</h4><p>MySQL会解析查询，并创建内部数据结构（解析树），然后对其进行各种优化，包括重写査询、决定表的读取顺序，以及选择合适的索引等。用户可以通过特殊的关键字提示（hint）优化器，影响它的决策过程。</p>
<p>优化器并不关心表使用的是什么存储引擎。但优化器会请求存储引擎提供容量或某个具体操作的开销信息，以及表数据的统计信息等。</p>
<p>对于 SELECT语句，在解析查询之前，服务器会先检查查询缓存（ Query Cache），如果能够在其中找到对应的査询，服务器就不必再执行查询解析、优化和执行的整个过程，而是直接返回查询缓存中的结果集。</p>
<h3 id="1-2-并发控制"><a href="#1-2-并发控制" class="headerlink" title="1.2 并发控制"></a>1.2 并发控制</h3><p>只要有多个查询需要在同一时刻修改数据，都会产生并发控制的问题。</p>
<h4 id="1-2-1-读写锁"><a href="#1-2-1-读写锁" class="headerlink" title="1.2.1 读写锁"></a>1.2.1 读写锁</h4><p>在处理并发读或者写问题时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁（shared lock）和排他锁（ exclusive lock），也叫读锁（ read lock）和写锁（ write lock）</p>
<p>读锁是共享的，或者说是相互不阻塞的。多个客户在同一时刻可以同时读取同一个资源，而互不干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁。</p>
<p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL会通过锁定防止其他用户读取同一数据。大多数时候，MySQL锁的内部管理都是透明的。</p>
<h4 id="1-2-2-锁粒度"><a href="#1-2-2-锁粒度" class="headerlink" title="1.2.2 锁粒度"></a>1.2.2 锁粒度</h4><p>种提高共享资源并发性的方式就是让锁定对象更有选择性。尽量只锁定需要修改的部分数据，而不是所有的资源。在给定的资源上，锁定的数据量越少，则系统的并发程度越高，只要相互之间不发生冲突即可。</p>
<p><strong>锁的各种操作，包括获得锁</strong>、检査锁是否已经解除、释放锁等，都会<strong>增加系统的开销</strong>。</p>
<p>所谓的锁策略，就是在锁的开销和数据的安全性之间寻求平衡。大多数商业数据库系统没有提供更多的选择，一般都是在表上施加行级锁（row level lock），并以各种复杂的方式来实现，以便在锁比较多的情况下尽可能地提供更好的性能。而MySQL则提供了多种选择。每种MySQL存储引擎都可以实现自己的锁策略和锁粒度。</p>
<h5 id="1-2-2-1-表锁（table-lock）"><a href="#1-2-2-1-表锁（table-lock）" class="headerlink" title="1.2.2.1 表锁（table lock）"></a>1.2.2.1 表锁（table lock）</h5><p>表锁是 MySQL中最基本的锁策略，并且是开销最小的策略。它会锁定整张表。</p>
<p>在特定的场景中，表锁也可能有良好的性能。例如，READ LOCAL表锁支持某些类型的并发写操作。另外，写锁也比读锁有更高的优先级，因此一个写锁请求可能会被插入到读锁队列的前面</p>
<p>尽管存储引擎可以管理自己的锁，MYSQL本身还是会使用各种有效的表锁来实现不同的目的。例如，服务器会为诸如 ALTER TABLE之类的语句使用表锁，而忽略存储引擎的锁机制。</p>
<h5 id="1-2-2-2-行级锁（row-lock）"><a href="#1-2-2-2-行级锁（row-lock）" class="headerlink" title="1.2.2.2 行级锁（row lock）"></a>1.2.2.2 行级锁（row lock）</h5><p>行级锁可以最大程度地支持并发处理（同时也带来了最大的锁开销）。在InnoDB和ⅹ traDB，以及其他一些存储引擎中实现了行级锁。行级锁只在存储引擎层实现，而 MySQL服务器层没有实现。所有的存储引擎都以自己的方式实现了锁机制。</p>
<h3 id="1-3-事务"><a href="#1-3-事务" class="headerlink" title="1.3 事务"></a>1.3 事务</h3><p>事务就是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。</p>
<p>可以用<code>START TRANSACTION</code>语句开始一个事务，然后要么使用<code>COMMIT</code>提交事务将修改的数据持久保留，要么使用<code>ROLLBACK</code>撒销所有的修改。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">SELECT</span> balance <span class="keyword">FROM</span> checking <span class="keyword">WHERE</span> customer_id = <span class="number">1022331</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> checking <span class="keyword">SET</span> balance = balance - <span class="number">200</span> <span class="keyword">WHERE</span> customer_id = <span class="number">1022331</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> saving <span class="keyword">SET</span> balance = balance - <span class="number">200</span> <span class="keyword">WHERE</span> customer_id = <span class="number">1022331</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure></p>
<p>除非系统通过严格的ACID测试，否则空谈事务的概念是不够的。ACID表示原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）。一个运行良好的事务处理系统，必须具备这些标准特征。</p>
<ul>
<li>原子性（atomicity）:一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚。</li>
<li>一致性（consistency）:数据库总是从一个一致性的状态转换到另外一个一致性的状态。</li>
<li>隔离性（isolation）:通常来说，一个事务所做的修改在最终提交以前，对其他事务是不可见的。</li>
<li>持久性（durability）:一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，修改的数据也不会丢失。</li>
</ul>
<p>但是这种事务处理过程中额外的安全性，也会需要数据库系统做更多的额外工作。一个实现了ACID的数据库，相比没有实现ACID的数据库，通常会需要更强的CPU处理能力、更大的内存和更多的磁盘空间。但这也正是MySQL的存储引擎架构可以发挥优势的地方。用户可以根据业务是否需要事务处理，来选择合适的存储引擎。对于一些不需要事务的查询类应用，选择个非事务型的存储引擎，可以获得更髙的性能。</p>
<h4 id="1-3-1-隔离级别"><a href="#1-3-1-隔离级别" class="headerlink" title="1.3.1 隔离级别"></a>1.3.1 隔离级别</h4><p>在SQL标准中定义了四种隔离级别，每一种级别都规定了个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高的并发，系统的开销也更低。</p>
<ul>
<li><p>READ UNCOMMITTED（未提交读）:在READ UNCOMMITTED级别，事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。</p>
</li>
<li><p>READ COMMITTED（提交读）:大多数数据库系统的默认隔离级别都是 READ COMMITTED。它满足前面提到的隔离性的简单定义：一个事务从开始直到提交之前，所做的任何修改对其他事务都是不可见的。这个级别有时候也叫做不可重复读（nonrepeatable read），因为两次执行同样的查询，可能会得到不一样的结果</p>
</li>
<li><p>REPEATABLE READ（可重复读）:REPEATABLE READ解决了脏读和不可重复读的问题。该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom read）的问题。所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行（Phantom row）。 InnoDB存储引擎通过多版本并发控制（MVCC, Multiversion Concurrency Control）解决了幻读的问题。可重复读是MySQL的默认事务隔离级别。</p>
</li>
<li><p>SERIALIZABLE（可串行化）:SERIALIZABLE是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单来说， SERIALIZABLE会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。</p>
</li>
</ul>
<p><img src="/2020/02/24/MySQL-1-MySQL架构与历史/200224_1.png" alt=""></p>
<h4 id="1-3-2-死锁"><a href="#1-3-2-死锁" class="headerlink" title="1.3.2 死锁"></a>1.3.2 死锁</h4><p>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。</p>
<p>下面举一个例子</p>
<p><img src="/2020/02/24/MySQL-1-MySQL架构与历史/200224_2.png" alt=""></p>
<p>如果凑巧，两个事务都执行了第一条<code>UPDATE</code>语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条<code>UPDATE</code>语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，则陷入死循环。除非有外部因素介入才可能解除死锁。</p>
<p>为了解决这种问题，数据库系统实现了各种死锁检测和死锁超时机制。InnoDB存储引擎，能检测到死锁的循环依赖，并立即返回一个错误。还有一种解决方式，就是当査询的时达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。 InnoDB目前处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p>
<h4 id="1-3-3-事务日志"><a href="#1-3-3-事务日志" class="headerlink" title="1.3.3 事务日志"></a>1.3.3 事务日志</h4><p>事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其<strong>内存</strong>拷贝，再把该修改行为记录到持久在硬盘上的<strong>事务日志</strong>中，而不用每次都将修改的数据本身持久到磁盘。事务日志持久以后，内存中被修改的数据在后台可以<strong>慢慢地刷回到磁盘</strong>。</p>
<h4 id="1-3-4-MySQL中的事务"><a href="#1-3-4-MySQL中的事务" class="headerlink" title="1.3.4 MySQL中的事务"></a>1.3.4 MySQL中的事务</h4><p>MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。</p>
<h5 id="1-3-4-1-自动提交"><a href="#1-3-4-1-自动提交" class="headerlink" title="1.3.4.1 自动提交"></a>1.3.4.1 自动提交</h5><p>MySQL默认采用自动提交（AUTOCOMMIT）模式。如果不是显式地开始个事务，则毎个査询都被当作一个事务执行提交操作。可以通过设置AUTOCOMMIT变量来启用或者禁用自动提交模式。</p>
<p>1或者ON表示启用，θ或者OFF表示禁用。当<code>AUTOCOMMIT=0</code>时，所有的查询都是在一个事务中，直到显式地执行提交或者回滚，该事务结束，开始一个新事务。修改<code>AUTOCOMMIT</code>对非事务型的表，比如<code>MyISAM</code>或者内存表，不会有任何影响。</p>
<p>另外还有一些命令，在执行之前会强制执行COMMIT提交当前的活动事务。典型的例子在数据定义语言（DDL）中，如果是会导致大量数据改变的操作，比如<code>ALTER TABLE</code>就是如此。</p>
<p>MySQL可以通过执行<code>SET TRANSACTION ISOLATION LEVEL</code>命令来设置隔离级别。新的隔离级别会在下一个事务开始的时候生效。</p>
<p>MySQL能够识别所有的4个ANSI隔离级别，InnoDB引擎也支持所有的隔离级别。</p>
<h5 id="1-3-4-2-在事务中混合使用存储引擎"><a href="#1-3-4-2-在事务中混合使用存储引擎" class="headerlink" title="1.3.4.2 在事务中混合使用存储引擎"></a>1.3.4.2 在事务中混合使用存储引擎</h5><p>MySQL服务器层不管理事务，事务是由下层的存储引擎实现的。所以在同一个事务中，使用多种存储引擎是不可靠的。</p>
<p>如果在事务中混合使用了事务型和非事务型的表，在正常提交的情况下不会有什么问题。</p>
<p>但如果该事务需要回滚，非事务型的表上的变更就无法撤销，这会导致数据库处于不一致的状态，这种情况很难修复，事务的最终结果将无法确定。所以，为每张表选择合适的存储引擎非常重要。</p>
<p>在非事务型的表上执行事务相关操作的时候， MySQL通常不会发出提醒，也不会报错。</p>
<h5 id="1-3-4-3-隐式和显式锁定"><a href="#1-3-4-3-隐式和显式锁定" class="headerlink" title="1.3.4.3 隐式和显式锁定"></a>1.3.4.3 隐式和显式锁定</h5><p>InnoDB采用的是两阶段锁定协议（two-phase locking protocol），包括显示锁定和隐式锁定。在事务执行过程中，随时都可以执行锁定，锁只有在执行<code>COMMIT</code>或者<code>ROLLBACK</code>的时候才会释放。前面描述的锁定都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁。</p>
<p>InnoDB也支持通过特定的语句进行显式锁定<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">FOR</span>　<span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p>
<p>MySQL也支持<code>LOCK TABLES</code>和<code>UNLOCK TABLES</code>语句，这是在服务器层实现的，和存储引擎无关。它们有自己的用途，但并不能替代事务处理。如果应用需要用到事务，还是应该选择事务型存储引擎。</p>
<h3 id="1-4-多版本控制"><a href="#1-4-多版本控制" class="headerlink" title="1.4 多版本控制"></a>1.4 多版本控制</h3><p>MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。</p>
<p>可以认为MVCC是行级锁的一个变种，但是它在很多情况下避免了加锁操作，因此开销更低。虽然实现机制有所不同，但大都实现了<strong>非阻塞的读</strong>操作，<strong>写操作也只锁定必要的行</strong>。</p>
<p>MvCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。</p>
<p>前面说到不同存储引擎的MVCC实现是不同的，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。下面我们通过InnoDB的简化版行为来说明MVCC是如何工作的。</p>
<p>InnoDB的MVCC，是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的过期时间（或删除时间）。当然存储的并不是实际的时间值，而是系统版本号（system version number）。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p>
<p>下面看一下在REPEATABLE READ隔离级别下，MVCC具体是如何操作的。</p>
<ul>
<li><p>SELECT：InnoDB会根据以下两个条件检查每行记录</p>
<ul>
<li>InnoDB只查找版本早于当前事务版本的数据行（也就是，行的系统版本号小于或等于事务的系统版本号），这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的。</li>
<li>行的删除版本要么未定义，要么大于当前事务版本号。这可以确保事务读取到的行，在事务开始之前未被删除。</li>
</ul>
</li>
<li><p>INSERT</p>
<ul>
<li>InnoDB为新插入的每一行保存当前系统版本号作为行版本号</li>
</ul>
</li>
<li><p>DELETE</p>
<ul>
<li>InnoDB为删除的每一行保存当前系统版本号作为行删除标识</li>
</ul>
</li>
<li><p>UPDATE</p>
<ul>
<li>InnodB插入一行新记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标识。</li>
</ul>
</li>
</ul>
<p>保存这两个额外系统版本号，使大多数读操作都可以不用加锁。这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行。不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</p>
<p>MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为 READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行。而SERIALIZABLE则会对所有读取的行都加锁。</p>
<h3 id="1-5-MySQL的存储引擎"><a href="#1-5-MySQL的存储引擎" class="headerlink" title="1.5 MySQL的存储引擎"></a>1.5 MySQL的存储引擎</h3><p>在文件系统中，MySQL将每个数据库（也可以称之为schema）保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件保存表的定义。因为MySQL使用文件系统的目录和文件来保存数据库和表的定义，大小写敏感性和具体的平台密切相关。在Windows中，大小写是不敏感的；而在类Unxx中则是敏感的。<strong>不同的存储引擎保存数据和索引的方式是不同的，但表的定义则是在MySQL服务层统一处理的。</strong></p>
<p>可以使用<code>SHOW TABLE STATUS</code>命令显示表的相关信息。</p>
<p><img src="/2020/02/24/MySQL-1-MySQL架构与历史/200225_0.png" alt=""></p>
<h4 id="1-5-1-InnoDB存储引擎"><a href="#1-5-1-InnoDB存储引擎" class="headerlink" title="1.5.1 InnoDB存储引擎"></a>1.5.1 InnoDB存储引擎</h4><p>InnoDB是MySQL的默认事务型引擎，也是最重要、使用最广泛的存储引擎。它被设计用来处理大量的短期（short-lived）事务，短期事务大部分情况是正常提交的，很少会被回滚。InnoDB的性能和自动崩溃恢复特性，使得它在非事务型存储的需求中也很流行。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</p>
<p>InnoDB的数据存储在表空间（tablespace）中，表空间是由InnoDB管理的一个<strong>黑盒子</strong>由一系列的数据文件组成。在MySQL4.1以后的版本中，InnoDB可以将每个表的数据和索引存放在单独的文件中。 </p>
<p>InnoDB采用<strong>MVCC</strong>来支持<strong>高并发</strong>，并且实现了四个标准的隔离级别。其默认级别是REPEATABLE READ（可重复读），并且通过间隙锁（next-key locking）策略<strong>防止幻读</strong>的出现。间隙锁使得InnoDB不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定，以防止幻影行的插入。</p>
<p>InnoDB表是基于聚簇索引建立的。InnoDB的索引结构和MySQL的其他存储引擎有很大的不同，聚簇索引对主键查询有很高的性能。不过它的二级索引（secondary index，非主键索引）中必须包含主键列。因此，若表上的索引较多的话，主键应当尽可能的小。 InnoDB的存储格式是平台独立的，也就是说可以将数据和索引文件从Intel平台复制到 PowerPC或者Sun sparo平台。</p>
<p>作为事务型的存储引擎， InnoDB通过一些机制和工具支持真正的热备份。MySQL的其他存储引擎不支持热备份，要获取一致性视图需要停止对所有表的写入。</p>
<h4 id="1-5-2-MyISAM存储引擎"><a href="#1-5-2-MyISAM存储引擎" class="headerlink" title="1.5.2 MyISAM存储引擎"></a>1.5.2 MyISAM存储引擎</h4><p>在MySQL5.1及之前的版本， MyISAM是默认的存储引擎。MyISAM提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且有一个亳无疑问的缺陷就是崩溃后无法安全恢复。对于只读的数据，或者表比较小、可以忍受修复（repair）操作，则依然可以继续使用MyISAM。</p>
<h5 id="1-5-2-1-存储"><a href="#1-5-2-1-存储" class="headerlink" title="1.5.2.1 存储"></a>1.5.2.1 存储</h5><p>MyISAM会将表存储在两个文件中：数据文件和索引文件，分别以<code>.MYD</code>和<code>.MY</code>为扩展名。MyISAM表可以包含动态或者静态（长度固定）行。 MySQL会根据表的定义来决定采用何种行格式。MyISAM表的最大行数，一般受限于可用的磁盘空间或者操作系统中单个文件的最大尺寸。MyISAM表如果是变长行，则默认配置只能处理256TB的数据，因为指向数据记录的指针长度是6个字节。</p>
<h5 id="1-5-2-2-MyISAM特性"><a href="#1-5-2-2-MyISAM特性" class="headerlink" title="1.5.2.2 MyISAM特性"></a>1.5.2.2 MyISAM特性</h5><p>加锁与并发</p>
<ul>
<li>MyISAM对整张表加锁，而不是针对行。</li>
<li>读取时会对需要读到的所有表加共享锁，写人时则对表加排他锁。</li>
</ul>
<p>修复</p>
<ul>
<li>对于MyISAM表，MySQL可以手工或者自动执行检查和修复操作</li>
<li>执行表的修复可能导致一些数据丢失，而且修复操作是非常慢的。</li>
</ul>
<p>索引特性</p>
<ul>
<li>对于MyISAM表，即使是BLOB和TXT等长字段，也可以基于其前500个字符创建索引。 </li>
<li>MyISAM也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</li>
</ul>
<p>延迟更新索引键（Delayed Key Write）</p>
<ul>
<li>创建MyISAM表的时候，如果指定了<code>DELAY KEY WRITE</code>选项，在每次修改执行完成时，不会立刻将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区（in-memory key buffer），只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入到磁盘。</li>
<li>这种方式可以极大地提升写人性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。</li>
</ul>
<h5 id="1-5-2-3-MyISAM压缩表"><a href="#1-5-2-3-MyISAM压缩表" class="headerlink" title="1.5.2.3 MyISAM压缩表"></a>1.5.2.3 MyISAM压缩表</h5><p>如果表在创建并导入数据以后，不会再进行修改操作，那么这样的表或许适合采用MyISAM压缩表。</p>
<p>可以使用<code>myisampack</code>对MyISAM表进行压缩。压缩表是不能进行修改的。压缩表可以极大地减少磁盘空间占用，因此也可以减少磁盘I/O，从而提升查询性能。压缩表也支持索引，但索引也是只读的。</p>
<h5 id="1-5-2-4-MyISAM性能"><a href="#1-5-2-4-MyISAM性能" class="headerlink" title="1.5.2.4 MyISAM性能"></a>1.5.2.4 MyISAM性能</h5><p>在服务器级别，MyISAM有很大的性能限制。但MyISAM最典型的性能问题还是表锁的问题，如果你发现所有的查询都长期处于<code>Locked</code>状态，那么毫无疑问表锁就是罪魁祸首。</p>
<h4 id="1-5-3-MySQL内建的其他存储引擎"><a href="#1-5-3-MySQL内建的其他存储引擎" class="headerlink" title="1.5.3 MySQL内建的其他存储引擎"></a>1.5.3 MySQL内建的其他存储引擎</h4><h5 id="1-5-3-1-Archive引擎"><a href="#1-5-3-1-Archive引擎" class="headerlink" title="1.5.3.1 Archive引擎"></a>1.5.3.1 Archive引擎</h5><p>Archive存储引擎只支持<code>INSERT</code>和<code>SELECT</code>操作，Archive引擎会缓存所有的写并利用zlib对插入的行进行压缩，所以比MyISAM表的磁盘I/O更少。但是每次<code>SELECT</code>查询都需要执行全表扫描。所以Archive表适合日志和数据采集类应用，这类应用做数据分析时往往需要全表扫描。</p>
<p>Archive引擎支持行级锁和专用的缓冲区，所以可以实现高并发的插入。在一个查询开始直到返回表中存在的所有行数之前，Archive引擎会阻止其他的<code>SELECT</code>执行，以实现一致性读。 Archive引擎不是一个事务型的引擎，而是一个针对高速插入和压缩做了优化的简单引擎。</p>
<h5 id="1-5-3-2-Blackhole引擎"><a href="#1-5-3-2-Blackhole引擎" class="headerlink" title="1.5.3.2 Blackhole引擎"></a>1.5.3.2 Blackhole引擎</h5><p>Blackhole引擎没有实现任何的存储机制，它会丢弃所有插入的数据，不做任何保存。但是服务器会记录 Blackhole表的日志。这种特殊的存储引擎可以在一些特殊的复制架构和日志审核时发挥作用。</p>
<h5 id="1-5-3-3-CSV引擎"><a href="#1-5-3-3-CSV引擎" class="headerlink" title="1.5.3.3 CSV引擎"></a>1.5.3.3 CSV引擎</h5><p>CSV引擎可以将普通的CSV文件（逗号分割值的文件）作为MySQL的表来处理，但这种表不支持索引。CSV引擎可以作为一种数据交换的机制，非常有用。</p>
<h5 id="1-5-3-4-Federated引擎"><a href="#1-5-3-4-Federated引擎" class="headerlink" title="1.5.3.4 Federated引擎"></a>1.5.3.4 Federated引擎</h5><p>Federated引擎是访问其他 MySQL服务器的一个代理，它会创建一个到远程MySQL服务器的客户端连接，并将查询传输到远程服务器执行，然后提取或者发送需要的数据。</p>
<h5 id="1-5-3-5-Memory引擎"><a href="#1-5-3-5-Memory引擎" class="headerlink" title="1.5.3.5 Memory引擎"></a>1.5.3.5 Memory引擎</h5><p>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用的。 Memory表至少比MyISAM表要快一个数量级，因为所有的数据都保存在内存中，不需要进行磁盘I/O。Memory表的结构在重启以后还会保留，但数据会丢失。</p>
<p>Memroy表是表级锁，因此并发写入的性能较低。它不支持BLOB或TEXT类型的列，并且每行的长度是固定的，所以即使指定了<code>VARCHAR</code>列，实际存储时也会转换成<code>CHAR</code>，这可能导致部分内存的浪费。</p>
<p>如果MySQL在执行查询的过程中需要使用临时表来保存中间结果，内部使用的临时表就是Memory表。</p>
<h5 id="1-5-3-6-Merge引擎"><a href="#1-5-3-6-Merge引擎" class="headerlink" title="1.5.3.6 Merge引擎"></a>1.5.3.6 Merge引擎</h5><p>Merge表是由多个 MyISAM表合并而来的虚拟表。如果将 MySQL用于日志或者数据仓库类应用，该引擎可以发挥作用。但是引入分区功能后，该引擎已经被放弃。</p>
<h5 id="1-5-3-7-NDB集群引擎"><a href="#1-5-3-7-NDB集群引擎" class="headerlink" title="1.5.3.7 NDB集群引擎"></a>1.5.3.7 NDB集群引擎</h5><p>MySQL服务器、NDB集群存储引擎，以及分布式的、 share- nothing的、容灾的、高可用的NDB数据库的组合，被称为 MySQL集群（MySQL Cluster）。</p>
<h4 id="1-5-4-第三方存储引擎"><a href="#1-5-4-第三方存储引擎" class="headerlink" title="1.5.4 第三方存储引擎"></a>1.5.4 第三方存储引擎</h4><p>MySQL从2007年开始提供了插件式的存储引擎API，从此涌出了一系列为不同目的而设计的存储引擎。</p>
<h5 id="1-5-4-1-OLTP类引擎"><a href="#1-5-4-1-OLTP类引擎" class="headerlink" title="1.5.4.1 OLTP类引擎"></a>1.5.4.1 OLTP类引擎</h5><p>Percona的XtraDB存储引擎是基于 InnoＤB引擎的一个改进版本。它的改进点主要集中在性能、可测量性和操作灵活性方面XtraDB可以作为 InnoDB的一个完全的替代产品，甚至可以兼容地读写 InnoDB的数据文件，并支持 InnoDB的所有查询。</p>
<p>TokuDB引擎使用了一种新的叫做分形树（Fractal Trees）的索引数据结构。该结构是缓存无关的，因此即使其大小超过内存性能也不会下降，也就没有内存生命周期和碎片的问题。TokuDB是一种大数据存储引擎，因为其拥有很高的压缩比，可以在很大的数据量上创建大量索引。在本书写作时，这个引擎还处于早期的生产版本状态，</p>
<h5 id="1-5-4-2-面向列的存储引擎"><a href="#1-5-4-2-面向列的存储引擎" class="headerlink" title="1.5.4.2 面向列的存储引擎"></a>1.5.4.2 面向列的存储引擎</h5><p>MySQL默认是面向行的，每一行的数据是一起存储的，服务器的查询也是以行为单位处理的。而在大数据量处理时，面向列的方式可能效率更高。如果不需要整行的数据，面向列的方式可以传输更少的数据。如果每一列都单独存储，那么压缩的效率也会更高。</p>
<p>Infobright是最有名的面向列的存储引擎。在非常大的数据量（数十TB）时，该引擎工作良好。Infobright是为数据分析和数据仓库应用设计的。数据高度压缩，按照块进行排序，每个块都对应有一组元数据。在处理查询时，访问元数据可决定跳过该块，甚至可能只需要元数据即可满足查询的需求。但该引擎不支持索引，不过在这么大的数据量级，即使有索引也很难发挥作用，而且块结构也是一种准索引。</p>
<h4 id="1-5-5-选择合适的引擎"><a href="#1-5-5-选择合适的引擎" class="headerlink" title="1.5.5 选择合适的引擎"></a>1.5.5 选择合适的引擎</h4><p>InnoDB都是正确的选择。除非需要用到某些InnoDB不具备的特性，并且没有其他办法可以替代，否则都应该优先选择 InnoDB引擎。例如，如果要用到全文索引，建议优先考虑InnoDB加上Sphinx的组合，而不是使用支持全文索引的 MyISAM。</p>
<p>除非万不得已，否则建议不要混合使用多种存储引擎，否则可能带来一系列复杂的问题，以及一些潜在的bug和边界问题。存储引擎层和服务器层的交互已经比较复杂，更不用说混合多个存储引擎了。至少，混合存储对一致性备份和服务器参数配置都带来了一些困难。</p>
<p>如果应用需要选择存储引擎，通常从如下几个角度考虑</p>
<p>事务</p>
<ul>
<li>如果应用需要事务支持，那么InnoDB是目前最稳定并且经过验证的选择。</li>
<li>如果不需要事务，并且主要是<code>SELECT</code>和<code>INSERT</code>操作，那么MyISAM是不错的选择。一般日志型的应用比较符合这一特性。</li>
</ul>
<p>备份</p>
<ul>
<li>如果可以定期地关闭服务器来执行备份，那么备份的因素可以忽略。</li>
<li>反之，如果需要在线热备份，那么选择InnoDB就是基本的要求。</li>
</ul>
<p>崩渍恢复</p>
<ul>
<li>MyISAM崩溃后发生损坏的概率比InnoDB要高很多，而且恢复速度也要慢。</li>
<li>因此，即使不需要事务支持，很多人也选择InnoDB引擎。</li>
</ul>
<p>下面从不同应用类型的角度考虑存储引擎的选择</p>
<p>日志型应用</p>
<ul>
<li>假设你需要实时地记录一台中心电话交换机的每一通电话的日志到MySQL中。</li>
<li>这一类应用的插入速度有很高的要求，数据库不能成为瓶颈。 </li>
<li>MyISAM或者Archive存储引擎对这类应用比较合适，因为它们开销低，而且插入速度非常快。</li>
</ul>
<p>只读或者大部分情况下只读的表</p>
<ul>
<li>有些表的数据用于编制类目或者分列清单（如工作岗位、竞拍、不动产等），这种应用场景是典型的读多写少的业务。</li>
<li>如果不介意MyISAM的崩溃恢复问题，选用MyISAM引擎是合适的。</li>
</ul>
<p>订单处理</p>
<ul>
<li>如果涉及订单处理，那么支持事务就是必要选项。半完成的订单是无法用来吸引用户的。</li>
<li>另外一个重要的考虑点是存储引擎对外键的支持情况。</li>
<li>InnoDB是订单处理类应用的最佳选择。</li>
</ul>
<p>大数据量</p>
<ul>
<li>什么样的数据量算大？我们创建或者管理的很多InnoDB数据库的数据量在3~5TB之间，或者更大，这些系统运行得还不错</li>
<li>如果数据量继续增长到10TB以上的级别，可能就需要建立数据仓库。 </li>
<li>Infobright是MySQL数据仓库最成功的解决方案。也有一些大数据库不适合Infobright，却可能适合TokuDB</li>
</ul>
<h4 id="1-5-6-转换表的引擎"><a href="#1-5-6-转换表的引擎" class="headerlink" title="1.5.6 转换表的引擎"></a>1.5.6 转换表的引擎</h4><p>我们将讲述其中的三种方法将表的存储引擎转换成另外一种引擎。</p>
<h5 id="1-5-6-1-ALTER-TABLE"><a href="#1-5-6-1-ALTER-TABLE" class="headerlink" title="1.5.6.1 ALTER TABLE"></a>1.5.6.1 ALTER TABLE</h5><p>将表从一个引擎修改为另一个引擎最简单的办法是使用 ALTER TABLE语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> mytable <span class="keyword">ENGINE</span> = <span class="keyword">InnoDB</span></span><br></pre></td></tr></table></figure>
<p>上述语法可以适用任何存储引擎。但需要执行很长时间。 MySQL会按行将数据从原表复制到张新的表中，在复制期间可能会消耗系统所有的I/O能力，同时原表上会加上读锁。所以，在繁忙的表上执行此操作要特别小心。</p>
<h5 id="1-5-6-2-导出与导入"><a href="#1-5-6-2-导出与导入" class="headerlink" title="1.5.6.2 导出与导入"></a>1.5.6.2 导出与导入</h5><p>为了更好地控制转换的过程，可以使用mysqldump工具将数据导出到文件，然后修改文件中<code>CREATE TABLE</code>语句的存储引擎选项，注意同时修改表名。\</p>
<h5 id="1-5-6-3-创建与查询-CREATE和SELECT"><a href="#1-5-6-3-创建与查询-CREATE和SELECT" class="headerlink" title="1.5.6.3 创建与查询(CREATE和SELECT)"></a>1.5.6.3 创建与查询(CREATE和SELECT)</h5><p>不需要导出整个表的数据，而是先创建一个新的存储引擎的表，然后利用<code>INSERT… SELECT</code>语法来导数据</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">innodb</span> <span class="keyword">table</span> <span class="keyword">LIKE</span> myisam <span class="keyword">table</span>; </span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">innodb</span> <span class="keyword">table</span> <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>; </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">innodb</span> <span class="keyword">table</span> <span class="keyword">SELECT</span> <span class="keyword">FROM</span> mmyisam <span class="keyword">table</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-6-MySQL的开发模式"><a href="#1-6-MySQL的开发模式" class="headerlink" title="1.6 MySQL的开发模式"></a>1.6 MySQL的开发模式</h3><p>MySQL依然遵循GPL开源协议，全部的源代码都会开放给社区。现在Oracle为付费用户提供了一些服务器插件，但是没有这些插件，MySQL也是功能完整的数据库。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/22/SpringBoot-15-SpringBoot处理高并发/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/" itemprop="url">[SpringBoot][15][SpringBoot处理高并发]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-22T21:31:52+08:00">
                2020-02-22
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-15-章-SpringBoot处理高并发"><a href="#第-15-章-SpringBoot处理高并发" class="headerlink" title="第 15 章 SpringBoot处理高并发"></a>第 15 章 SpringBoot处理高并发</h2><p>在企业实际应用中，会遇到很多高并发场景，最典型的例子就是双十一的抢购。这时候，如果仅仅按照之前简单的方式进行处理，不仅性能无法保证，而且有可能导致数据库某些数据的超发。</p>
<p>下图演示了超发的一种情况</p>
<p><img src="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/200221_2.png" alt=""></p>
<p>为此，我们提供了三种高并发场景下的方案：悲观锁、乐观锁和使用Redis</p>
<h3 id="15-1-悲观锁"><a href="#15-1-悲观锁" class="headerlink" title="15.1 悲观锁"></a>15.1 悲观锁</h3><p>本节讨论使用悲观锁处理高并发超发的问题。在高并发中出现超发现象，根本在于共享的数据被多个线程所修改，无法保证其执行的顺序。为此，悲观锁给出的解决方案是：如果一个数据库事务读取到产品后，就将数据直接锁定，不允许别的线程进行读写操作，直至当前数据库事务完成才释放这条数据的锁，则不会出现之前看到的超发问题。</p>
<p>下面举个简单的实现方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getProduct"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"product"</span>&gt;</span></span><br><span class="line">    select id, product_name as productName,</span><br><span class="line">    stock, price, from t_product</span><br><span class="line">    where id = #&#123;id&#125; for update</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的SQL在最后加了<code>for update</code>就是使用数据库内部的锁对记录加锁，从而使得其他事务等待以保证数据一致性。</p>
<p>悲观锁的最大缺点是损失大量的性能</p>
<h3 id="15-2-乐观锁"><a href="#15-2-乐观锁" class="headerlink" title="15.2 乐观锁"></a>15.2 乐观锁</h3><p>乐观锁是一种不使用数据库锁和不阻塞线程并发的方案。下面我们分步骤来解释乐观锁</p>
<p>第一步，我们想到一种最简单的方式，CAS（Compare And Swap）：以本章的商品购买为例来说，就是一个线程一开始先读取既有的商品库存数据，保存起来们把这些旧数据称为旧值，然后去执行一定的业务逻辑，等到需要对共享数据做修改时，会事先保存的旧值库存与当前数据库的库存进行比较，如果旧值与当前库存一致，它就认为数据没有被改过，否则就认为数据已经被修改过，当前计算将不被信任，所以就不再修改任何数据。其流程图如下。</p>
<p><img src="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/200221_3.png" alt=""></p>
<p>但是，这个方案会带来ABA问题</p>
<p><img src="/2020/02/22/SpringBoot-15-SpringBoot处理高并发/200221_4.png" alt=""></p>
<p>从表中可以看出，在T2到T5时刻，线程1计算商品总价格的时候，当前库存会被线程2所修改，它是一个A→B→A的过程，所以人们比较形象地称之为“ABA问题”。换句话说，线程1在计算商品总价格时，当前库存是一个变化的值，这样就可能出现错误的计算。</p>
<p>第二步，为了克服这个问题，我们引入了一些规则，典型的如增加版本号（version）。在数据库的商品表中多加一个字段叫做版本号，并且规定：只要操作过程中修改共享值，无论业务正常、回退还是异常，版本号只增不减。这时，按照第一步的思路，一开始我们读取商品库存，获得了版本号；当我们要修改这个库存时，再次读取库存，如果发现版本号变了，那么证明有其他线程修改过这个数据，则取消业务。</p>
<p>但是，这个方案的问题是，我们会频繁的取消业务，导致一定比例的用户请求被拒绝。</p>
<p>第三步，为了克服这个问题，乐观锁还可以引入重入机制，就是一旦更新失败，就重做一次。并且会使用限制时间或重入次数的方式压制过多的SQL执行</p>
<p>现在总结一下乐观锁的机制：乐观锁是一种不使用数据库锁的机制，并且不会造成线程的阻塞，只是采用多版本号机制来实现。但是，因为版本的冲突造成了请求失败的概率剧增，所以这时往往需要通过重入的机制将请求失败的概率降低。但是，多次的重入会带来过多执行SQL的问题。为了克服这个问题，可以考虑使用按时间戳或者限制重入次数的办法。可见乐观锁还是一个相对比较复杂的机制。</p>
<h3 id="15-3-使用Redis处理高并发"><a href="#15-3-使用Redis处理高并发" class="headerlink" title="15.3 使用Redis处理高并发"></a>15.3 使用Redis处理高并发</h3><p>我们也可以通过Redis Lua的原子性来处理高并发，并且由于Redis是基于内存的，通常大幅度提升性能。</p>
<p>下面描述简单的实现思路</p>
<ul>
<li>首先使用Redis代替数据库来响应高并发，将商品库存放入Redis中存储、访问、更新</li>
<li>此外，因为Redis基于内存，为了防止数据丢失，设置一个定时任务，定时将数据从Redis存入数据库。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
