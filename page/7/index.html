<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/7/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/7/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/SSM-9-SpringIOC的概念/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/SSM-9-SpringIOC的概念/" itemprop="url">[SSM][9][SpringIOC的概念]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:49:37+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/SSM-9-SpringIOC的概念/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/SSM-9-SpringIOC的概念/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第九章-SpringIOC的概念"><a href="#第九章-SpringIOC的概念" class="headerlink" title="第九章 SpringIOC的概念"></a>第九章 SpringIOC的概念</h2><h3 id="9-1-Spring的概括"><a href="#9-1-Spring的概括" class="headerlink" title="9.1 Spring的概括"></a>9.1 Spring的概括</h3><ul>
<li><p><code>Spring</code>简介</p>
<ul>
<li>它的成功来自于理念，而不是技术，它最为核心的理念是<code>IoC</code>(控制反转)和<code>AOP</code>(面向切面编程)</li>
<li>其中<code>IoC</code>是Spring的基础，而<code>AOP</code>则是其重要的功能，最为典型的当属数据库事务的使用</li>
<li>在<code>Spring</code>中，它会认为一切<code>Java</code>类都是资源，而资源都是<code>Bean</code>，容纳这些<code>Bean</code>的是<code>Spring</code>所提供的<code>IoC</code>容器，所以<code>Spring</code>是一种基于<code>Bean</code>的编程</li>
</ul>
</li>
<li><p><code>Spring</code>的理念</p>
<ul>
<li>基于接口的编程是一种理念，强调<code>OOD</code>的设计理念，比技术实现更为重要</li>
<li><code>Java</code>开发的一大通病是大量使用<code>try...catch...finally...</code>，<code>Spring</code>尝试改善它们</li>
<li>在当时的<code>Java</code>技术中，很多框架都是侵略性的，也就是必须使用当前框架所提供的类库，才能实现功能，这样会造成应用对框架的依赖</li>
<li><code>Spring</code>技术不是为了取代现有的技术，而是提供更好的整合模板使它们能够整合到<code>Spring</code>技术上来</li>
</ul>
</li>
<li><p><code>Spring</code>的策略</p>
<ul>
<li>对于<code>POJO</code>的潜力开发，提供轻量级和低侵入的编程，可以通过配置（ <code>XML</code> 、注解等）来扩展<code>POJO</code>的功能，通过依赖注入的理念去扩展功能，建议通过接口编程，强调<code>OOD</code> 的开发模式理念，降低系统稿合度，提高系统可读性和可扩展性。</li>
<li>提供切面编程，尤其是把企业的核心应用一一数据库应用，通过切面消除了以前复杂的<code>try... catch ... finally ...</code>代码结构，使得开发人员能够把精力更加集中于业务开发而不是技术本身</li>
<li>为了整合各个框架和技术的应用，<code>Spring</code>提供了模板类，通过模板可以整合各个框架和技术，比如支持<code>Hibernate</code> 开发的<code>Hibernate Template</code>、支持<code>MyBatis</code>开发的<code>SqlSessionTemplate</code>、支持<code>Redis</code>开发的<code>RedisTemplate</code> 等，这样就把各种企业用到的技术框架整合到<code>Spring</code>中，提供了统一的模板，从而使得各种技术用起来更简单。</li>
</ul>
<h3 id="2-SpringIoC-阐述"><a href="#2-SpringIoC-阐述" class="headerlink" title="2 SpringIoC 阐述"></a>2 SpringIoC 阐述</h3></li>
<li><p>控制反转:控制反转是一种通过描述(在<code>Java</code>中可以是<code>XML</code>或者<code>注解</code>)并通过第三方去产生或获取特定对象的方式</p>
</li>
<li><p>IoC 容器</p>
<ul>
<li>在<code>Spring</code>中实现控制反转的是<code>IoC</code>容器，其实现的方式是依赖注入(Dependency Injection, DI)</li>
<li><code>Spring</code>会提供<code>IoC</code>容器来管理对应的资源，正如上面例子中的饮品店和订单资源，由它们产生依赖注入的关系</li>
</ul>
</li>
<li><p>示例<br>  <img src="/2019/12/25/SSM-9-SpringIOC的概念/0430_0.png" alt=""></p>
</li>
<li><p>对于交易开发人员:</p>
<ul>
<li>当熟悉财务的同事完成对财务接口模块的开发，就可以将其服务发布到<code>Spring IoC</code>的容器里，</li>
<li>这个时候你只需要过程描述得到对应的财务接口，就可以完成对应的财务操作了，</li>
<li>而财务模块是如何工作的，它又需要依赖哪些对象，都是由熟悉财务模块的同事完成的，这些并不需要你去理解，你只需要知道它能完成对应的财务操作即可</li>
</ul>
</li>
<li><p>对于测试人员</p>
<ul>
<li>对于测试人员也一样，也许他早早把财务模块测试好了，需要测试交易模块</li>
<li>他并不希望非常细致地了解交易模块，他只需要从<code>Spring IoC</code>容器中获取就可以了。而他的测试代码也只需要从<code>Spring IoC</code>容器获取交易模块的内容,至于内部复杂的依赖并不是他所需要关注的内容</li>
<li>这样就有利于测试人员对模块的测试，降低测试人员测试的复杂度</li>
</ul>
</li>
<li><p>总结: 降低开发难度，对模块解耦，同时更利于测试</p>
</li>
</ul>
<h3 id="9-3-Spring-IoC-容器"><a href="#9-3-Spring-IoC-容器" class="headerlink" title="9.3 Spring IoC 容器"></a>9.3 Spring IoC 容器</h3><ul>
<li>Spring IoC容器的作用是容纳我们所开发的各种Bean，并且我们可以从中获取各种发布在Spring IoC容器里的Bean，并且通过描述可以得到它</li>
</ul>
<h4 id="9-3-1-Spring-IoC-容器的设计"><a href="#9-3-1-Spring-IoC-容器的设计" class="headerlink" title="9.3.1 Spring IoC 容器的设计"></a>9.3.1 Spring IoC 容器的设计</h4><ul>
<li><p>Spring IoC 接口设计</p>
<ul>
<li>Spring IoC 容器的设计主要基于<code>BeanFactory</code>和<code>ApplicationContext</code>两个接口</li>
<li><code>BeanFactory</code>是Spring IoC容器所定义的最底层的接口</li>
<li><code>ApplicationContext</code>是高级接口之一，并且对<code>BeanFactory</code>的功能做了许多有用的扩展</li>
<li>Spring IoC 容器接口类图<br>  <img src="/2019/12/25/SSM-9-SpringIOC的概念/0501_0.png" alt=""></li>
</ul>
</li>
<li><p><code>BeanFactory</code>接口解读</p>
<ul>
<li><code>getBean</code>的多个方法用来获取配置给Spring IoC容器的<code>Bean</code></li>
<li><code>isSingleton</code>用来判断是否单例，如果判断为真，其意思是该<code>Bean</code>在容器中是作为唯一单例存在的</li>
<li><code>isPrototype</code>如果判断为真，意思是当你从容器中获取<code>Bean</code>，容器就为你生成一个新的实例</li>
<li><code>type</code>是一个按照<code>java</code>类型匹配的方法</li>
<li><code>getAliases</code>方法是获取别名的方法</li>
</ul>
</li>
</ul>
<h4 id="9-3-2-Spring-IoC容器的初始化和依赖注入"><a href="#9-3-2-Spring-IoC容器的初始化和依赖注入" class="headerlink" title="9.3.2 Spring IoC容器的初始化和依赖注入"></a>9.3.2 Spring IoC容器的初始化和依赖注入</h4><ul>
<li><p><code>Bean</code>的定义步骤</p>
<ol>
<li><code>Resource</code>定位</li>
<li><code>BeanDefinition</code>的载入</li>
<li><code>BeanDefinition</code>的注册</li>
</ol>
</li>
<li><p>依赖注入: </p>
<ul>
<li>依赖注入的观念就是将所有东西先在”外面”准备好，然后再带入“内部”的程式中，如此一来你就能够在检视程式码的时候，一目了然地知道这个程式依赖著哪些类别。</li>
<li>通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。</li>
<li>技术描述:<code>Class A</code>中用到了<code>Class B</code>的对象<code>b</code>，一般情况下，需要在<code>A</code>的代码中显式的<code>new</code>一个<code>B</code>的对象。采用依赖注入技术之后，<code>A</code>的代码只需要定义一个私有的<code>B</code>对象，不需要直接<code>new</code>来获得这个对象，而是通过相关的容器控制程序来将<code>B</code>对象在外部<code>new</code>出来并注入到<code>A</code>类里的引用中。而具体获取的方法、对象被获取时的状态由配置文件（如XML）来指定。</li>
</ul>
</li>
</ul>
<h4 id="9-3-3-Spring-Bean-的生命周期"><a href="#9-3-3-Spring-Bean-的生命周期" class="headerlink" title="9.3.3 Spring Bean 的生命周期"></a>9.3.3 Spring Bean 的生命周期</h4><ul>
<li><p><code>Bean</code>在容器中存在其生命周期，它的初始化和销毁也需要一个过程，在一些需要自定义的过程中，我们可以插入代码来改变它们的一些行为</p>
</li>
<li><p><code>Bean</code>的生命周期<br>  <img src="/2019/12/25/SSM-9-SpringIOC的概念/0501_1.png" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/SSM-3-认识MyBatis核心组件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/SSM-3-认识MyBatis核心组件/" itemprop="url">[SSM][3][认识MyBatis核心组件]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:44:47+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/SSM-3-认识MyBatis核心组件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/SSM-3-认识MyBatis核心组件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-3-章-认识MyBatis核心组件"><a href="#第-3-章-认识MyBatis核心组件" class="headerlink" title="第 3 章 认识MyBatis核心组件"></a>第 3 章 认识MyBatis核心组件</h2><h3 id="3-1-持久层的概念和MyBatis的特点"><a href="#3-1-持久层的概念和MyBatis的特点" class="headerlink" title="3.1 持久层的概念和MyBatis的特点"></a>3.1 持久层的概念和MyBatis的特点</h3><ul>
<li><p>持久层概念</p>
<ul>
<li>持久层可以将业务数据存储到磁盘，具备长期存储能力</li>
<li>一般执行持久任务的都是数据库系统，持久层可以使用巨大的磁盘空间，也比较廉价，缺点是比较慢</li>
</ul>
</li>
<li><p>Java互联网应用可以通过MyBatis框架访问数据库<br>  <img src="/2019/12/25/SSM-3-认识MyBatis核心组件/0425_0.png" alt=""></p>
</li>
<li><p>MyBatis最大的成功有三点</p>
<ul>
<li>不屏蔽SQL<ul>
<li>意味着可以更为精确的定位SQL语句，可以对其进行优化和改造</li>
<li>这有利于互联网系统性能的提高，符合互联网需要性能优化的特点</li>
</ul>
</li>
<li>提供强大、灵活的映射机制，方便Java开发者的使用<ul>
<li>提供动态SQL的功能，允许我们根据不同条件组装SQL，这个功能远比其他工具或者Java编码的可读性和可维护性高得多，满足各种应用系统的同时也满足了需求经常需要变化的互联网应用的要求 </li>
</ul>
</li>
<li>在MyBatis中，提供了使用Mapper的接口编程，只要一个接口和一个XML就能创建映射器</li>
</ul>
</li>
</ul>
<h3 id="3-2-准备MyBatis环境"><a href="#3-2-准备MyBatis环境" class="headerlink" title="3.2 准备MyBatis环境"></a>3.2 准备MyBatis环境</h3><ul>
<li>我们只要在工程中加入MyBatis包即可，它包含MyBatis工程包和其依赖包</li>
</ul>
<h3 id="3-3-MyBatis的核心组件"><a href="#3-3-MyBatis的核心组件" class="headerlink" title="3.3 MyBatis的核心组件"></a>3.3 MyBatis的核心组件</h3><ul>
<li><p><code>MyBatis</code>的核心组件分为4个部分</p>
<ul>
<li><code>SqlSessionFactoryBuilder</code>(构造器)：它根据配置或者代码来生成<code>SqlSessionFactory</code>，采用的是分布构建的<code>Builder</code>模式</li>
<li><code>SqlSessionFactory</code>(工厂接口)：依靠它来生成<code>SqlSession</code>，使用的是工厂模式</li>
<li><code>SqlSession</code>(会话)：一个既可以发送<code>SQL</code>执行返回结果，也可以获取<code>Mapper</code>的接口。在现有的技术中，一般我们会让其在业务逻辑代码中消失，而使用的是<code>MyBatis</code>提供的<code>SQL Mapper</code>接口编程技术，它能提高代码的可读性和可维护性</li>
<li><code>SQL Mapper</code>(映射器)：<code>MyBatis</code>新设计存在的组件，它由一个<code>Java</code>接口和<code>XML</code>文件构成，需要给出对应的<code>SQL</code>和映射规则。它负责发送<code>SQL</code>去执行，并返回结果</li>
</ul>
</li>
<li><p><code>MyBatis</code>核心组件之间的关系<br>  <img src="/2019/12/25/SSM-3-认识MyBatis核心组件/0425_1.png" alt=""></p>
</li>
<li><p>注意: 无论是映射器还是<code>SQLSession</code>都可以发送<code>SQL</code>到数据库执行</p>
</li>
</ul>
<h3 id="3-4-SqlSessionFactory-工厂接口"><a href="#3-4-SqlSessionFactory-工厂接口" class="headerlink" title="3.4 SqlSessionFactory(工厂接口)"></a>3.4 SqlSessionFactory(工厂接口)</h3><ul>
<li>概述<ul>
<li>使用MyBatis首先是使用配置或者代码去生产SqlSessionFactory</li>
<li>每个基于MyBatis的应用都是以一个SqlSessionFactory的实例为中心的，而SqlSessionFactory的唯一作用是生产MyBatis的核心接口对象SqlSession，所以它是职责单一的</li>
</ul>
</li>
</ul>
<ul>
<li><p>如何生成<code>SqlSessionFactory</code></p>
<ul>
<li>而MyBatis提供了构造器SqlSessionFactoryBuilder。它提供了一个类<code>org.apache.ibatis.session.Configuration</code>作为引导，采用的是Builder模式</li>
<li>在MyBatis中，既可以通过读取<code>XML</code>配置文件的方式生成<code>SqlSessionFactory</code>，也可以通过Java代码的形式生成<code>SqlSessionFactory</code></li>
<li>当配置了XML或者提供了代码后，MyBatis会读取配置文件，通过<code>Configuration</code>类对象构建整个<code>MyBatis</code>的上下文</li>
</ul>
</li>
<li><p>SqlSessionFactory接口的结构<br>  <img src="/2019/12/25/SSM-3-认识MyBatis核心组件/0425_2.png" alt=""></p>
</li>
</ul>
<h4 id="3-4-1-使用XML构建SqlSessionFactory"><a href="#3-4-1-使用XML构建SqlSessionFactory" class="headerlink" title="3.4.1 使用XML构建SqlSessionFactory"></a>3.4.1 使用XML构建SqlSessionFactory</h4><ul>
<li><p>MyBatis中的XML分为两类</p>
<ol>
<li>基础配置文件: 通常只有一个，主要是配置一些最基本的上下文参数和运行环境</li>
<li>映射文件: 它可以配置映射关系、SQL、参数等信息</li>
</ol>
</li>
<li><p>示例: 一份基础配置文件</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"MyBatisDemo.Role"</span> <span class="attr">alias</span>=<span class="string">"role"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/ssm"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"MybatisDemo/RoleMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>MyBatis基础配置文件的结构</p>
<ul>
<li><code>&lt;typeAlias&gt;</code>:用于定义别名，定义之后，在MyBatis上下文中就可以使用别名代替全限定名</li>
<li><code>&lt;environment&gt;</code>:这里描述的是数据库。其中<code>&lt;transactionManager&gt;</code>元素是配置事务管理器。然后采用<code>&lt;dataSource&gt;</code>元素配置数据库</li>
<li><code>&lt;mapper&gt;</code>: 代表引入的那些映射器，在谈到映射器时会详细讨论它</li>
</ul>
</li>
<li><p>有了这些配置文件，就可以用一段简短的代码来生成<code>SqlSessionFactory</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">null</span>;</span><br><span class="line">String resource = <span class="string">"mybatis-config.xml"</span>;</span><br><span class="line">InputStream inputStream;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">    sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-4-2-使用代码构建SqlSessionFactory"><a href="#3-4-2-使用代码构建SqlSessionFactory" class="headerlink" title="3.4.2 使用代码构建SqlSessionFactory"></a>3.4.2 使用代码构建SqlSessionFactory</h4><ul>
<li><p>示例: 使用代码构建SqlSessionFactory</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据库连接池信息</span></span><br><span class="line">PooledDataSource dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">dataSource.setDriver(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setUsername(<span class="string">"root"</span>);</span><br><span class="line">dataSource.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">dataSource.setUrl(<span class="string">"jdbc://localhost:3306/ssm"</span>);</span><br><span class="line">dataSource.setDefaultAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//采用MyBatis的JDBC事务方式</span></span><br><span class="line">TransactionFactory transactionFactory = <span class="keyword">new</span> JdbcTransactionFactory();</span><br><span class="line">Environment environment = <span class="keyword">new</span> Environment(<span class="string">"development"</span>, transactionFactory, dataSource);</span><br><span class="line">Configuration configuration = <span class="keyword">new</span> Configuration(environment);</span><br><span class="line">configuration.getTypeAliasRegistry().registerAlias(<span class="string">"role"</span>, Role,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">configuration.addMapper(RoleMapper.class);</span><br><span class="line">SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(configuration);</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 但是代码冗长，如果系统发生修改，那么有可能重新编译代码才能继续，所以这不是一个很好的方式。</p>
</li>
</ul>
<h3 id="2-5-SqlSession"><a href="#2-5-SqlSession" class="headerlink" title="2.5 SqlSession"></a>2.5 SqlSession</h3><ul>
<li><p>简介</p>
<ul>
<li>在<code>MyBatis</code>中，<code>SqlSession</code>是其核心接口</li>
<li>在<code>MyBatis</code>中有两个实现类，<code>DefaultSqlSession</code>和<code>SqlSessionManager</code>，<code>DefaultSqlSession</code>是单线程使用的，<code>SqlSessionManager</code>在多线程环境下使用</li>
<li><code>SqlSession</code>的作用类似于一个<code>JDBC</code>中的<code>Connection</code>对象，代表着一个连续资源的启用</li>
</ul>
</li>
<li><p><code>SqlSession</code>的主要作用</p>
<ul>
<li>获取<code>Mapper</code>接口</li>
<li>发送<code>Sql</code>给数据库</li>
<li>控制数据库事务</li>
</ul>
</li>
</ul>
<ul>
<li><p><code>SqlSession</code>只是一个门面(<code>Facade</code>)接口，它有很多方法，可以直接发送<code>SQL</code></p>
<ul>
<li>它就好像一家软件公司的商务人员，是一个门面，而实际干活的是软件工程师</li>
<li>在<code>MyBatis</code>中，真正干活的是<code>Executor</code></li>
</ul>
</li>
<li><p>示例: <code>SqlSession</code>控制事务的伪代码</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    sqlSession = SqlSessionFactory.openSession();</span><br><span class="line">    sqlSession.commit();</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">    sqlSession.rollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sqlSession != <span class="keyword">null</span>)&#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-6-映射器-Mapper"><a href="#3-6-映射器-Mapper" class="headerlink" title="3.6 映射器(Mapper)"></a>3.6 映射器(Mapper)</h3><ul>
<li><p>简介</p>
<ul>
<li>映射器是<code>MyBatis</code>中最重要、最复杂的组件</li>
<li>它由一个接口和对应的<code>XML</code>文件组成</li>
</ul>
</li>
<li><p>映射器可以配置以下内容</p>
<ul>
<li>描述映射规则</li>
<li>提供<code>SQL</code>语句，并可以配置<code>SQL</code>参数类型、返回类型、缓存刷新等信息</li>
<li>配置缓存</li>
<li>提供动态<code>SQL</code></li>
</ul>
</li>
<li><p>映射器的主要功能</p>
<ul>
<li>将<code>SQL</code>查询到的结果映射为一个<code>POJO</code></li>
<li>将<code>POJO</code>的数据插入到数据库</li>
<li>定义一些关于缓存等的重要内容</li>
</ul>
</li>
</ul>
<h4 id="3-6-1-用XML实现映射器"><a href="#3-6-1-用XML实现映射器" class="headerlink" title="3.6.1 用XML实现映射器"></a>3.6.1 用XML实现映射器</h4><ul>
<li><p>步骤</p>
<ol>
<li><p>先定义一个映射器接口</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用XML的方式创建映射器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"myBatisDemo.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">        select id, role_name as roleName, note from t_role where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>上面XML文件的解读</p>
<ul>
<li><code>&lt;mapper&gt;</code>元素中的属性<code>namespace</code>所对应的是一个接口的全限定名，于是<code>MyBatis</code>上下文就可以通过它找到对应的接口</li>
<li><code>&lt;select&gt;</code>元素表明这是一条查询语句，而属性<code>id</code>标识了这条<code>SQL</code>，属性<code>parameterType=&quot;long&quot;</code>说明传递给<code>SQL</code>的是一个<code>long</code>型参数，而<code>resultType=&quot;role&quot;</code>表示返回的是一个<code>role</code>类型的返回值</li>
<li>这条<code>SQL</code>中的<code>#{id}</code>表示传递进去的参数</li>
</ul>
</li>
</ul>
<h4 id="3-6-2-注解实现映射器"><a href="#3-6-2-注解实现映射器" class="headerlink" title="3.6.2 注解实现映射器"></a>3.6.2 注解实现映射器</h4><ul>
<li><p>还可以采用注解的方式定义映射器，它只需要一个接口就可以通过<code>MyBatis</code>的注解来注入SQL</p>
</li>
<li><p>示例: 通过注解实现映射器</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleMapper2</span></span>&#123;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select id, role name as roleName, note from t_role where id=#&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Role <span class="title">getRole</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注意: 如果它和XML方式同时定义时，XML方式将覆盖掉注解方式，所以<code>MyBatis</code>官方推荐使用的是<code>XML</code>的方式</p>
</li>
<li><p>注解方式的缺点</p>
<ul>
<li>如果把大量的SQL放入到java代码中，显然代码的可读性会降低</li>
<li>如果同时还要考虑使用动态SQL，会使得注解更加复杂，不利于日后的维护和修改</li>
<li>XML可以相互引入，而注解则不可以</li>
</ul>
</li>
</ul>
<h4 id="3-6-3-SqlSession发送SQL"><a href="#3-6-3-SqlSession发送SQL" class="headerlink" title="3.6.3 SqlSession发送SQL"></a>3.6.3 SqlSession发送SQL</h4><ul>
<li><p>有了映射器就可以通过SqlSession发送SQL</p>
</li>
<li><p>示例: 使用SqlSession发送SQL</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Role role = (Role)sqlSession.selectOne(<span class="string">"mapper.RoleMapper.getRole"</span>, <span class="number">1l</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>代码解释</p>
<ul>
<li><code>selectOne</code>方法表示使用查询并且只返回一个对象，而参数则是一个<code>String</code>对象和一个<code>Object</code>对象</li>
<li><code>String</code>对象是由一个命名空间加上<code>SQL id</code>组合而成的，它完全定位了一条<code>SQL</code>，这样<code>MyBatis</code>就会找到对应的<code>SQL</code></li>
</ul>
</li>
</ul>
<h4 id="3-6-4-用Mapper接口发送SQL"><a href="#3-6-4-用Mapper接口发送SQL" class="headerlink" title="3.6.4 用Mapper接口发送SQL"></a>3.6.4 用Mapper接口发送SQL</h4><ul>
<li><p><code>SqlSession</code>还可以获得<code>Mapper</code>接口，通过<code>Mapper</code>接口发送<code>SQL</code></p>
</li>
<li><p>示例:通过<code>Mapper</code>接口发送<code>SQL</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">Role role = roleMapper.getRole(<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-6-5-对比两种发送SQL的方式"><a href="#3-6-5-对比两种发送SQL的方式" class="headerlink" title="3.6.5 对比两种发送SQL的方式"></a>3.6.5 对比两种发送SQL的方式</h4><ul>
<li>笔者建议使用<code>SqlSession</code>获取<code>Mapper</code>的方式来发送<code>SQL</code><ul>
<li>使用<code>Mapper</code>接口编程可以消除<code>SqlSession</code>带来的功能性代码，提高可读性，类似<code>roleMapper.getRole(1L)</code>是完全面向对象的语言，更能体现业务逻辑</li>
<li>使用<code>mapper.getRole(1L)</code>的方式，IDE会提示错误和校验</li>
</ul>
</li>
</ul>
<h3 id="3-7-生命周期"><a href="#3-7-生命周期" class="headerlink" title="3.7 生命周期"></a>3.7 生命周期</h3><ul>
<li>生命周期: 生命周期就是每个对象应该存活的时间，比如一些对象一次用完后就要关闭，使它们被JVM销毁</li>
</ul>
<h4 id="3-7-1-SqlSessionFactoryBuilder"><a href="#3-7-1-SqlSessionFactoryBuilder" class="headerlink" title="3.7.1 SqlSessionFactoryBuilder"></a>3.7.1 SqlSessionFactoryBuilder</h4><ul>
<li><p><code>SqlSessionFactoryBuilder</code> 的作用在于创建<code>SqlSessionFactory</code>，创建成功后，<code>SqlSessionFactoryBuilder</code> 就失去了作用</p>
</li>
<li><p>所以它只能存在于创建<code>SqlSessionFactory</code> 的方法中，而不要让其长期存在。</p>
</li>
</ul>
<h4 id="3-7-2-SqlSessionFactory"><a href="#3-7-2-SqlSessionFactory" class="headerlink" title="3.7.2 SqlSessionFactory"></a>3.7.2 SqlSessionFactory</h4><ul>
<li><p><code>SqlSessionFactory</code> 可以被认为是一个数据库连接池，它的作用是创建 <code>SqlSession</code> 接口对象。</p>
</li>
<li><p>因为 <code>MyBatis</code> 的本质就是 <code>Java</code> 对数据库的操作，所以 <code>SqlSessionFactory</code> 的生命周期存在于整个 <code>MyBatis</code> 的应用之中，所以一旦创建了<code>SqlSessionFactory</code>，就要长期保存它，直至不再使用<code>MyBatis</code>应用</p>
</li>
<li><p>在一般的应用中我们往往希望 <code>SqlSessionFactory</code> 作为一个单例，让它在应用中被共享。</p>
</li>
</ul>
<h4 id="3-7-3-SqlSession"><a href="#3-7-3-SqlSession" class="headerlink" title="3.7.3 SqlSession"></a>3.7.3 SqlSession</h4><ul>
<li><p><code>SqlSession</code> 就相当于一个数据库连接(<code>Connection</code> 对象)</p>
</li>
<li><p>它应该存活在一个业务请求中，处理完整个请求后，应该关闭这条连接，让它归还给<code>SqlSessionFactory</code> ， 否则数据库资源就很快被耗费精光，系统就会瘫痪，所以用<code>try... catch ... finally ...</code>语句来保证其正确关闭。</p>
</li>
</ul>
<h4 id="3-7-4-Mapper"><a href="#3-7-4-Mapper" class="headerlink" title="3.7.4 Mapper"></a>3.7.4 Mapper</h4><ul>
<li><p><code>Mapper</code> 是一个接口，它由 <code>SqlSession</code> 所创建，所以它的最大生命周期至多和 <code>SqlSession</code> 保持一致</p>
</li>
<li><p><code>Mapper</code> 代表的是一个请求中的业务处理，所以它应该在一个请求中，一旦处理完了相关的业务，就应该废弃它。</p>
</li>
</ul>
<h4 id="3-7-5-总结"><a href="#3-7-5-总结" class="headerlink" title="3.7.5 总结"></a>3.7.5 总结</h4><ul>
<li><code>MyBatis</code>组件的生命周期<br>  <img src="/2019/12/25/SSM-3-认识MyBatis核心组件/0428_0.png" alt=""></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/SSM-2-JAVA设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/SSM-2-JAVA设计模式/" itemprop="url">[SSM][2][JAVA设计模式]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:39:40+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/SSM-2-JAVA设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/SSM-2-JAVA设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-2-章-JAVA设计模式"><a href="#第-2-章-JAVA设计模式" class="headerlink" title="第 2 章 JAVA设计模式"></a>第 2 章 JAVA设计模式</h2><h3 id="2-1-JAVA反射技术"><a href="#2-1-JAVA反射技术" class="headerlink" title="2.1 JAVA反射技术"></a>2.1 JAVA反射技术</h3><ul>
<li><p>Java反射技术应用广泛，它能够配置：类的全限定名、方法和参数，完成对象的初始化，甚至是反射某些方法</p>
</li>
<li><p>在Java中，反射是通过包<code>java.lang.reflect.*</code>来实现的</p>
</li>
</ul>
<h4 id="2-1-1-通过反射构建对象"><a href="#2-1-1-通过反射构建对象" class="headerlink" title="2.1.1 通过反射构建对象"></a>2.1.1 通过反射构建对象</h4><ul>
<li><p>Java中允许通过反射配置信息构建对象</p>
</li>
<li><p>示例一: 通过反射构建无参数的实例</p>
<ul>
<li><p>ReflectServiceImpl: 我们要构建的类</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectServiceImpl</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello, "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>反射生成对象的方式</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectServiceImpl <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReflectServiceImpl object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//给类加载器注册了一个类ReflectServiceImpl的全限定名，然后通过newInstance方法初始化一个对象</span></span><br><span class="line">        object = (ReflectServiceImpl)Class.forName(<span class="string">"com.edu.neu.ReflectServiceImpl"</span>).newInstance();</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException | InstantiationException | IllegalAccessException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>示例二: 通过反射构建有参数的实例</p>
<ul>
<li><p>ReflectServiceImpl2: 构造方法含有参数的类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectServiceImpl2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReflectServiceImpl2</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过反射生成带有参数的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ReflectServiceImpl2 <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReflectServiceImpl2 object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="comment">//先通过forName加载到类的加载器。然后通过getConstructor方法，它的参数可以是多个，这里定义为String.class,意为有且只有一个参数类型为String的构造方法</span></span><br><span class="line">        object = (ReflectServiceImpl2)Class.forName("com.edu.neu.ReflectServiceImpl2").getConstructor(String,class).newInstance("张三");</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>反射的优点: 只要配置就可以生成对象，可以解除程序的耦合度，比较灵活</p>
</li>
<li><p>反射的缺点: 运行比较慢</p>
</li>
</ul>
<h4 id="2-1-2-反射方法"><a href="#2-1-2-反射方法" class="headerlink" title="2.1.2 反射方法"></a>2.1.2 反射方法</h4><ul>
<li><p>下面讲解如何使用反射机制调用方法</p>
</li>
<li><p>示例: 获取和反射方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reflectMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Object returnObj = <span class="keyword">null</span>;</span><br><span class="line">    ReflectServiceImpl tatget = <span class="keyword">new</span> ReflectServiceImpl();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Method method = ReflectServiceImpl.class.getMethod(<span class="string">"sayHello"</span>, String.class);</span><br><span class="line">        returnObj = method.invoke(target, <span class="string">"张三"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-1-3-实例"><a href="#2-1-3-实例" class="headerlink" title="2.1.3 实例"></a>2.1.3 实例</h4><ul>
<li><p>示例: 如何通过反射生成对象和反射调用方法</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">reflect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReflectServiceImpl object = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        object = (ReflectServiceImpl)Class.forName(<span class="string">"com.edu.neu.ReflectServiceImpl"</span>).newInstance();</span><br><span class="line">        Method method = object.getClass().getMethod(<span class="string">"sayHello"</span>, String,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">        method.invoke(object, <span class="string">"张三"</span>);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | SecurityException | IllegalArgumentException | InvocationTargetException ex)&#123;</span><br><span class="line">        ex.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对象在反射机制下生成后，反射了方法，这样我们完全可以通过配置来完成对象和方法的反射，大大增加了Java的可配置性和可扩展性，其中<code>Spring IoC</code>就是一个典型的例子</p>
</li>
</ul>
<h3 id="2-2-动态代理模式和责任链模式"><a href="#2-2-动态代理模式和责任链模式" class="headerlink" title="2.2 动态代理模式和责任链模式"></a>2.2 动态代理模式和责任链模式</h3><ul>
<li><p>动态代理的意义在于生成一个占位(又称代理对象)，来代理真实对象，从而控制对真实对象的访问</p>
</li>
<li><p>代理的作用就是，在真实对象访问之前或之后加入对应的逻辑，或者根据其他规则控制是否使用真实对象，显然在这个例子中商务控制了客户对软件工程师的访问</p>
</li>
<li><p>示例<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0423_0.PNG" alt=""></p>
</li>
<li><p>我们需要在调用调用对象之前产生一个代理对象，而这个代理对象需要和真实对象建立起代理关系，所以代理对象分为两步</p>
<ul>
<li>代理对象和真实对象建立代理关系</li>
<li>实现代理对象的代理逻辑技术</li>
</ul>
</li>
<li><p>常见的动态代理技术</p>
<ol>
<li>JDK</li>
<li>CGLIB</li>
<li>Javassist</li>
<li>ASM</li>
</ol>
</li>
</ul>
<h4 id="2-2-1-JDK动态代理"><a href="#2-2-1-JDK动态代理" class="headerlink" title="2.2.1 JDK动态代理"></a>2.2.1 JDK动态代理</h4><ul>
<li><p>简介: JDK动态代理是<code>java.lang.reflect.*</code>包提供的方式，它<strong>必须借助一个接口</strong>才能产生代理对象</p>
</li>
<li><p>示例代码:使用JDK动态代理</p>
<ul>
<li><p>定义<code>HelloWorld</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>HelloWorldImpl</code>类实现<code>HelloWorld</code>接口，这个类充当真实对象的角色</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>JdkProxyExample</code>类来实现<code>java.lang.reflect.InvocationHandler</code>接口，这个类用来动态绑定代理和实现代理逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdkProxyExample</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 建立代理对象和真实对象的代理关系，并返回代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 代理对象</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">bind</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 代理方法逻辑</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy	代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 当前调用方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 当前方法参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> java.lang.Object 代理结果返回</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@date</span> 2019/4/23 16:26</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"进入代理逻辑方法"</span>);</span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之前的服务"</span>);</span><br><span class="line">        Object obj = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"在调度真实对象之后的服务"</span>);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序主入口，测试JDK动态代理<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        JdkProxyExample jdk = <span class="keyword">new</span> JdkProxyExample();</span><br><span class="line">        HelloWorld proxy = (HelloWorld)jdk.bind(<span class="keyword">new</span> HelloWorldImpl());</span><br><span class="line">        proxy.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>代码解读(<code>JdkProxyExample</code>类)</p>
<ol>
<li>建立代理对象和真实对象的关系<ul>
<li>这里使用<code>bind</code>方法完成，方法里首先用类的属性<code>target</code>保存了真实对象，并且调用<code>Proxy.newProxyInstace</code>建立并生成了代理对象</li>
<li><code>newProxyInstance</code>方法包含3个参数<ul>
<li>第1个是类加载器，我们采用了<code>target</code>本身的类加载器。</li>
<li>第2个是把生成的动态代理对象下挂在哪些接口下，这个写法就是放在<code>target</code>实现的接口下。<code>HelloWorldlmpl</code>对象的接口显然就是<code>HelloWorld</code></li>
<li>第3个是定义实现方法逻辑的代理类，<code>this</code>表示当前对象，它必须实现<code>InvocationHandler</code>接口的<code>invoke</code>方法，它就是代理逻辑方法的现实方法。</li>
</ul>
</li>
</ul>
</li>
<li>实现代理逻辑方法<ul>
<li><code>invoke</code>方法可以实现代理逻辑</li>
<li><code>invoke</code>方法的三个参数如下<ul>
<li><code>proxy</code>, 代理对象，也就是通过<code>bind</code>方法生成的对象</li>
<li><code>method</code>, 当前调度的方法</li>
<li><code>args</code>，调度方法的参数</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><p>类比前面的例子</p>
<ul>
<li>proxy 相当于商务</li>
<li>target 相当于软件工程师</li>
<li>bind 方法就是建立商务和软件工程师代理关系的方法</li>
<li>invoke，相当于商务逻辑，它控制对软件工程师的访问</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-CGLIB动态代理"><a href="#2-2-2-CGLIB动态代理" class="headerlink" title="2.2.2 CGLIB动态代理"></a>2.2.2 CGLIB动态代理</h4><ul>
<li><p>CGLIB动态代理的优势在于它不需要提供接口，只要一个非抽象类就可以实现动态代理</p>
</li>
<li><p>示例代码: CGLIB动态代理</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyExample</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成CGLIB代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cls Class类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Class类的CGLIB代理对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class cls)</span></span>&#123;</span><br><span class="line">        <span class="comment">//CGLIB enhancer增强类对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置增强类型</span></span><br><span class="line">        enhancer.setSuperclass(cls);</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象，要求当前对象实现MethodInterceptor接口</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//生成并返回代理对象</span></span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用真实对象前"</span>);</span><br><span class="line">        <span class="comment">//CGLIB反射调用真实对象</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"调用真实对象后"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxyExample cpe = <span class="keyword">new</span> CglibProxyExample();</span><br><span class="line">        ReflectServiceImpl obj = (ReflectServiceImpl)cpe.getProxy(ReflectServiceImpl.class);</span><br><span class="line">        obj.sayHello(<span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>概括: JDK动态代理和CGLIB动态代理都是通过<code>getProxy</code>方法生成代理对象，制定代理的逻辑类。而代理的逻辑类要实现一个接口的一个方法，这个方法就是代理对象的逻辑方法，它可以控制真实对象的方法</p>
</li>
</ul>
<h4 id="2-2-3-拦截器"><a href="#2-2-3-拦截器" class="headerlink" title="2.2.3 拦截器"></a>2.2.3 拦截器</h4><ul>
<li><p>拦截器可以进一步简化动态代理的使用方法，使程序变得更简单</p>
<ul>
<li>开发者只要知道拦截器的作用就可以编写拦截器，编写完后可以设置拦截器，这样就完成了任务，所以对于开发者来说相对简单了</li>
<li>设计者可能是精通java的开发人员，他来完成动态代理的逻辑</li>
<li>设计者只会把拦截器接口暴露给开发者使用，让动态代理的逻辑在开发者的视野中“消失”</li>
</ul>
</li>
<li><p>示例：使用JDK实现一个拦截器</p>
<ol>
<li><p>定义拦截器接口<code>Interceptor</code>,通常存在于类库中，由类库的设计人员实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 20:11</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>before</code>方法: 返回<code>boolean</code>值，它在真实对象前调用。当返回<code>true</code>时，则反射真实对象的方法；当返回为<code>false</code>时，则调用<code>around</code>方法</li>
<li><code>around</code>方法: 当<code>before</code>方法返回为<code>false</code>时，执行<code>around</code>方法</li>
<li>在反射真实对象方法或者<code>around</code>方法执行之后，调用<code>after</code>方法</li>
</ul>
</li>
<li><p>定义一个<code>Interceptor</code>接口的实现类，由开发人员实现，来控制对真实对象的访问，这里只是随便实现一个比较简单的没有任何功能的<code>Interceptor</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 20:14</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"反射方法前逻辑"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"取代了被代理对象的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">(Object proxy, Object target, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"反射方法后逻辑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在JDK动态代理中使用拦截器，由类库的设计者实现，对程序开发人员透明</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 20:16</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorJdkProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//真实对象</span></span><br><span class="line">    <span class="keyword">private</span> String interceptorClass = <span class="keyword">null</span>;<span class="comment">//拦截器全限定名</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InterceptorJdkProxy</span><span class="params">(Object target, String interceptorClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="keyword">this</span>.interceptorClass = interceptorClass;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 绑定委托对象并返回一个[代理占位]</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> target 真实对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> interceptorClass 实现了InvocationHandler的类</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 代理对象[占位]</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">bind</span><span class="params">(Object target, String interceptorClass)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), <span class="keyword">new</span> InterceptorJdkProxy(target, interceptorClass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/***</span></span><br><span class="line"><span class="comment">    * 通过代理对象调用方法， 首先进入这个方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> method 方法，被调用的方法</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> args 方法的参数</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(interceptorClass == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//没有设置拦截器则直接反射原有的方法</span></span><br><span class="line">            <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">        &#125;</span><br><span class="line">        Object result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//通过反射生成拦截器</span></span><br><span class="line">        Interceptor interceptor = (Interceptor) Class.forName(interceptorClass).newInstance();</span><br><span class="line">        <span class="comment">//调用前置方法</span></span><br><span class="line">        <span class="keyword">if</span>(interceptor.before(proxy, target, method, args))&#123;</span><br><span class="line">            <span class="comment">//反射原有的方法</span></span><br><span class="line">            result = method.invoke(target, args);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//假如返回false执行around方法</span></span><br><span class="line">            interceptor.around(proxy, target, method, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用后置方法</span></span><br><span class="line">        interceptor.after(proxy, target, method, args);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>执行步骤(针对上文<code>InterceptorProxy</code>类)<ol>
<li>在bind 方法中用JDK 动态代理绑定了一个对象，然后返回代理对象。</li>
<li>如果没有设置拦截器， 则直接反射真实对象的方法，然后结束，否则进行第 3 步。</li>
<li>通过反射生成拦截器，并准备使用它。</li>
<li>调用拦截器的before 方法，如果返回为true ，反射原来的方法；否则运行拦截器的around 方法。</li>
<li>调用拦截器的after 方法。</li>
<li>返回结果。</li>
</ol>
</li>
</ul>
</li>
<li>测试拦截器：可以看出，比手动实现Proxy的方式更加简单了 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ReflectDemo.JDKProxy.HelloWorld;</span><br><span class="line"><span class="keyword">import</span> ReflectDemo.JDKProxy.HelloWorldImpl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 20:32</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HelloWorld proxy = (HelloWorld) InterceptorJdkProxy.bind(<span class="keyword">new</span> HelloWorldImpl(), <span class="string">"InterceptorDemo.MyInterceptor"</span>);</span><br><span class="line">        proxy.sayHelloWorld();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>拦截器的工作流程图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_1.PNG" alt=""></p>
</li>
</ul>
<h4 id="2-2-4-责任链模式"><a href="#2-2-4-责任链模式" class="headerlink" title="2.2.4 责任链模式"></a>2.2.4 责任链模式</h4><ul>
<li><p>责任链模式</p>
<ul>
<li>当一个对象在一个链上被多个拦截器拦截处理（拦截器也可以选择不拦截处理它）时，我们把这种设计模式称为责任链模式</li>
<li>可以考虑用层层代理的方式来实现这种模式</li>
<li>拦截逻辑如下图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_0.PNG" alt=""></li>
</ul>
</li>
<li><p>示例：使用层层代理的方式实现责任链模式</p>
<ol>
<li><p>定义3个拦截器</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor1</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span> <span class="params">(Object proxy, Object target , Method method , Object [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器1的before方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span> <span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器1的after方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor2</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span> <span class="params">(Object proxy, Object target , Method method , Object [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器2的before方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span> <span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器2的after方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interceptor3</span> <span class="keyword">implements</span> <span class="title">Interceptor</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">before</span> <span class="params">(Object proxy, Object target , Method method , Object [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器3的before方法"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span> <span class="params">(Object proxy, Object target, Method method, Object [] args)</span></span>&#123; </span><br><span class="line">        System.out.println(<span class="string">"拦截器3的after方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试责任链模式上的多拦截器</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HelloWorld proxy1 = (HelloWorld)InterceptorJdkProxy.bind(<span class="keyword">new</span> HelloWorldimpl(), <span class="string">"interceptor.Interceptorl"</span>);</span><br><span class="line">    HelloWorld proxy2 = (HelloWorld)InterceptorJdkProxy.bind(proxy1, <span class="string">"interceptor.Interceptor2"</span>);</span><br><span class="line">    HelloWorld proxy3 = (HelloWorld)InterceptorJdkProxy.bind(proxy2, <span class="string">"interceptor.Interceptor3"</span>);           </span><br><span class="line">    proxy3.sayHelloWorld() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>before</code>方法按照从最后一个拦截器都第一个拦截器的加载顺序运行</li>
<li><code>after</code>方法按照从第一个拦截器到最后一个拦截器的加载顺序运行</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li>责任链模式的优缺点<ul>
<li>优点：可以在传递链上加入新的拦截器，增加拦截逻辑</li>
<li>缺点：会增加代理和反射，而代理和反射的性能不高</li>
</ul>
</li>
</ul>
<h3 id="2-3-观察者模式"><a href="#2-3-观察者模式" class="headerlink" title="2.3 观察者模式"></a>2.3 观察者模式</h3><ul>
<li><p>观察者模式</p>
<ul>
<li>又称为发布订阅模式，是对象的行为模式</li>
<li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监视着被观察者的状态，当被观察者的状态发生变化时，会通知所有观察者，并让其自动更新自己</li>
<li>被观察者是自变量而观察者是因变量</li>
</ul>
</li>
<li><p>示例：如何使用JDK中的观察者模式</p>
<ol>
<li><p>继承类库中的Observable类，定义一个被观察者</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:22</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductList</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; productList = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ProductList instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ProductList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductList <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> ProductList();</span><br><span class="line">            instance.productList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">(String newProduct)</span></span>&#123;</span><br><span class="line">        productList.add(newProduct);</span><br><span class="line">        System.out.println(<span class="string">"产品列表增加了: "</span> + newProduct);</span><br><span class="line">        <span class="keyword">this</span>.setChanged();</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(newProduct);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现类库中的Observer接口，定义两个被观察者</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingDongObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.out.println(<span class="string">"发布了新产品: "</span> + newProduct + <span class="string">"，已加入京东"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBaoObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.out.println(<span class="string">"发布了新产品: "</span> + newProduct + <span class="string">"，已加入淘宝"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试观察者模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@date</span> 2019/4/24 21:30</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                ProductList productList =ProductList.getInstance();</span><br><span class="line">                productList.addObserver(<span class="keyword">new</span> JingDongObserver());</span><br><span class="line">                productList.addObserver(<span class="keyword">new</span> TaoBaoObserver());</span><br><span class="line">                productList.addProduct(<span class="string">"呆滞牌夹心饼干"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ````### 2.3 观察者模式</span><br><span class="line"></span><br><span class="line">- 观察者模式</span><br><span class="line">    - 又称为发布订阅模式，是对象的行为模式</span><br><span class="line">    - 观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监视着被观察者的状态，当被观察者的状态发生变化时，会通知所有观察者，并让其自动更新自己</span><br><span class="line">    - 被观察者是自变量而观察者是因变量</span><br><span class="line"></span><br><span class="line">- 示例：如何使用JDK中的观察者模式</span><br><span class="line">    <span class="number">1</span>. 继承类库中的Observable类，定义一个被观察者</span><br><span class="line">        ````java</span><br><span class="line">        <span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line">        <span class="keyword">import</span> java.util.List;</span><br><span class="line">        <span class="keyword">import</span> java.util.Observable;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@date</span> 2019/4/24 21:22</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductList</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> List&lt;String&gt; productList = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">static</span> ProductList instance;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> <span class="title">ProductList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ProductList <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> ProductList();</span><br><span class="line">                    instance.productList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addProduct</span><span class="params">(String newProduct)</span></span>&#123;</span><br><span class="line">                productList.add(newProduct);</span><br><span class="line">                System.out.println(<span class="string">"产品列表增加了: "</span> + newProduct);</span><br><span class="line">                <span class="keyword">this</span>.setChanged();</span><br><span class="line">                <span class="keyword">this</span>.notifyObservers(newProduct);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现类库中的Observer接口，定义两个被观察者</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:27</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JingDongObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.out.println(<span class="string">"发布了新产品: "</span> + newProduct + <span class="string">"，已加入京东"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Observable;</span><br><span class="line"><span class="keyword">import</span> java.util.Observer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:28</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaoBaoObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object product)</span> </span>&#123;</span><br><span class="line">        String newProduct = (String) product;</span><br><span class="line">        System.out.println(<span class="string">"发布了新产品: "</span> + newProduct + <span class="string">"，已加入淘宝"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试观察者模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> t0ugh</span></span><br><span class="line"><span class="comment">* <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment">* <span class="doctag">@date</span> 2019/4/24 21:30</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProductList productList =ProductList.getInstance();</span><br><span class="line">        productList.addObserver(<span class="keyword">new</span> JingDongObserver());</span><br><span class="line">        productList.addObserver(<span class="keyword">new</span> TaoBaoObserver());</span><br><span class="line">        productList.addProduct(<span class="string">"呆滞牌夹心饼干"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h3 id="2-4-工厂模式和抽象工厂模式"><a href="#2-4-工厂模式和抽象工厂模式" class="headerlink" title="2.4 工厂模式和抽象工厂模式"></a>2.4 工厂模式和抽象工厂模式</h3><h4 id="2-4-1-普通工厂-Simple-Factory-模式"><a href="#2-4-1-普通工厂-Simple-Factory-模式" class="headerlink" title="2.4.1 普通工厂(Simple Factory)模式"></a>2.4.1 普通工厂(Simple Factory)模式</h4><ul>
<li><p>简介</p>
<ul>
<li>在简单工厂模式中，可以根据参数的不同返回不同类的实例</li>
<li>简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</li>
</ul>
</li>
<li><p>模式结构</p>
<ul>
<li><code>Factory</code>(工厂角色): 工厂角色负责实现创建所有实例的内部逻辑</li>
<li><code>Product</code>(抽象产品角色): 抽象产品角色是创建的所有产品的父类，负责描述所有实例所共有的公共接口</li>
<li><code>ConcreteProduct</code>(具体产品角色): 具体产品角色是创建目标，所有创建的对象都充当了这个角色的某个具体类的实例</li>
</ul>
</li>
<li><p>类图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_2.png" alt=""></p>
</li>
<li><p>时序图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_5.jpg" alt=""></p>
</li>
</ul>
<h4 id="2-4-2-抽象工厂-Abstract-Factory-模式"><a href="#2-4-2-抽象工厂-Abstract-Factory-模式" class="headerlink" title="2.4.2 抽象工厂(Abstract Factory)模式"></a>2.4.2 抽象工厂(Abstract Factory)模式</h4><ul>
<li><p>简介: </p>
<ul>
<li>提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。</li>
<li>抽象工厂模式又称为Kit模式，属于对象创建型模式。</li>
<li>用于生产一个产品族的产品</li>
</ul>
</li>
<li><p>模式结构</p>
<ul>
<li>AbstractFactory：抽象工厂</li>
<li>ConcreteFactory：具体工厂</li>
<li>AbstractProduct：抽象产品</li>
<li>Product：具体产品</li>
</ul>
</li>
<li><p>类图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_3.jpg" alt=""></p>
</li>
<li><p>时序图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0424_4.jpg" alt=""></p>
</li>
</ul>
<h3 id="2-5-建造者模式"><a href="#2-5-建造者模式" class="headerlink" title="2.5 建造者模式"></a>2.5 建造者模式</h3><ul>
<li><p>简介</p>
<ul>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
<li>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。根据中文翻译的不同，建造者模式又可以称为生成器模式。</li>
</ul>
</li>
<li><p>模式结构</p>
<ul>
<li>Builder：抽象建造者</li>
<li>ConcreteBuilder：具体建造者</li>
<li>Director：指挥者</li>
<li>Product：产品角色</li>
</ul>
</li>
<li><p>类图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0425_0.jpg" alt=""></p>
</li>
<li><p>时序图<br>  <img src="/2019/12/25/SSM-2-JAVA设计模式/0425_1.jpg" alt=""></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/数据结构考研-4-树与二叉树/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/数据结构考研-4-树与二叉树/" itemprop="url">[数据结构考研][4][树与二叉树]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:31:39+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/数据结构考研-4-树与二叉树/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/数据结构考研-4-树与二叉树/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第四章-树与二叉树"><a href="#第四章-树与二叉树" class="headerlink" title="第四章 树与二叉树"></a>第四章 树与二叉树</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    树形结构-&gt;二叉树[dir=none];</span><br><span class="line">    树形结构-&gt;树和森林[dir=none];</span><br><span class="line">    二叉树-&gt;概念[dir=none];</span><br><span class="line">    二叉树-&gt;操作[dir=none];</span><br><span class="line">    二叉树-&gt;应用[dir=none];</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-1-树的基本概念"><a href="#4-1-树的基本概念" class="headerlink" title="4.1 树的基本概念"></a>4.1 树的基本概念</h3><h4 id="4-1-1-树的定义"><a href="#4-1-1-树的定义" class="headerlink" title="4.1.1 树的定义"></a>4.1.1 树的定义</h4><p>任何一颗非空树要满足</p>
<ol>
<li>有且只有一个特定的称为根的节点</li>
<li>当$n$大于$1$时，其余节点可分为$m(m&gt;0)$个互不相交的有限集合$T_1, T_2, …,T_m$，其中每个集合本身又是一颗树，并且称为根节点的子树</li>
</ol>
<p>树是一种递归结构也是一种层次结构</p>
<h4 id="4-1-2-基本术语"><a href="#4-1-2-基本术语" class="headerlink" title="4.1.2 基本术语"></a>4.1.2 基本术语</h4><ul>
<li>祖先节点和子孙节点</li>
<li>双亲节点和孩子节点</li>
<li>兄弟节点</li>
<li>节点的度: 某节点的子节点的个数称为该节点的度</li>
<li>树的度: 树中节点的最大度数</li>
<li>分支节点: 度大于$0$的节点</li>
<li>叶子节点: 度为$0$的节点</li>
<li>节点的层次、深度、高度，数的高度</li>
<li>有序树和无序树</li>
<li>路径和路径长度</li>
<li>森林: 森林是$m(m\ge0)$棵互不相交的树的集合</li>
</ul>
<h4 id="4-1-3-树的性质"><a href="#4-1-3-树的性质" class="headerlink" title="4.1.3 树的性质"></a>4.1.3 树的性质</h4><ol>
<li>树中的节点数等于所有节点的度数$+1$</li>
<li>度为$m$的树中第$i$层上至多有$m^{i-1}$个节点</li>
<li>高度为$h$的$m$叉树至多有$\frac{m^h-1}{m-1}$个节点</li>
<li>具有$n$个节点的$m$叉树的最小高度为$log_m(n(m-1)+1)$</li>
</ol>
<h3 id="4-2-二叉树的概念"><a href="#4-2-二叉树的概念" class="headerlink" title="4.2 二叉树的概念"></a>4.2 二叉树的概念</h3><h4 id="4-2-1-二叉树的定义及其主要特性"><a href="#4-2-1-二叉树的定义及其主要特性" class="headerlink" title="4.2.1 二叉树的定义及其主要特性"></a>4.2.1 二叉树的定义及其主要特性</h4><h5 id="1-二叉树的定义"><a href="#1-二叉树的定义" class="headerlink" title="1 二叉树的定义"></a>1 二叉树的定义</h5><p>二叉树每个节点至多只有两棵子树，并且二叉树的子树有左右之分，其次序不能任意颠倒</p>
<p>二叉树与度为$2$的有序树的区别</p>
<ol>
<li>度为$2$的树至少有$3$个节点，而二叉树可以为空</li>
<li>度为$2$的有序树的孩子节点的左右次序是相对另一个孩子节点而言的，若某个节点只有一个孩子节点，则这个孩子节点就无需区分其左右顺序，而二叉树无论其孩子数是否为$2$，均需要确定其左右次序，即二叉树的节点次序不是相对于另一节点而言，而是确定的</li>
</ol>
<h5 id="2-几个特殊的二叉树"><a href="#2-几个特殊的二叉树" class="headerlink" title="2 几个特殊的二叉树"></a>2 几个特殊的二叉树</h5><ol>
<li><p>满二叉树: 除了叶子节点，所有节点度都是2</p>
</li>
<li><p>完全二叉树: 略</p>
</li>
<li><p>二叉排序树</p>
<ul>
<li>左子树上所有节点的关键字均小于根节点和关键字</li>
<li>右子树上所有节点的关键字均大于根节点和关键字</li>
<li>左子树和右子树又各是一棵二叉排序树</li>
</ul>
</li>
<li><p>平衡二叉树</p>
<ul>
<li>树上任一节点的左子树和右子树的深度之差不超过$1$</li>
</ul>
</li>
</ol>
<h5 id="3-二叉树的性质"><a href="#3-二叉树的性质" class="headerlink" title="3 二叉树的性质"></a>3 二叉树的性质</h5><ol>
<li>非空二叉树上的叶子节点数等于度为$2$的节点数加$1$，即$n_0=n_2+1$</li>
<li>非空二叉树上第$k$层上至多又$2^{k-1}$个节点</li>
<li>高度为$h$的二叉树至多为$2^h-1$</li>
<li>具有$n$个($n&gt;0$)节点的完全二叉树的高度为$log_2(n+1)$或$log_2n+1$</li>
</ol>
<h4 id="4-2-2-二叉树的存储结构"><a href="#4-2-2-二叉树的存储结构" class="headerlink" title="4.2.2 二叉树的存储结构"></a>4.2.2 二叉树的存储结构</h4><h5 id="1-顺序存储结构"><a href="#1-顺序存储结构" class="headerlink" title="1 顺序存储结构"></a>1 顺序存储结构</h5><p>二叉树的顺序存储结构是指用一组地址连续的存储单元依次自上而下、自左而右存储完全二叉树上的节点元素</p>
<p>依据二叉树的性质，完全二叉树和满二叉树采用顺序存储比较合适，树中节点的序号可以唯一地反应节点之间的逻辑关系，这样既可以节省存储空间，又能利用数组元素的下标值确定节点在二叉树中的位置，以及节点之间的关系</p>
<p>对于一般二叉树，为了让数组下标能反映二叉树中节点之间的逻辑关系，只能添加一些并不存在的空节点</p>
<h5 id="2-链式存储结构"><a href="#2-链式存储结构" class="headerlink" title="2 链式存储结构"></a>2 链式存储结构</h5><p>由于顺序存储的空间利用率较低，因此二叉树一般采用链式存储结构</p>
<p>二叉链表至少包含$3$个域: 数据域<code>data</code>、左指针域<code>lchild</code>和右指针域<code>rchild</code></p>
<p>二叉树的链式存储结构描述如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode, *BiTree;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-3-二叉树的遍历和线索二叉树"><a href="#4-3-二叉树的遍历和线索二叉树" class="headerlink" title="4.3 二叉树的遍历和线索二叉树"></a>4.3 二叉树的遍历和线索二叉树</h3><h4 id="4-3-1-二叉树的遍历"><a href="#4-3-1-二叉树的遍历" class="headerlink" title="4.3.1 二叉树的遍历"></a>4.3.1 二叉树的遍历</h4><p>二叉树的遍历是指按照某条搜索路径访问树中的每个节点，使得每个节点均被访问一次</p>
<h5 id="1-先序遍历-PreOrder"><a href="#1-先序遍历-PreOrder" class="headerlink" title="1 先序遍历(PreOrder)"></a>1 先序遍历(PreOrder)</h5><p>步骤如下:</p>
<ol>
<li>先访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrder</span><span class="params">(BiTree t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        visit(t);</span><br><span class="line">        PreOrder(t-&gt;lchild);</span><br><span class="line">        PreOrder(t-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2 中序遍历"></a>2 中序遍历</h5><p>步骤如下:</p>
<ol>
<li>中序遍历左子树</li>
<li>访问根节点</li>
<li>中序遍历右子树</li>
</ol>
<h5 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3 后序遍历"></a>3 后序遍历</h5><p>步骤如下:</p>
<ol>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ol>
<h5 id="4-递归算法与非递归算法的转换"><a href="#4-递归算法与非递归算法的转换" class="headerlink" title="4 递归算法与非递归算法的转换"></a>4 递归算法与非递归算法的转换</h5><p>以先序遍历和中序遍历为例</p>
<p>中序遍历</p>
<ol>
<li>先将根节点的左子孙全加入栈中</li>
<li>弹出并访问，并将该节点的右孩子和右孩子的所有左子孙加入栈中</li>
<li>重复执行2，直到栈为空</li>
</ol>
<p>先序遍历</p>
<ol>
<li>对于根节点和它的所有左子孙，先访问并加入栈中</li>
<li>弹出，访问该节点的右孩子和右孩子的所有左子孙并将它们加入栈中</li>
<li>重复执行2，直到栈为空</li>
</ol>
<p>后序遍历</p>
<ul>
<li>每个节点需要一个标志来判断是不是第一次被访问</li>
<li>先略</li>
</ul>
<h5 id="5-层次遍历"><a href="#5-层次遍历" class="headerlink" title="5 层次遍历"></a>5 层次遍历</h5><p>要进行层次遍历，需要借助一个队列</p>
<ol>
<li>先将二叉树的根节点入队，</li>
<li>然后出队，访问该节点，若它有左子树，则将左子树根节点入队；若它有右子树，则将右子树根节点入队。</li>
<li>如此反复，直到队列为空</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelOrder</span><span class="params">(BiTree T)</span></span>&#123;</span><br><span class="line">    InitQueue(Q);</span><br><span class="line">    BiTree p;</span><br><span class="line">    EnQueue(Q, T);</span><br><span class="line">    <span class="keyword">while</span>(!IsEmpty(Q))&#123;</span><br><span class="line">        DeQueue(Q, p);</span><br><span class="line">        visit(p);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rchild != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            EnQueue(Q, p-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-由遍历构造二叉树"><a href="#6-由遍历构造二叉树" class="headerlink" title="6 由遍历构造二叉树"></a>6 由遍历构造二叉树</h5><p>由二叉树的先序遍历和中序遍历可以唯一地确定一棵二叉树，以下几种也可以</p>
<ol>
<li>中序和后序</li>
<li>层序和中序</li>
</ol>
<p>但是先序和后序不可以</p>
<h4 id="4-3-2-线索二叉树"><a href="#4-3-2-线索二叉树" class="headerlink" title="4.3.2 线索二叉树"></a>4.3.2 线索二叉树</h4><h5 id="1-线索二叉树的基本概念"><a href="#1-线索二叉树的基本概念" class="headerlink" title="1 线索二叉树的基本概念"></a>1 线索二叉树的基本概念</h5><p>遍历二叉树的实质: 是对一个非线性结构进行线性化操作，使这个访问序列中的每个节点都有一个直接前驱和一个直接后继</p>
<p>引入线索二叉树是为了加快查找节点前驱和后继的速度</p>
<p>二叉树线索化的方法</p>
<ol>
<li>若无左子树，令<code>lchild</code>指向其前驱节点；若无右子树，令<code>rchild</code>指向其后继节点</li>
<li>还需要增加两个标志域来表明当前指针域所指对象是指向左/右子节点还是直接前驱/后继</li>
</ol>
<p>线索二叉树的储存结构描述为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ThreadNode</span> *<span class="title">lchild</span>, *<span class="title">rchild</span>;</span></span><br><span class="line">    <span class="keyword">int</span> ltag, rtag;</span><br><span class="line">&#125;ThreadNode;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-线索二叉树的构造"><a href="#2-线索二叉树的构造" class="headerlink" title="2 线索二叉树的构造"></a>2 线索二叉树的构造</h5><p>对二叉树的线索化，实质上是遍历一次二叉树，只是在遍历的过程中，检查当前节点左、右指针是否为空，若为空，将它们改为指向前驱节点和后继节点的线索</p>
<p>中序遍历的递归算法为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InThread</span><span class="params">(ThreadTree *p, ThreadTree *pre)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(p-&gt;lchild, pre);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;lchild == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p-&gt;lchild = pre;</span><br><span class="line">            p-&gt;ltag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( pre != <span class="literal">NULL</span> &amp;&amp; pre-&gt;rchilc == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            pre-&gt;rchild = p;</span><br><span class="line">            pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pre=p;</span><br><span class="line">        InThread(p-&gt;rchild, pre);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateInThread</span><span class="params">(ThreadTree T)</span></span>&#123;</span><br><span class="line">    ThreadTree pre = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(T != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        InThread(T, pre);</span><br><span class="line">        pre-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">        pre-&gt;rtag = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="3-线索二叉树的遍历"><a href="#3-线索二叉树的遍历" class="headerlink" title="3 线索二叉树的遍历"></a>3 线索二叉树的遍历</h5><p>中序线索化二叉树主要是为了访问运算服务的，这种遍历不再需要借助栈，因为它的节点隐含了线索二叉树的前驱和后继信息</p>
<p>算法如下</p>
<ol>
<li><p>求中序线索二叉树中中序序列下的第一个节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadNode *<span class="title">FirstNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(p-&gt;ltag==<span class="number">0</span>)&#123;</span><br><span class="line">        p=p-&gt;lchild;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求中序线索二叉树中节点p在中序序列下的后继节点</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function">ThreadNode *<span class="title">NextNode</span><span class="params">(ThreadNode *p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rtag==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> FirstNode(p-&gt;rchild);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> p-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ````    </span><br><span class="line"><span class="number">3.</span> 利用上面两个算法可以实现线索二叉树的中序遍历</span><br><span class="line">    ````c</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InOrder</span><span class="params">(ThreadNode *T)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(ThreadNode *p=FirstNode(T); p!=<span class="literal">NULL</span>; p=NextNode(p))&#123;</span><br><span class="line">            visit(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-4-树、森林"><a href="#4-4-树、森林" class="headerlink" title="4.4 树、森林"></a>4.4 树、森林</h3><h4 id="4-4-1-树的存储结构"><a href="#4-4-1-树的存储结构" class="headerlink" title="4.4.1 树的存储结构"></a>4.4.1 树的存储结构</h4><h5 id="1-父亲表示法"><a href="#1-父亲表示法" class="headerlink" title="1 父亲表示法"></a>1 父亲表示法</h5><p>这种存储方式采用一组连续空间来存储每个节点，同时在每个节点中增设一个伪指针，指示其父亲节点在数组中的位置</p>
<h5 id="2-孩子表示法"><a href="#2-孩子表示法" class="headerlink" title="2 孩子表示法"></a>2 孩子表示法</h5><p>孩子表示法是将每个节点的孩子节点都用单链表链接起来形成一个线性结构，此时$n$个节点就有$n$个孩子链表</p>
<h5 id="3-孩子兄弟表示法"><a href="#3-孩子兄弟表示法" class="headerlink" title="3 孩子兄弟表示法"></a>3 孩子兄弟表示法</h5><p>又称为二叉树表示法，以二叉链表作为树的存储结构，孩子兄弟表示法使每个节点包括三部分内容</p>
<ul>
<li>节点值</li>
<li>指向节点第一个孩子节点的指针</li>
<li>指向节点下一个兄弟节点的指针</li>
</ul>
<p>孩子兄弟表示法的存储结构描述<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>, *<span class="title">nextsibling</span>;</span></span><br><span class="line">&#125;CSNode</span><br></pre></td></tr></table></figure></p>
<h4 id="4-4-2-树、森林和二叉树的转换"><a href="#4-4-2-树、森林和二叉树的转换" class="headerlink" title="4.4.2 树、森林和二叉树的转换"></a>4.4.2 树、森林和二叉树的转换</h4><p>树与二叉树的关系</p>
<ul>
<li>给定一棵树，可以找到唯一的一棵二叉树与之对应。</li>
<li>从物理结构上看，树的孩子兄弟表示法与二叉树的二叉链表表示法相同</li>
<li>因此，可以用同一存储结构的不同解释将一棵树转换为二叉树</li>
</ul>
<p>树转换为二叉树的规则</p>
<ul>
<li>每个节点左指针指向它的第一个孩子节点</li>
<li>右指针指向它在树中的相邻兄弟节点</li>
</ul>
<p>森林转换为二叉树的规则</p>
<ul>
<li>先将森林中的每棵树转换为二叉树</li>
<li>将第一棵树的根作为转换后二叉树的根，将第一棵树的左子树作为转换后二叉树根的左子树</li>
<li>将第二棵树作为转化后二叉树的右子树</li>
<li>将第三棵树作为转化后二叉树根的右子树的右子树</li>
</ul>
<p>二叉树转换回森林的规则</p>
<ul>
<li>略，与前面的过程相反</li>
</ul>
<h4 id="4-4-3-树和森林的遍历"><a href="#4-4-3-树和森林的遍历" class="headerlink" title="4.4.3 树和森林的遍历"></a>4.4.3 树和森林的遍历</h4><h5 id="1-树的遍历"><a href="#1-树的遍历" class="headerlink" title="1 树的遍历"></a>1 树的遍历</h5><ol>
<li>先根遍历: 若树非空，则先访问根节点，再按从左到右的顺序遍历根节点的每棵子树。其顺序与这棵树相应二叉树的先序遍历顺序相同</li>
<li>后根遍历: 若树非空，则按从左到右的顺序遍历根节点的每棵子树，之后再访问根节点，其访问顺序与这棵树对应二叉树的中序遍历顺序相同</li>
</ol>
<h5 id="2-森林的遍历"><a href="#2-森林的遍历" class="headerlink" title="2 森林的遍历"></a>2 森林的遍历</h5><ol>
<li><p>先序遍历森林</p>
<ul>
<li>访问森林中第一课树的根节点</li>
<li>先序遍历第一课树中根节点的子树森林</li>
<li>先序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
<li><p>中序遍历森林</p>
<ul>
<li>中序遍历森林中第一棵树的根节点的子树森林</li>
<li>访问第一棵树的根节点</li>
<li>中序遍历除去第一棵树之后剩余的树构成的森林</li>
</ul>
</li>
</ol>
<h4 id="4-4-5-树的应用–并查集"><a href="#4-4-5-树的应用–并查集" class="headerlink" title="4.4.5 树的应用–并查集"></a>4.4.5 树的应用–并查集</h4><p>并查集是一种简单的集合表示，它支持以下三种操作</p>
<ol>
<li><code>Union(S, Root1, Root2)</code>: 把集合<code>S</code>中的子集合<code>Root2</code>并入子集合<code>Root1</code>。要求<code>Root1</code>和<code>Root2</code>互不相交，否则无法合并</li>
<li><code>Find(S, x)</code>: 查找集合<code>S</code>中单元素<code>x</code>所在的子集合，并返回该子集合的名字</li>
<li><code>Initial(S)</code>: 将集合<code>S</code>中的每个元素都初始化为只有一个单元素的子集合</li>
</ol>
<p>通常用树的父亲表示法作为并查集的存储结构</p>
<ul>
<li>每个子集合以一棵树表示</li>
<li>所有表示子集合的树，构成全集合的森林，存放在父亲表示数组内</li>
<li>为了得到两个子集合的并，只需要将其中一个子集合根节点的父亲指针指向另一个集合的根节点</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="keyword">int</span> UFSets[SIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initial</span><span class="params">(<span class="keyword">int</span> S[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++)&#123;</span><br><span class="line">        S[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(S[x] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        x = S[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> S[], <span class="keyword">int</span> Root1, <span class="keyword">int</span> Root2)</span></span>&#123;</span><br><span class="line">    S[Root2]=Root1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-5-树与二叉树的应用"><a href="#4-5-树与二叉树的应用" class="headerlink" title="4.5 树与二叉树的应用"></a>4.5 树与二叉树的应用</h3><h4 id="4-5-1-二叉排序树"><a href="#4-5-1-二叉排序树" class="headerlink" title="4.5.1 二叉排序树"></a>4.5.1 二叉排序树</h4><h5 id="1-二叉排序树的定义"><a href="#1-二叉排序树的定义" class="headerlink" title="1 二叉排序树的定义"></a>1 二叉排序树的定义</h5><p>二叉排序树(BST)，又称二叉查找树</p>
<ol>
<li>若左子树非空，则左子树上所有节点关键字值均小于根节点关键字值</li>
<li>若右子树非空。则右子树上所有节点关键字值均大于根节点关键字值</li>
<li>左、右子树本身也分别是一棵二叉排序树</li>
</ol>
<h5 id="2-二叉排序树的查找"><a href="#2-二叉排序树的查找" class="headerlink" title="2 二叉排序树的查找"></a>2 二叉排序树的查找</h5><p>二叉排序树的查找从根节点开始，沿某个分支逐层向下进行比较。若当前节点为空，则查找失败。若当前节点非空且与给定值相等，则查找成功。若给定关键字小于当前节点关键字，则在这个节点的左子树查找，否则在右子树查找。</p>
<h5 id="3-二叉排序树的插入"><a href="#3-二叉排序树的插入" class="headerlink" title="3 二叉排序树的插入"></a>3 二叉排序树的插入</h5><p>若为空，则直接插入节点；否则，若给定值小于当前节点值，则插入到左子树；否则，插入到右子树</p>
<h5 id="4-二叉排序树的构建"><a href="#4-二叉排序树的构建" class="headerlink" title="4 二叉排序树的构建"></a>4 二叉排序树的构建</h5><p>略</p>
<h5 id="5-二叉排序树的删除"><a href="#5-二叉排序树的删除" class="headerlink" title="5 二叉排序树的删除"></a>5 二叉排序树的删除</h5><ol>
<li>若被删除节点$z$是叶子节点，则直接删除</li>
<li>若节点$z$只有左子树或右子树，则让$z$的子树成为$z$父节点的子树，替代$z$的位置</li>
<li>若节点$z$有左、右两棵子树，则令$z$的直接后继(或直接前驱)替代$z$，然后将问题转换为$z$的直接后继(或直接前驱)的删除问题，直到转换为情况1或情况2</li>
</ol>
<h5 id="6-二叉排序树的查找效率分析"><a href="#6-二叉排序树的查找效率分析" class="headerlink" title="6 二叉排序树的查找效率分析"></a>6 二叉排序树的查找效率分析</h5><p>二叉排序树查找算法的效率，主要取决于树的高度。对于高度为$h$的二叉排序树，其插入和删除操作的运行时间都为$O(h)$</p>
<ul>
<li>若二叉排序树是一个只有左(或右)孩子的单支树，则其平均查找长度与单链表相同，为$O(n)$</li>
<li>若二叉排序树的左、右子树的高度之差的绝对值不超过$1$，则这样的二叉排序树为平衡二叉树，它的平均查找长度为$O(log_2n)$</li>
</ul>
<h4 id="4-5-2-平衡二叉树"><a href="#4-5-2-平衡二叉树" class="headerlink" title="4.5.2 平衡二叉树"></a>4.5.2 平衡二叉树</h4><h5 id="1-平衡二叉树的定义"><a href="#1-平衡二叉树的定义" class="headerlink" title="1 平衡二叉树的定义"></a>1 平衡二叉树的定义</h5><p>平衡二叉树: 任意节点的左、右子树高度差的绝对值不超过1，将这样的二叉树称为平衡二叉树</p>
<p>平衡因子: 定义节点左子树与右子树的高度差为该节点的平衡因子</p>
<h5 id="2-平衡二叉树的插入"><a href="#2-平衡二叉树的插入" class="headerlink" title="2 平衡二叉树的插入"></a>2 平衡二叉树的插入</h5><p>二叉排序树保证平衡的基本思想如下</p>
<ul>
<li>每当在二叉排序树中插入一个节点时，首先检查其插入路径上的节点是否因为此次操作而导致了不平衡</li>
<li>若导致了不平衡，则先找到插入路径上离插入节点最近的平衡因子的绝对值大于$1$的节点A</li>
<li>再对以A为根的子树，在保持二叉排序树特性的前提下，调整各节点的位置关系，使之重新达到平衡</li>
</ul>
<p>调整方法如下</p>
<ol>
<li>LL平衡旋转<ul>
<li>将A的左孩子B向右上旋转代替A成为根节点</li>
<li>将A节点向右下旋转成为B的右子树的根节点</li>
<li>B的原右子树作为A的左子树</li>
</ul>
</li>
<li>RR平衡旋转<ul>
<li>略</li>
</ul>
</li>
<li>LR平衡旋转<ul>
<li>先将A节点的左孩子B的右子树的根节点C向左上旋转提升到B节点的位置</li>
<li>然后再把该C节点向右上旋转提升到A节点的位置</li>
</ul>
</li>
<li>RL平衡旋转<ul>
<li>略<h5 id="3-平衡二叉树的查找"><a href="#3-平衡二叉树的查找" class="headerlink" title="3 平衡二叉树的查找"></a>3 平衡二叉树的查找</h5></li>
</ul>
</li>
</ol>
<p>含有n个节点的平衡二叉树的最大深度为$O(log_2n)$，因此平衡二叉树的平均查找长度为$O(log_2n)$</p>
<h4 id="4-5-3-哈夫曼树和哈夫曼编码"><a href="#4-5-3-哈夫曼树和哈夫曼编码" class="headerlink" title="4.5.3 哈夫曼树和哈夫曼编码"></a>4.5.3 哈夫曼树和哈夫曼编码</h4><h5 id="1-哈夫曼树的定义"><a href="#1-哈夫曼树的定义" class="headerlink" title="1 哈夫曼树的定义"></a>1 哈夫曼树的定义</h5><p>节点的权: 为树中节点赋予的一个表示某种特殊意义的数值</p>
<p>节点的带权路径长度: 从树根节点到该节点的路径长度与该节点上权值的乘积</p>
<p>树的带权路径长度: 树中所有叶节点的带权路径长度之和称为该树的带权路径长度</p>
<p>哈夫曼树(最优二叉树): 在含有n个带权叶子节点的二叉树中，带权路径长度最小的二叉树</p>
<h5 id="2-哈夫曼树的构建"><a href="#2-哈夫曼树的构建" class="headerlink" title="2 哈夫曼树的构建"></a>2 哈夫曼树的构建</h5><p>通过哈夫曼算法可以构建最优二叉树，如下</p>
<ol>
<li>将这$n$个节点分别作为$n$棵仅含有一个节点的二叉树，构成森林$F$</li>
<li>构造一个新节点，从$F$中选取两棵根节点权值最小的树作为新节点的左、右子树，并且将新节点的权值置为左、右子树上根节点的权值之和</li>
<li>从$F$中删除刚才选出的两棵树，同时将新得到的树加入到$F$中</li>
<li>重复2和3，直到F中只剩下一棵树为止</li>
</ol>
<p>从上述构建过程可以看出哈夫曼树的特点</p>
<ol>
<li>每个初始节点最终都成为叶节点，且权值越小的节点到根节点的路径长度越大</li>
<li>构建过程中共新建了$n-1$个节点，因此哈夫曼树中节点总数为$2n-1$</li>
<li>每次构建都选择两棵树作为新节点的孩子，因此哈夫曼树不存在度为1的节点</li>
</ol>
<h5 id="3-哈夫曼编码"><a href="#3-哈夫曼编码" class="headerlink" title="3 哈夫曼编码"></a>3 哈夫曼编码</h5><p>固定长度编码和可变长度编码: 对于待处理的一个字符串序列，若对每个字符用相同长度的二进制位表示，则称这种编码方式为固定长度编码；若允许对不同字符用不等长的二进制表示，则这种方式称为可变长度编码</p>
<p>可变长度编码的好处: 对频率高的字符赋以短编码，而对频率低的字符赋以长编码，从而可以使字符平均编码长度减短，达到压缩数据的效果</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/数据结构考研-3-栈和队列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/数据结构考研-3-栈和队列/" itemprop="url">[数据结构考研][3][栈和队列]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:26:47+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/数据结构考研-3-栈和队列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/数据结构考研-3-栈和队列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    线性表-&gt;操作受限[dir=none];</span><br><span class="line">    线性表-&gt;推广[dir=none];</span><br><span class="line">    操作受限-&gt;栈[dir=none];</span><br><span class="line">    操作受限-&gt;队列[dir=none];</span><br><span class="line">    栈-&gt;顺序栈[dir=none];</span><br><span class="line">    栈-&gt;链栈[dir=none];</span><br><span class="line">    栈-&gt;共享栈[dir=none];</span><br><span class="line">    队列-&gt;循环队列[dir=none];</span><br><span class="line">    队列-&gt;链式队列[dir=none];</span><br><span class="line">    队列-&gt;双端队列[dir=none];</span><br><span class="line">    推广-&gt;数组[dir=none];</span><br><span class="line">    数组-&gt;一维数组[dir=none];</span><br><span class="line">    数组-&gt;多维数组[dir=none];</span><br><span class="line">    多维数组-&gt;压缩存储[dir=none];</span><br><span class="line">    多维数组-&gt;稀疏矩阵[dir=none];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-栈"><a href="#3-1-栈" class="headerlink" title="3.1 栈"></a>3.1 栈</h3><h4 id="3-1-1-栈的基本概念"><a href="#3-1-1-栈的基本概念" class="headerlink" title="3.1.1 栈的基本概念"></a>3.1.1 栈的基本概念</h4><h5 id="1-栈的定义"><a href="#1-栈的定义" class="headerlink" title="1 栈的定义"></a>1 栈的定义</h5><p>栈(Stack)，只允许在一端进行插入或删除操作的线性表</p>
<p>栈顶(Top)，线性表允许进行插入和删除的那一端</p>
<p>栈底(Bottom)，固定的，不允许进行插入和删除的那一端</p>
<p>空栈，不含任何元素的空表</p>
<p>栈是一种后进先出(Last In First Out, LIFO)的结构</p>
<h5 id="2-栈的基本操作"><a href="#2-栈的基本操作" class="headerlink" title="2 栈的基本操作"></a>2 栈的基本操作</h5><p><code>InitStact()</code>: 初始化空栈</p>
<p><code>StackEmpty()</code>: 判断一个栈是否为空</p>
<p><code>Push()</code>: 进栈，若栈未满，则将新元素加入使其成为新的栈顶</p>
<p><code>Pop()</code>: 出栈，若栈未空，则弹出栈顶元素</p>
<p><code>GetTop()</code>: 获得栈顶元素的值</p>
<p><code>ClearStack()</code>: 摧毁栈，并释放栈所占的内存空间</p>
<h4 id="3-1-2-栈的顺序存储结构"><a href="#3-1-2-栈的顺序存储结构" class="headerlink" title="3.1.2 栈的顺序存储结构"></a>3.1.2 栈的顺序存储结构</h4><h5 id="1-顺序栈的实现"><a href="#1-顺序栈的实现" class="headerlink" title="1 顺序栈的实现"></a>1 顺序栈的实现</h5><p>采用顺序存储的栈称为顺序栈，它利用一组地址连续的存储单元存放自栈底到栈顶的数据元素，同时设附一个指针(top)指示当前栈顶的位置</p>
<p>栈的顺序存储类型可描述为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem;</span><br><span class="line">    <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">int</span> listsize;</span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p>
<h5 id="2-顺序栈的基本运算"><a href="#2-顺序栈的基本运算" class="headerlink" title="2 顺序栈的基本运算"></a>2 顺序栈的基本运算</h5><ol>
<li><p>初始化</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">InitStack</span><span class="params">(SqStack *s)</span></span>&#123;</span><br><span class="line">    s-&gt;elem = (ElemType *)<span class="built_in">malloc</span>(LIST_INIT_SIZE * <span class="keyword">sizeof</span>(ElemType));</span><br><span class="line">    <span class="keyword">if</span>(!s-&gt;elem)</span><br><span class="line">        <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    s-&gt;length = <span class="number">0</span>;</span><br><span class="line">    s-&gt;listsize = LIST_INIT_SIZE;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判栈空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">StackEmpty</span><span class="params">(SqStack *s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> == s-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Push</span><span class="params">(SqStack *s, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;length &gt;= s-&gt;listsize &amp;&amp; OVERFLOW == ReAllocStack(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;elem[s-&gt;length] = e;</span><br><span class="line">    s-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">Pop</span><span class="params">(SqStack *s, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = s-&gt;elem[s-&gt;length<span class="number">-1</span>];</span><br><span class="line">    s-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>读栈顶元素</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">GetTop</span><span class="params">(SqStack *s, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(s))&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = s-&gt;elem[s-&gt;length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="3-共享栈"><a href="#3-共享栈" class="headerlink" title="3 共享栈"></a>3 共享栈</h5><p>利用栈底位置相对不变的特性，可让两个顺序栈共享一个一维数据空间，将两个栈的栈底分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸</p>
<p>两个栈的栈顶指针都指向栈顶元素</p>
<ul>
<li><code>top=-1</code>时0号栈为空，<code>top1=MaxSize</code>时1号栈为空</li>
<li>仅当两个栈顶指针相邻(<code>top1-top0=1</code>)，判断为栈满</li>
<li>当0号栈进栈时<code>top0</code>先加<code>1</code>再赋值，1号栈进栈时<code>top1</code>先减<code>1</code>再赋值；出栈时则刚好相反</li>
</ul>
<h4 id="3-1-3-栈的链式存储结构"><a href="#3-1-3-栈的链式存储结构" class="headerlink" title="3.1.3 栈的链式存储结构"></a>3.1.3 栈的链式存储结构</h4><p>采用链式存储的栈称为链栈</p>
<ul>
<li>链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况</li>
<li>通常用单链表实现，并规定所有操作都是再单链表的表头进行。</li>
</ul>
<p>栈的链式存储类型可描述为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>&#123;</span></span><br><span class="line">    ElemType data;          <span class="comment">//数据域</span></span><br><span class="line">    Struct LinkNode *next;  <span class="comment">//指针栈</span></span><br><span class="line">&#125;*LinkStack;                <span class="comment">//栈类型定义</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-1-4-其他"><a href="#3-1-4-其他" class="headerlink" title="3.1.4 其他"></a>3.1.4 其他</h4><p>对于$n$个不同的元素进栈，出栈序列的个数为<br>
$$\frac{1}{n+1}C_{2n}^n=\frac{1}{n+1}\frac{2n!}{{n!}\times{n!}}$$ 
</p>
<h3 id="3-2-队列"><a href="#3-2-队列" class="headerlink" title="3.2 队列"></a>3.2 队列</h3><h4 id="3-2-1-队列的基本概念"><a href="#3-2-1-队列的基本概念" class="headerlink" title="3.2.1 队列的基本概念"></a>3.2.1 队列的基本概念</h4><h5 id="1-队列的定义"><a href="#1-队列的定义" class="headerlink" title="1 队列的定义"></a>1 队列的定义</h5><p>队列是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除</p>
<ul>
<li>其操作的特性为先进先出</li>
<li>队头(Front):允许删除的一端，又称队首</li>
<li>队尾(Rear):允许插入的一端</li>
<li>空队列: 不含任何元素的空表</li>
</ul>
<h5 id="2-队列常见的基本操作"><a href="#2-队列常见的基本操作" class="headerlink" title="2 队列常见的基本操作"></a>2 队列常见的基本操作</h5><ul>
<li><code>InitQueue()</code>:初始化队列，构建一个空队列Q</li>
<li><code>QueueEmpty()</code>:判队列空</li>
<li><code>EnQueue()</code>:入队</li>
<li><code>DeQueue()</code>:出队</li>
<li><code>GetHead()</code>:读取队头元素</li>
</ul>
<h4 id="3-2-2-队列的顺序存储结构"><a href="#3-2-2-队列的顺序存储结构" class="headerlink" title="3.2.2 队列的顺序存储结构"></a>3.2.2 队列的顺序存储结构</h4><h5 id="1-队列的顺序存储"><a href="#1-队列的顺序存储" class="headerlink" title="1 队列的顺序存储"></a>1 队列的顺序存储</h5><p>队列的顺序实现是值分配一块连续的存储单元存放队列中的元素，并附设两个指针<code>front</code>和<code>rear</code>分别指示队头元素和队尾元素</p>
<h5 id="2-循环队列"><a href="#2-循环队列" class="headerlink" title="2 循环队列"></a>2 循环队列</h5><p>将顺序队列设想为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。当队首指针<code>Q.front=MaxSize-1</code>后，再前进一个位置就自动为<code>0</code></p>
<p>为了区分队空还是队满的情况</p>
<ol>
<li>牺牲一个单元来区分队空和队满，入队时少用一个队列单元</li>
<li>类型中增设表示元素个数的数据成员</li>
<li>类型中增设<code>tag</code>数据成员，以区分是队满还是队空</li>
</ol>
<h5 id="3-循环队列的操作"><a href="#3-循环队列的操作" class="headerlink" title="3 循环队列的操作"></a>3 循环队列的操作</h5><p>当删除元素时，队头指针<code>+1</code></p>
<p>当插入元素时，队尾指针<code>+1</code></p>
<h4 id="3-2-3-队列的链式存储"><a href="#3-2-3-队列的链式存储" class="headerlink" title="3.2.3 队列的链式存储"></a>3.2.3 队列的链式存储</h4><h5 id="1-队列的链式存储"><a href="#1-队列的链式存储" class="headerlink" title="1 队列的链式存储"></a>1 队列的链式存储</h5><p>队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表</p>
<ul>
<li>出队时，首先判断队是否为空，若不空，则取出队头元素，将其从链表中摘除</li>
<li>入队时，建立一个新节点，将新节点插入到链表的尾部，并改让<code>Q.rear</code>指向这个新插入的节点</li>
</ul>
<h5 id="2-链式队列的基本操作"><a href="#2-链式队列的基本操作" class="headerlink" title="2 链式队列的基本操作"></a>2 链式队列的基本操作</h5><p>略</p>
<h4 id="3-2-4-双端队列"><a href="#3-2-4-双端队列" class="headerlink" title="3.2.4 双端队列"></a>3.2.4 双端队列</h4><p>双端队列: 双端队列是指允许两端都可以进行入队和出队操作的队列，将队列的两端分别称为前端和后端，两端都可以入队和出队。</p>
<p>输出受限的双端队列:允许在一端进行插入和删除，但在另一端只允许插入的双端队列称为输出受限的双端队列</p>
<p>输入受限的双端队列:允许在一端进行插入和删除，但在另一端只允许删除的双端队列称为输入受限的双端队列</p>
<h3 id="3-3-栈和队列的应用"><a href="#3-3-栈和队列的应用" class="headerlink" title="3.3 栈和队列的应用"></a>3.3 栈和队列的应用</h3><h4 id="3-3-1-栈在括号匹配中的应用"><a href="#3-3-1-栈在括号匹配中的应用" class="headerlink" title="3.3.1 栈在括号匹配中的应用"></a>3.3.1 栈在括号匹配中的应用</h4><p>思想如下</p>
<ul>
<li>初始设置一个空栈，顺序读入括号</li>
<li>若是右括号，则或者使置于栈顶的元素得以消解，或者不合法输入</li>
<li>若是左括号，则将其压入栈中</li>
<li>当算法结束时，要保证栈为空</li>
</ul>
<h4 id="3-3-2-栈在表达式求值中的应用"><a href="#3-3-2-栈在表达式求值中的应用" class="headerlink" title="3.3.2 栈在表达式求值中的应用"></a>3.3.2 栈在表达式求值中的应用</h4><p>中缀表达式</p>
<ul>
<li>通常表达式</li>
<li>例如<code>(a+b)*c</code></li>
</ul>
<p>后缀表达式</p>
<ul>
<li>运算符在操作数后面，在后缀表达式中已经考虑了运算符的优先级，没有括号</li>
<li>例如<code>ab+c*</code></li>
</ul>
<p>中缀表达式转后缀表达式</p>
<ol>
<li>遇到操作数直接输出</li>
<li>遇到操作符<ol>
<li>若优先级大于栈顶元素，则压入栈中</li>
<li>若优先级小于或等于栈顶元素，则弹出栈中操作符，直到优先级大于栈顶元素，然后压入栈中</li>
</ol>
</li>
<li>遇到左括号，压入栈中</li>
<li>遇到右括号，弹出栈顶元素直到弹出一个左括号</li>
</ol>
<h4 id="3-3-3-栈在递归中的应用"><a href="#3-3-3-栈在递归中的应用" class="headerlink" title="3.3.3 栈在递归中的应用"></a>3.3.3 栈在递归中的应用</h4><p>可以将递归算法转换为非递归算法，通常需要借助栈来实现这种转换</p>
<h4 id="3-3-4-队列在层次遍历中的应用"><a href="#3-3-4-队列在层次遍历中的应用" class="headerlink" title="3.3.4 队列在层次遍历中的应用"></a>3.3.4 队列在层次遍历中的应用</h4><p>可以用队列实现二叉树的层次遍历，思路如下</p>
<ol>
<li>根节点入队</li>
<li>若队空，则结束遍历，否则重复步骤3</li>
<li>队列中的第一个节点出队，访问它，若其有左孩子，左孩子入队；若其有右孩子，右孩子入队。</li>
</ol>
<h4 id="3-3-5-队列在计算机系统中的应用"><a href="#3-3-5-队列在计算机系统中的应用" class="headerlink" title="3.3.5 队列在计算机系统中的应用"></a>3.3.5 队列在计算机系统中的应用</h4><ol>
<li>解决主机与外部设备之间速度不匹配的问题</li>
<li>解决由多用户引起的资源竞争问题</li>
</ol>
<h3 id="3-4-特殊矩阵的压缩存储"><a href="#3-4-特殊矩阵的压缩存储" class="headerlink" title="3.4 特殊矩阵的压缩存储"></a>3.4 特殊矩阵的压缩存储</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/数据结构考研-2-线性表/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/数据结构考研-2-线性表/" itemprop="url">[数据结构考研][2][线性表]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:12:15+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/数据结构考研-2-线性表/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/数据结构考研-2-线性表/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-2-章-线性表"><a href="#第-2-章-线性表" class="headerlink" title="第 2 章 线性表"></a>第 2 章 线性表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    线性表-&gt;顺序存储[dir=none];</span><br><span class="line">    线性表-&gt;链式存储[dir=none];</span><br><span class="line">    链式存储-&gt;单链表[dir=none];</span><br><span class="line">    链式存储-&gt;双链表[dir=none];</span><br><span class="line">    链式存储-&gt;循环链表[dir=none];</span><br><span class="line">    链式存储-&gt;静态链表[dir=none];</span><br><span class="line">    单链表-&gt;指针实现[dir=none];</span><br><span class="line">    双链表-&gt;指针实现[dir=none];</span><br><span class="line">    循环链表-&gt;指针实现[dir=none];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-线性表的定义和基本操作"><a href="#2-1-线性表的定义和基本操作" class="headerlink" title="2.1 线性表的定义和基本操作"></a>2.1 线性表的定义和基本操作</h3><h4 id="2-1-1-线性表的定义"><a href="#2-1-1-线性表的定义" class="headerlink" title="2.1.1 线性表的定义"></a>2.1.1 线性表的定义</h4><p>线性表是具有相同数据类型的$n(n \ge 0)$个元素的有限序列，其中$n$为表长</p>
<p>若用$L$命名线性表，则其一般表示为<br>$$L=(a_1,a_2,…,a_n)$$</p>
<p>线性表的逻辑特性</p>
<ul>
<li>除第一个元素外，每个元素有且仅有一个直接前驱</li>
<li>除最后一个元素外，每个元素有且仅有一个直接后继</li>
</ul>
<p>线性表的特点有</p>
<ul>
<li>表中元素的个数有限</li>
<li>表中元素具有逻辑上的顺序性，在序列中各元素排序有其先后顺序</li>
<li>表中元素都是数据元素，每个元素都是单个数据</li>
<li>表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间</li>
<li>表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容</li>
</ul>
<p>注意: 线性表是一种逻辑结构，表示元素之间的一对一的相邻关系，顺序表和链表是指存储结构，两者属于不同层面的概念，因此不要混淆</p>
<h4 id="2-1-2-线性表的基本操作"><a href="#2-1-2-线性表的基本操作" class="headerlink" title="2.1.2 线性表的基本操作"></a>2.1.2 线性表的基本操作</h4><p>数据结构的基本操作</p>
<ul>
<li>一个数据结构的基本操作是指其最核心、最基本的操作</li>
<li>其他较复杂的操作可以通过基本操作来实现</li>
</ul>
<p>线性表的主要操作</p>
<ul>
<li><code>InitList(&amp;L)</code>: 初始化表，构建一个空的线性表</li>
<li><code>Length(L)</code>: 求表长，返回线性表$L$的长度，即$L$中数据元素的个数</li>
<li><code>LocateElem(L,e)</code>: 按值查找操作，在表$L$中查找具有给定关键字值的元素</li>
<li><code>GetElem(L,i)</code>: 按位查找操作。获取表$L$中第$i$个位置的元素的值</li>
<li><code>ListInsert(&amp;L, i, e)</code>:插入操作，在表$L$中的第$i$个位置上插入指定元素$e$</li>
<li><code>ListDelete(&amp;L, i ,&amp;e)</code>:删除操作，删除表$L$中第$i$个位置的元素，并用$e$返回删除的元素的值</li>
<li><code>PrintList(L)</code>:输出操作。按前后顺序输出线性表$L$的所有元素值</li>
<li><code>Empty(L)</code>:判空操作。若$L$为空表，则返回<code>true</code>，否则返回<code>false</code></li>
<li><code>DestroyList(&amp;L)</code>: 销毁操作。销毁线性表，并释放线性表$L$所占的内存空间<h3 id="2-2-线性表的顺序表示"><a href="#2-2-线性表的顺序表示" class="headerlink" title="2.2 线性表的顺序表示"></a>2.2 线性表的顺序表示</h3></li>
</ul>
<h4 id="2-2-1-顺序表的定义"><a href="#2-2-1-顺序表的定义" class="headerlink" title="2.2.1 顺序表的定义"></a>2.2.1 顺序表的定义</h4><p>线性表的顺序存储又称顺序表，它是用一组地址连续的存储单元依次存储线性表中的数据元素，从而使逻辑上相邻的两个元素在物理位置上也相邻</p>
<p>顺序表的特点是表中元素的逻辑顺序与其物理顺序相同</p>
<p>顺序表支持随机访问，即通过首地址和元素序号可在时间$O(1)$内找到指定的元素</p>
<p>顺序表的存储密度高，每个节点除了数据元素外，不存储其他多余的值</p>
<p>顺序表逻辑上相邻的元素物理上也相邻，所以插入和删除操作需要移动大量元素</p>
<h4 id="2-2-2-顺序表上基本操作的实现"><a href="#2-2-2-顺序表上基本操作的实现" class="headerlink" title="2.2.2 顺序表上基本操作的实现"></a>2.2.2 顺序表上基本操作的实现</h4><h5 id="1-插入操作"><a href="#1-插入操作" class="headerlink" title="1 插入操作"></a>1 插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(SqList *l, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; l-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l-&gt;length &gt;= l-&gt;listsize &amp;&amp; OVERFLOW == ReAllocList(l))&#123;</span><br><span class="line">            <span class="keyword">return</span> OVERFLOW;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = l-&gt;length - <span class="number">1</span>; j &gt;= i; j --)&#123;</span><br><span class="line">        l-&gt;elem[j+<span class="number">1</span>] = l-&gt;elem[j]; </span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;elem[i] = e;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>插入操作的时间复杂度</p>
<ul>
<li>最好情况: 在表尾插入，元素不需要后移，时间复杂度为$O(1)$</li>
<li>最坏情况: 在表头插入，元素整体都后移，时间复杂度$O(n)$</li>
<li>平均情况: 时间复杂度为$O(n)$<br>$$\sum_{i=1}^{n+1}p_i(n-i+1)=\sum_{i=1}^{n+1}\frac{1}{n+1}(n-i+1)=\frac{n}{2}$$</li>
</ul>
<h5 id="2-删除操作"><a href="#2-删除操作" class="headerlink" title="2 删除操作"></a>2 删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除元素</span></span><br><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(SqList *l, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; l-&gt;length)&#123;</span><br><span class="line">        e = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e = l-&gt;elem[i];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"before: %d\n"</span>, e-&gt;id);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; l-&gt;length - <span class="number">1</span>; j ++)&#123;</span><br><span class="line">        l-&gt;elem[j] = l-&gt;elem[j+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"after: %d\n"</span>, e-&gt;id);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除操作的时间复杂度</p>
<ul>
<li>最好情况: 删除表尾元素($i=n$)，无须移动元素，时间复杂度为$O(1)$</li>
<li>最坏情况: 删除表头元素($i=1$)，需要移动所有元素，时间复杂度为$O(n)$</li>
<li>平均情况: 时间复杂度为$O(n)$</li>
</ul>
<h5 id="3-按值查找"><a href="#3-按值查找" class="headerlink" title="3 按值查找"></a>3 按值查找</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按值查找元素</span></span><br><span class="line"><span class="function">Status <span class="title">LocateElem</span><span class="params">(SqList *l, ElemType e, <span class="keyword">int</span> *locate)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l-&gt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l-&gt;elem[i].id == e.id)&#123;</span><br><span class="line">            *locate = i;</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *locate = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> NOSUCHELEM; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按值查找的时间复杂度</p>
<ul>
<li>最好情况: 查找的元素就在表头，仅需比较$1$次，时间复杂度为$O(1)$</li>
<li>最坏情况: 查找的元素在表尾，需比较$n$次，时间复杂度为$O(n)$</li>
<li>平均情况: 时间复杂度为$O(n)$<br>$$\sum_{i=1}^{n}p_i\times{i}=\sum_{i=1}^{n}\frac{1}{n}\times{i}=\frac{n+1}{2}$$</li>
</ul>
<h3 id="2-3-线性表的链式表示"><a href="#2-3-线性表的链式表示" class="headerlink" title="2.3 线性表的链式表示"></a>2.3 线性表的链式表示</h3><p>链式存储线性表时，不需要使用地址连续的存储单元，即它不要求逻辑上相邻的两个元素在物理位置上也相邻</p>
<p>它通过”链”建立起数据元素之间的逻辑关系，因此对于线性表的插入、删除不需要移动元素，而只需要修改指针</p>
<h4 id="2-3-1-单链表的定义"><a href="#2-3-1-单链表的定义" class="headerlink" title="2.3.1 单链表的定义"></a>2.3.1 单链表的定义</h4><p>线性表的链式存储又称单链表，它是指通过一组任意的存储单元来存储线性表中的数据元素</p>
<p>为了建立数据元素之间的线性关系，对每个链表节点，除存放元素本身的信息外，还需要存放一个指向其后继的指针</p>
<p>单链表中节点类型的描述<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;LNode</span><br></pre></td></tr></table></figure></p>
<p>非随机存储</p>
<ul>
<li>由于单链表的元素是离散地分布在存储空间中的</li>
<li>所以单链表是非随机存取的存储结构</li>
<li>不能直接找到表中某个特定的节点</li>
</ul>
<p>头指针和头节点</p>
<ul>
<li>通常用头指针来标识一个单链表</li>
<li>为了操作方便，在单链表第一个节点之前附加一个节点，称为头节点。头节点的数据域可以不设任何信息，也可以记录表长等相关信息</li>
</ul>
<p>头节点和头指针的区别</p>
<ul>
<li>不管带不带头节点，头指针始终指向链表的第一个节点</li>
<li>而头节点是带头节点的链表中的第一个节点，节点内通常不存储信息</li>
</ul>
<p>引入头节点之后的优点</p>
<ol>
<li>由于开始节点的位置被存在头节点的指针域中，所以在链表的第一个位置上的操作与在表的其他位置上的操作一致，无须进行特殊处理</li>
<li>无论链表是否为空，其头指针都指向头节点的非空指针</li>
</ol>
<h4 id="2-3-2-单链表上基本操作的实现"><a href="#2-3-2-单链表上基本操作的实现" class="headerlink" title="2.3.2 单链表上基本操作的实现"></a>2.3.2 单链表上基本操作的实现</h4><h5 id="1-插入操作-1"><a href="#1-插入操作-1" class="headerlink" title="1 插入操作"></a>1 插入操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListInsert</span><span class="params">(LinkedList *l, <span class="keyword">int</span> i, ElemType e)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ListInsert: %d %d %s\n"</span>, i, e.id, e.name);</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; l-&gt;length)&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *curr = l-&gt;head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">        curr = curr-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    LNode *p = (LNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LNode));</span><br><span class="line">    p-&gt;elem = e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"AfterInsert: %d %s\n"</span>, p-&gt;elem.id, p-&gt;elem.name);</span><br><span class="line">    p-&gt;next = curr-&gt;next;</span><br><span class="line">    curr-&gt;next = p;</span><br><span class="line">    l-&gt;length++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: $O(n)$</p>
<p>扩展: 对某节点的前插操作</p>
<ol>
<li>前插操作是指在某节点的前面插入一个新节点，与后插操作相反</li>
<li>要找到插入节点的前驱节点，然后对这个节点执行后插操作</li>
</ol>
<h5 id="2-删除操作-1"><a href="#2-删除操作-1" class="headerlink" title="2 删除操作"></a>2 删除操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">ListDelete</span><span class="params">(LinkedList *l, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; l-&gt;length)&#123;</span><br><span class="line">        e = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *curr = l-&gt;head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">        curr = curr-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    *e = curr-&gt;next-&gt;elem;<span class="comment">//[正确写法]</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Delete: %d %s\n"</span>,e-&gt;id, e-&gt;name);</span><br><span class="line">    curr-&gt;next = curr-&gt;next-&gt;next;</span><br><span class="line">    l-&gt;length--;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: $O(n)$</p>
<p>扩展:删除节点<code>*p</code></p>
<ul>
<li>可以将其后继节点的值赋予其自身，然后删除后继节点</li>
<li>这样可以让时间复杂度为 $O(1)$</li>
</ul>
<h5 id="3-按序号查找操作"><a href="#3-按序号查找操作" class="headerlink" title="3 按序号查找操作"></a>3 按序号查找操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按位置查找元素</span></span><br><span class="line"><span class="function">Status <span class="title">GetElem</span><span class="params">(LinkedList *l, <span class="keyword">int</span> i, ElemType *e)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; l-&gt;length)&#123;</span><br><span class="line">        e = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    LNode *curr = l-&gt;head-&gt;next;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">        curr = curr-&gt;next; </span><br><span class="line">    &#125;</span><br><span class="line">    *e = curr-&gt;elem;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度$O(n)$</p>
<h5 id="4-按值查找操作"><a href="#4-按值查找操作" class="headerlink" title="4 按值查找操作"></a>4 按值查找操作</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Status <span class="title">LocateElem</span><span class="params">(LinkedList *l, ElemType e, <span class="keyword">int</span> *locate)</span></span>&#123;</span><br><span class="line">    LNode *curr = l-&gt;head;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(curr-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        curr = curr-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(curr-&gt;elem.id == e.id)&#123;</span><br><span class="line">            *locate = i;</span><br><span class="line">            <span class="keyword">return</span> OK;</span><br><span class="line">        &#125;</span><br><span class="line">        i ++;</span><br><span class="line">    &#125;</span><br><span class="line">    *locate = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> NOSUCHELEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>时间复杂度: $O(n)$</p>
<h4 id="2-3-3-双链表"><a href="#2-3-3-双链表" class="headerlink" title="2.3.3 双链表"></a>2.3.3 双链表</h4><p>双链表节点中有两个指针<code>prior</code>和<code>next</code>分别指向前驱节点和后继节点</p>
<h4 id="2-3-4-循环链表"><a href="#2-3-4-循环链表" class="headerlink" title="2.3.4 循环链表"></a>2.3.4 循环链表</h4><h5 id="1-循环单链表"><a href="#1-循环单链表" class="headerlink" title="1 循环单链表"></a>1 循环单链表</h5><p>循环单链表和单链表的区别是，表中最后一个节点的指针不是<code>NULL</code>，而是改为指向头节点，从而整个链表形成一个环</p>
<p>有时对单链表常做的操作是在表头和表尾进行的，此时对循环单链表不设头指针而仅设尾指针，从而效率更高，对表头和表尾进行操作都是$O(1)$</p>
<h5 id="2-循环双链表"><a href="#2-循环双链表" class="headerlink" title="2 循环双链表"></a>2 循环双链表</h5><p>略</p>
<h4 id="2-3-5-静态链表"><a href="#2-3-5-静态链表" class="headerlink" title="2.3.5 静态链表"></a>2.3.5 静态链表</h4><p>静态链表是借助数组来描述线性表的链式存储结构</p>
<p>节点也有数据域<code>data</code>和指针域<code>next</code>，但是，这里的指针是节点的相对地址(数组下标)</p>
<p>静态链表结构类型如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 50</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">int</span> next;</span><br><span class="line">&#125;SLinkedList[MAXSIZE];</span><br></pre></td></tr></table></figure></p>
<p>静态链表以<code>next == -1</code>为结束标志</p>
<p>总体来说，静态链表没有单链表使用起来方便</p>
<h4 id="2-3-6-顺序表和链表的比较"><a href="#2-3-6-顺序表和链表的比较" class="headerlink" title="2.3.6 顺序表和链表的比较"></a>2.3.6 顺序表和链表的比较</h4><h5 id="1-存取方式"><a href="#1-存取方式" class="headerlink" title="1 存取方式"></a>1 存取方式</h5><p>顺序表可以顺序存取，也可以随机存取，链表只能从表头顺序存取元素</p>
<h5 id="2-逻辑结构与物理结构"><a href="#2-逻辑结构与物理结构" class="headerlink" title="2 逻辑结构与物理结构"></a>2 逻辑结构与物理结构</h5><p>采用顺序存储时，逻辑上相邻的元素，其对应的物理存储位置也相邻</p>
<p>采用链式存储时，逻辑上相邻的元素，其物理存储位置不一定相邻</p>
<h5 id="3-查找、插入和删除操作"><a href="#3-查找、插入和删除操作" class="headerlink" title="3 查找、插入和删除操作"></a>3 查找、插入和删除操作</h5><p>按值查找操作</p>
<ul>
<li>顺序表无序时，两者的时间复杂度都为$O(n)$</li>
<li>顺序表有序时，可用折半查找，顺序表时间复杂度为$O(log_2n)$</li>
</ul>
<p>按位置查找</p>
<ul>
<li>顺序表为$O(1)$</li>
<li>链表为$O(n)$</li>
</ul>
<p>插入和删除</p>
<ul>
<li>链表的插入和删除只需要修改相关节点的指针域；而顺序表平均需要移动半个表长的元素</li>
<li>但是由于链表的每个节点都带有指针域，因而在存储空间上要比顺序存储代价大，存储密度不够大</li>
</ul>
<h5 id="4-空间分配动态存储"><a href="#4-空间分配动态存储" class="headerlink" title="4 空间分配动态存储"></a>4 空间分配动态存储</h5><ul>
<li>顺序表在静态存储分配情形下，一旦存储空间装满就不能扩充。在动态存储分配下，虽然存储空间可以扩充，但需要移动大量元素，效率很低</li>
<li>链式存储的节点空间只在需要时申请分配，灵活高效</li>
</ul>
<h5 id="5-如何选择存储结构"><a href="#5-如何选择存储结构" class="headerlink" title="5 如何选择存储结构"></a>5 如何选择存储结构</h5><ol>
<li><p>基于存储考虑</p>
<ul>
<li>难以估计线性表的长度和存规模时，不宜采用顺序表</li>
</ul>
</li>
<li><p>基于运算考虑</p>
<ul>
<li>若经常做的运算是按序号访问数据元素，则显然顺序表优于链表</li>
<li>若插入和删除操作较多，建议使用链表，因为不需要大量移动元素</li>
</ul>
</li>
<li><p>基于环境考虑</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/数据结构考研-1-绪论/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/数据结构考研-1-绪论/" itemprop="url">[数据结构考研][1][绪论]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T12:07:28+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/数据结构考研-1-绪论/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/数据结构考研-1-绪论/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-1-章-绪论"><a href="#第-1-章-绪论" class="headerlink" title="第 1 章 绪论"></a>第 1 章 绪论</h2><h3 id="1-1-数据结构的基本概念"><a href="#1-1-数据结构的基本概念" class="headerlink" title="1.1 数据结构的基本概念"></a>1.1 数据结构的基本概念</h3><h3 id="1-1-1-基本概念和术语"><a href="#1-1-1-基本概念和术语" class="headerlink" title="1.1.1 基本概念和术语"></a>1.1.1 基本概念和术语</h3><h5 id="1-数据"><a href="#1-数据" class="headerlink" title="1 数据"></a>1 数据</h5><p>数据是信息的载体，是描述客观事物属性的数、字符及所有能输入到计算机中并被计算机程序识别和处理的符号的集合</p>
<h5 id="2-数据元素"><a href="#2-数据元素" class="headerlink" title="2 数据元素"></a>2 数据元素</h5><p>数据元素是数据的基本单位，通常作为一个整体进行考虑和处理</p>
<p>一个数据元素可由若干数据项组成，数据项是构成数据元素的不可分割的最小单位</p>
<p>例如，学生记录就是一个数据元素，它由学号、姓名和性别等数据项组成</p>
<h5 id="3-数据对象"><a href="#3-数据对象" class="headerlink" title="3 数据对象"></a>3 数据对象</h5><p>数据对象是具有相同性质的数据元素的集合，是数据的一个子集。</p>
<p>例如，整数数据对象是集合<code>N={0, 1, 2}</code></p>
<h5 id="4-数据类型"><a href="#4-数据类型" class="headerlink" title="4 数据类型"></a>4 数据类型</h5><p>数据类型是一个值的集合和定义在此集合上的一组操作的总称</p>
<ol>
<li>原子类型: 其值不可再分的数据类型</li>
<li>结构类型: 其值可以再分解为若干成分的数据类型</li>
<li>抽象数据类型: 抽象数据组织及与之相关的操作</li>
</ol>
<h5 id="5-抽象数据类型"><a href="#5-抽象数据类型" class="headerlink" title="5 抽象数据类型"></a>5 抽象数据类型</h5><p>抽象数据类型(<code>ADT</code>)是指一个数据模型及定义在该模型上的一组操作</p>
<p>抽象数据类型的定义仅取决于它的一组逻辑特性，而与其再计算机内部如何表示和实现无关，即无论其内部结构如何变化，只要它的数学特性不变，都不影响其外部的使用</p>
<p>通常用数据对象、数据关系和基本操作集这样的三元组来表示抽象数据类型</p>
<h5 id="6-数据结构"><a href="#6-数据结构" class="headerlink" title="6 数据结构"></a>6 数据结构</h5><p>数据元素不是孤立存在的，它们之间存在某种关系</p>
<p>这种数据元素相互之间的关系称为结构</p>
<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合</p>
<p>数据结构包括三方面的内容：逻辑结构、存储结构和数据的运算</p>
<p>数据的逻辑结构和存储结构是密不可分的两个方面，一个算法的设计取决于所选定的逻辑结构，而算法的实现依赖于所采用的存储结构</p>
<h4 id="1-1-2-数据结构三要素"><a href="#1-1-2-数据结构三要素" class="headerlink" title="1.1.2 数据结构三要素"></a>1.1.2 数据结构三要素</h4><h5 id="1-数据的逻辑结构"><a href="#1-数据的逻辑结构" class="headerlink" title="1 数据的逻辑结构"></a>1 数据的逻辑结构</h5><p>逻辑结构是指数据元素之间的逻辑关系。它与数据的存储无关，独立于计算机</p>
<ol>
<li>集合: 结构中的数据元素之间除”同属于一个集合”的关系外，别无其他关系</li>
<li>线性结构: 结构中的数据元素之间只存在一对一的关系</li>
<li>树形结构: 结构中的数据元素之间存在一对多的关系</li>
<li>涂装结构或网状结构: 结构中的数据元素之间存在多对多的关系</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">digraph demo&#123;</span><br><span class="line">    数据的逻辑结构-&gt;线性结构[dir=none];</span><br><span class="line">    数据的逻辑结构-&gt;非线性结构[dir=none];</span><br><span class="line">    线性结构-&gt;一般线性表[dir=none];</span><br><span class="line">    线性结构-&gt;受限线性表[dir=none];</span><br><span class="line">    线性结构-&gt;线性表推广[dir=none];</span><br><span class="line">    受限线性表-&gt;栈[dir=none];</span><br><span class="line">    受限线性表-&gt;队列[dir=none];</span><br><span class="line">    受限线性表-&gt;串[dir=none];</span><br><span class="line">    线性表推广-&gt;数组[dir=none];</span><br><span class="line">    线性表推广-&gt;广义表[dir=none];</span><br><span class="line">    非线性结构-&gt;集合[dir=none];</span><br><span class="line">    非线性结构-&gt;树形结构[dir=none];</span><br><span class="line">    非线性结构-&gt;图状结构[dir=none];</span><br><span class="line">    树形结构-&gt;一般树[dir=none];</span><br><span class="line">    树形结构-&gt;二叉树[dir=none];</span><br><span class="line">    图状结构-&gt;有向图[dir=none];</span><br><span class="line">    图状结构-&gt;无向图[dir=none];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-数据的存储结构"><a href="#2-数据的存储结构" class="headerlink" title="2 数据的存储结构"></a>2 数据的存储结构</h5><p>存储结构是指数据结构在计算机中的表示(也叫做映像)，也称物理结构</p>
<p>数据的存储结构是用计算机语言实现的逻辑结构，它依赖于计算机语言</p>
<p>数据的存储结构主要由顺序存储、链式存储、索引存储和散列存储</p>
<ol>
<li>顺序存储<ul>
<li>把逻辑上相邻的元素存储在物理位置上也相邻的存储单元中，元素之间的关系由存储单元的邻接关系来体现</li>
<li>其优点是可以实现随机存取，每个元素占用最少的存储空间；</li>
<li>缺点是只能使用相邻的一整块存储单元，因此可能产生较多的外部碎片</li>
</ul>
</li>
<li>链式存储<ul>
<li>不要求逻辑上相邻的元素在物理位置上也相邻，借助指示元素存储地址的指针来表示元素之间的逻辑关系</li>
<li>优点是不会出现碎片现象，能充分利用所有存储结构</li>
<li>缺点是每个元素因存储指针而占用额外的存储空间，且只能实现顺序存取</li>
</ul>
</li>
<li>索引存储<ul>
<li>在存储元素信息的同时，还建立附加的索引表</li>
<li>索引表中的每一项称为索引项，索引项的一般形式是<code>关键字+地址</code></li>
<li>其优点是索引速度快</li>
<li>缺点是增加附加的索引表后会占用较多的存储空间</li>
<li>另外，在郑家和删除数据时要修改索引表，因而会花费较多时间</li>
</ul>
</li>
<li>散列存储<ul>
<li>根据元素的关键字直接计算出该元素的存储地址，又称<code>hash</code>存储</li>
<li>优点时检索、增加和删除节点的操作都很快</li>
<li>缺点是若散列函数不好，则可能出现元素存储单元的冲突，而解决冲突会增加时间和空间开销</li>
</ul>
</li>
</ol>
<h5 id="3-数据的运算"><a href="#3-数据的运算" class="headerlink" title="3 数据的运算"></a>3 数据的运算</h5><p>施加在数据上的运算包括运算的定义和实现</p>
<p>运算的定义是针对逻辑结构的，指出运算的功能</p>
<p>运算的实现是针对存储结构的，指出运算的具体操作步骤</p>
<h3 id="1-2-算法和算法评价"><a href="#1-2-算法和算法评价" class="headerlink" title="1.2 算法和算法评价"></a>1.2 算法和算法评价</h3><h4 id="1-2-1-算法的基本概念"><a href="#1-2-1-算法的基本概念" class="headerlink" title="1.2.1 算法的基本概念"></a>1.2.1 算法的基本概念</h4><p>算法是对特定问题求解步骤的一种描述，它是指令的优先序列，其中的每条指令表示一个或多个操作</p>
<p>算法的5个重要特性</p>
<ol>
<li>有穷性: 一个算法必须总是在执行有穷步之后结束，且每一步都可在有穷的时间内完成</li>
<li>确定性: 算法中每条指令必须由确切的含义，读者理解时不会产生二义性，即对于相同的输入只能得到相同的输出</li>
<li>可行性: 一个算法是可行的，即算法中描述的操作都是可以通过已经实现的基本算法执行有限次来实现的</li>
<li>输入: 一个算法有零个或多个输入，这些输入取自于某个特定的对象的集合</li>
<li>输出: 一个算法有一个或多个输出，这些输出是与输入有着某种特定关系的量</li>
</ol>
<p>通常设计一个好的算法应考虑达成如下目标</p>
<ol>
<li>正确性: 算法应能够正确地解决求解问题</li>
<li>可读性: 算法应具有良好的可读性，以帮助人们理解</li>
<li>健壮性: 输入非法数据时，算法应能适当做出反应或进行处理，而不会产生莫名奇妙的输出结果</li>
<li>效率和低存储量需求: 效率是指算法执行的时间，存储量需求是指算法执行过程中所需要的最大存储空间，这两者都与问题的规模有关</li>
</ol>
<h4 id="1-2-2-算法效率的度量"><a href="#1-2-2-算法效率的度量" class="headerlink" title="1.2.2 算法效率的度量"></a>1.2.2 算法效率的度量</h4><p>算法效率的度量是通过时间复杂度和空间复杂度来描述的</p>
<h5 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1 时间复杂度"></a>1 时间复杂度</h5><p>频度: 一个语句的频度是指该语句在算法中被重复执行的次数</p>
<p>$T(n)$: 算法中所有语句的频度之和记为$T(n)$，它是该算法问题规模$n$的函数</p>
<p>$T(n)$ 的数量级:若$T(n)=N^2 + N + 1$，数量级为$N^2$，时间复杂度主要分析$T(n)$的数量级，算法中基本运算(最深层循环内的语句)的频度$f(n)$与$T(n)$同数量级</p>
<p>通常采用算法中基本运算的频度 $f(n)$ 来分析算法的时间复杂度。因此，算法的时间复杂度记为 $T(n)=O(f(n))$</p>
<p>算法的时间复杂度不仅依赖于问题的规模 $n$，也取决于待输入数据的性质(如输入数据元素的初始状态)</p>
<ol>
<li>最坏时间复杂度: 在最坏情况下，算法的时间复杂度</li>
<li>平均时间复杂度: 所有可能输入实例在等概率出现的情况下，算法的期望运行时间</li>
<li>最好时间复杂度: 在最好情况下，算法的时间复杂度</li>
</ol>
<p>一般总是考虑在最坏情况下的时间复杂度，以确保算法的运行时间不会比它长</p>
<p>在分析一个程序的时间复杂性时，有以下两条规则</p>
<ol>
<li>加法规则<br>$$T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n), g(n))$$</li>
<li>乘法规则<br>$$T(n) = T_1(n) \times T_2(n) = O(f(n)) * O(g(n)) = O(f(n) \times g(n))$$</li>
</ol>
<p>常见的渐进时间复杂度为<br>$$O(1) &lt; O(log_2n) &lt; O(n) &lt; O(nlog_2n) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)$$</p>
<p>时间复杂度的两种解法</p>
<ol>
<li><p>循环主体中的变量参与循环条件的判断</p>
<ul>
<li>此类题应找出主体语句中与$T(n)$成正比的循环变量，将之代入条件中进行计算</li>
<li><p>例如</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= n)</span><br><span class="line">    i *= <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>  i乘以2的次数正是主题语句的执行次数，因此有$2^t \le n$，取对数后得$t \le log_2n$</p>
</li>
</ul>
</li>
<li>循环主题中的变量与循环条件无关<ul>
<li>此类题可采用数学归纳法或直接累计循环次数。多层循环时从内到外分析，忽略单步语句、条件判断语句，只关注主体语句的执行次数。此类问题又可分为递归程序和非递归程序</li>
<li>若用递归程序，一般用公式进行递推，例如: $T(n) = 1 + T(n - 1) = 1 + 1 + T(n - 2) = n - 1 + T(1)$</li>
<li>如果非递归程序，直接累计次数即可</li>
</ul>
</li>
</ol>
<h5 id="2-空间复杂度"><a href="#2-空间复杂度" class="headerlink" title="2 空间复杂度"></a>2 空间复杂度</h5><p>算法的空间复杂度$S(N)$定义为该算法所耗费的存储空间，它是问题规模$n$的函数。渐进空间复杂度也常简称为空间复杂度，记为$S(n)=O(g(n))$</p>
<p>一个上机程序出需要存储空间来存放本身所用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储为实现计算所需要的一些信息的辅助空间，若输入数据所占空间只取决于问题本身而与算法无关，只需分析除输入和程序外的额外空间</p>
<p>算法<em>原地工作</em>是指算法所需的辅助空间为常量，即$O(1)$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/C语言/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/C语言/" itemprop="url">[C语言]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T11:59:35+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/c/" itemprop="url" rel="index">
                    <span itemprop="name">c</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/C语言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/C语言/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="C语言笔记"><a href="#C语言笔记" class="headerlink" title="C语言笔记"></a>C语言笔记</h1><h2 id="第二章-常量、变量及数据类型"><a href="#第二章-常量、变量及数据类型" class="headerlink" title="第二章 常量、变量及数据类型"></a>第二章 常量、变量及数据类型</h2><h3 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h3><p>C语言的字符集包括：字母、数字、特殊字符和空格</p>
<h3 id="2-3-C标记符"><a href="#2-3-C标记符" class="headerlink" title="2.3 C标记符"></a>2.3 C标记符</h3><p>在C语言中最小的单元称为C标记符</p>
<p>C语言标记符包括</p>
<ol>
<li>关键字: float、while</li>
<li>标识符(给函数和变量起名): main、amount</li>
<li>常量: -15.9、100</li>
<li>字符串: “ABC”、”year”</li>
<li>运算符: <code>+</code>、<code>-</code></li>
</ol>
<h3 id="2-4-关键字与标识符"><a href="#2-4-关键字与标识符" class="headerlink" title="2.4 关键字与标识符"></a>2.4 关键字与标识符</h3><p>所有关键字都有固定的含义，且其含义不可改变</p>
<p>标识符是变量名、函数和数组名。是自定义的名称</p>
<p>标识符的规则</p>
<ol>
<li>第一个字符必须是字母或者下划线</li>
<li>只能由字母、数组或下划线组成</li>
<li>只有头31个字符是有效的(标识符最长31个字符)</li>
<li>不能使用关键字</li>
<li>不能包含空格</li>
</ol>
<h3 id="2-5-常量"><a href="#2-5-常量" class="headerlink" title="2.5 常量"></a>2.5 常量</h3><p>C语言的常量是指固定值，在程序的运行中不能修改<br>常量的类型</p>
<ul>
<li>数值常量<ul>
<li>整型常量</li>
<li>实数常量</li>
</ul>
</li>
<li>字符常量<ul>
<li>单字符常量</li>
<li>字符串常量</li>
</ul>
</li>
</ul>
<h4 id="2-5-1-整型常量"><a href="#2-5-1-整型常量" class="headerlink" title="2.5.1 整型常量"></a>2.5.1 整型常量</h4><p>整型常量有三种类型</p>
<ol>
<li>十进制<ul>
<li>由0-9的数字组成，前面可加<code>-</code>和<code>+</code></li>
<li>例如: 123、0、-312</li>
</ul>
</li>
<li>十六进制<ul>
<li>数字前加0x或0X的数字，由0-9及A-F或a-f组成</li>
<li>例如: 0x2、0x9f</li>
</ul>
</li>
<li>八进制<ul>
<li>由0-7的数字组成，且由0开头</li>
<li>例如: 02、027</li>
</ul>
</li>
</ol>
<p>补充: 二进制: <code>0b1100</code></p>
<p>可以给U、L和UL修饰符，U代表无符号整数，L代表长整数</p>
<h4 id="2-5-2-实数常量"><a href="#2-5-2-实数常量" class="headerlink" title="2.5.2 实数常量"></a>2.5.2 实数常量</h4><p>由十进制标识，且后面跟有一个小数点和小数部分，例如: 0.002、-0.79、215.、.96</p>
<p>也可用指数表示法，例如:0.65e4、12e2等</p>
<p>浮点常量通常为双精度数，但是后缀f或F用于强制转换为单精度数</p>
<h4 id="2-5-3-单字符常量"><a href="#2-5-3-单字符常量" class="headerlink" title="2.5.3 单字符常量"></a>2.5.3 单字符常量</h4><p>单字符常量是用一对单引号括起来的单个字符，例如: ‘X’、’:’等</p>
<p>字符常量具有ASCII整数值，可以对字符常量进行算术操作</p>
<h4 id="2-5-4-字符串常量"><a href="#2-5-4-字符串常量" class="headerlink" title="2.5.4 字符串常量"></a>2.5.4 字符串常量</h4><p>字符串常量是用双引号括起来的一系列字符，例如: “hello”、”2014”等</p>
<h4 id="2-5-5-反斜杠字符常量"><a href="#2-5-5-反斜杠字符常量" class="headerlink" title="2.5.5 反斜杠字符常量"></a>2.5.5 反斜杠字符常量</h4><p>符号’\n’为换行符</p>
<h3 id="2-6-变量"><a href="#2-6-变量" class="headerlink" title="2.6 变量"></a>2.6 变量</h3><p>变量是用来保存数据值的数据名</p>
<p>变量命名规则</p>
<ol>
<li>必须以字母开头，也可以下划线开头</li>
<li>ANSI标准只识别前31个字符</li>
<li>区分大小写</li>
<li>不能是关键字</li>
<li>不允许使用空格</li>
</ol>
<h3 id="2-7-数据类型"><a href="#2-7-数据类型" class="headerlink" title="2.7 数据类型"></a>2.7 数据类型</h3><p>C语言支持三种数据类型</p>
<ul>
<li>基本数据类型</li>
<li>派生数据类型</li>
<li>自定义数据类型</li>
</ul>
<p>五种基本数据类型</p>
<ol>
<li><p>整形(<code>int</code>)</p>
<ul>
<li>十六位计算机的整形为-32768-+32767，32位为-2147483648-+2147483647</li>
<li><code>short int</code>、<code>int</code>、<code>long int</code></li>
<li>还可将其声明为<code>unsigned int</code></li>
</ul>
</li>
<li><p>浮点型(<code>float</code>)与双精度浮点型(<code>double</code>)</p>
<ul>
<li><code>float</code>、<code>double</code>、<code>long double</code></li>
</ul>
</li>
<li><p>void类型</p>
<ul>
<li>void类型没有数值</li>
<li>当函数不返回值时定义为void</li>
<li>它还可以起一般作用，用于表示其他各种标准类型</li>
</ul>
</li>
<li><p>字符类型(<code>char</code>)</p>
<ul>
<li>单字符定义为字符类型，字符通常用8位来保存</li>
<li><code>signed</code>和<code>unsigned</code>可用于字符</li>
</ul>
</li>
</ol>
<h3 id="2-8-变量的声明"><a href="#2-8-变量的声明" class="headerlink" title="2.8 变量的声明"></a>2.8 变量的声明</h3><p>在设计了适当的变量名之后，需要进行变量声明。声明完成两件事</p>
<ol>
<li>告诉编译器变量名是什么</li>
<li>指定变量的数据类型</li>
</ol>
<h4 id="2-8-1-基本类型的声明"><a href="#2-8-1-基本类型的声明" class="headerlink" title="2.8.1 基本类型的声明"></a>2.8.1 基本类型的声明</h4><p>声明变量的语法为: <code>data-type v1,v2,v3;</code></p>
<p>目前的规则允许在函数或代码块的任何位置声明变量，但必须在使用前声明。之前的规则中，只允许在函数或代码块的开头位置声明变量</p>
<h4 id="2-8-2-自定义类型的声明"><a href="#2-8-2-自定义类型的声明" class="headerlink" title="2.8.2 自定义类型的声明"></a>2.8.2 自定义类型的声明</h4><p><code>Typedef type indentifier</code>用于将一个已有的数据类型，赋予一个新的名称。<code>type</code>为已有的数据类型，<code>identifier</code>是赋给该数据类型的新名字</p>
<p><code>typedef</code>的主要优点是可创建具有意义的数据类型名，从而提高程序的可读性</p>
<p>枚举类型<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">enum day&#123;Monday, Tuesday, ..., Sunday&#125;;</span><br><span class="line">enum day week_st, week_end;</span><br><span class="line">week_st = Sunday;</span><br><span class="line">week_end = Saturday;</span><br></pre></td></tr></table></figure></p>
<p>编译器自动将整数赋予给所有枚举常量，如上程序，0赋给<code>Monday</code>，1赋给<code>Tuesday</code></p>
<h3 id="2-9-存储类型的声明"><a href="#2-9-存储类型的声明" class="headerlink" title="2.9 存储类型的声明"></a>2.9 存储类型的声明</h3><p>全局变量与局部变量</p>
<ul>
<li>全局变量: 可以在程序的所有函数中使用，并不需要在其他函数中再进行声明</li>
<li>局部变量：只有再定义它的函数中可见且有意义</li>
</ul>
<p>C语言提供了一些存储类型标识符，可以显式地声明变量的作用域和生存期</p>
<ul>
<li>auto: 局部变量，直在声明它的函数中有效</li>
<li>static: 静态变量，不多解释，C中比较复杂(<a href="https://blog.csdn.net/keyeagle/article/details/6708077" target="_blank" rel="noopener">https://blog.csdn.net/keyeagle/article/details/6708077</a>)</li>
<li>extern: 全局变量，对文件中的所有函数都有效</li>
<li>register: 局部变量，存储在寄存器中</li>
</ul>
<h3 id="2-10-变量的赋值"><a href="#2-10-变量的赋值" class="headerlink" title="2.10 变量的赋值"></a>2.10 变量的赋值</h3><p>使用<code>=</code>运算符可以将数值赋给变量: <code>variable_name = constant</code></p>
<p>可以直接在变量声明时进行赋值: <code>data-type variable_name = constant;</code></p>
<p><code>scanf()</code>函数用来从键盘中读取输入的数据: <code>scanf(&quot;%d&quot;, &amp;number)</code></p>
<h3 id="2-11-符号常量的定义"><a href="#2-11-符号常量的定义" class="headerlink" title="2.11 符号常量的定义"></a>2.11 符号常量的定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 200</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="number">100</span> &lt; MAX)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"HEllo"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#define</code>语句是一条预处理编译器指令，它可以位于程序的任何位置，但是必须位于使用它的语句之前</p>
<h3 id="2-12-其他"><a href="#2-12-其他" class="headerlink" title="2.12 其他"></a>2.12 其他</h3><p><code>const</code>用来将变量声明为常量，在定义之后，这种变量无法再被修改</p>
<p><code>volatile</code>用于告诉编译器，变量的值可能随时被其他外部因素修改。每次碰到该变量时，编译器都会检测该变量的值是否被外部因素修改过</p>
<h2 id="第三章-运算符与表达式"><a href="#第三章-运算符与表达式" class="headerlink" title="第三章 运算符与表达式"></a>第三章 运算符与表达式</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>运算符是一种符号，它告诉计算机执行某些数学或逻辑操作</p>
<p>运算符分为</p>
<ul>
<li>算术运算符</li>
<li>关系运算符</li>
<li>逻辑运算符</li>
<li>赋值运算符</li>
<li>递增和递减运算符</li>
<li>条件运算符</li>
<li>逐位运算符</li>
<li>特殊运算符</li>
</ul>
<p>表达式是操作数和运算符的组成系列，最终产生一个单独的值</p>
<h3 id="3-2-算术运算符"><a href="#3-2-算术运算符" class="headerlink" title="3.2 算术运算符"></a>3.2 算术运算符</h3><p><code>+</code>、<code>-</code>、<code>*</code>、<code>\</code>、<code>%</code></p>
<h3 id="3-3-关系运算符"><a href="#3-3-关系运算符" class="headerlink" title="3.3 关系运算符"></a>3.3 关系运算符</h3><p><code>&lt;</code>、<code>&gt;</code>、<code>!=</code>、<code>==</code>等</p>
<p>关系表达式为真，则值为1；为假，则值为0</p>
<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><p><code>&amp;&amp;</code>、<code>||</code>、<code>!</code></p>
<h3 id="3-5-赋值运算符"><a href="#3-5-赋值运算符" class="headerlink" title="3.5 赋值运算符"></a>3.5 赋值运算符</h3><p><code>=</code></p>
<p>赋值语句的返回值，等于其右边表达式的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, a=<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上程序将返回<code>2</code></p>
<h3 id="3-6-递增和递减运算符"><a href="#3-6-递增和递减运算符" class="headerlink" title="3.6 递增和递减运算符"></a>3.6 递增和递减运算符</h3><p><code>++</code> 和 <code>--</code></p>
<p>对于<code>++m</code>和<code>m++</code>，当单独使用时，意义相同</p>
<p>再赋值语句中，意义不同</p>
<ul>
<li><code>y = ++m</code>，先<code>++</code>再赋值</li>
<li><code>y = m++</code>，先赋值再<code>++</code></li>
</ul>
<p><code>++</code>和<code>--</code>的优先级和关联性与一元的<code>+</code>和<code>-</code>相同</p>
<h3 id="3-7-条件运算符"><a href="#3-7-条件运算符" class="headerlink" title="3.7 条件运算符"></a>3.7 条件运算符</h3><p><code>exp1 ? exp2: exp3</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">15</span>;</span><br><span class="line">x = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-逐位运算符"><a href="#3-8-逐位运算符" class="headerlink" title="3.8 逐位运算符"></a>3.8 逐位运算符</h3><p>用于对数据的位进行操作，可将位左移或者右移</p>
<p>逐位运算符不能用于<code>float</code>或<code>double</code></p>
<p><code>&amp;</code>逐位与、<code>|</code>逐位或、<code>^</code>逐位异或、<code>&gt;&gt;</code>左移位、<code>&lt;&lt;</code>右移位</p>
<h3 id="3-9-特殊运算符"><a href="#3-9-特殊运算符" class="headerlink" title="3.9 特殊运算符"></a>3.9 特殊运算符</h3><h4 id="3-9-1-逗号运算符"><a href="#3-9-1-逗号运算符" class="headerlink" title="3.9.1 逗号运算符"></a>3.9.1 逗号运算符</h4><p>逗号运算符用于将相关的表达式链接在一起。由于逗号链接的表达式是从左到右计算的，因此最右边的表达式的值即为该组合表达式的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = ( x = <span class="number">10</span>, y = <span class="number">5</span>, x+y);</span><br><span class="line">    <span class="comment">//value的值为15</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逗号运算符具有最低的优先级</p>
<h4 id="3-9-2-sizeof运算符"><a href="#3-9-2-sizeof运算符" class="headerlink" title="3.9.2 sizeof运算符"></a>3.9.2 sizeof运算符</h4><p>sizeof是编译时运算符，当用于操作数的时候，返回操作数所占的字节数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = <span class="keyword">sizeof</span>(sum);</span><br><span class="line">n = <span class="keyword">sizeof</span>(<span class="keyword">long</span> <span class="keyword">int</span>);</span><br><span class="line">k = <span class="keyword">sizeof</span>(<span class="number">325L</span>);</span><br></pre></td></tr></table></figure>
<h3 id="3-10-算术表达式"><a href="#3-10-算术表达式" class="headerlink" title="3.10 算术表达式"></a>3.10 算术表达式</h3><p>算数表达式就是变量、常量和运算符按C语言的语法组成的组合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a * b - c</span><br></pre></td></tr></table></figure>
<h3 id="3-11-表达式的计算"><a href="#3-11-表达式的计算" class="headerlink" title="3.11 表达式的计算"></a>3.11 表达式的计算</h3><p>语法: <code>variable = expression;</code></p>
<p>在计算之前，表达式中的所有变量都必须已经赋值</p>
<h3 id="3-12-算术表达式的优先级"><a href="#3-12-算术表达式的优先级" class="headerlink" title="3.12 算术表达式的优先级"></a>3.12 算术表达式的优先级</h3><ul>
<li>首先，加括号的子表达式从左到右进行计算</li>
<li>如果括号有嵌套，应从最里面的子表达式开始计算</li>
<li>在计算子表达式时，优先规则用于确定运算符的使用顺序</li>
<li>当两个或多个同等优先级的运算符出现在子表达式中时，应用关联规则</li>
<li>算术表达式使用优先级规则从左到右计算</li>
<li>当使用括号时，括号中的表达式为最高优先级</li>
</ul>
<h3 id="3-14-表达式中的类型转换"><a href="#3-14-表达式中的类型转换" class="headerlink" title="3.14 表达式中的类型转换"></a>3.14 表达式中的类型转换</h3><h4 id="3-14-1-隐式类型转换"><a href="#3-14-1-隐式类型转换" class="headerlink" title="3.14.1 隐式类型转换"></a>3.14.1 隐式类型转换</h4><p>C语言允许在表达式中混合使用不同类型的常量和变量。C语言主动将所有中间值转换为正确的类型，这样就可以确保计算正确而不丢失任何内容。这种自动转换称为隐式类型转换</p>
<p>如果操作数是不同的类型，那么在运算进行之前，“较低”类型自动转换为“较高”类型</p>
<h4 id="3-14-2-显示类型转换"><a href="#3-14-2-显示类型转换" class="headerlink" title="3.14.2 显示类型转换"></a>3.14.2 显示类型转换</h4><p>有时我们可能想按与自动转换不同的方式来进行强制转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ratio = (float)female_number/male_number;</span><br></pre></td></tr></table></figure>
<p>运算符(float)无法影响变量female_number的值，而且在程序的其他地方,female_number的类型仍为int</p>
<h3 id="3-15-运算符的优先级及其关联性"><a href="#3-15-运算符的优先级及其关联性" class="headerlink" title="3.15 运算符的优先级及其关联性"></a>3.15 运算符的优先级及其关联性</h3><p>优先级</p>
<ul>
<li>C语言的每个运算符都有与之关联的优先级。</li>
<li>优先级用于确定含有多个运算符的表达式是如何进行计算的。较高优先级的运算符先运算</li>
</ul>
<p>关联性</p>
<ul>
<li>用来确定多个同级运算符应用的顺序</li>
</ul>
<h2 id="第四章-输入输出操作管理"><a href="#第四章-输入输出操作管理" class="headerlink" title="第四章 输入输出操作管理"></a>第四章 输入输出操作管理</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>输入输出</p>
<ul>
<li>C语言的语法中没有任何内置的输入\输出语句。所有IO都是通过诸如<code>printf</code>和<code>scanf</code>完成的</li>
</ul>
<p><code>#include</code>指令</p>
<ul>
<li>一种预编译指令</li>
<li>每个使用了标准输入输出函数的程序都必须在程序的开始处包含如下语句<code>#include &lt;stdio.h&gt;</code></li>
<li>对于<code>printf</code>和<code>scanf</code>函数没有必要包含上述语句，因为它们已被定义为C的一部分</li>
<li>文件<code>stdio.h</code>是标准输入输出头文件的缩写。指令<code>#include&lt;stdio.h&gt;</code>告诉编译器去搜索名为<code>stdio.h</code>的文件，并将其内容放入到程序中。编译后，头文件的内容就变成了源代码的一部分</li>
</ul>
<h3 id="4-2-读取一个字符"><a href="#4-2-读取一个字符" class="headerlink" title="4.2 读取一个字符"></a>4.2 读取一个字符</h3><p>读取某个字符可以通过函数<code>getchar()</code>来完成，语法为:<code>variable_name = getchar();</code></p>
<p>在<code>ctype.h</code>头文件中，包含许多字符测试函数，例如<code>isdigit</code>用于判断字符是否为数字</p>
<h3 id="4-3-写一个字符"><a href="#4-3-写一个字符" class="headerlink" title="4.3 写一个字符"></a>4.3 写一个字符</h3><p>写字符可以通过函数<code>putchar()</code>来完成，语法为:<code>putchar(variable_name);</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> answer = <span class="string">'Y'</span>;</span><br><span class="line"><span class="built_in">putchar</span>(answer);</span><br></pre></td></tr></table></figure>
<h3 id="4-4-格式化输入"><a href="#4-4-格式化输入" class="headerlink" title="4.4 格式化输入"></a>4.4 格式化输入</h3><p>格式化输入是指输入数据已按特定格式排列好了</p>
<p>scanf函数的一般形式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;控制字符串&quot;, arg1, arg2, ..., argn);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>控制字符串用于指定数据输入的格式</li>
<li>而<code>arg1</code>, <code>arg2</code>指数据的保存地址</li>
</ul>
<p>控制字符串包含格式说明符，用于指定输入数据的格式转换说明，可以包括</p>
<ul>
<li>格式说明符，包含<ul>
<li>转换字符<code>%</code></li>
<li>字符宽度说明符</li>
<li>数据类型字符</li>
<li>例如，<code>%1d</code>,说明输入格式为宽度为1的整数</li>
</ul>
</li>
<li>空白符、制表符或换行符</li>
</ul>
<h4 id="4-4-1-整数输入"><a href="#4-4-1-整数输入" class="headerlink" title="4.4.1 整数输入"></a>4.4.1 整数输入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;% w sd&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>w</code>为一个整数指定要读取的数字的字段宽度</li>
<li><code>s</code>可以为字母<code>l</code>或者字母<code>h</code>，是可省略的，代表长整数和短整数</li>
<li><code>d</code>为数据类型字符</li>
</ul>
<p>另外，通过在字段的宽度说明符位置，指定为<code>*</code>，就可跳过输入字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d %*d %d&quot;,&amp;a, &amp;b)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>若输入数据为<code>123 456 789</code>，则123赋给a，456被忽略, 789赋给b</li>
</ul>
<h4 id="4-4-2-实数输入"><a href="#4-4-2-实数输入" class="headerlink" title="4.4.2 实数输入"></a>4.4.2 实数输入</h4><p>与整数不同，实数的字段宽度不用指定，因而<code>scanf</code>函数只需要用简单的字段说明符<code>%f</code>来读取实数，可用十进制小数或指数形式来表示实数</p>
<p>如果要读取的数字为<code>double</code>类型，那么字段说明符应为<code>%lf</code></p>
<p><code>%*f</code>可用于忽略字段</p>
<h4 id="4-4-3-字符串输入"><a href="#4-4-3-字符串输入" class="headerlink" title="4.4.3 字符串输入"></a>4.4.3 字符串输入</h4><p>字段说明符可以为<code>%ws</code>或者<code>%wc</code></p>
<ul>
<li>当使用<code>%ws</code>时，<code>w</code>为指定长度，若指定长度，则系统将一直等待，直到第w个字符被键入</li>
<li>当使用<code>%wc</code>时，任何字符都会被键入，直到输入字符串达到<code>w</code>长度为止</li>
<li>使用<code>%[^\n]</code>时，可以直接实现直接键入<code>new york</code>的效果</li>
</ul>
<h4 id="4-4-4-混合数据类型的读取"><a href="#4-4-4-混合数据类型的读取" class="headerlink" title="4.4.4 混合数据类型的读取"></a>4.4.4 混合数据类型的读取</h4><p>可以使用一条<code>scanf</code>语句来读取含有多种数据类型的一行数据，此时应确保输入的数据项与控制说明符的顺序和类型相匹配。如果试图读取不匹配的项，<code>scanf</code>函数将不再进一步读取任何数据，并立刻返回已读取的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scanf(&quot;%d %c %f %s&quot;, &amp;count, &amp;code, &amp;ratio, name);</span><br></pre></td></tr></table></figure></p>
<h4 id="4-4-5-错误输入的检测"><a href="#4-4-5-错误输入的检测" class="headerlink" title="4.4.5 错误输入的检测"></a>4.4.5 错误输入的检测</h4><p><code>scanf</code>函数的返回值为<code>int</code>类型，将返回已成功读取的项数，可用于检测在读取输入时是否有错误发生</p>
<p>当试图为<code>int</code>变量读取实数时，将把实数的整数部分赋给变量，截取后的小数部分则赋给下一个变量</p>
<h4 id="4-4-6-使用scanf函数时的几个要点"><a href="#4-4-6-使用scanf函数时的几个要点" class="headerlink" title="4.4.6 使用scanf函数时的几个要点"></a>4.4.6 使用scanf函数时的几个要点</h4><p>I/O历程并不是c语言的组成部分，而是c库函数的单独模块或者操作系统的一部分</p>
<p><code>scanf</code>的几个注意要点</p>
<ul>
<li>函数的所有参数，除控制字符串外，都必须是指向变量的指针</li>
<li>控制字符串中包含的格式说明符应依次与相应的参数匹配</li>
<li>输入数据项必须用空格分隔开，并且必须按相同的顺序与接受输入的变量匹配</li>
<li>当<code>scanf</code>遇到不匹配的数据或者不合法的字符，读取会停止</li>
<li>一行中任何未读的数据项都被认为是下一个scanf函数的数据输入行</li>
</ul>
<h3 id="4-5-格式化输出"><a href="#4-5-格式化输出" class="headerlink" title="4.5 格式化输出"></a>4.5 格式化输出</h3><p><code>printf</code>语句提供某些特性，能有效地用来控制在终端显示的对齐方式和间距</p>
<p><code>printf</code>的一般形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"控制字符串"</span>, arg1, arg2, ..., argn);</span><br></pre></td></tr></table></figure></p>
<p>控制字符串的组成</p>
<ol>
<li>显示在屏幕上的字符的外观</li>
<li>用于定义每项显示的输入格式的格式说明符</li>
<li>转义序列字符，如<code>\n</code>、<code>\t</code>和<code>\b</code>等</li>
</ol>
<p>注意，<code>printf</code>不能自动换行，因此多条<code>printf</code>语句产生的输出将显示在同一行中。利用<code>\n</code>可以实现换行</p>
<h4 id="4-5-1-整数的输出"><a href="#4-5-1-整数的输出" class="headerlink" title="4.5.1 整数的输出"></a>4.5.1 整数的输出</h4><p>用于显示整数的格式说明符为<code>%wd</code>，其中<code>w</code>指定输出的最小字段宽度</p>
<p>通过在<code>%</code>字符后面放置一个减号，就可以强制使显示输出左对齐</p>
<p>在字段宽度说明符之前加一个<code>0</code>，可以使得输出结果的前面用零来填充</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%06d"</span>, <span class="number">9876</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-6d"</span>, <span class="number">9876</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%6d"</span>, <span class="number">9876</span>);</span><br></pre></td></tr></table></figure>
<h4 id="4-5-2-实数的输出"><a href="#4-5-2-实数的输出" class="headerlink" title="4.5.2 实数的输出"></a>4.5.2 实数的输出</h4><p>用于显示实数的格式说明符为<code>%w.pf</code>，该值将被圆整为p个小数位，并在列宽为w的区域内以右对齐的方式显示</p>
<p>也可以用指数的形式来显示实数<code>%w.pe</code></p>
<p>一些系统还支持使用特殊的字段说明符，让用户在运行程序时定义字段的大小，形式如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%*.*f"</span>, width, precision, number);</span><br></pre></td></tr></table></figure>
<h4 id="4-5-3-单个字符的显示"><a href="#4-5-3-单个字符的显示" class="headerlink" title="4.5.3 单个字符的显示"></a>4.5.3 单个字符的显示</h4><p>用于显示单个字符的格式字符串为<code>%wc</code>，字符将以右对齐的方式显示在列宽为<code>w</code>的区域内。在整数<code>w</code>之前加负号，则以左对齐的方式显示。<code>w</code>默认为1</p>
<h4 id="4-5-4-字符串的显示"><a href="#4-5-4-字符串的显示" class="headerlink" title="4.5.4 字符串的显示"></a>4.5.4 字符串的显示</h4><p>用于显示字符串的格式说明符为<code>%w.ps</code>，<code>w</code>指定显示的区域宽度，<code>p</code>表示只显示字符串的前<code>p</code>个字符，并且右对齐</p>
<h2 id="第五章-判断与分支"><a href="#第五章-判断与分支" class="headerlink" title="第五章 判断与分支"></a>第五章 判断与分支</h2><h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>在很多情况中必须基于某些条件来改变语句的执行顺序，或反复执行一组语句，直到满足某些特定的条件。</p>
<p>如下语句具有判断的能力，也称为控制语句</p>
<ul>
<li><code>if</code>语句</li>
<li><code>switch</code>语句</li>
<li>条件运算符语句</li>
<li><code>goto</code>语句</li>
</ul>
<h3 id="5-2-if语句"><a href="#5-2-if语句" class="headerlink" title="5.2 if语句"></a>5.2 if语句</h3><p><code>if</code>语句是含有两条分支的判断语句，附带一个表达式，形式如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(判断表达式)</span><br></pre></td></tr></table></figure></p>
<p>首先计算判断表达式，然后根据表达式的值是真还是假，将控制权转换到特定的语句</p>
<h3 id="5-3-简单if语句"><a href="#5-3-简单if语句" class="headerlink" title="5.3 简单if语句"></a>5.3 简单if语句</h3><p>形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断表达式)&#123;</span><br><span class="line">    statement-block;</span><br><span class="line">&#125;</span><br><span class="line">statement-x;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>statement-block</code>可以是一条或者一组语句</li>
<li>如果判断表达式为真，将执行<code>statement-block</code>语句，否则将跳过<code>statement-block</code>语句</li>
<li>无论如何，都会执行<code>statement-x</code>语句</li>
</ol>
<h3 id="5-4-if…else语句"><a href="#5-4-if…else语句" class="headerlink" title="5.4 if…else语句"></a>5.4 if…else语句</h3><p>形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断表达式)&#123;</span><br><span class="line">    <span class="literal">true</span>-statement-block;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="literal">false</span>-statement-block;</span><br><span class="line">&#125;</span><br><span class="line">statement-x;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>如果判断表达式为真，就执行紧跟<code>if</code>语句的<code>true-block</code>，否则执行<code>false-block</code></li>
<li>在这两种情况下，接下来控制权都将被转移到<code>statemnt-x</code>语句</li>
</ol>
<h3 id="5-5-嵌套if…else语句"><a href="#5-5-嵌套if…else语句" class="headerlink" title="5.5 嵌套if…else语句"></a>5.5 嵌套if…else语句</h3><p>在C中，一条else语句总是与最近的未终止的if匹配</p>
<h3 id="5-6-阶梯式else-if语句"><a href="#5-6-阶梯式else-if语句" class="headerlink" title="5.6 阶梯式else if语句"></a>5.6 阶梯式else if语句</h3><p>形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(condition<span class="number">-1</span>)</span><br><span class="line">    statement<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(condition<span class="number">-2</span>)</span><br><span class="line">    statement<span class="number">-2</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(condition<span class="number">-3</span>)</span><br><span class="line">    statement<span class="number">-3</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(condition<span class="number">-4</span>)</span><br><span class="line">    statement<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">default</span>-statement;</span><br><span class="line">statement-x;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>条件是从上往下计算的</li>
<li>只要发现有一个为真的条件，就执行与之相关的语句，然后将控制权转移到<code>statement-x</code>语句</li>
<li>如果所有条件都为假，就执行最后那个含有<code>default-statement</code>的<code>else</code>语句</li>
</ol>
<h3 id="5-7-switch语句"><a href="#5-7-switch语句" class="headerlink" title="5.7 switch语句"></a>5.7 switch语句</h3><p>c内置名为<code>switch</code>的多路判断语句。<code>switch</code>语句把给定变量(或表达式)的值与一个<code>case</code>值列表进行比较，如果发现有<code>case</code>与之匹配，就执行与该<code>case</code>相关的语句块</p>
<p>形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression)&#123;</span><br><span class="line">    <span class="keyword">case</span> value<span class="number">-1</span>:</span><br><span class="line">        block<span class="number">-1</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> value<span class="number">-2</span>:</span><br><span class="line">        block<span class="number">-2</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    .....</span><br><span class="line">    .....</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">default</span>-block</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">statement-x;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>expression</code>可以是整数表达式或者字符</li>
<li><code>value</code>为常量或常量表达式</li>
<li>当运行<code>switch</code>语句时，<code>expression</code>的值与<code>value-1</code>、<code>value-2</code>的值进行比较，如果发现某个<code>case</code>的值与<code>expression</code>的值匹配，就执行该<code>case</code>后边的语句块</li>
<li>每个语句块的末尾是<code>break</code>语句。它标志着该<code>case</code>的结尾，并使控制权从该<code>switch</code>语句中退出来，转移到<code>switch</code>后面的<code>statement-x</code>语句</li>
</ol>
<h4 id="5-8-运算符"><a href="#5-8-运算符" class="headerlink" title="5.8 ?:运算符"></a>5.8 ?:运算符</h4><p>条件运算符使用的格式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件表达式? 表达式1: 表达式2</span><br></pre></td></tr></table></figure></p>
<h4 id="5-9-goto语句"><a href="#5-9-goto语句" class="headerlink" title="5.9 goto语句"></a>5.9 goto语句</h4><p><code>c</code>也支持<code>goto</code>语句，用于无条件地从程序的一处跳转到另一处</p>
<p><code>goto</code>语句要求有个标签，来标识要跳转的未知。一个标签就是一个合法的变量名，后面必须跟一个冒号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">goto label;</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">....</span><br><span class="line">label:</span><br><span class="line">statement;</span><br></pre></td></tr></table></figure>
<h2 id="第六章-判断与循环"><a href="#第六章-判断与循环" class="headerlink" title="第六章 判断与循环"></a>第六章 判断与循环</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>程序循环由两部分组成，一部分称为循环体，另一部分称为控制语句。控制语句测试某些条件，然后指示包含在循环体中的语句反复执行</p>
<p>入口控制循环和出口控制循环</p>
<ul>
<li>入口控制循环中，控制条件在循环执行开始之前测试。如果条件不满足，将不执行循环体</li>
<li>出口控制循环中，测试是在循环体的末尾进行的，因此循环体的第一次执行是无条件的</li>
</ul>
<p>无限循环: 由于某些原因不能把控制权转移出循环，因此形成无限循环</p>
<p>循环处理过程</p>
<ol>
<li>设置并初始化条件变量</li>
<li>执行循环体中的语句</li>
<li>用指定的值来测试条件变量，从而决定是否再次执行循环体</li>
<li>递增并更新条件变量的值</li>
</ol>
<p>C的三种循环结构</p>
<ul>
<li>while语句</li>
<li>do语句</li>
<li>for语句</li>
</ul>
<p>计数器控制循环和始终标记控制循环</p>
<ul>
<li><p>如果知道循环将执行的确切次数，就使用计数器控制循环，例如</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>( n &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">    sum = sum + n;</span><br><span class="line">    n++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这是计数器控制循环，变量<code>n</code>称为计数器</p>
</li>
<li><p>在始终标记控制循环中，使用一个称为始终数值的特殊值来改变循环控制表达式的值，在循环结束之前，并不知道<br>循环重复的次数</p>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(c != <span class="string">'Y'</span>)&#123;</span><br><span class="line">    c = getchar();</span><br><span class="line">&#125;</span><br><span class="line">statement-x;</span><br></pre></td></tr></table></figure>
<p>  这是典型的始终标记控制循环，字符常量’y’称为始终标记值</p>
</li>
</ul>
<h3 id="6-2-while语句"><a href="#6-2-while语句" class="headerlink" title="6.2 while语句"></a>6.2 while语句</h3><p>while的基本格式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(测试条件)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>while是入口控制语句。循环体将不断执行，直到测试条件最终为假。此时，控制权将转移出该循环。控制权移除后，程序继续执行紧跟在循环体后面的语句</p>
<h3 id="6-3-do语句"><a href="#6-3-do语句" class="headerlink" title="6.3 do语句"></a>6.3 do语句</h3><p>do的基本格式<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;<span class="keyword">while</span>(测试条件);</span><br></pre></td></tr></table></figure></p>
<p>运行到<code>do</code>语句时，程序接着执行循环体。在循环体的末尾，计算while语句中的测试条件。如果条件为真，程序再次执行循环体</p>
<p>这是一种出口控制循环，循环体至少执行一次</p>
<h3 id="6-4-for语句"><a href="#6-4-for语句" class="headerlink" title="6.4 for语句"></a>6.4 for语句</h3><h4 id="6-4-1-简单for循环"><a href="#6-4-1-简单for循环" class="headerlink" title="6.4.1 简单for循环"></a>6.4.1 简单for循环</h4><p><code>for</code>循环是另一种入口控制循环，一般形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(initialization; test-condition; increment)&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>for</code>语句执行的过程如下</p>
<ol>
<li>首先进行控制变量的初始化</li>
<li>使用测试条件表达式来测试控制变量的值，若测试条件为真，则执行循环体；否则，循环结束</li>
<li>当循环体执行时，在计算完循环的最后一条语句后，将控制权转交给<code>for</code>语句。此时控制变量使用诸如<code>i=i+1</code>之类的赋值语句进行递增计算，并把控制变量的新值应用到测试条件表达式</li>
</ol>
<p><code>for</code>循环的主要一点是，所有三个动作，即初始化、测试和递增，都放在<code>for</code>语句本身之中，因而程序员和用户在一个地方就可以看见它们</p>
<h4 id="6-4-2-for循环的其他特性"><a href="#6-4-2-for循环的其他特性" class="headerlink" title="6.4.2 for循环的其他特性"></a>6.4.2 for循环的其他特性</h4><p>例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(n=<span class="number">1</span>, m=<span class="number">50</span>; n&lt;=m &amp;&amp; n&lt;<span class="number">10</span>; n++, m--)&#123;</span><br><span class="line">    p = m/n;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, n, m, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>特性一: 初始化段可由多个组成部分，用逗号隔开</li>
<li>特性二: 递增段也可以不止一部分</li>
<li>特性三: 测试条件可以含有任何组合关系</li>
<li><p>特性四: 可以在初始化段和递增段的赋值语句中使用表达式</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(x=(m+n)/<span class="number">2</span>; x&gt;<span class="number">0</span>; x=x/<span class="number">2</span>)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>特性五: 如果有必要可以省去其中的一个或多个段</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;m != <span class="number">100</span>;;)&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="6-4-3-for循环的嵌套"><a href="#6-4-3-for循环的嵌套" class="headerlink" title="6.4.3 for循环的嵌套"></a>6.4.3 for循环的嵌套</h4><p>可以根据需要嵌套多条for语句。循环应正确地缩排，以便读者能容易地确定每条for语句中包含了哪些语句</p>
<h3 id="6-5-循环中的跳转"><a href="#6-5-循环中的跳转" class="headerlink" title="6.5 循环中的跳转"></a>6.5 循环中的跳转</h3><h4 id="6-5-1-跳出循环"><a href="#6-5-1-跳出循环" class="headerlink" title="6.5.1 跳出循环"></a>6.5.1 跳出循环</h4><p>利用<code>break</code>语句或者<code>goto</code>语句可以实现从循环中退出来</p>
<p>当循环为嵌套时，<code>break</code>语句只从包含它地循环中退出。也就是只能退出一层循环</p>
<p>结构化程序设计</p>
<ol>
<li>只使用三种控制结构，从而使程序地逻辑容易理解：顺序结构、选择结构、重复结构</li>
<li>结构化程序设计有助于实现良好设计的程序，更容易编写、阅读和维护</li>
<li>结构化程序设计不鼓励使用诸如goto、break、continue之类的跳转语句来实现无条件分支</li>
</ol>
<h4 id="6-5-2-跳出循环的一部分"><a href="#6-5-2-跳出循环的一部分" class="headerlink" title="6.5.2 跳出循环的一部分"></a>6.5.2 跳出循环的一部分</h4><p>c支持continue语句，在循环中，continue语句使得控制权直接跳转到测试条件</p>
<h4 id="6-5-3-避免使用goto语句"><a href="#6-5-3-避免使用goto语句" class="headerlink" title="6.5.3 避免使用goto语句"></a>6.5.3 避免使用goto语句</h4><p>良好的编程习惯避免使用goto语句</p>
<ol>
<li>当使用goto语句时，程序的结构太复杂，不可读</li>
<li>而且编译器产生的代码效率会变得底下</li>
</ol>
<h4 id="6-5-4-跳出程序"><a href="#6-5-4-跳出程序" class="headerlink" title="6.5.4 跳出程序"></a>6.5.4 跳出程序</h4><p>当我们希望终止程序，回到操作系统，可以使用<code>exit</code>函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(test-condition)<span class="built_in">exit</span>(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h3 id="6-6-简洁的测试表达式"><a href="#6-6-简洁的测试表达式" class="headerlink" title="6.6 简洁的测试表达式"></a>6.6 简洁的测试表达式</h3><p>由于每个整数表达式都有真值和假值，所以没必要显式的和0比较，例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(expression == 0)</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(!expression)</span><br></pre></td></tr></table></figure>
<h2 id="第-7-章-数组"><a href="#第-7-章-数组" class="headerlink" title="第 7 章 数组"></a>第 7 章 数组</h2><h3 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h3><p>C提供一种派生数据类型，称为数组，是一种功能强大的数据类型，可以灵活高效地存储、访问和操作数据项</p>
<p>所谓数组，就是一个大小固定、含有相同数据类型元素的顺序集合。使用单个数组名来表示元素的集合，通过指定序号来引用某项元素，使得程序的开发更加简单高效</p>
<h3 id="7-2-一维数组"><a href="#7-2-一维数组" class="headerlink" title="7.2 一维数组"></a>7.2 一维数组</h3><p>数组下标可以是整形常量、整形变量或者可以生成整数的表达式</p>
<p>C语言不进行边界检查，因此应确保数组索引位于合理范围内</p>
<h3 id="7-3-一维数组的声明"><a href="#7-3-一维数组的声明" class="headerlink" title="7.3 一维数组的声明"></a>7.3 一维数组的声明</h3><p>数组必须在使用之前进行声明，数组声明的形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable-name[size];</span><br></pre></td></tr></table></figure></p>
<ul>
<li>type指定包含在数组中的元素的类型</li>
<li>size则指定数组所能存储元素的最大数目</li>
</ul>
<h3 id="7-4-一维数组的初始化"><a href="#7-4-一维数组的初始化" class="headerlink" title="7.4 一维数组的初始化"></a>7.4 一维数组的初始化</h3><h4 id="7-4-1-编译时初始化"><a href="#7-4-1-编译时初始化" class="headerlink" title="7.4.1 编译时初始化"></a>7.4.1 编译时初始化</h4><p>可以像普通变量一样在声明数组时便初始化数组的元素。初始化数组的一般形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">array</span>-name[size] = &#123;<span class="built_in">list</span> of values&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>若列表中的数值少于元素的个数，只有部分元素被初始化，剩余的元素自动设置为默认值，int类型将设置为0，字符类型会被初始化为空</li>
<li>数组的大小可以省略。此时，编译器将为所有已初始化的元素分配足够的存储空间</li>
<li>如果用于初始化的数值多于所声明的数组大小，编译器会报错 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="7-4-2-运行时初始化"><a href="#7-4-2-运行时初始化" class="headerlink" title="7.4.2 运行时初始化"></a>7.4.2 运行时初始化</h4><p>可以在运行时，显式初始化数组<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i ++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">50</span>)</span><br><span class="line">        sum[i] = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sum[i] = <span class="number">1.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="7-5-二维数组"><a href="#7-5-二维数组" class="headerlink" title="7.5 二维数组"></a>7.5 二维数组</h3><p>二维数组的声明如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">array</span>-name[row_size][column_size];</span><br></pre></td></tr></table></figure></p>
<p>与一维数组一样，数组的每个维都是从0到最大值-1索引的，第1个索引选择行，第2个索引选择该行的列</p>
<h3 id="7-6-二维数组的初始化"><a href="#7-6-二维数组的初始化" class="headerlink" title="7.6 二维数组的初始化"></a>7.6 二维数组的初始化</h3><p>通过在二维数组的声明语句的后面加上大括号括起来的初始值列表，就可以进行二维数组的初始化</p>
<p>例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> table[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> table1[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> table2[][<span class="number">3</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> table3[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">int</span> talbe3[][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>可以不指定第一维的大小</li>
<li>初始化时，遗漏的元素值将初始化为0</li>
<li>二维数组的存储也是连续存储在内存中</li>
</ol>
<h3 id="7-7-多维数组"><a href="#7-7-多维数组" class="headerlink" title="7.7 多维数组"></a>7.7 多维数组</h3><p>c支持多维数组，具体限制由编译器决定，大多数编译器只允许7到10维</p>
<p>多维数组的一般形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type <span class="built_in">array</span>-name[s1][s2][s3]...[sm];</span><br></pre></td></tr></table></figure></p>
<h3 id="7-8-动态数组"><a href="#7-8-动态数组" class="headerlink" title="7.8 动态数组"></a>7.8 动态数组</h3><p>静态数组</p>
<ul>
<li>在编译时分配存储空间的过程称为静态内存分配</li>
<li>接受静态内存存储空间的数组称为静态数组</li>
</ul>
<p>动态数组</p>
<ul>
<li>在c中，可以在运行时为数组分配存储空间，称为动态内存分配，在运行时创建的数组称为动态数组。可以有效地将数组的定义推迟到运行时</li>
<li>动态数组使用指针变量和内存管理函数<code>malloc</code>、<code>calloc</code>和<code>realloc</code>来创建</li>
</ul>
<h3 id="7-9-与数组相关的内容"><a href="#7-9-与数组相关的内容" class="headerlink" title="7.9 与数组相关的内容"></a>7.9 与数组相关的内容</h3><ul>
<li>使用指针访问数组</li>
<li>将数组作为函数的参数</li>
<li>将数组作为结构体的成员</li>
<li>把结构类型的数据作为数组元素</li>
<li>把数组作为动态数据类型</li>
<li>操作字符数组和字符串</li>
</ul>
<h2 id="第8章-字符数组和字符串"><a href="#第8章-字符数组和字符串" class="headerlink" title="第8章 字符数组和字符串"></a>第8章 字符数组和字符串</h2><h3 id="8-1-概述"><a href="#8-1-概述" class="headerlink" title="8. 1 概述"></a>8. 1 概述</h3><p>字符串就是字符的序列，可以看成是单个数据项</p>
<p>定义在双引号之间的字符组就是一个字符串常量</p>
<p>字符串经常用来创建有意义且可读性好的程序，作用于字符串的常见操作有</p>
<ul>
<li>读写字符串</li>
<li>字符串的合并</li>
<li>字符串的赋值</li>
<li>比较两个字符串是否相等</li>
<li>从字符串中提取子字符串</li>
</ul>
<h3 id="8-2-字符串变量的声明和初始化"><a href="#8-2-字符串变量的声明和初始化" class="headerlink" title="8.2 字符串变量的声明和初始化"></a>8.2 字符串变量的声明和初始化</h3><p>c语言并不支持字符串数据类型,但允许使用字符数组来表示字符串。在c中，字符串变量就是一个字符数组。</p>
<p>一般形式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char string_name[size];</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>当编译器把字符串赋给字符数组时，会自动在字符串的末尾添加空字符<code>\0</code>，因此size必须比字符串长度大一个，不然会乱码</p>
</li>
<li><p>在初始化字符数组时，也可以不指定数组的大小。在这种情况下，数组的大小将根据初始化元素的数量自动确定</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">string</span>[] = <span class="string">"GOOD"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以把数组的大小声明得比初始化字符串更大，这种情况下多余的位置将放置空字符<code>\0</code></p>
</li>
</ol>
<p>注意</p>
<ol>
<li>不能把初始化从声明中分隔开</li>
<li>数组名不能作为赋值运算符的左操作数</li>
</ol>
<h3 id="8-3-从终端读取字符串"><a href="#8-3-从终端读取字符串" class="headerlink" title="8.3 从终端读取字符串"></a>8.3 从终端读取字符串</h3><h4 id="8-3-1-使用scanf函数"><a href="#8-3-1-使用scanf函数" class="headerlink" title="8.3.1 使用scanf函数"></a>8.3.1 使用scanf函数</h4><p>可以使用<code>scanf</code>函数加上<code>%s</code>格式说明符来读取字符串，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> address[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, address);</span><br></pre></td></tr></table></figure></p>
<p>scanf函数的问题是，一旦遇到空白符，就会终止输入</p>
<p>在字符数组中，变量名的前面不需要加<code>&amp;</code>符号，因为数组名变量的值即是数组的首地址</p>
<p>但是，未占用的空间中存储的仍然是垃圾</p>
<p>也可以在scanf语句中使用<code>%ws</code>格式说明符来指定字段的宽度，用于从输入字符串中读取指定数量的字符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"%ws"</span>, name);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>宽度<code>w</code>等于或大于所键入的字符数时，整个字符串都保存在字符串变量中</li>
<li>宽度<code>w</code>小于键入的字符数，多余的字符将被截除，不被读取</li>
</ul>
<h4 id="8-3-2-读取文本行"><a href="#8-3-2-读取文本行" class="headerlink" title="8.3.2 读取文本行"></a>8.3.2 读取文本行</h4><p>可以使用编辑集转换码<code>%[^\n]</code>来读取包含空格的文本行</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> line[<span class="number">80</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>, line);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, line);</span><br></pre></td></tr></table></figure>
<h4 id="8-3-3-使用getchar和gets函数"><a href="#8-3-3-使用getchar和gets函数" class="headerlink" title="8.3.3 使用getchar和gets函数"></a>8.3.3 使用getchar和gets函数</h4><p>可以使用getchar函数从终端中读取单个字符<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ch = getchar();</span><br></pre></td></tr></table></figure></p>
<p>要读取含有空格的字符串文本，更加方便的方法是使用库函数<code>gets</code>，它位于头文件<code>&lt;stdio.h&gt;</code>中，形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gets(str);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>str</code>是一个已经正确声明过的字符串变量</li>
<li><code>gets</code>函数从键盘中读取字符到<code>str</code>中，直到遇到一个换行符，然后将一个空字符附加到该字符串中</li>
</ul>
<h3 id="8-4-在屏幕上显示字符串"><a href="#8-4-在屏幕上显示字符串" class="headerlink" title="8.4 在屏幕上显示字符串"></a>8.4 在屏幕上显示字符串</h3><h4 id="8-4-1-使用printf函数"><a href="#8-4-1-使用printf函数" class="headerlink" title="8.4.1 使用printf函数"></a>8.4.1 使用<code>printf</code>函数</h4><p>格式说明符<code>%s</code>可以用来显示以空字符结尾的字符数组，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>, name);</span><br></pre></td></tr></table></figure></p>
<p>说明符<code>%10.4s</code>表示前4个字符显示在宽度为10列的字段中，字符串以右对齐的方式显示</p>
<h4 id="8-4-2-使用putchar和puts函数"><a href="#8-4-2-使用putchar和puts函数" class="headerlink" title="8.4.2 使用putchar和puts函数"></a>8.4.2 使用putchar和puts函数</h4><p><code>putchar(ch)</code>可以将ch字符输出到屏幕上</p>
<p>显示字符串值更加方便地方式是使用puts函数<code>puts(str)</code>，此函数会自动加入<code>\n</code></p>
<h3 id="8-5-字符的算术计算"><a href="#8-5-字符的算术计算" class="headerlink" title="8.5 字符的算术计算"></a>8.5 字符的算术计算</h3><p>C允许像数字一样对字符进行操作，当某个字符常量或者字符变量在表达式中出现时，系统自动将它转换为对应的整数值</p>
<p>也可以对字符常量和字符变量执行算术运算<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> x = <span class="string">'z'</span> - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>还可以在关系表达式中使用字符常量，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &gt;= <span class="string">'A'</span> &amp;&amp; ch &lt;= <span class="string">'Z'</span></span><br></pre></td></tr></table></figure></p>
<p>c有一个库函数<code>atoi</code>可以将数组字符串转换为相应的整数值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="string">"1998"</span>;</span><br><span class="line">year = atoi(number);</span><br></pre></td></tr></table></figure></p>
<h3 id="8-6-字符串处理函数"><a href="#8-6-字符串处理函数" class="headerlink" title="8.6 字符串处理函数"></a>8.6 字符串处理函数</h3><h4 id="8-6-1-strcat函数"><a href="#8-6-1-strcat函数" class="headerlink" title="8.6.1 strcat函数"></a>8.6.1 strcat函数</h4><p><code>strcat</code>用于将两个字符串拼接在一起<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strcat(str1, str2);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>当执行strcat函数时，str2附加到str1上</li>
<li>它将str1后的空字符删除，然后把str2放置在其后。字符串str2保持不变</li>
<li>必须确保str1足够大，以便容纳最终的字符串</li>
</ul>
<h4 id="8-6-2-strcmp函数"><a href="#8-6-2-strcmp函数" class="headerlink" title="8.6.2 strcmp函数"></a>8.6.2 strcmp函数</h4><p><code>strcmp</code>对两个字符串进行比较<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcmp</span>(str1, str2);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>如果相等，返回值为0</li>
<li>如果不相等，就返回字符串中第一个不匹配的字符的数值差</li>
</ul>
<h4 id="8-6-3-strcpy函数"><a href="#8-6-3-strcpy函数" class="headerlink" title="8.6.3 strcpy函数"></a>8.6.3 strcpy函数</h4><p>strcpy函数用于字符串拷贝<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>它将str2的内容赋给str1</li>
</ul>
<h4 id="8-6-4-strlen函数"><a href="#8-6-4-strlen函数" class="headerlink" title="8.6.4 strlen函数"></a>8.6.4 strlen函数</h4><p><code>strlen</code>函数计算并返回字符串中的字符数</p>
<h2 id="第-9-章-用户自定义函数"><a href="#第-9-章-用户自定义函数" class="headerlink" title="第 9 章 用户自定义函数"></a>第 9 章 用户自定义函数</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p>C函数分为两类，库函数和自定义函数</p>
<p>库函数不需要自己编写，自定义函数需要用户自己开发</p>
<h3 id="9-2-为什么需要自定义函数"><a href="#9-2-为什么需要自定义函数" class="headerlink" title="9.2 为什么需要自定义函数"></a>9.2 为什么需要自定义函数</h3><p>main是C的一个特别的函数。每个程序都必须有一个main函数，以表明程序运行的起始点</p>
<p>但是，只用一个main函数可能会导致程序变得太大、太复杂，使得调试、测试和维护工作变得困难</p>
<p>自定义函数这种分而治之的方法有很多优点</p>
<ol>
<li>便于自顶向下的模块化编程</li>
<li>通过在适当的地方使用函数，可以减短源代码的长度</li>
<li>更容易定义和隔离有错误的函数，以便进一步检查</li>
<li>函数可以被其他多个程序共用</li>
</ol>
<h3 id="9-3-多函数程序"><a href="#9-3-多函数程序" class="headerlink" title="9.3 多函数程序"></a>9.3 多函数程序</h3><p>函数就是执行某个特定任务的自包含的代码块。函数一旦设计和封装好后，就可以看成一个黑盒子</p>
<p>除了起点之外，程序中的函数之间不存在其他预定义的关系、优先规则和层次结构。函数可按任意顺序排列。被调用函数可放在调用函数之前，也可放在调用函数之后</p>
<h3 id="9-4-自定义函数的元素"><a href="#9-4-自定义函数的元素" class="headerlink" title="9.4 自定义函数的元素"></a>9.4 自定义函数的元素</h3><p>在c中，函数被归类于派生数据类型</p>
<p>函数和变量之间的关系</p>
<ul>
<li>可将函数名和变量名看成标记符</li>
<li>与变量一样，函数具有与之相关的类型(返回值类型)</li>
<li>与变量一样，在使用之前，函数名及其类型必须已经定义和声明</li>
</ul>
<p>为了使用自定义函数，我们需要创建和函数有关的3个元素</p>
<ul>
<li>函数定义</li>
<li>函数调用</li>
<li>函数声明</li>
</ul>
<h3 id="9-5-函数定义"><a href="#9-5-函数定义" class="headerlink" title="9.5 函数定义"></a>9.5 函数定义</h3><p>函数定义应包括</p>
<ul>
<li>函数名</li>
<li>函数类型</li>
<li>参数列表</li>
<li>局部变量声明</li>
<li>函数语句</li>
<li>返回语句</li>
</ul>
<p>一般形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function_type <span class="title">function_name</span><span class="params">(parameter <span class="built_in">list</span>)</span></span>&#123;</span><br><span class="line">    local variable declaration;</span><br><span class="line">    executable statement1;</span><br><span class="line">    executable statement2;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-5-1-函数头"><a href="#9-5-1-函数头" class="headerlink" title="9.5.1 函数头"></a>9.5.1 函数头</h4><p>函数头有三部分：函数类型、函数名和形参列表</p>
<ol>
<li>函数类型: 函数类型指定希望函数返回给调用程序的值的类型。若没有显式地指定类型，将返回整型。如果函数不返回任何值，就需要将返回类型指定为<code>void</code></li>
<li>函数名是任何合法的c标识符，因此要遵守c的变量名命名规则</li>
<li>形参列表：形参列表声明的变量用来接受从调用程序发送来的数据。但没有参数时，可以在括号中填写<code>void</code>也可以不填写任何值</li>
</ol>
<h4 id="9-5-2-函数体"><a href="#9-5-2-函数体" class="headerlink" title="9.5.2 函数体"></a>9.5.2 函数体</h4><p>函数体中包含了函数声明以及完成任务所需的语句。函数体用括号括起来，包括三部分</p>
<ul>
<li>局部变量: 即本函数所需的变量</li>
<li>完成函数任务的函数语句</li>
<li>return语句，返回由函数所得的值</li>
</ul>
<h3 id="9-6-返回值及其类型"><a href="#9-6-返回值及其类型" class="headerlink" title="9.6 返回值及其类型"></a>9.6 返回值及其类型</h3><p>尽管可以给调用函数传递任意数量的值，但被调用函数在每次调用时最多只能返回一个值</p>
<p>当返回值时，将自动将表达式转化为声明的返回值类型。假设在函数中使用double类型，而返回值为int类型，那么返回值将被截取为int类型</p>
<h3 id="9-7-函数调用"><a href="#9-7-函数调用" class="headerlink" title="9.7 函数调用"></a>9.7 函数调用</h3><p>函数调用是后缀表达式，优先级很高。因此函数调用作为表达式的一部分时，除非使用括号来改变优先顺序，否则首先计算函数</p>
<p>如果实参比形参多，那么多余的实参将被丢弃</p>
<p>如果实参比形参少，那么没有实参与之匹配的形参将被初始化为垃圾数据</p>
<p>数据类型的任何不匹配都阿静导致产生垃圾数据；</p>
<h3 id="9-8-函数声明"><a href="#9-8-函数声明" class="headerlink" title="9.8 函数声明"></a>9.8 函数声明</h3><p>C程序中所有的函数在使用之前都必须声明</p>
<p>函数声明由4部分组成</p>
<ul>
<li>函数类型</li>
<li>函数名</li>
<li>参数列表</li>
<li>终止分号</li>
</ul>
<p>形如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function-type function-name(paramater <span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>参数列表必须用逗号分隔开</li>
<li>函数原型声明与函数定义中的参数名无需相同</li>
<li>参数的类型、数量和顺序必须与函数定义中的匹配</li>
<li>声明中的参数名可以不写</li>
</ul>
<h3 id="9-9-函数的类型"><a href="#9-9-函数的类型" class="headerlink" title="9.9 函数的类型"></a>9.9 函数的类型</h3><h3 id="9-10-无参数无返回值的函数"><a href="#9-10-无参数无返回值的函数" class="headerlink" title="9.10 无参数无返回值的函数"></a>9.10 无参数无返回值的函数</h3><p>这种情况下在调用函数和被调用函数之间没有任何数据传递，只进行控制权转换</p>
<h3 id="9-11-有参数无返回值的函数"><a href="#9-11-有参数无返回值的函数" class="headerlink" title="9.11 有参数无返回值的函数"></a>9.11 有参数无返回值的函数</h3><p>函数调用时，只是将实参的值的副本传递给了被调用函数。被调用函数中所发生的一切都不会影响实参中的变量</p>
<p>可变的参数数量</p>
<ul>
<li>有些函数的参数的数目和类型在编译时并不知道，这时可以使用称为省略号的新符号来处理这种函数</li>
<li>例如<code>double area(float d, ...)</code></li>
<li>函数声明和定义中都必须使用省略号来表明参数的数量和类型是任意的</li>
</ul>
<h3 id="9-12-有参数有返回值的函数"><a href="#9-12-有参数有返回值的函数" class="headerlink" title="9.12 有参数有返回值的函数"></a>9.12 有参数有返回值的函数</h3><p>可以在main函数内部声明其他函数，但是函数定义要在外部完成<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    sum(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>但是按照目前的规则，不声明并不会报错，只会产生警告</li>
</ul>
<h3 id="9-13-有参数但有一个返回值的函数"><a href="#9-13-有参数但有一个返回值的函数" class="headerlink" title="9.13 有参数但有一个返回值的函数"></a>9.13 有参数但有一个返回值的函数</h3><h3 id="9-14-返回多个值的函数"><a href="#9-14-返回多个值的函数" class="headerlink" title="9.14 返回多个值的函数"></a>9.14 返回多个值的函数</h3><p>我们可以使用参数，来往调用函数返回信息，用来返回信息的参数称为输出参数</p>
<p>使用地址运算符<code>&amp;</code>和间接运算符<code>*</code>可以实现通过参数返回信息<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mathoperation</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> *s, <span class="keyword">int</span> *d)</span></span>;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">int</span> x=<span class="number">20</span>, y=<span class="number">10</span>, s, d;</span><br><span class="line">    mathoperation(x, y, &amp;s, &amp;d);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"s=%d\n d=%d\n"</span>, s, d);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mathoperation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> *sum, <span class="keyword">int</span> *diff)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>在函数调用中，我们是把x和y的实际值传递给该函数，并把保存s值和d值的内存地址传递给该函数</p>
<p>函数头的sum和diff声明中的间接运算符<code>*</code>表示，这些变量用于保存地址，而不是实际的变量值</p>
<p>运算符<code>*</code>称为间接运算符，是因为它通过变量的地址来间接引用变量</p>
<p>变量<code>*sum</code>和<code>*diff</code>称为指针，<code>sum</code>和<code>diff</code>称为指针变量。它们都被声明为int类型，因此它们可以指向int类型的数据的存储位置</p>
<h3 id="9-15-函数的嵌套"><a href="#9-15-函数的嵌套" class="headerlink" title="9.15 函数的嵌套"></a>9.15 函数的嵌套</h3><h3 id="9-16-函数的递归"><a href="#9-16-函数的递归" class="headerlink" title="9.16 函数的递归"></a>9.16 函数的递归</h3><p>递归指的是函数调用自身</p>
<h3 id="9-17-将数组传递给函数"><a href="#9-17-将数组传递给函数" class="headerlink" title="9.17 将数组传递给函数"></a>9.17 将数组传递给函数</h3><p>形如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">largest</span><span class="params">(<span class="keyword">float</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure></p>
<p>在c中，数组名表示的是数组第一个元素的地址。传递数组名时，实际上是把数组的地址传递给被调用函数。这样被调用函数中的数组就指向内存中相同的数组了。这样被调用函数的数组的任何改变都将反映到原始数组上</p>
<p>把参数的地址传递给函数称为地址传递或指针传递</p>
<h3 id="9-18-将字符串传递给函数"><a href="#9-18-将字符串传递给函数" class="headerlink" title="9.18 将字符串传递给函数"></a>9.18 将字符串传递给函数</h3><p>在c中因为字符串被看作字符数组，所以传递字符串给函数的规律非常类似于传递数组给函数</p>
<ol>
<li><p>必须将字符串变量声明为函数的形参</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">char</span> item_name[])</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数调用必须带一个无下标的字符串数组名作为实参，例如<code>display(name)</code></p>
</li>
</ol>
<p>按值传递和按指针传递</p>
<ol>
<li>在按值传递中，实参的值被复制给被调用函数参数列表中的变量。被调用函数使用的是实参的副本，而不是原始值</li>
<li>在按指针传递中，发送给被调用函数的是变量的地址，而不是值的副本</li>
</ol>
<h3 id="9-19-变量的作用域、可见性和生存期"><a href="#9-19-变量的作用域、可见性和生存期" class="headerlink" title="9.19 变量的作用域、可见性和生存期"></a>9.19 变量的作用域、可见性和生存期</h3><p>在C语言中，变量不仅属于某种数据类型，而且还具有某种存储类型(<code>storage class</code>)</p>
<p>变量的储存类型有</p>
<ul>
<li>自动变量</li>
<li>外部变量</li>
<li>静态变量</li>
<li>寄存器变量</li>
</ul>
<p>作用域: 变量的作用域确定在程序的哪些区域可以使用该变量</p>
<p>可见性: 变量的可访问性</p>
<p>生存期: 程序运行时变量保持某个值的时间段</p>
<h4 id="9-19-1-自动变量"><a href="#9-19-1-自动变量" class="headerlink" title="9.19.1 自动变量"></a>9.19.1 自动变量</h4><p>自动变量是在某个函数中声明的变量，这些变量只能在该函数中使用。在调用函数时创建变量，在函数退出时自动销毁，因此命名为自动变量。自动变量又称为局部变量或内部变量</p>
<p>默认情况下，如果声明在某个函数中的变量没有指定存储类型，就为自动变量</p>
<p>也可以用关键字auto来显示声明自动变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="keyword">int</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-19-2-外部变量"><a href="#9-19-2-外部变量" class="headerlink" title="9.19.2 外部变量"></a>9.19.2 外部变量</h4><p>在整个程序中都存在并活动的变量称为外部变量，又称为全局变量。与局部变量不同，全局变量可以被程序中的所有函数访问。外部变量在函数的外面进行声明</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> number;</span><br><span class="line">main()&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果局部变量与全局变量同名，在声明局部变量的函数中，局部变量具有比全局变量更高的优先级</p>
<p>全局变量的另一个特性是，只有从全局变量的声明之处开始到程序的末尾可用</p>
<h4 id="9-19-3-外部声明"><a href="#9-19-3-外部声明" class="headerlink" title="9.19.3 外部声明"></a>9.19.3 外部声明</h4><p>例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> y;</span><br><span class="line">    .....</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br><span class="line">func1()&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">int</span> y;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> y</span><br></pre></td></tr></table></figure></p>
<p>尽管变量y声明在两个函数之后，但函数中y的外部声明语句告诉编译器，y是个整数，是在程序的其他地方声明的，这样就可以在函数中使用变量y了</p>
<h4 id="9-19-4-静态变量"><a href="#9-19-4-静态变量" class="headerlink" title="9.19.4 静态变量"></a>9.19.4 静态变量</h4><p>静态变量的值可以一直保持到程序结束，使用关键字static可以将变量声明为静态<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">float</span> y;</span><br></pre></td></tr></table></figure></p>
<p>内部静态变量: 作用范围仅限于定义它的函数中，但是此变量会一直保持，只在程序编译时初始化一次，以后再也不进行初始化</p>
<p>静态外部变量与简单外部变量的区别是：它只在定义它的文件中可用，而简单外部变量可以被其他文件访问</p>
<p>static也可用来控制函数的作用范围。若需要一个函数，只对定义它的文件可见，而对其他文件中的任何函数都不可见，就可以通过用存储类型static定义函数来实现</p>
<h4 id="9-19-5-寄存器变量"><a href="#9-19-5-寄存器变量" class="headerlink" title="9.19.5 寄存器变量"></a>9.19.5 寄存器变量</h4><p>寄存器变量存储在寄存器中，而不是内存中，访问速度更快<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure></p>
<h3 id="9-20-多文件函数"><a href="#9-20-多文件函数" class="headerlink" title="9.20 多文件函数"></a>9.20 多文件函数</h3><p>extern说明符告诉编译器，后面的变量类型和名称已经在其他地方进行了声明，不用再为它们创建存储空间了</p>
<h2 id="第-10-章-结构体和共用体"><a href="#第-10-章-结构体和共用体" class="headerlink" title="第 10 章 结构体和共用体"></a>第 10 章 结构体和共用体</h2><h3 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述</h3><p>C语言支持一种结构化的数据类型，称为结构体，来用单个名称来表示不同类型的数据集合</p>
<p>结构体有助于以一种有意义的方法来组织复杂数据</p>
<h3 id="10-2-结构体的定义"><a href="#10-2-结构体的定义" class="headerlink" title="10.2 结构体的定义"></a>10.2 结构体的定义</h3><p>必须首先定义结构体的格式，然后才能声明和使用结构体的变量</p>
<p>例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_bank</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>关键字struct声明一个结构体，它有4个数据字段。且属于不同的数据类型</li>
<li>book_bank时结构体名，称为结构体标记符</li>
<li>结构体模板以分号结尾</li>
</ul>
<h3 id="10-3-声明结构体变量"><a href="#10-3-声明结构体变量" class="headerlink" title="10.3 声明结构体变量"></a>10.3 声明结构体变量</h3><p>定义之后，才可以声明这种类型的变量，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_bank</span> <span class="title">book1</span>, <span class="title">book2</span>, <span class="title">book3</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>当编译器遇到声明语句时，将为结构体变量保留存储空间</p>
<p>也可以使用typedef定义结构体，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125; book_bank;</span><br><span class="line"></span><br><span class="line">book_bank book1;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-4-访问结构体成员"><a href="#10-4-访问结构体成员" class="headerlink" title="10.4 访问结构体成员"></a>10.4 访问结构体成员</h3><p>成员与变量之间的链接可以使用成员运算符<code>.</code>来建立，下面是访问结构体成员的例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strcpy</span>(book1.title, <span class="string">"BASIC"</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(book1.author, <span class="string">"Balagurusamy"</span>);</span><br><span class="line">book1.pages = <span class="number">250</span>;</span><br><span class="line">book1.price = <span class="number">120.50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="10-5-结构体的初始化"><a href="#10-5-结构体的初始化" class="headerlink" title="10.5 结构体的初始化"></a>10.5 结构体的初始化</h3><p>结构体变量也可以在声明时进行初始化，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">book_bank</span> <span class="title">book1</span> = &#123;</span><span class="string">"BKTL"</span>, <span class="string">"BKATR"</span>, <span class="number">100</span>, <span class="number">10.11</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>不能对结构体模板中的单个成员进行初始化</li>
<li>包含在花括号中的数值必须与结构体定义中的成员顺序一致</li>
<li>允许只初始化前面的成员</li>
<li>未初始化的成员将被赋值为0或者空字符</li>
</ul>
<h3 id="10-6-结构体变量的复制和比较"><a href="#10-6-结构体变量的复制和比较" class="headerlink" title="10.6 结构体变量的复制和比较"></a>10.6 结构体变量的复制和比较</h3><p>结构体变量可以直接进行赋值操作，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book2 = book1;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>此时，这两个变量共享一块内存</li>
</ul>
<p>但是不允许进行比较操作<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book2 == book1 <span class="comment">//这是非法的</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要比较请依次对成员进行比较</p>
<h3 id="10-7-单个成员的运算"><a href="#10-7-单个成员的运算" class="headerlink" title="10.7 单个成员的运算"></a>10.7 单个成员的运算</h3><p>结构体变量加句点运算符再加成员，就可以像其他变量名一样来处理，例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(book1.num == <span class="number">100</span>)&#123;</span><br><span class="line">    book1.price++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>访问成员的三种方式</p>
<ul>
<li>使用句点表示法: v.x</li>
<li>使用间接表示法: (*ptr).x</li>
<li>使用选择表示法: ptr-&gt;x</li>
</ul>
<h3 id="10-8-结构体数组"><a href="#10-8-结构体数组" class="headerlink" title="10.8 结构体数组"></a>10.8 结构体数组</h3><p>例如<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">marks</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sub1;</span><br><span class="line">    <span class="keyword">int</span> sub2;</span><br><span class="line">    <span class="keyword">int</span> sub3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">marks</span>[3] = &#123;</span>&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="10-9-结构体中的数组"><a href="#10-9-结构体中的数组" class="headerlink" title="10.9 结构体中的数组"></a>10.9 结构体中的数组</h3><p>略</p>
<h3 id="10-10-结构体中的结构体"><a href="#10-10-结构体中的结构体" class="headerlink" title="10.10 结构体中的结构体"></a>10.10 结构体中的结构体</h3><p>结构体的嵌套</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">salary</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">int</span> city;</span><br><span class="line">        <span class="keyword">int</span> house_rent;</span><br><span class="line">    &#125; allowance;</span><br><span class="line">&#125;employee;</span><br><span class="line">employee.allowance.city = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>也等价于<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pay</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> city;</span><br><span class="line">    <span class="keyword">int</span> house_rent;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">salary</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pay</span> <span class="title">allowance</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">salary</span> <span class="title">employee</span>;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="10-11-结构体与函数"><a href="#10-11-结构体与函数" class="headerlink" title="10.11 结构体与函数"></a>10.11 结构体与函数</h3><p>C支持将结构体的值作为参数传递给函数，有三种方式</p>
<ol>
<li>把结构体的每个成员作为函数调用的实参进行传递，然后像普通变量一样处理这些实参</li>
<li>将整个结构体的副本传递给被调用函数，由于函数使用的副本，所以在函数中对结构体成员的任何修改都不能反应到调用函数的初始结构体中</li>
<li>使用指针以参数形式来传递结构体。此时，结构体的地址被传递给被调用函数。类似于将数组传递给函数</li>
</ol>
<p>第二种方式的例子<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> title[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> author[<span class="number">15</span>];</span><br><span class="line">    <span class="keyword">int</span> pages;</span><br><span class="line">    <span class="keyword">float</span> price;</span><br><span class="line">&#125; book_bank;</span><br><span class="line"><span class="function">book_bank <span class="title">update</span><span class="params">(book_bank book, <span class="keyword">int</span> new_pages, <span class="keyword">char</span> new_title[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    book_bank book1 = &#123;<span class="string">"BKTL"</span>, <span class="string">"BKATR"</span>, <span class="number">100</span>, <span class="number">10.11</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s %d %f\n"</span>, book1.title, book1.author, book1.pages, book1.price);</span><br><span class="line">    book1 = update(book1, <span class="number">150</span>, <span class="string">"BKTL1"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s %s %d %f\n"</span>, book1.title, book1.author, book1.pages, book1.price);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">book_bank <span class="title">update</span><span class="params">(book_bank book, <span class="keyword">int</span> new_pages, <span class="keyword">char</span> new_title[])</span></span>&#123;</span><br><span class="line">    book.pages = new_pages;</span><br><span class="line">    <span class="built_in">strcpy</span>(book.title, new_title);</span><br><span class="line">    <span class="keyword">return</span> book;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在这种方式中，函数update接收到的只是book1的副本，就如同传递一个简单变量一样</li>
<li>所以要完成更新操作，必须再次赋值</li>
</ul>
<h3 id="10-12-共用体"><a href="#10-12-共用体" class="headerlink" title="10.12 共用体"></a>10.12 共用体</h3><p>共用体中的所有成员使用相同的存储空间，只给共用体变量分配了一片存储空间。尽管共用体可以包含不同数据类型的多种成员，但一次只能处理一个成员</p>
<h3 id="10-13-结构体的大小"><a href="#10-13-结构体的大小" class="headerlink" title="10.13 结构体的大小"></a>10.13 结构体的大小</h3><p>可以使用<code>sizeof</code>来获取结构体的大小<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(struct book_bank);</span><br></pre></td></tr></table></figure></p>
<h3 id="10-14-位域"><a href="#10-14-位域" class="headerlink" title="10.14 位域"></a>10.14 位域</h3><h2 id="第-11-章-指针"><a href="#第-11-章-指针" class="headerlink" title="第 11 章 指针"></a>第 11 章 指针</h2><h3 id="11-1-概述"><a href="#11-1-概述" class="headerlink" title="11.1 概述"></a>11.1 概述</h3><p>在C语言中，指针是一种派生数据类型。指针以内存地址作为值。由于内存地址表示在计算机内存中保存程序指令和数据的位置，因此可用指针来直接访问和操作存储在内存中的数据</p>
<p>指针的优点</p>
<ul>
<li>便于处理数据和数据表</li>
<li>通过作为函数参数，指针可用来从函数中返回多个值</li>
<li>指针允许引用函数，因而可以把函数作为参数传递给其他函数</li>
<li>使用指向字符串的指针数组，可以节省内存的数据存储空间</li>
<li>指针使得C语言支持动态内存管理</li>
<li>指针为操作动态数据结构提供了帮助</li>
</ul>
<h3 id="11-2-理解指针"><a href="#11-2-理解指针" class="headerlink" title="11.2 理解指针"></a>11.2 理解指针</h3><p>计算机的内存是一系列”存储单元”的集合。每个单元有一个称为地址的数字与之关联</p>
<p>当我们声明一个变量时，系统会在内存中分配合适的存储空间，以保存该变量的值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> quantity = <span class="number">179</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>程序运行时，系统总是把变量名<code>quantity</code>与地址5000相关联(类似房间和房间号)</li>
<li>要访问数值179，可以使用变量名quantity或地址5000</li>
<li>由于内存地址只是编号，因而又可以把它们赋给变量。这种保存内存地址的变量就称为指针变量</li>
<li>指针变量只是保存地址的变量，而地址则是另一个变量在内存中的位置</li>
</ul>
<p>我们并不关心指针变量的实际值，因为每次运行程序时，指针的值都是会发生变化的。我们关心的是变量<code>p</code>与变量<code>quantity</code>之间的关系</p>
<h3 id="11-3-访问变量的地址"><a href="#11-3-访问变量的地址" class="headerlink" title="11.3 访问变量的地址"></a>11.3 访问变量的地址</h3><p>变量在内存中的实际地址与具体的系统有关，因此我们并不能立即知道某个变量的地址</p>
<p>我们利用地址运算符<code>&amp;</code>可以确定变量的地址<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = &amp;quantity;</span><br></pre></td></tr></table></figure></p>
<h3 id="11-4-指针变量的声明"><a href="#11-4-指针变量的声明" class="headerlink" title="11.4 指针变量的声明"></a>11.4 指针变量的声明</h3><p>由于指针变量包含的是存储某种数据类型的地址，因此在使用之前必须把它们声明为指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data_type *pt_name</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>*</code>说明变量<code>pt_name</code>是指针变量</li>
<li><code>pt_name</code>需要内存空间</li>
<li><code>pt_name</code>指向<code>data_type</code>类型的变量</li>
</ul>
<p>声明语句使得编译器为指针变量分配存储空间。由于存储空间没有赋给任何值，因而这些变量中包含的是一些未知的值，这样它们指向的也是未知的地址。</p>
<h3 id="11-5-指针变量的初始化"><a href="#11-5-指针变量的初始化" class="headerlink" title="11.5 指针变量的初始化"></a>11.5 指针变量的初始化</h3><p>把变量的地址赋给指针变量的过程称为指针变量的初始化</p>
<p>所有未初始化的指针的值都是未知的,这些值同样会被解释为内存地址。它们可能不是有效地址，也可能指向错误的值。但是编译器不会检测这些错误，因而含有未初始化指针的程序会产生错误的结果</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> quantity;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = &amp;quantity;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;quantity;</span><br></pre></td></tr></table></figure>
<p>除了NULL和0之外，其他变量不能赋给指针变量</p>
<h3 id="11-6-通过指针访问变量"><a href="#11-6-通过指针访问变量" class="headerlink" title="11.6 通过指针访问变量"></a>11.6 通过指针访问变量</h3><p>通过间接运算符可以使用指针来访问变量的值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> quantity, *p;</span><br><span class="line">quantity = <span class="number">179</span>;</span><br><span class="line">p = &amp;quantity;</span><br></pre></td></tr></table></figure></p>
<p>在C语言中，指针和地址的赋值都是通过符号名来动态实现的。不能使用<code>*5378</code>来访问存储在地址5378中的值</p>
<h3 id="11-7-指针链"><a href="#11-7-指针链" class="headerlink" title="11.7 指针链"></a>11.7 指针链</h3><p>可以将一个指针指向另一个指针，来形成指针链</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x, *p1, **p2;</span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">p1 = &amp;x;</span><br><span class="line">p2 = &amp;p1;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, **p2);</span><br></pre></td></tr></table></figure>
<h3 id="11-8-指针表达式"><a href="#11-8-指针表达式" class="headerlink" title="11.8 指针表达式"></a>11.8 指针表达式</h3><p>可以在指针变量的前面或后面添加递增或递减运算符</p>
<p>指针变量可以与整数值进行加减运算</p>
<p>当两个指针指向同一个数组时，可以用一个指针变量减去另一个指针变量</p>
<p>当两个指针指向相同数据类型的对象时，可以使用关系运算符对它们进行比较操作</p>
<p>不能对指针变量与常量做乘法运算</p>
<p>两个指针变量不能做加法操作</p>
<h3 id="11-9-指针的递增和比例因子"><a href="#11-9-指针的递增和比例因子" class="headerlink" title="11.9 指针的递增和比例因子"></a>11.9 指针的递增和比例因子</h3><p>当指针进行递增时，所增加的值为该指针指向的数据类型的长度，这种长度就称为比例因子(scale factor)</p>
<h3 id="11-10-指针与数组"><a href="#11-10-指针与数组" class="headerlink" title="11.10 指针与数组"></a>11.10 指针与数组</h3><p>当声明数组时，编译器在连续的内存空间分配基本地址和足够的存储空间，以容纳数组的所有元素。基本地址是数组第一个元素的存储位置。编译器还将数组名定义为指向第一个元素的常量指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">int</span> *p = x;</span><br><span class="line"><span class="keyword">while</span>( p &lt;= &amp;x[<span class="number">4</span>])&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, *p);</span><br><span class="line">    p++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-11-指针与字符串"><a href="#11-11-指针与字符串" class="headerlink" title="11.11 指针与字符串"></a>11.11 指针与字符串</h3><p>C语言支持另一种创建字符串的方式，即使用<code>char</code>类型的指针变量<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = <span class="string">"good"</span>;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>上述语句创建了一个文本字符串，并将其地址保存在指针变量str中</li>
<li>这样指针str就指向了字符串<code>good</code>的第一个字符</li>
</ul>
<h3 id="11-12-指针数组"><a href="#11-12-指针数组" class="headerlink" title="11.12 指针数组"></a>11.12 指针数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *name[<span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="string">"New Zealand"</span>,</span><br><span class="line">    <span class="string">"Australia"</span>,</span><br><span class="line">    <span class="string">"India"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="11-13-将指针作为函数的参数"><a href="#11-13-将指针作为函数的参数" class="headerlink" title="11.13 将指针作为函数的参数"></a>11.13 将指针作为函数的参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span> *)</span></span>;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    x = <span class="number">100</span>;</span><br><span class="line">    y = <span class="number">200</span>;</span><br><span class="line">    exchange(&amp;x, &amp;y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    t = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当把地址传递给函数时，接收地址的参数必须是指针。使用指针传递变量地址的函数调用过程称为引用调用</p>
<p>上面的程序有如下几点</p>
<ul>
<li>函数的参数声明为指针</li>
<li>在函数体中使用了间接引用指针</li>
<li>当调用函数时，地址作为实参被传递</li>
</ul>
<h3 id="11-14-函数返回指针"><a href="#11-14-函数返回指针" class="headerlink" title="11.14 函数返回指针"></a>11.14 函数返回指针</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">largest</span><span class="params">(<span class="keyword">int</span> *, <span class="keyword">int</span> *)</span></span>;</span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">int</span> *p;</span><br><span class="line">    p = largest(&amp;a, &amp;b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">largest</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(*x &gt; *y)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="11-15-指向指针的函数"><a href="#11-15-指向指针的函数" class="headerlink" title="11.15 指向指针的函数"></a>11.15 指向指针的函数</h3><p>与变量一样，函数也属于某种数据类型，在内存中也需要有存储空间。因此可以声明一个指向函数的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">double</span> (*p1)();</span><br><span class="line">p1 = mul;</span><br></pre></td></tr></table></figure></p>
<p><code>(*p1)(x, y)</code>等价于<code>mul(x, y)</code></p>
<p>兼容性与类型转换</p>
<ol>
<li>总是有一种数据类型与指针关联，我们不能把一种类型的指针赋给另一种类型的指针，尽管两者都是以内存地址作为值。这称为指针的兼容性</li>
<li>对不同类型的指针不能使用赋值运算符，但可以利用类型转换，在不兼容的指针类型之间显式地进行赋值操作</li>
</ol>
<p>空指针</p>
<ul>
<li>空指针<code>void*</code>是通用指针，可以表示任何指针类型</li>
<li>所有指针类型都可以赋给空指针</li>
<li>而空指针无须类型转换就可以赋值给任意指针</li>
</ul>
<h3 id="11-16-指针与结构体"><a href="#11-16-指针与结构体" class="headerlink" title="11.16 指针与结构体"></a>11.16 指针与结构体</h3><p>运算符<code>-&gt;</code>、<code>.</code>、<code>()</code>和<code>[]</code>的优先级最高，它们与它们的操作数高度捆绑在一起</p>
<p>记住下列语句的意义</p>
<ul>
<li><code>*ptr-&gt;p</code>: 返回<code>p</code>指向的内容</li>
<li><code>*ptr-&gt;p++</code>: 在访问<code>p</code>指向的内容后递增<code>p</code></li>
<li><code>(*ptr-&gt;p)++</code>: 是<code>p</code>指向的内容递增</li>
<li><code>*ptr++-&gt;p</code>: 在访问<code>p</code>的内容后，使<code>ptr</code>递增</li>
</ul>
<h3 id="11-17-指针存在的问题"><a href="#11-17-指针存在的问题" class="headerlink" title="11.17 指针存在的问题"></a>11.17 指针存在的问题</h3><p>常见错误如下</p>
<ol>
<li><p>向未初始化的指针赋值</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p, m = <span class="number">100</span>;</span><br><span class="line">*p = m; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将数值赋值给指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p, m = <span class="number">100</span>;</span><br><span class="line">p = m; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>需要时没有间接引用指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p, x = <span class="number">100</span>;</span><br><span class="line">p = &amp;x; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, p);<span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将未初始化变量的地址赋值给指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p, m;</span><br><span class="line">p = &amp;m; <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>比较指向不同对象的指针</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> name1[<span class="number">20</span>], name2[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">char</span> *p1 = name1;</span><br><span class="line"><span class="keyword">char</span> *p2 = name2;</span><br><span class="line"><span class="keyword">if</span>(p1 &gt; p2).... <span class="comment">//error</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="第-12-章-文件管理"><a href="#第-12-章-文件管理" class="headerlink" title="第 12 章 文件管理"></a>第 12 章 文件管理</h2><h3 id="12-1-概述"><a href="#12-1-概述" class="headerlink" title="12.1 概述"></a>12.1 概述</h3><p>基于控制台的I/O操作有两个主要问题</p>
<ul>
<li>通过终端来处理大量数据是笨拙且费时的</li>
<li>当程序终止或关机时，所有数据都将丢失</li>
</ul>
<p>文件是在磁盘上存储一组相关数据的地方</p>
<p>基本的文件操作</p>
<ul>
<li>文件命名</li>
<li>打开文件</li>
<li>从文件中读取数据</li>
<li>往文件中写入数据</li>
<li>关闭文件</li>
</ul>
<p>在C语言中有两种不同的方法来执行文件操作</p>
<ol>
<li>低级I/O操作，使用UNIX系统调用</li>
<li>高级I/O操作，使用C语言的标准I/O库函数</li>
</ol>
<h3 id="12-2-定文并打开文件"><a href="#12-2-定文并打开文件" class="headerlink" title="12.2 定文并打开文件"></a>12.2 定文并打开文件</h3><p>要把数据存储在辅存的文件中，就必须向操作系统指定文件的某些信息</p>
<ul>
<li>文件名</li>
<li>数据结构</li>
<li>打开方式</li>
</ul>
<p>文件名是个字符串，操作系统的合法文件名包括两部分：基本名称和可选的扩展名</p>
<p>文件的数据结构定义为<code>FILE</code>，因此，所有文件在使用之前都必须声明为<code>FILE</code>类型。<code>FILE</code>是一种已定义的数据类型</p>
<p>声明并打开文件的一般格式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp;</span><br><span class="line">fp = fopen(<span class="string">"filename"</span>, <span class="string">"mode"</span>);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一条语句把变量<code>fp</code>声明为“指向FILE数据类型的指针”</li>
<li>第二条语句打开名为<code>filename</code>的文件，并把标识符赋给<code>FILE</code>类型的指针<code>fp</code></li>
<li><code>fp</code>指针包含了文件的所有信息，随后可用作系统与程序之间的通信链接</li>
</ul>
<p><code>mode</code>可以是以下情况之一</p>
<ul>
<li><code>r</code>: 以只读方式打开文件</li>
<li><code>w</code>：以只写方式打开文件</li>
<li><code>a</code>: 以附加（或添加）数据的方式打开文件</li>
<li><code>r+</code>: 打开已有文件，用于读和写数据</li>
<li><code>w+</code>: 除了可用于读和写数据之外，其他的与<code>w</code>相同</li>
<li><code>a+</code>: 除了可用于读和写数据之外，其他的与<code>a</code>相同</li>
</ul>
<p>当试图打开文件时，将发生以下事情之一</p>
<ul>
<li>当<code>mode</code>为<code>w</code>时，如果文件不存在，就创建指定名称的文件；如果存在，就删除其内容</li>
<li>当<code>mode</code>为<code>a</code>时，打开文件并且保留当前内容：如果文件不存在，就创建指定名称的文件</li>
<li>当<code>mode</code>为<code>r</code>时，如果文件存在，就打开文件并保留当前内容：如果文件不存在，就会发生错误</li>
</ul>
<h3 id="12-3-关闭文件"><a href="#12-3-关闭文件" class="headerlink" title="12.3 关闭文件"></a>12.3 关闭文件</h3><p>只要所有操作已经完成，就应立即关闭文件</p>
<p>这样就可以确保与该文件有关的未完成的信息从缓冲区中冲刷掉，所有与该文件的链接也会被断开</p>
<p>形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fclose(file_pointer);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-4-文件的输入输出操作"><a href="#12-4-文件的输入输出操作" class="headerlink" title="12.4 文件的输入输出操作"></a>12.4 文件的输入输出操作</h3><h4 id="12-4-1-getc与putc函数"><a href="#12-4-1-getc与putc函数" class="headerlink" title="12.4.1 getc与putc函数"></a>12.4.1 <code>getc</code>与<code>putc</code>函数</h4><p>最简单的文件<code>I/O</code>函数是<code>getc</code>和<code>putc</code>。它们类似于<code>getchar</code>和<code>putchar</code>函数，一次处理一个字符</p>
<p><code>putc(c, fp1)</code>把字符变量<code>c</code>包含的字符写入<code>fp1</code>指向的文件中</p>
<p><code>c=getc(fp2)</code>getc函数用于从已读取方式打开的文件中读取一个字符</p>
<p>每次进行<code>getc</code>和<code>putc</code>操作后，文件指针就移动一个字符的位置。当到达文件末尾时，<code>getc</code>函数将返回文件末尾标记符<code>EOF</code>。因此，当遇到<code>EOF</code>标记符时，读取工作将停止</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">main(</span><br><span class="line">    FILE *fp;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    fp = fopen(<span class="string">"INPUT"</span>,<span class="string">"w"</span>);</span><br><span class="line">    <span class="keyword">while</span>((c=getchar()) != EOF)</span><br><span class="line">        putc(c, fp);</span><br><span class="line">    fclose(fp);</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="12-4-2-getw与putw函数"><a href="#12-4-2-getw与putw函数" class="headerlink" title="12.4.2 getw与putw函数"></a>12.4.2 <code>getw</code>与<code>putw</code>函数</h4><p><code>getw</code>和<code>putw</code>时基于整数的函数，用来读取和写入整数值<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">putw(integer, fp);</span><br><span class="line">getw(fp);</span><br></pre></td></tr></table></figure></p>
<h4 id="12-4-3-fprintf与fscanf函数"><a href="#12-4-3-fprintf与fscanf函数" class="headerlink" title="12.4.3 fprintf与fscanf函数"></a>12.4.3 <code>fprintf</code>与<code>fscanf</code>函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fprintf</span>(fp1, <span class="string">"%s %d %f"</span>, name, age, <span class="number">7.5</span>);</span><br><span class="line"><span class="built_in">fscanf</span>(fp2, <span class="string">"%s %d"</span>, item, &amp;quantity);</span><br></pre></td></tr></table></figure>
<h3 id="12-5-I-O操作的错误处理"><a href="#12-5-I-O操作的错误处理" class="headerlink" title="12.5 I/O操作的错误处理"></a>12.5 I/O操作的错误处理</h3><p>常见的错误包括</p>
<ul>
<li>读取试图超过文件结尾标识符</li>
<li>设备溢出</li>
<li>试图使用还没有打开的文件</li>
<li>当文件打开用于某种操作时，试图执行另一种操作</li>
<li>打开不合法的文件名</li>
<li>试图往写保护的文件写入数据</li>
</ul>
<p><code>feof</code>函数用来检测是否到达文件末尾，如果指定文件的所有数据都已读取，返回非零常数；否则返回零<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foef(fp) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p><code>ferror</code>函数用于报告指定函数的状态。该函数也是以<code>FILE</code>指针作为参数，如果检测出错误，就返回一个非零整数；否则返回零<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feeror(fp) == <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>当使用<code>fopen</code>函数打开文件时，将返回一个文件指针。如果因为某些原因不能打开文件，那么函数返回<code>NULL</code>指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"File could not be opened.\n"</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="12-6-随机访问文件"><a href="#12-6-随机访问文件" class="headerlink" title="12.6 随机访问文件"></a>12.6 随机访问文件</h3><p><code>ftell</code>函数以一个文件指针为参数，返回一个<code>long</code>类型的数字，它对应于当前的位置。形式为<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n = ftell(fp);</span><br></pre></td></tr></table></figure></p>
<p><code>rewind</code>函数以一个文件指针作为参数，把指针位置重置到文件的开头<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rewind(fp);</span><br></pre></td></tr></table></figure></p>
<p><code>fseek</code>函数用于把文件指针移到指定的文件位置，形式如下<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fseek(file_ptr, offset, position);</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>file_ptr</code>: 文件指针</li>
<li><code>offset</code>: 指定从<code>position</code>开始计算的要移动的位置</li>
<li>position可以是以下3个值<ul>
<li>0: 文件的开头</li>
<li>1: 当前位置</li>
<li>2: 文件的末尾</li>
</ul>
</li>
</ul>
<h3 id="12-7-命令行参数"><a href="#12-7-命令行参数" class="headerlink" title="12.7 命令行参数"></a>12.7 命令行参数</h3><h2 id="第-13-章-动态内存分配与链表"><a href="#第-13-章-动态内存分配与链表" class="headerlink" title="第 13 章 动态内存分配与链表"></a>第 13 章 动态内存分配与链表</h2><h3 id="13-1-概述"><a href="#13-1-概述" class="headerlink" title="13.1 概述"></a>13.1 概述</h3><p>动态数据结构可以在运行时灵活地添加、删除或重排数据项，而动态内存管理则运行在运行时分配更多的内存空间或释放不再需要的空间，因而可以优化存储空间的使用</p>
<h3 id="13-2-动态内存分配"><a href="#13-2-动态内存分配" class="headerlink" title="13.2 动态内存分配"></a>13.2 动态内存分配</h3><p>在运行时分配内存空间的过程称为动态内存分配，尽管C语言本身不具备这种能力，但它有4个名为“内存管理函数”的库例程，可以用来在程序运行时分配和释放内存</p>
<p>内存分配过程</p>
<ol>
<li>程序指令、全局变量和静态变量存储在永久存储区内，而局部变量存储在栈中</li>
<li>位于这两个区之间的内存空间可以用于程序运行时的动态分配。这些内存区称为堆</li>
<li>当程序运行时，堆的大小是不断变化的，因为会发生函数或代码块的局部变量的创建和销毁</li>
<li>因此有可能遇到内存的溢出，在这种情况下，内存分配函数将返回空指针</li>
</ol>
<h3 id="13-3-用malloc函数分配一块内存"><a href="#13-3-用malloc函数分配一块内存" class="headerlink" title="13.3 用malloc函数分配一块内存"></a>13.3 用malloc函数分配一块内存</h3><p>利用<code>malloc</code>函数可以分配一块内存。<code>malloc</code>函数将保留指定大小的内存块，并返回<code>void</code>类型的指针。这意味着可以通过类型转化将它赋给任意类型的指针<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *x = (<span class="keyword">int</span> *)<span class="built_in">malloc</span>(<span class="number">100</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure></p>
<p>注意，动态分配的存储空间没有名称，因此只能通过指针来访问其内容</p>
<p>也可以用<code>malloc</code>函数来给诸如结构体之类的复杂数据类型分配存储空间<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">st_var = (struct store *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct store));</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>malloc</code>函数分配的是连续的字节块。如果堆的空间不能满足要求，分配失败。如果失败，将返回NULL。因此，在使用内存指针之前，应检查内存分配是否成功</p>
<h3 id="13-4-用calloc函数分配多个内存块"><a href="#13-4-用calloc函数分配多个内存块" class="headerlink" title="13.4 用calloc函数分配多个内存块"></a>13.4 用calloc函数分配多个内存块</h3><p>calloc是另一种内存分配函数，通常用于在运行时为了存储派生数据类型而分配所需的内存空间</p>
<p>malloc函数分配的是单个内存块，而calloc函数分配的是多个内存块，且每个内存块的大小相等，并把所有字节都设为0<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = (cast-type *)<span class="built_in">calloc</span>(n ,elem-size);</span><br></pre></td></tr></table></figure></p>
<h3 id="13-5-用free函数释放已用的空间"><a href="#13-5-用free函数释放已用的空间" class="headerlink" title="13.5 用free函数释放已用的空间"></a>13.5 用free函数释放已用的空间</h3><p>变量的编译时存储空间是由系统根据其存储类型来分配和释放的。而对于运行时的内存分配，当不再需要时，由程序员来负责释放。当存储空间有限时，内存的释放就变得很重要了</p>
<p>当不再需要保存在内存块中的数据，且不打算用这块内存来存储任何其他信息时，可用<code>free</code>函数来释放掉该内存块，以供将来使用<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">free</span>(ptr);</span><br></pre></td></tr></table></figure></p>
<h3 id="13-6-用realloc函数改变内存块的大小"><a href="#13-6-用realloc函数改变内存块的大小" class="headerlink" title="13.6 用realloc函数改变内存块的大小"></a>13.6 用realloc函数改变内存块的大小</h3><p>可以用<code>realloc</code>函数来改变已分配内存的大小<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = <span class="built_in">realloc</span>(ptr, newsize);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>该函数把大小为newsize的新内存空间分配给指针变量<code>ptr</code>，并返回一个指向新内存块的第一个字节的指针</li>
<li><code>newsize</code>可以比<code>size</code>更大或更小</li>
<li>新内存块的开始位置可以与旧的相同</li>
<li>如果在相同区域中找不到其他的内存空间，就将在全新的区域中创建，旧内存块中的内容将移到新块中</li>
<li>如果函数没有成功分配更多的空间，将返回空指针，旧块被丢弃</li>
</ul>
<h3 id="13-7-链表的概念"><a href="#13-7-链表的概念" class="headerlink" title="13.7 链表的概念"></a>13.7 链表的概念</h3><p>列表是指按序组成的项值。</p>
<p>数组就是一种列表。在数组中，元素的顺序是由索引隐式地给定的。我们就是使用索引来访问和操作数组元素的</p>
<p>链表</p>
<ul>
<li>用结构体表示一个列表成员，它含有指向下一个结构体成员的链接</li>
<li>它由两个字段组成：一个包含数据项，另一个包含指向链表中下一个数据项的地址</li>
<li>链表是结构体的集合，顺序不是由它们在内存中的物理位置确定的，而是由逻辑位置确定的</li>
<li>这种逻辑位置链接是指向同类型的另一个结构体的指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> item;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>node1的<code>next</code>指针可以利用下面的语句来使其指向node2<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node1.next = &amp;node2;</span><br></pre></td></tr></table></figure></p>
<p>C语言提供了空指针，可以把它存储在链表的最后一个节点的<code>next</code>字段中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node2.next = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-8-链表的优点"><a href="#13-8-链表的优点" class="headerlink" title="13.8 链表的优点"></a>13.8 链表的优点</h3><p>优点</p>
<ol>
<li>其大小可以在程序运行时增大或缩小。链表的长度可以按需决定</li>
<li>不会浪费空间，任何时候，链表使用的内存就是它所需要的</li>
<li>链表提供的灵活性允许高效地重排数据项，通过重排链接，可以很容易地插入和删除数据项</li>
</ol>
<p>局限：访问任何数据项时有些笨拙或费时</p>
<h3 id="13-9-链表的种类"><a href="#13-9-链表的种类" class="headerlink" title="13.9 链表的种类"></a>13.9 链表的种类</h3><ul>
<li>线性链表</li>
<li>环形链表</li>
<li>双向链表</li>
<li>循环双向链表</li>
</ul>
<h3 id="13-10再论指针"><a href="#13-10再论指针" class="headerlink" title="13.10再论指针"></a>13.10再论指针</h3><p>在使用之前必须把指针初始化为内存地址，有两种初始化方式</p>
<ol>
<li><p>赋给已有变量的地址(静态赋值)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = &amp;count</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用内存分配函数(动态赋值)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="13-11-创建链表"><a href="#13-11-创建链表" class="headerlink" title="13.11 创建链表"></a>13.11 创建链表</h3><p>可以使用指针和诸如<code>malloc</code>之类的动态内存分配函数来创建链表节点<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linked_list</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> number;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linked_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linked_list</span> <span class="title">node</span>;</span></span><br><span class="line">node *head;</span><br><span class="line">head = (node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(node));</span><br><span class="line">head -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">head -&gt; number = <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="13-12-插入一个数据项"><a href="#13-12-插入一个数据项" class="headerlink" title="13.12 插入一个数据项"></a>13.12 插入一个数据项</h3><p>链表的优点之一是，相比较而言，它更容易插入一个新节点，只要求重置两个指针即可</p>
<h3 id="13-13-删除一个数据项"><a href="#13-13-删除一个数据项" class="headerlink" title="13.13 删除一个数据项"></a>13.13 删除一个数据项</h3><p>略</p>
<h3 id="13-14-链表的应用"><a href="#13-14-链表的应用" class="headerlink" title="13.14 链表的应用"></a>13.14 链表的应用</h3><p>略  </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/了解SpringBoot/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/了解SpringBoot/" itemprop="url">了解SpringBoot</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-18T17:27:25+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/18/了解SpringBoot/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/18/了解SpringBoot/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="了解SpringBoot"><a href="#了解SpringBoot" class="headerlink" title="了解SpringBoot"></a>了解SpringBoot</h2><h3 id="1-什么是SpringBoot"><a href="#1-什么是SpringBoot" class="headerlink" title="1 什么是SpringBoot"></a>1 什么是SpringBoot</h3><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。</p>
<p>该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。</p>
<p>Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p>
<h3 id="2-使用SpringBoot的好处"><a href="#2-使用SpringBoot的好处" class="headerlink" title="2 使用SpringBoot的好处"></a>2 使用SpringBoot的好处</h3><p>开箱即用、简单、快速、方便</p>
<h3 id="3-使用SpringBoot搭建项目"><a href="#3-使用SpringBoot搭建项目" class="headerlink" title="3 使用SpringBoot搭建项目"></a>3 使用SpringBoot搭建项目</h3><ol>
<li><p>访问 <a href="http://start.spring.io/" target="_blank" rel="noopener">http://start.spring.io/</a></p>
</li>
<li><p>配置工程的基本信息<br><img src="/2019/07/18/了解SpringBoot/0718_0.png" alt=""></p>
</li>
<li><p>点击Generate Project下载项目压缩包</p>
</li>
<li><p>解压后用idea打开即可，maven会自动下载依赖</p>
</li>
<li><p>建议的目录类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com</span><br><span class="line">  +- example</span><br><span class="line">    +- myproject</span><br><span class="line">      +- Application.java</span><br><span class="line">      |</span><br><span class="line">      +- model</span><br><span class="line">      |  +- Customer.java</span><br><span class="line">      |  +- CustomerRepository.java</span><br><span class="line">      |</span><br><span class="line">      +- service</span><br><span class="line">      |  +- CustomerService.java</span><br><span class="line">      |</span><br><span class="line">      +- controller</span><br><span class="line">      |  +- CustomerController.java</span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/18/了解SpringCloud/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/18/了解SpringCloud/" itemprop="url">了解SpringCloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-18T16:11:27+08:00">
                2019-07-18
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/other/" itemprop="url" rel="index">
                    <span itemprop="name">other</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/07/18/了解SpringCloud/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/07/18/了解SpringCloud/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="SpringCloud初步了解"><a href="#SpringCloud初步了解" class="headerlink" title="SpringCloud初步了解"></a>SpringCloud初步了解</h2><p><a href="http://www.ityouknow.com/spring-cloud.html" target="_blank" rel="noopener">原文地址</a></p>
<h3 id="1-大话SpringCloud"><a href="#1-大话SpringCloud" class="headerlink" title="1 大话SpringCloud"></a>1 大话SpringCloud</h3><p>Spring Cloud从技术架构上降低了对大型系统构建的要求，使我们以非常低的成本（技术或者硬件）搭建一套高效、分布式、容错的平台</p>
<h4 id="1-1-SpringCloud"><a href="#1-1-SpringCloud" class="headerlink" title="1.1 SpringCloud"></a>1.1 SpringCloud</h4><p>Spring Cloud是一系列框架的集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</p>
<p>微服务是可以独立部署、水平扩展、独立访问（或者有独立的数据库）的服务单元，springcloud就是这些微服务的管家，采用了微服务这种架构之后，项目的数量会非常多</p>
<h4 id="1-2-和SpringBoot的关系"><a href="#1-2-和SpringBoot的关系" class="headerlink" title="1.2 和SpringBoot的关系"></a>1.2 和SpringBoot的关系</h4><ul>
<li>Spring Boot 是 Spring 的一套快速配置脚手架，可以基于Spring Boot 快速开发单个微服务</li>
<li>Spring Cloud是一个基于Spring Boot实现的云应用开发工具</li>
<li>Spring Boot专注于快速、方便集成的单个个体，Spring Cloud是关注全局的服务治理框架</li>
<li>Spring Boot使用了默认大于配置的理念，很多集成方案已经帮你选择好了，能不配置就不配置</li>
<li>Spring Cloud很大的一部分是基于Spring Boot来实现，但Spring Boot可以离开Spring Cloud独立使用开发项目</li>
</ul>
<h4 id="1-3-Spring-Cloud的优势"><a href="#1-3-Spring-Cloud的优势" class="headerlink" title="1.3 Spring Cloud的优势"></a>1.3 Spring Cloud的优势</h4><ul>
<li>产出于spring大家族，可以保证后续的更新、完善</li>
<li>Spring Boot提供的开箱即用性</li>
<li>作为一个微服务治理的大家伙，考虑的很全面，几乎服务治理的方方面面都考虑到了</li>
<li>Spring Cloud 活跃度很高，教程很丰富，遇到问题很容易找到解决方案</li>
<li>轻轻松松几行代码就完成了熔断、均衡负载、服务中心的各种平台功能</li>
</ul>
<h4 id="1-4-其他"><a href="#1-4-其他" class="headerlink" title="1.4 其他"></a>1.4 其他</h4><ul>
<li><p>Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。</p>
</li>
<li><p>同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在目前五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当前Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。</p>
</li>
</ul>
<h3 id="2-注册中心Eureka"><a href="#2-注册中心Eureka" class="headerlink" title="2 注册中心Eureka"></a>2 注册中心Eureka</h3><h4 id="2-1-注册中心"><a href="#2-1-注册中心" class="headerlink" title="2.1 注册中心"></a>2.1 注册中心</h4><p>注册中心，管理各种服务功能包括服务的注册、发现、熔断、负载、降级等</p>
<p>正常调用项目A请求项目B<br><img src="/2019/07/18/了解SpringCloud/0718_1.jpg" alt=""></p>
<p>有了服务中心之后，任何一个服务都不能直接去调用，都需要通过服务中心来调用<br><img src="/2019/07/18/了解SpringCloud/0718_0.jpg" alt=""></p>
<p>通过服务中心来获取服务你不需要关注你调用的项目IP地址，由几台服务器组成，每次直接去服务中心获取可以使用的服务去调用即可</p>
<p>由于各种服务都注册到了服务中心，就有了去做很多高级功能条件</p>
<ol>
<li>几台服务提供相同服务来做均衡负载</li>
<li>监控服务器调用成功率来做熔断，移除服务列表中的故障点</li>
<li>监控服务调用时间来对不同的服务器设置不同的权重等等。</li>
</ol>
<h4 id="2-2-Eureka"><a href="#2-2-Eureka" class="headerlink" title="2.2 Eureka"></a>2.2 Eureka</h4><p><img src="/2019/07/18/了解SpringCloud/0718_2.png" alt=""></p>
<p>Eureka的基础架构</p>
<ol>
<li>Eureka Server: 提供服务注册和发现</li>
<li>Service Provider: 服务提供方，将自身服务注册到Eureka中，从而使得服务消费方能够找到</li>
<li>Service Consumer: 服务消费方，从Eureka获取注册服务列表，从而能够消费服务</li>
</ol>
<h3 id="3-熔断器Hystrix"><a href="#3-熔断器Hystrix" class="headerlink" title="3 熔断器Hystrix"></a>3 熔断器Hystrix</h3><h4 id="3-1-雪崩效应"><a href="#3-1-雪崩效应" class="headerlink" title="3.1 雪崩效应"></a>3.1 雪崩效应</h4><p>在微服务架构中通常会有多个服务层调用，基础服务的故障可能会导致级联故障，进而造成整个系统不可用的情况，这种现象被称为服务雪崩效应。</p>
<p>服务雪崩效应是一种因服务提供者的不可用导致服务消费者的不可用,并将不可用逐渐放大的过程。</p>
<p>如下图所示: A作为服务提供者，B为A的服务消费者，C和D是B的服务消费者。A不可用引起了B不可用，并将不可用像滚雪球一样放大到C和D，雪崩效应形成了</p>
<p><img src="/2019/07/18/了解SpringCloud/0718_3.png" alt=""></p>
<h4 id="3-2-熔断器"><a href="#3-2-熔断器" class="headerlink" title="3.2 熔断器"></a>3.2 熔断器</h4><p>熔断器可以实现快速失败，如果它在一段时间内侦测到许多类似的错误，会强迫其以后的多个调用快速失败，不再访问远程服务器，使得应用程序继续执行而不浪费CPU时间去等待长时间的超时产生。</p>
<p>熔断器也可以使应用程序能够诊断错误是否已经修正，如果已经修正，应用程序会再次尝试调用操作。</p>
<p>熔断器模式就像是那些容易导致错误的操作的一种代理。这种代理能够记录最近调用发生错误的次数，然后决定是允许操作继续，还是快速失败。熔断器开关相互转换的逻辑如下图：</p>
<p><img src="/2019/07/18/了解SpringCloud/0719_4.png" alt=""></p>
<h4 id="3-2-3-Hystrix特性"><a href="#3-2-3-Hystrix特性" class="headerlink" title="3.2.3 Hystrix特性"></a>3.2.3 Hystrix特性</h4><ol>
<li><p>断路器机制</p>
<ul>
<li>当Hystrix Command请求后端服务失败数量超过一定比例(默认50%), 断路器会切换到开路状态(Open). 这时所有请求会直接失败而不会发送到后端服务</li>
<li>断路器保持在开路状态一段时间后(默认5秒), 自动切换到半开路状态(HALF-OPEN). 这时会判断下一次请求的返回情况, 如果请求成功, 断路器切回闭路状态(CLOSED), 否则重新切换到开路状态(OPEN)</li>
<li>一旦后端服务不可用, 断路器会直接切断请求链, 避免发送大量无效请求影响系统吞吐量, 并且断路器有自我检测并恢复的能力.</li>
</ul>
</li>
<li><p>Fallback</p>
<ul>
<li>Fallback相当于是降级操作</li>
<li>对于查询操作, 我们可以实现一个fallback方法, 当请求后端服务出现异常的时候, 可以使用fallback方法返回的值</li>
<li>fallback方法的返回值一般是设置的默认值或者来自缓存.</li>
</ul>
</li>
<li><p>资源隔离</p>
<ul>
<li>在Hystrix中, 主要通过线程池来实现资源隔离</li>
<li>通常在使用的时候我们会根据调用的远程服务划分出多个线程池. 例如调用产品服务的Command放入A线程池, 调用账户服务的Command放入B线程池. 这样做的主要优点是运行环境被隔离开了. </li>
<li>这样就算调用服务的代码存在bug或者由于其他原因导致自己所在线程池被耗尽时, 不会对系统的其他服务造成影响. </li>
</ul>
</li>
</ol>
<h3 id="4-服务网关Zuul"><a href="#4-服务网关Zuul" class="headerlink" title="4 服务网关Zuul"></a>4 服务网关Zuul</h3><p>在微服务架构中，后端服务往往不直接开放给调用端，而是通过一个API网关根据请求的url，路由到相应的服务。</p>
<p>当添加API网关后，在第三方调用端和服务提供方之间就创建了一面墙，这面墙直接与调用方通信进行权限控制，后将请求均衡分发给后台服务端。</p>
<h4 id="4-1-为什么需要API-GateWay"><a href="#4-1-为什么需要API-GateWay" class="headerlink" title="4.1 为什么需要API GateWay"></a>4.1 为什么需要API GateWay</h4><p>在微服务架构模式下后端服务的实例数一般是动态的，对于客户端而言很难发现动态改变的服务实例的访问地址信息。<br>因此在基于微服务的项目中为了简化前端的调用逻辑，通常会引入API Gateway作为轻量级网关，同时API Gateway中也会实现相关的认证逻辑从而简化内部服务之间相互调用的复杂度。</p>
<p><img src="/2019/07/18/了解SpringCloud/0718_4.png" alt=""></p>
<h3 id="5-Spring-Cloud-Config配置中心"><a href="#5-Spring-Cloud-Config配置中心" class="headerlink" title="5 Spring Cloud Config配置中心"></a>5 Spring Cloud Config配置中心</h3><p>随着线上项目变的日益庞大，每个项目都散落着各种配置文件，如果采用分布式的开发模式，需要的配置文件随着服务增加而不断增多。</p>
<p>某一个基础服务信息变更，都会引起一系列的更新和重启，配置中心便是解决此类问题的灵丹妙药。</p>
<h4 id="5-1-配置中心提供的核心功能"><a href="#5-1-配置中心提供的核心功能" class="headerlink" title="5.1 配置中心提供的核心功能"></a>5.1 配置中心提供的核心功能</h4><ul>
<li>提供服务端和客户端支持</li>
<li>集中管理各环境的配置文件</li>
<li>配置文件修改之后，可以快速的生效</li>
<li>可以进行版本管理</li>
<li>支持大的并发查询</li>
<li>支持各种语言</li>
</ul>
<h4 id="5-2-Spring-Cloud-Config"><a href="#5-2-Spring-Cloud-Config" class="headerlink" title="5.2 Spring Cloud Config"></a>5.2 Spring Cloud Config</h4><p>Spring Cloud Config项目是一个解决分布式系统的配置管理方案。</p>
<p>它包含了Client和Server两个部分，server提供配置文件的存储、以接口的形式将配置文件的内容提供出去，client通过接口获取数据、并依据此数据初始化自己的应用。</p>
<p>Spring cloud使用git或svn存放配置文件，默认情况下使用git</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
