<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/5/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/NLP-3-中文分词技术/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/NLP-3-中文分词技术/" itemprop="url">[NLP][3][中文分词技术]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:15:34+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index">
                    <span itemprop="name">nlp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/NLP-3-中文分词技术/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/NLP-3-中文分词技术/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第三章-中文分词技术"><a href="#第三章-中文分词技术" class="headerlink" title="第三章 中文分词技术"></a>第三章 中文分词技术</h2><blockquote>
<p>在语言理解中，词是最小的能够独立活动的有意义的语言成分。将词确定下来是理解自然语言的第一步，只有跨越了这一步，中文才能像英文那样过渡到短语划分、概念抽取以及主题分析，以至自然语言理解，最终达到智能计算的最高境界</p>
</blockquote>
<h3 id="3-1-中文分词简介"><a href="#3-1-中文分词简介" class="headerlink" title="3.1 中文分词简介"></a>3.1 中文分词简介</h3><ul>
<li><p>简介：中文分词技术通过计算机自动识别出句子中的词，在词间加入边界标识符，分隔出各个词汇</p>
</li>
<li><p>分词方法</p>
<ol>
<li>规则分词：通过人工设立词库，按照一定方式进行匹配切分</li>
<li>统计分词：应用统计学方法进行分词</li>
<li>混合分词：前两种方法的混合</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-2-规则分词"><a href="#3-2-规则分词" class="headerlink" title="3.2 规则分词"></a>3.2 规则分词</h3><ul>
<li><p>简介</p>
<ul>
<li>基于规则的分词是一种机械分词方法，主要通过维护词典</li>
<li>在切分语句时，将语句中每个字符串与词表中的词进行逐一匹配，找到则切分，否则不切分</li>
</ul>
</li>
<li><p>几种匹配切分的方法</p>
<ol>
<li><p>正向最大匹配法(Maximum Match Method, MM)</p>
<ul>
<li>从左到右取待切分语句的m个字符作为匹配字段，其中m为机器词典中最长词条的字符数</li>
<li>查找机器词典并进行匹配。若匹配成功，则将这个匹配字段作为一个词切分出来。若不成功，则将这个匹配字段的最后一个字去掉，剩下的字符串作为新的匹配字段再次匹配。重复，直到切分出一个词或者字段长度为1</li>
</ul>
</li>
<li><p>逆向最大匹配法(Reverse Maximum Match Method, RMM)</p>
<ul>
<li>原理同MM，只不过方向相反，使用逆序词典，从被处理文档的末端开始匹配扫描</li>
<li>由于汉语中偏正结构较多，逆向匹配可以提高一定的精度</li>
</ul>
</li>
<li><p>双向最大匹配法(Bi-directction Match Method)</p>
<ul>
<li>将MM和RMM得到的结果进行比较，然后按照最大匹配原则，选取词数切分最少的作为结果</li>
</ul>
</li>
</ol>
</li>
</ul>
<hr>
<h3 id="3-3-统计分词"><a href="#3-3-统计分词" class="headerlink" title="3.3 统计分词"></a>3.3 统计分词</h3><ul>
<li>主要思想<ul>
<li>把每个词看做是由词的最小单位的各个字组成的</li>
<li>如果<strong>相连的字</strong>在不同的文本中<strong>出现的次数越多</strong>，就证明着相连的字很可能是一个<strong>词</strong></li>
<li>我们可以利用<strong>字与字相邻出现的频率</strong>来反应<strong>成词的可靠度</strong></li>
<li>统计语料中相邻出现的各个字的组合的频率，当组合频率高于某个临界值时，我们便认为此<strong>字组</strong>可能构成一个<strong>词</strong></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-1-语言模型"><a href="#3-3-1-语言模型" class="headerlink" title="3.3.1 语言模型"></a>3.3.1 语言模型</h4><ul>
<li><p>简介</p>
<ul>
<li><strong>为长度为n的字符串确定其概率分布P(w<sub>1</sub>, w<sub>2</sub>,…,w<sub>n</sub>)</strong></li>
<li>其中,w<sub>1</sub>, w<sub>2</sub>,w<sub>n</sub>等表示字符串的第1,2,n个字符</li>
<li>P(w<sub>1</sub>, w<sub>2</sub>,…,w<sub>n</sub>)可以使用链式公式进行计算<br><img src="/2020/02/01/NLP-3-中文分词技术/链式公式.png" alt=""></li>
</ul>
</li>
<li><p>n-gram 模型</p>
<ul>
<li>如果字符串长度过长，可能会导致计算量巨大，这时，可以使用n-gram 模型，来降低计算量</li>
<li><strong>n-gram模型就是在估计条件概率的时候，忽略距离大于等于n的上文词的影响</strong>，公式如下<br><img src="/2020/02/01/NLP-3-中文分词技术/ngram.png" alt=""></li>
</ul>
</li>
<li><p>几种 n-gram 模型</p>
<ul>
<li>一元模型 (unigram model) : n=1，完全损失句子中的词序信息<br>  <img src="/2020/02/01/NLP-3-中文分词技术/1gram.png" alt=""></li>
<li>二元模型(bigram model)：n=2, 即条件概率只与前1个上下文有关<br>  <img src="/2020/02/01/NLP-3-中文分词技术/2gram.png" alt=""></li>
<li>三元模型：n=3, 即条件概率只与前2个上下文有关<br>  <img src="/2020/02/01/NLP-3-中文分词技术/3gram.png" alt=""></li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-3-2-HMM模型-隐含马尔可夫模型"><a href="#3-3-2-HMM模型-隐含马尔可夫模型" class="headerlink" title="3.3.2 HMM模型(隐含马尔可夫模型)"></a>3.3.2 HMM模型(隐含马尔可夫模型)</h4><ol>
<li><p>构词位置</p>
<ul>
<li>每个字在构造一个特定的词语的时候都占据着一个确定的构词位置(即词位)</li>
<li>规定每个字最多只有4个构词位置<ul>
<li>B 词首</li>
<li>M 词中</li>
<li>E 词尾</li>
<li>S 单独成词</li>
</ul>
</li>
<li>例如  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">中文, 分词, 是, 文本处理, 不可或缺, 的, 一步</span><br><span class="line">中(B)文(E), 分(B)词(E), 是(S), 文(B)本(M)处(M)理(E), 不(B)可(M)或(M)缺(E), 的(S), 一(B)步(E)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>任务</p>
<ul>
<li>输入:句子，如，<code>中文, 分词, 是, 文本处理, 不可或缺, 的, 一步</code></li>
<li>输出:标签序列，如，<code>中(B)文(E), 分(B)词(E), 是(S), 文(B)本(M)处(M)理(E), 不(B)可(M)或(M)缺(E), 的(S), 一(B)步(E)</code></li>
<li>我们的任务是寻找在已知输入句子的情况下,所有可能的输出标签序列中概率最大的一种，即MAX{P(o<sub>1</sub>,o<sub>2</sub>,…o<sub>n</sub>|i<sub>1</sub>,i<sub>2</sub>,…i<sub>n</sub>)}</li>
</ul>
</li>
<li><p>进行独立性假设</p>
<ul>
<li>因为P(o|i)是关于2n个变量的条件概率,且n不固定，因此几乎无法对P(o|i)进行计算</li>
<li>这里引入独立性假设，即每个字的输出(o)仅仅与当前字有关(i),公式如下<br><img src="/2020/02/01/NLP-3-中文分词技术/独立性假设.png" alt=""></li>
<li>然而这种方法完全没有考虑上下文的影响,且输出中会出现如BBB,BEM等不合理情况</li>
</ul>
</li>
<li><p>添加上下文影响</p>
<ul>
<li>首先对P(o|i)使用贝叶斯公式<br><img src="/2020/02/01/NLP-3-中文分词技术/贝叶斯公式.png" alt=""></li>
<li>其中，因为i是给定输入,所以P(i)为常数，可以忽略不计</li>
<li>然后对P(i|o)也进行独立性假设，公式如下<br><img src="/2020/02/01/NLP-3-中文分词技术/独立性假设2.png" alt=""></li>
<li>P(o)根据链式公式可求得为<br><img src="/2020/02/01/NLP-3-中文分词技术/链式公式2.png" alt=""></li>
<li>然后对P(o)做齐次马尔科夫假设，即，每个输出仅仅与上一个输出有关<br><img src="/2020/02/01/NLP-3-中文分词技术/齐次马尔科夫.png" alt=""></li>
<li>于是P(o|i)最终等于<br><img src="/2020/02/01/NLP-3-中文分词技术/hmm最终公式.png" alt=""></li>
<li>我们把P(i<sub>k</sub>|o<sub>k</sub>)称为发射频率,P(o<sub>k</sub>|o<sub>k-1</sub>)称为转移频率</li>
<li>通过设置某些P(o<sub>k</sub>|o<sub>k-1</sub>)=0,就可以排除类似BBB、EM等不合理的情况</li>
</ul>
</li>
<li><p>如何寻找最大的P(i|o)P(o)</p>
<ul>
<li>通常采用Veterbi算法</li>
<li>它是一种动态规划方法</li>
<li>核心思想是：如果最终的最优路径经过某个o<sub>i</sub>，那么从初始节点到o<sub>i-1</sub>的路径必然也是最优路径</li>
<li>根据这个思想，在考虑每个o<sub>i</sub>时只需要求出所有经过各o<sub>i-1</sub>的最优路径，然后再与当前的o<sub>i</sub>结合比较</li>
</ul>
</li>
<li><p>理解</p>
<ul>
<li>HMM算法是一种基于统计学的切词算法</li>
<li>它首先需要遍历给定语料库，计算发射概率和转移概率</li>
<li>发射概率P(i<sub>k</sub>|o<sub>k</sub>)：是指当一个字被标记为O时(O为B、M、E、S中的一个),这个字是I的概率(I是语料库中所有字中的一个)</li>
<li>转移概率P(o<sub>k</sub>|o<sub>k-1</sub>):是指当上一个标记为o<sub>k</sub>时，下一个标记为o<sub>k-1</sub>的概率,正是因为转移概率的引入，使得HMM算法可以考虑到上下文情况进行切词</li>
<li>之后，当用户输入一个句子时，模型根据Veterbi算法,找到针对输入的句子出现概率最大的标记序列情况，完成切词</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-3-3-其他统计分词算法"><a href="#3-3-3-其他统计分词算法" class="headerlink" title="3.3.3 其他统计分词算法"></a>3.3.3 其他统计分词算法</h4><ul>
<li>条件随机场(CRF)<ul>
<li>一种基于马尔科夫思想的统计模型</li>
<li>可以解决HMM中，每个o只与上一个o有关这样的假设有偏差的问题</li>
<li>在条件随机场中，每个状态不仅与它之前的状态有关，还与它后面的状态有关</li>
</ul>
</li>
<li>神经网络分词算法<ul>
<li>采用CNN、LSTM等深度学习网络自动发现一些模式和特征</li>
<li>然后结合CRF、softmax等分类算法进行分词预测</li>
</ul>
</li>
</ul>
<hr>
<h3 id="3-5-中文分词工具-Jieba"><a href="#3-5-中文分词工具-Jieba" class="headerlink" title="3.5 中文分词工具 Jieba"></a>3.5 中文分词工具 Jieba</h3><h4 id="3-5-1-简介"><a href="#3-5-1-简介" class="headerlink" title="3.5.1 简介"></a>3.5.1 简介</h4><ul>
<li><p>Jieba分词结合了基于规则和基于统计这两类方法</p>
</li>
<li><p>首先基于前缀词典进行词图扫描构建包含全部可能分词结果的有向无环图，前缀字典是指词典中的词按照前缀包含的顺序排列</p>
</li>
<li><p>然后基于标注语料，使用动态规划的方法找到最大概率路径，并将其作为最终的分词结果</p>
</li>
<li><p>对于未登录词(词典里没有的词)，Jieba使用基于汉字成词的HMM模型，采用了Viterbi算法进行推导</p>
</li>
</ul>
<h4 id="3-5-2-Jieba的三种分词模式"><a href="#3-5-2-Jieba的三种分词模式" class="headerlink" title="3.5.2 Jieba的三种分词模式"></a>3.5.2 Jieba的三种分词模式</h4><ul>
<li><p>精确模式：试图将句子最精确地切开，适合文本分析</p>
</li>
<li><p>全模式：把句子中所有可以成词的词语都扫描出来，速度非常快，但是不能解决歧义</p>
</li>
<li><p>搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词</p>
</li>
</ul>
<h4 id="3-5-2-样例代码"><a href="#3-5-2-样例代码" class="headerlink" title="3.5.2 样例代码"></a>3.5.2 样例代码</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全模式分词,并且不使用HMM来处理未登录词</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"我来到北京清华大学"</span>, cut_all=<span class="keyword">True</span>, HMM=<span class="keyword">False</span>)</span><br><span class="line">print(<span class="string">"Full Mode: "</span> + <span class="string">"/ "</span>.join(seg_list))  <span class="comment"># 全模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 精确模式分词,并且使用HMM来处理未登录词</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"我来到北京清华大学"</span>, cut_all=<span class="keyword">False</span>, HMM=<span class="keyword">True</span>)</span><br><span class="line">print(<span class="string">"Default Mode: "</span> + <span class="string">"/ "</span>.join(seg_list))  <span class="comment"># 默认模式</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认精确模式分词,并且使用HMM来处理未登录词</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"他来到了网易杭研大厦"</span>, HMM=<span class="keyword">True</span>)</span><br><span class="line">print(<span class="string">", "</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认精确模式分词,不使用HMM来处理未登录词</span></span><br><span class="line">seg_list = jieba.cut(<span class="string">"他来到了网易杭研大厦"</span>, HMM=<span class="keyword">False</span>)</span><br><span class="line">print(<span class="string">", "</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搜索引擎模式分词</span></span><br><span class="line">seg_list = jieba.cut_for_search(<span class="string">"小明硕士毕业于中国科学院计算所，后在日本京都大学深造"</span>, HMM=<span class="keyword">False</span>)  <span class="comment"># 搜索引擎模式</span></span><br><span class="line">print(<span class="string">", "</span>.join(seg_list))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Full Mode: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学</span></span><br><span class="line"><span class="string">Default Mode: 我/ 来到/ 北京/ 清华大学</span></span><br><span class="line"><span class="string">他, 来到, 了, 网易, 杭研, 大厦</span></span><br><span class="line"><span class="string">他, 来到, 了, 网易, 杭, 研, 大厦</span></span><br><span class="line"><span class="string">小, 明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, ，, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-10-基本数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-10-基本数据结构/" itemprop="url">[算法导论][10][基本数据结构]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:10:08+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-10-基本数据结构/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-10-基本数据结构/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="10-1-栈和队列"><a href="#10-1-栈和队列" class="headerlink" title="10.1 栈和队列"></a>10.1 栈和队列</h3><h4 id="10-1-1-简介"><a href="#10-1-1-简介" class="headerlink" title="10.1.1 简介"></a>10.1.1 简介</h4><ul>
<li><p>栈和队列都是动态集合，且在其上进行DELETE操作所移除的元素都是预先设定的</p>
</li>
<li><p>栈实现的是一种后进后出(last-in, first-out, LIFO)策略</p>
</li>
<li><p>队列实现的是一种先进先出(first-in, first-out, FIFO)策略</p>
</li>
</ul>
<h4 id="10-1-2-栈"><a href="#10-1-2-栈" class="headerlink" title="10.1.2 栈"></a>10.1.2 栈</h4><ul>
<li><p>栈操作</p>
<ul>
<li><code>PUSH</code></li>
<li><code>POP</code></li>
<li><code>STACK-EMPTY</code></li>
</ul>
</li>
<li><p>可以用一个大小为<code>n</code>的数组来实现一个最多容纳<code>n</code>个元素的栈</p>
</li>
<li><p>如果试图对一个空栈执行弹出操作，则称为栈下溢(underflow)</p>
</li>
<li><p>如果试图对一个满栈执行压入操作，则成为栈上溢(overflow, 著名的stackoverflow)</p>
</li>
<li><p>栈操作的伪代码<br><img src="/2020/02/01/算法导论-10-基本数据结构/stack.PNG" alt=""></p>
</li>
<li><p>三种栈操作的执行时间都是<code>O(1)</code></p>
</li>
</ul>
<h4 id="10-1-3-队列"><a href="#10-1-3-队列" class="headerlink" title="10.1.3 队列"></a>10.1.3 队列</h4><ul>
<li><p>队列中的<code>INSERT</code>操作称为入队(<code>ENQUEUE</code>),<code>DELETE</code>操作称为出队(<code>DEQUEUE</code>)</p>
</li>
<li><p>利用长度为<code>n</code>的数组可以实现一个最多容纳<code>n-1</code>个元素的队列的一种方式</p>
</li>
<li><p>队列操作的伪代码<br><img src="/2020/02/01/算法导论-10-基本数据结构/queue.PNG" alt=""></p>
</li>
<li><p>两种队列操作的执行时间都是<code>O(1)</code></p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-9-中位数和顺序统计量/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-9-中位数和顺序统计量/" itemprop="url">[算法导论][9][中位数和顺序统计量]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:07:34+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-9-中位数和顺序统计量/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-9-中位数和顺序统计量/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-9-章-中位数和顺序统计量"><a href="#第-9-章-中位数和顺序统计量" class="headerlink" title="第 9 章 中位数和顺序统计量"></a>第 9 章 中位数和顺序统计量</h2><ul>
<li><p>顺序统计量</p>
<ul>
<li>在一个由n个元素组成的集合中，第i个<strong>顺序统计量</strong>(order statistic)是该集合中第i小的元素</li>
<li>例如，在一个元素集合中，<strong>最小值</strong>是第1个顺序统计量，<strong>最大值</strong>是第n个顺序统计量(i=n)</li>
</ul>
</li>
<li><p>一个中位数是它所属集合的中点元素</p>
</li>
</ul>
<h3 id="9-1-最小值和最大值"><a href="#9-1-最小值和最大值" class="headerlink" title="9.1 最小值和最大值"></a>9.1 最小值和最大值</h3><h4 id="9-1-1-在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素呢"><a href="#9-1-1-在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素呢" class="headerlink" title="9.1.1 在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素呢"></a>9.1.1 在一个有n个元素的集合中，需要做多少次比较才能确定其最小元素呢</h4><ul>
<li><p>例程: MINIMUM算法<br>  <img src="/2020/02/01/算法导论-9-中位数和顺序统计量/minimum.PNG" alt=""></p>
</li>
<li><p>结论: 为了确定最小值，至少要做<code>n-1</code>次比较</p>
</li>
</ul>
<h4 id="9-1-2-同时找到最小值和最大值"><a href="#9-1-2-同时找到最小值和最大值" class="headerlink" title="9.1.2 同时找到最小值和最大值"></a>9.1.2 同时找到最小值和最大值</h4><ul>
<li><p>我们只需要最多 <code>3 * Math.floor(n/2)</code> 次比较就可以同时找到最小值和最大值</p>
</li>
<li><p>具体方法如下</p>
<ol start="0">
<li>我们需要记录已知的最小值和最大值</li>
<li>我们将一对输入元素相互进行比较</li>
<li>我们将较小的与当前最小值比较，将较大的与当前最大值比较，这样，对每两个元素共需要3次比较</li>
</ol>
</li>
<li><p>如何设定已知的最小值和最大值的初始值依赖于n是奇数还是偶数</p>
<ul>
<li>如果n是奇数，我们就将最小值和最大值的初值都设为第一个元素的值，然后成对地处理余下地元素</li>
<li>如果n是偶数，就对前两个元素做一次比较，以决定最小值和最大值的初值，然后与n是奇数的情形一样，成对处理剩下的元素</li>
</ul>
</li>
<li><p>代码实现: 同时求解最大值和最小值</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">minimum_and_maximum</span><span class="params">(arr)</span>:</span></span><br><span class="line">    arr_len = len(arr)</span><br><span class="line">    print(arr_len)</span><br><span class="line">    <span class="keyword">if</span> arr_len == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">raise</span> IndexError(<span class="string">"param: arr is empty"</span>)</span><br><span class="line">    <span class="keyword">if</span> arr_len % <span class="number">2</span>:</span><br><span class="line">        max_val, min_val = arr[<span class="number">0</span>], arr[<span class="number">0</span>]</span><br><span class="line">        start = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        max_val, min_val = (arr[<span class="number">0</span>], arr[<span class="number">1</span>]) <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; arr[<span class="number">1</span>]) <span class="keyword">else</span> (arr[<span class="number">1</span>], arr[<span class="number">0</span>])</span><br><span class="line">        start = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start, arr_len, <span class="number">2</span>):</span><br><span class="line">        temp_max, temp_min = (arr[i], arr[i + <span class="number">1</span>]) <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) <span class="keyword">else</span> (arr[i + <span class="number">1</span>], arr[i])</span><br><span class="line">        <span class="keyword">if</span> temp_max &gt; max_val:</span><br><span class="line">            max_val = temp_max</span><br><span class="line">        <span class="keyword">if</span> temp_min &lt; min_val:</span><br><span class="line">            min_val = temp_min</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max_val, min_val</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">-3</span>, <span class="number">19</span>, <span class="number">-2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">17</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">18</span>]</span><br><span class="line">    max_val, min_val = minimum_and_maximum(arr)</span><br><span class="line">    print(max_val, min_val)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-2-期望为线性时间的选择算法"><a href="#9-2-期望为线性时间的选择算法" class="headerlink" title="9.2 期望为线性时间的选择算法"></a>9.2 期望为线性时间的选择算法</h3><ul>
<li><p>选择算法: 用于选择序列中的第i个顺序统计量</p>
</li>
<li><p>伪代码<br>  <img src="/2020/02/01/算法导论-9-中位数和顺序统计量/randomized_select.PNG" alt=""></p>
</li>
<li><p>解释</p>
<ol>
<li>第一行检查递归的基本情况</li>
<li>若不符合基本情况，第三行调用<code>RANDOMIZED-PARTITION</code>将数组<code>A[p...r]</code>划分为两个子数组<code>A[p..q-1]</code>和<code>A[q+1..r]</code>，使得<code>A[p..q-1]</code>中的每个元素都小于或等于<code>A[q]</code>，而<code>A[q+1..r]</code>中的元素都大于<code>A[q]</code></li>
<li>然后检查<code>A[q]</code>是否是第i个统计量</li>
<li>若不是则继续递归的调用此算法</li>
</ol>
</li>
<li><p>代码实现: <code>RANDOMIZED-SELECT</code>算法</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_partition</span><span class="params">(arr, p, r)</span>:</span></span><br><span class="line">    t = random.randint(p, r)</span><br><span class="line">    arr[t], arr[r] = arr[r], arr[t]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt; arr[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    arr[i + <span class="number">1</span>], arr[r] = arr[r], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">randomized_select</span><span class="params">(arr, p, r, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p == r:</span><br><span class="line">        <span class="keyword">return</span> arr[p]</span><br><span class="line">    q = randomized_partition(arr, p, r)</span><br><span class="line">    k = q - p + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> k == i:</span><br><span class="line">        <span class="keyword">return</span> arr[q]</span><br><span class="line">    <span class="keyword">elif</span> k &gt; i:</span><br><span class="line">        <span class="keyword">return</span> randomized_select(arr, p, q, i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> randomized_select(arr, q+<span class="number">1</span>, r, i - k)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    o = randomized_select(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度</p>
<ul>
<li>最坏情况<ul>
<li>O(n<sup>2</sup>)</li>
<li>每次划分都极不走运地总是按余下地元素中最大地来进行划分</li>
</ul>
</li>
<li>平均情况<ul>
<li>O(n)</li>
<li>又因为它是随机化的，所以不存在一个特定的会导致其最坏情况发生的输入数据</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-3-最坏情况为线性时间的选择算法"><a href="#9-3-最坏情况为线性时间的选择算法" class="headerlink" title="9.3 最坏情况为线性时间的选择算法"></a>9.3 最坏情况为线性时间的选择算法</h3><h4 id="9-3-1-简介"><a href="#9-3-1-简介" class="headerlink" title="9.3.1 简介"></a>9.3.1 简介</h4><ul>
<li><code>SELECT</code>算法通过对输入数组的递归划分来找出所需元素，但是，在该算法中能够保证得到对数组的一个好的划分</li>
</ul>
<h4 id="9-3-2-算法步骤"><a href="#9-3-2-算法步骤" class="headerlink" title="9.3.2 算法步骤"></a>9.3.2 算法步骤</h4><ol>
<li><p>将输入数组的n个元素划分为<code>floor(n / 5)</code>组，每组有5个元素，且至多只有一组由剩下的<code>n % 5</code>个元素组成</p>
</li>
<li><p>寻找这<code>ceil(n / 5)</code>组中每一组的中位数: 首先对每组元素进行插入排序, 然后确定每组有序元素的中位数</p>
</li>
<li><p>对第二步中找到的<code>ceil(n / 5)</code>个中位数，递归调用<code>SELECT</code>以找出其中位数<code>x</code></p>
</li>
<li><p>通过<code>PARTITION</code>函数按照<code>x</code>对输入数组进行划分, 假设<code>x</code>是数组的第<code>k</code>个顺序统计量</p>
</li>
<li><p>如果<code>i=k</code>,则返回<code>x</code>; 如果<code>i&lt;k</code>,则在低区递归调用<code>SELECT</code>来找出第<code>i</code>小的元素;如果<code>i&gt;k</code>,则在高区递归查找第<code>i-k</code>小的元素</p>
</li>
</ol>
<h4 id="9-3-3-算法实现-Python"><a href="#9-3-3-算法实现-Python" class="headerlink" title="9.3.3 算法实现:Python"></a>9.3.3 算法实现:Python</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide_arr</span><span class="params">(arr, start, end)</span>:</span></span><br><span class="line">    labels = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(start, end, <span class="number">5</span>)]</span><br><span class="line">    <span class="keyword">if</span> end != start[<span class="number">-1</span>]:</span><br><span class="line">        labels.append(end)</span><br><span class="line">    <span class="keyword">return</span> labels</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_median</span><span class="params">(arr, labels)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(labels) - <span class="number">1</span>):</span><br><span class="line">        insertion_sort(arr, labels[i], labels[i + <span class="number">1</span>])</span><br><span class="line">    medians = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(labels) - <span class="number">1</span>):</span><br><span class="line">        medians.append(arr[math.floor((labels[i] + labels[i + <span class="number">1</span>]) / <span class="number">2</span>)])</span><br><span class="line">    <span class="keyword">return</span> medians</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertion_sort</span><span class="params">(arr, start, end)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start &gt;= end + <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(start + <span class="number">1</span>, end):    </span><br><span class="line">        key = arr[i]</span><br><span class="line">        j = i - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt; start - <span class="number">1</span> <span class="keyword">and</span> arr[j] &gt; key:</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        arr[j + <span class="number">1</span>] = key</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select</span><span class="params">(arr, start, end, i)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> start == end - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[start]</span><br><span class="line">    <span class="keyword">elif</span> start &gt; end - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr[end - <span class="number">1</span>] </span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        labels = divide_arr(arr, start, end)</span><br><span class="line">        medians = find_median(arr, labels)</span><br><span class="line">        x = select(medians, <span class="number">0</span>, len(medians), math.floor((len(medians)<span class="number">-1</span>) / <span class="number">2</span>))</span><br><span class="line">        o = partition(arr, start, end, x)</span><br><span class="line">        <span class="keyword">if</span> o + <span class="number">1</span> - start == i:</span><br><span class="line">            <span class="keyword">return</span> arr[o]</span><br><span class="line">        <span class="keyword">elif</span> o + <span class="number">1</span> - start &lt; i:</span><br><span class="line">            <span class="keyword">return</span> select(arr, o + <span class="number">1</span>, end, i - (o + <span class="number">1</span> - start))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> select(arr, start, o, i) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, p, r, x)</span>:</span></span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    n = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= x:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">            <span class="keyword">if</span> arr[i] == x:</span><br><span class="line">                n = i</span><br><span class="line">    arr[i], arr[n] = arr[n], arr[i]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">        print()</span><br><span class="line">        arr = [<span class="number">8</span>, <span class="number">9</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>]</span><br><span class="line">        print(arr)</span><br><span class="line">        o = select(arr, <span class="number">0</span>, len(arr), i)</span><br><span class="line">        print(arr)</span><br><span class="line">        print(o)</span><br></pre></td></tr></table></figure>
<h4 id="9-3-4-时间复杂度"><a href="#9-3-4-时间复杂度" class="headerlink" title="9.3.4 时间复杂度"></a>9.3.4 时间复杂度</h4><ul>
<li><p>最坏情况下的递归式<br>  <img src="/2020/02/01/算法导论-9-中位数和顺序统计量/SELECT递归式.PNG" alt=""></p>
</li>
<li><p>最坏情况下的时间复杂度</p>
<ul>
<li><code>O(n)</code>, 带入主方法可以证明</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-8-线性时间排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-8-线性时间排序/" itemprop="url">[算法导论][8][线性时间排序]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:05:05+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-8-线性时间排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-8-线性时间排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第8章-线性时间排序"><a href="#第8章-线性时间排序" class="headerlink" title="第8章 线性时间排序"></a>第8章 线性时间排序</h2><ul>
<li><p>在排序的最终结果中，各元素的次序依赖于它们之间的比较，我们把这类排序算法称为比较排序</p>
</li>
<li><p>任何比较排序在最坏情况下都要经过<code>O(nlgn)</code>次比较</p>
</li>
</ul>
<hr>
<h3 id="8-1-排序算法的下界"><a href="#8-1-排序算法的下界" class="headerlink" title="8.1 排序算法的下界"></a>8.1 排序算法的下界</h3><h4 id="8-1-1-首先"><a href="#8-1-1-首先" class="headerlink" title="8.1.1 首先"></a>8.1.1 首先</h4><ul>
<li><p>在一个比较排序算法中，我们只使用元素间的比较来获得输入序列<code>&lt;a1, a2, ..., an&gt;</code>中的元素间次序的信息</p>
</li>
<li><p>我们不能用其他方法观测元素的值或者它们之间的次序信息</p>
</li>
</ul>
<h4 id="8-1-2-决策树模型"><a href="#8-1-2-决策树模型" class="headerlink" title="8.1.2 决策树模型"></a>8.1.2 决策树模型</h4><ul>
<li><p>比较排序可以被抽象为一颗决策树</p>
</li>
<li><p>决策树是一颗<strong>完全二叉树</strong>，它可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较情况</p>
</li>
<li><p>每个叶节点上都标注一个序列，每个内部节点都对应一次比较</p>
</li>
<li><p>排序算法的执行对应于一条从树的根节点到叶节点的路径</p>
</li>
<li><p>例如<br><img src="/2020/02/01/算法导论-8-线性时间排序/决策树举例.PNG" alt=""></p>
</li>
<li><p>对一个正确的比较排序算法来说，n个元素的n!种可能的情况都应该出现在决策树的叶节点上</p>
</li>
<li><p>而且每个叶节点都必须是可以从根节点经由某条路径到达的</p>
</li>
</ul>
<h4 id="8-1-3-最坏情况的下界"><a href="#8-1-3-最坏情况的下界" class="headerlink" title="8.1.3 最坏情况的下界"></a>8.1.3 最坏情况的下界</h4><ul>
<li><p>定理 8.1：在最坏情况下，任何比较排序算法都需要做O(nlgn)次比较</p>
</li>
<li><p>推论 8.2：堆排序和归并排序都是渐进最优的比较排序算法</p>
</li>
</ul>
<hr>
<h3 id="8-2-计数排序"><a href="#8-2-计数排序" class="headerlink" title="8.2 计数排序"></a>8.2 计数排序</h3><h4 id="8-2-1-简介"><a href="#8-2-1-简介" class="headerlink" title="8.2.1 简介"></a>8.2.1 简介</h4><ul>
<li><p>计数排序的前提：计数排序假设 <code>n</code> 个输入元素中的每一个都是在 <code>0</code> 到 <code>k</code> 区间内的一个整数，其中 <code>k</code> 为某个整数</p>
</li>
<li><p>计数排序的基本思想</p>
<ul>
<li>对于每个输入元素 <code>x</code>，确定小于 <code>x</code> 的元素个数</li>
<li>利用这一信息，就可以直接把 <code>x</code> 放到它在输出数组中的位置上了</li>
<li>例如，如果有17个元素小于 <code>x</code>，则 <code>x</code> 就应该在第18个输出位置上</li>
</ul>
</li>
</ul>
<h4 id="8-2-2-代码及解读"><a href="#8-2-2-代码及解读" class="headerlink" title="8.2.2 代码及解读"></a>8.2.2 代码及解读</h4><ul>
<li><p>伪代码如下<br>  <img src="/2020/02/01/算法导论-8-线性时间排序/计数排序伪代码.PNG" alt=""></p>
</li>
<li><p>解读</p>
<ol>
<li><code>1-3</code> 行创建一个大小为 <code>k+1</code> 的数组并将其初始化为全 <code>0</code></li>
<li>第 <code>4-5</code> 行的 <code>for</code> 循环遍历每个输入元素，如果一个输入元素的值为 <code>i</code>，就将 <code>C[i]</code> 值加 <code>1</code>，在第5行执行完后，<code>C[i]</code>中保存的就是等于 <code>i</code> 的元素的个数</li>
<li>第 <code>7-8</code> 行通过加总计算确定对每一个<code>i = 0, 1, ..., k</code>有多少输入元素是小于或等于 <code>i</code> 的</li>
<li>第 <code>10-12</code> 行的 <code>for</code> 循环部分，把每个元素 <code>A[j]</code> 放到它在输出数组 <code>B</code> 中的正确位置上</li>
</ol>
</li>
<li><p>代码实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(inputs, k)</span>:</span></span><br><span class="line">temp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, k)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> inputs:</span><br><span class="line">    temp[num] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">temp[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k):</span><br><span class="line">    temp[i] += temp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">outputs = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, len(inputs))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(inputs) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    outputs[temp[inputs[i]]] = inputs[i]</span><br><span class="line">    temp[inputs[i]] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    o = counting_sort([<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>], <span class="number">6</span>)</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-2-3-时间代价"><a href="#8-2-3-时间代价" class="headerlink" title="8.2.3 时间代价"></a>8.2.3 时间代价</h4><ul>
<li><p>时间复杂度: <code>O(n)</code></p>
</li>
<li><p>计数排序的下界要优于O(nlgn)，因为<strong>它并不是一个比较排序算法</strong>；它的代码中完全没有输入元素之间的比较操作</p>
</li>
<li><p>计数排序的一个重要性质就是它是<strong>稳定的</strong>，具有相同值的元素在输出数组中的相对次序与它们在输入数组中的相对次序相同</p>
</li>
</ul>
<hr>
<h3 id="8-3-基数排序"><a href="#8-3-基数排序" class="headerlink" title="8.3 基数排序"></a>8.3 基数排序</h3><h4 id="8-3-1-简介"><a href="#8-3-1-简介" class="headerlink" title="8.3.1 简介"></a>8.3.1 简介</h4><ul>
<li><p><strong>基数排序</strong>是一种曾经用在卡片排序机上的算法</p>
</li>
<li><p>基数排序的基本思想是将整数按位数切割成不同的数字，然后按每个位数分别排序</p>
</li>
<li><p>例如<br>  <img src="/2020/02/01/算法导论-8-线性时间排序/基数排序举例.PNG" alt=""></p>
<h4 id="8-3-2-代码及解读"><a href="#8-3-2-代码及解读" class="headerlink" title="8.3.2 代码及解读"></a>8.3.2 代码及解读</h4></li>
<li><p>伪代码如下<br>  <img src="/2020/02/01/算法导论-8-线性时间排序/基数排序伪代码.PNG" alt=""></p>
</li>
<li><p>解读</p>
<ol>
<li>对每一位分别运行一个”位数”排序算法</li>
<li>为了确保基数排序的正确性，”位数”排序算法必须是稳定的</li>
</ol>
</li>
<li><p>代码实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_digit_val</span><span class="params">(num, digit)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> int(num % pow(<span class="number">10</span>, digit) / pow(<span class="number">10</span>, digit - <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">counting_sort</span><span class="params">(inputs, digit)</span>:</span></span><br><span class="line">     temp = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>)]</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> num <span class="keyword">in</span> inputs:</span><br><span class="line">         digit_val = get_digit_val(num, digit)</span><br><span class="line">         temp[digit_val] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">     temp[<span class="number">0</span>] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">         temp[i] += temp[i - <span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">     outputs = [<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, len(inputs))]</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> range(len(inputs) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">         digit_val = get_digit_val(inputs[i], digit)</span><br><span class="line">         outputs[temp[digit_val]] = inputs[i]</span><br><span class="line">         temp[digit_val] -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(arr, digits)</span>:</span></span><br><span class="line">     <span class="keyword">for</span> digit <span class="keyword">in</span> range(<span class="number">1</span>, digits + <span class="number">1</span>):</span><br><span class="line">         arr = counting_sort(arr, digits)</span><br><span class="line">     <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">     o = radix_sort([<span class="number">12</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">50</span>, <span class="number">72</span>, <span class="number">33</span>, <span class="number">90</span>, <span class="number">13</span>], <span class="number">2</span>)</span><br><span class="line">     print(o)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-3-3-时间代价"><a href="#8-3-3-时间代价" class="headerlink" title="8.3.3 时间代价"></a>8.3.3 时间代价</h4><ul>
<li><p>时间复杂度: <code>O(n)</code></p>
</li>
<li><p>当位数<code>d</code>为常数时，基数排序具有线性的时间复杂度</p>
</li>
</ul>
<h4 id="8-3-4-基数排序与基于比较的排序的对比"><a href="#8-3-4-基数排序与基于比较的排序的对比" class="headerlink" title="8.3.4 基数排序与基于比较的排序的对比"></a>8.3.4 基数排序与基于比较的排序的对比</h4><ul>
<li><p>在处理的n个关键字时，尽管基数排序执行的循环轮数会比快速排序要少，但每一轮它所消耗的时间要长的多</p>
</li>
<li><p>此外，利用计数排序作为位数排序算法的基数排序不是原址排序，而很多<code>O(nlgn)</code>的排序算法都是原址排序</p>
</li>
</ul>
<hr>
<h3 id="8-4-桶排序"><a href="#8-4-桶排序" class="headerlink" title="8.4 桶排序"></a>8.4 桶排序</h3><h4 id="8-4-1-简介"><a href="#8-4-1-简介" class="headerlink" title="8.4.1 简介"></a>8.4.1 简介</h4><ul>
<li><p>桶排序简介</p>
<ul>
<li>桶排序假设输入数据服从均匀分布，平均情况下它的时间代价为<code>O(n)</code></li>
</ul>
</li>
<li><p>桶排序所做的假设</p>
<ul>
<li>更确切的说，桶排序假设输入是由一个随机过程产生，该过程将元素均匀、独立地分布在<code>[0, n)</code>的区间上</li>
<li>因为对输入数据进行了某种假设，所以桶排序的速度也很快</li>
</ul>
</li>
<li><p>桶排序的思路</p>
<ul>
<li>桶排序将<code>[0, n)</code>的区间划分为n个相同大小的子区间，或称为桶</li>
<li>然后，将n个输入数分别放到各个桶中</li>
<li>我们先对每个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可</li>
</ul>
</li>
<li><p>桶排序举例<br>  <img src="/2020/02/01/算法导论-8-线性时间排序/桶排序举例.PNG" alt=""></p>
</li>
</ul>
<h4 id="8-3-2-代码及解读-1"><a href="#8-3-2-代码及解读-1" class="headerlink" title="8.3.2 代码及解读"></a>8.3.2 代码及解读</h4><ul>
<li><p>伪代码如下<br>  <img src="/2020/02/01/算法导论-8-线性时间排序/桶排序伪代码.PNG" alt=""></p>
</li>
<li><p>代码实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = math.ceil(max(arr) / len(arr))</span><br><span class="line">    buckets = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">0</span>, n)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> arr:</span><br><span class="line">        index = int(item / n)</span><br><span class="line">        buckets[index].append(item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        bucket.sort()</span><br><span class="line"></span><br><span class="line">    output = []</span><br><span class="line">    <span class="keyword">for</span> bucket <span class="keyword">in</span> buckets:</span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> bucket:</span><br><span class="line">            output.append(item)</span><br><span class="line">    <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    o = bucket_sort([<span class="number">12</span>, <span class="number">5</span>, <span class="number">23</span>, <span class="number">50</span>, <span class="number">72</span>, <span class="number">33</span>, <span class="number">90</span>, <span class="number">13</span>])</span><br><span class="line">    print(o)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="8-3-3-时间代价-1"><a href="#8-3-3-时间代价-1" class="headerlink" title="8.3.3 时间代价"></a>8.3.3 时间代价</h4><ul>
<li><p>时间复杂度: <code>O(n)</code></p>
</li>
<li><p>即使输入数据不服从均匀分布，桶排序也仍然可以线性时间内完成，只要输入数据满足如下性质:所有桶的大小的平方和与总的元素数呈线性相关</p>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-7-快速排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-7-快速排序/" itemprop="url">[算法导论][7][快速排序]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:03:15+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-7-快速排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-7-快速排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-7-章-快速排序"><a href="#第-7-章-快速排序" class="headerlink" title="第 7 章 快速排序"></a>第 7 章 快速排序</h2><ul>
<li><p>快速排序通常是实际排序应用中最好的选择，因为它的平均性能比较好</p>
</li>
<li><p>它的期望时间复杂度是<code>O(nlgn)</code>，而且<code>O(nlgn)</code>中隐含的常数因子非常小</p>
</li>
<li><p>另外，它还能够进行原址排序，甚至在虚存环境中也能很好地工作</p>
</li>
</ul>
<hr>
<h3 id="7-1-快速排序的描述"><a href="#7-1-快速排序的描述" class="headerlink" title="7.1 快速排序的描述"></a>7.1 快速排序的描述</h3><ul>
<li><p>快速排序使用分治思想，下面是快排的三步分治过程</p>
<ol>
<li>分解<ul>
<li>数组<code>A[p..r]</code>被划分为两个子数组<code>A[p..q-1]</code>和<code>A[q+1..r]</code></li>
<li>然后通过调整，使得<code>A[p..q-1]</code>中的每个元素都小于等于<code>A[q]</code></li>
<li>并且使得<code>A[q+1..r]</code>中的每个元素都大于<code>A[q]</code></li>
</ul>
</li>
<li>解决<ul>
<li>通过递归调用快排，对子数组<code>A[p..q-1]</code>和<code>A[q+1..r]</code>进行排序</li>
</ul>
</li>
<li>合并<ul>
<li>因为都是原址排序，所以不需要合并操作</li>
</ul>
</li>
</ol>
</li>
<li><p>代码实现：快速排序</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(arr, p, r)</span>:</span></span><br><span class="line">    <span class="string">"""实现对子数组的原址重排"""</span></span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= arr[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    arr[i + <span class="number">1</span>], arr[r] = arr[r], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = partition(arr, p, r)</span><br><span class="line">        quick_sort(arr, p, q - <span class="number">1</span>)</span><br><span class="line">        quick_sort(arr, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>例子：如图<br><img src="/2020/02/01/算法导论-7-快速排序/QUICKSORTEXP.PNG" alt=""></p>
</li>
<li><p><code>PARTITION</code> 在子数组 <code>A[p..r]</code> 上的时间复杂度为 <code>O(n)</code></p>
</li>
</ul>
<hr>
<h3 id="7-2-快速排序的性能"><a href="#7-2-快速排序的性能" class="headerlink" title="7.2 快速排序的性能"></a>7.2 快速排序的性能</h3><h4 id="7-2-1-简述"><a href="#7-2-1-简述" class="headerlink" title="7.2.1 简述"></a>7.2.1 简述</h4><ul>
<li><p>快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于用于划分的元素</p>
</li>
<li><p>如果划分是平衡的，那么快速排序算法性能与归并排序一样</p>
</li>
<li><p>如果划分是不平衡的，那么快速排序的性能就接近于插入排序</p>
</li>
</ul>
<h4 id="7-2-2-最坏情况划分"><a href="#7-2-2-最坏情况划分" class="headerlink" title="7.2.2 最坏情况划分"></a>7.2.2 最坏情况划分</h4><ul>
<li><p>当划分产生的两个子问题分别包含了 <code>n - 1</code> 个元素和 <code>0</code> 个元素时，快速排序的最坏情况发生了</p>
</li>
<li><p>这种情况下算法运行时间的递归式<br>  <img src="/2020/02/01/算法导论-7-快速排序/最坏时间递归式.PNG" alt=""></p>
</li>
<li><p>最坏情况下时间复杂度为: O(n<sup>2</sup>)</p>
</li>
</ul>
<h4 id="7-2-3-最好情况划分"><a href="#7-2-3-最好情况划分" class="headerlink" title="7.2.3 最好情况划分"></a>7.2.3 最好情况划分</h4><ul>
<li><p>在可能的最平衡的划分中，<code>PARTITION</code> 得到的两个子问题的规模都不大于 <code>n/2</code></p>
</li>
<li><p>这种情况下算法运行时间的递归式<br>  <img src="/2020/02/01/算法导论-7-快速排序/最好时间递归式.PNG" alt=""></p>
</li>
<li><p>最坏情况下时间复杂度为: O(nlgn)</p>
</li>
</ul>
<h4 id="7-2-4-平衡的划分"><a href="#7-2-4-平衡的划分" class="headerlink" title="7.2.4 平衡的划分"></a>7.2.4 平衡的划分</h4><p>`</p>
<ul>
<li><p>快速排序的平均运行时间更接近于其最好情况</p>
</li>
<li><p>原因：任何一种常数比例的划分都会产生深度为O(lgn)的递归树，其中每一层的时间代价都是O(n)。因此，只要划分是常数比例的，算法的运行时间总是O(nlgn)</p>
</li>
</ul>
<hr>
<h3 id="7-3-快速排序的随机化版本"><a href="#7-3-快速排序的随机化版本" class="headerlink" title="7.3 快速排序的随机化版本"></a>7.3 快速排序的随机化版本</h3><ul>
<li><p>背景</p>
<ul>
<li>在讨论快速排序的平均情况性能的时候，我们的前提假设是：输入数据的所有排序都是等概率的</li>
<li>但是在实际工程中，这个假设并不会总是成立</li>
</ul>
</li>
<li><p>解决</p>
<ul>
<li>可以采用一种称为<strong>随机抽样</strong>的随机化技术</li>
<li>与始终采用<code>A[r]</code>作为主元的方法不同，随机抽样从子数组<code>A[p..r]</code>中随机选择一个元素作为主元</li>
<li>为了达到这一目的，首先将<code>A[r]</code>与从<code>A[p..r]</code>中随机选出的一个元素交换</li>
</ul>
</li>
<li><p>示例代码：快速排序的随机化版本</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">random_partition</span><span class="params">(arr, p, r)</span>:</span></span><br><span class="line">    t = random.randint(p, r)</span><br><span class="line">    arr[r], arr[t] = arr[t], arr[r]</span><br><span class="line">    i = p - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(p, r):</span><br><span class="line">        <span class="keyword">if</span> arr[j] &lt;= arr[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            arr[i], arr[j] = arr[j], arr[i]</span><br><span class="line">    arr[i + <span class="number">1</span>], arr[r] = arr[r], arr[i + <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(arr, p, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> p &lt; r:</span><br><span class="line">        q = random_partition(arr, p, r)</span><br><span class="line">        quick_sort(arr, p, q - <span class="number">1</span>)</span><br><span class="line">        quick_sort(arr, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    arr = [<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">16</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">7</span>]</span><br><span class="line">    quick_sort(arr, <span class="number">0</span>, len(arr) - <span class="number">1</span>)</span><br><span class="line">    print(arr)</span><br></pre></td></tr></table></figure>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-6-堆排序/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-6-堆排序/" itemprop="url">[算法导论][6][堆排序]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:00:45+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-6-堆排序/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-6-堆排序/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第六章-堆排序"><a href="#第六章-堆排序" class="headerlink" title="第六章 堆排序"></a>第六章 堆排序</h2><ul>
<li><p>与归并排序相同，堆排序的时间复杂度为O(nlgn)</p>
</li>
<li><p>与插入排序相同，堆排序同样具有空间原址性：任何时候都只需要常数个额外的元素空间存储临时数据</p>
</li>
</ul>
<hr>
<h3 id="6-1-堆"><a href="#6-1-堆" class="headerlink" title="6.1 堆"></a>6.1 堆</h3><ul>
<li><p>堆的简介</p>
<ul>
<li>堆被存储在一个数组中，可近似看成是完全二叉树</li>
<li>除了最底层外，该树是完全充满的，而且是从左到右填充</li>
<li>如图<br><img src="/2020/02/01/算法导论-6-堆排序/堆.PNG" alt=""></li>
</ul>
</li>
<li><p>堆的分类</p>
<ul>
<li>最大堆和最小堆</li>
<li>在这两种堆中，节点的值都要满足堆的性质，但一些细节定义则有所差异</li>
</ul>
</li>
<li><p>最大堆性质</p>
<ul>
<li>在最大堆中，除了根以外的所有结点<code>i</code>都要满足: <code>A[PARENT(i)] &gt;= A[i]</code></li>
<li>因此，堆中的最大元素存放在根节点</li>
</ul>
</li>
<li><p>高度</p>
<ul>
<li>堆中节点的高度：该节点到叶节点最长简单路径上<strong>边</strong>的数目</li>
<li>堆的高度：根节点的高度</li>
</ul>
</li>
<li><p>对于堆的一些基本操作</p>
<ul>
<li>MAX-HEAPIFY过程：其时间复杂度为O(lgn)，它是维护最大堆性质的关键</li>
<li>BUILD-MAX-HEAP过程：具有线性时间复杂度，功能是从无序的输入数据数组中构造一个最大堆</li>
<li>HEAPSORT过程：时间复杂度为O(nlgn)，功能是对一个数组进行原址排序</li>
<li>MAX-HEAP_INSERT、HEAP-EXTRACT-MAX、HEAP-INCREASE-KEY和HEAP-MAXIMUM过程：时间复杂度为O(lgn),功能是实现一个优先队列</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-2-维护堆的性质"><a href="#6-2-维护堆的性质" class="headerlink" title="6.2 维护堆的性质"></a>6.2 维护堆的性质</h3><ul>
<li><p><strong>MAX-HEAPIFY</strong>简介</p>
<ul>
<li>MAX-HEAPIFY用来维护最大堆性质</li>
<li>它的输入是一个数组 <code>A</code> 和一个下标 <code>i</code></li>
<li>我们假定 <code>A[i]</code> 的值有可能小于它的孩子，但是节点 <code>i</code> 的左右子树都是最大堆</li>
<li>MAX-HEAPIFY的目的是让以<code>i</code>节点为根的子树重新遵循最大堆性质</li>
</ul>
</li>
<li><p>伪代码描述<br>  <img src="/2020/02/01/算法导论-6-堆排序/MAXHEAPIFY.PNG" alt=""></p>
</li>
<li><p>代码实现: <code>max_heapify</code> (python实现)</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_heapify</span><span class="params">(i)</span>:</span></span><br><span class="line">    <span class="comment"># print("max_heapify: ", i)</span></span><br><span class="line">    l = left(i)</span><br><span class="line">    r = right(i)</span><br><span class="line">    <span class="keyword">if</span> l &lt;= heap_size <span class="keyword">and</span> arr[l] &gt; arr[i]:</span><br><span class="line">        largest = l</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        largest = i</span><br><span class="line">    <span class="keyword">if</span> r &lt;= heap_size <span class="keyword">and</span> arr[r] &gt; arr[largest]:</span><br><span class="line">        largest = r</span><br><span class="line">    <span class="keyword">if</span> largest != i:</span><br><span class="line">        arr[i], arr[largest] = arr[largest], arr[i]</span><br><span class="line">        max_heapify(largest)</span><br></pre></td></tr></table></figure>
</li>
<li><p>图片描述<br>  <img src="/2020/02/01/算法导论-6-堆排序/MAXHEAPIFYIMG.PNG" alt=""></p>
</li>
<li><p>文字描述</p>
<ol>
<li>在程序的每一步中，从<code>A[i]</code>、<code>A[LEFT(i)]</code>、<code>A[RIGHT(i)]</code>中选出最大的，存储在largest中</li>
<li>如果A[i]是最大的，那么以i为根节点的子树已经是最大堆了，程序结束</li>
<li>否则，最大元素是i的某个孩子节点，则交换<code>A[i]</code>和<code>A[largest]</code>的值</li>
<li>在交换后，需要对该子树递归调用<code>MAX-HEAPIFY</code></li>
</ol>
</li>
<li><p>运行时间分析</p>
<ul>
<li>递归式<br><img src="/2020/02/01/算法导论-6-堆排序/MAXHEAPIFYRECUR.PNG" alt=""></li>
<li>运行时间:T(n) = O(lgn)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-3-建堆"><a href="#6-3-建堆" class="headerlink" title="6.3 建堆"></a>6.3 建堆</h3><ul>
<li><p>思路</p>
<ul>
<li>我们可以用自底向上调用 <code>max_heapify</code>，把一个数组转换为最大堆</li>
<li>因为堆中从 <code>A(n/2 + 1, n)</code> 的元素都是树的叶节点，对于这些节点不需要调用 <code>max_heapify</code> 过程</li>
</ul>
</li>
<li><p>代码实现： <code>build_max_heap</code>(python实现)</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_max_heap</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(int(len_arr() / <span class="number">2</span>), <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        print(i)</span><br><span class="line">        max_heapify(i)</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度 : O(n)，证明见书 <code>P88</code></p>
</li>
<li><p>例子如图<br><img src="/2020/02/01/算法导论-6-堆排序/BUILDMAXHEAPDEMO.PNG" alt=""></p>
</li>
</ul>
<h3 id="6-4-堆排序算法"><a href="#6-4-堆排序算法" class="headerlink" title="6.4 堆排序算法"></a>6.4 堆排序算法</h3><ul>
<li><p>思路 </p>
<ol>
<li>首先，利用<code>build_max_heap</code>将输入数组建成最大堆</li>
<li>因为根节点保存的是最大元素，所以将根节点与<code>A[n]</code>互换</li>
<li>从堆中去掉节点n(通过减小heap_size的方式)</li>
<li>调用<code>max_heapify</code>保持堆的性质</li>
<li>重复执行步骤2，3，4，直到堆的大小降为<code>1</code></li>
</ol>
</li>
<li><p>代码实现: <code>heap_sort</code>(Python实现)</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">global</span> heap_size</span><br><span class="line">build_max_heap()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len_arr(), <span class="number">1</span>, <span class="number">-1</span>):</span><br><span class="line">    arr[i], arr[<span class="number">1</span>] = arr[<span class="number">1</span>], arr[i]</span><br><span class="line">    heap_size -= <span class="number">1</span></span><br><span class="line">    max_heapify(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>时间复杂度</p>
<ul>
<li>O(nlgn)</li>
<li>因为每次调用<code>build_max_heap</code>的时间复杂度为O(n)，而n-1次调用MAX-HEAPIFY，每次时间为O(lgn)</li>
</ul>
</li>
<li><p>例子如图<br><img src="/2020/02/01/算法导论-6-堆排序/HEAPSORTDEMO.PNG" alt=""></p>
</li>
</ul>
<h3 id="6-5-优先队列"><a href="#6-5-优先队列" class="headerlink" title="6.5 优先队列"></a>6.5 优先队列</h3><h4 id="6-5-1-优先队列的性质"><a href="#6-5-1-优先队列的性质" class="headerlink" title="6.5.1 优先队列的性质"></a>6.5.1 优先队列的性质</h4><ul>
<li><p>简介</p>
<ul>
<li>优先队列是一种维护由一组元素构成的集合S的数据结构</li>
<li>其中的每个元素都有一个相关的值，称为关键字(key)</li>
</ul>
</li>
<li><p>最大优先队列支持的操作</p>
<ul>
<li><code>insert(S, x)</code> : 把元素 <code>x</code> 插入到集合 <code>S</code> 中</li>
<li><code>maximum(S)</code> : 返回S中具有最大键字的元素</li>
<li><code>extract_max(S)</code> : 去掉并返回S中的具有最大键字的元素</li>
<li><code>increase_key(S, x, k)</code> : 把元素<code>x</code>的关键字值增加到<code>k</code>，这里假设<code>k</code>的值不小于<code>x</code>的关键字值</li>
</ul>
</li>
</ul>
<h4 id="6-5-2-通过堆来实现优先队列"><a href="#6-5-2-通过堆来实现优先队列" class="headerlink" title="6.5.2 通过堆来实现优先队列"></a>6.5.2 通过堆来实现优先队列</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/算法导论-5-概率分析和随机算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/算法导论-5-概率分析和随机算法/" itemprop="url">[算法导论][5][概率分析和随机算法]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:59:47+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/算法导论/" itemprop="url" rel="index">
                    <span itemprop="name">算法导论</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/算法导论-5-概率分析和随机算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/算法导论-5-概率分析和随机算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="5-1-雇用问题"><a href="#5-1-雇用问题" class="headerlink" title="5.1 雇用问题"></a>5.1 雇用问题</h3><h4 id="5-1-1-问题描述"><a href="#5-1-1-问题描述" class="headerlink" title="5.1.1 问题描述"></a>5.1.1 问题描述</h4><ul>
<li>问题<ul>
<li>假如你要找一个雇佣代理，帮你雇佣一个办公助理</li>
<li>雇佣代理每天给你推荐一个应聘者。你面试这个人，然后决定是否雇佣他。</li>
<li>你必须付给雇佣代理一小笔费用，以便面试应聘者。然而要真的雇佣一个应聘者需要花更多的钱，因为你必须辞掉目前的办公助理，还要付一大笔中介费给雇佣代理</li>
<li>你承诺任何时候都要找最适合的人来担任这项职务，因此，你决定在面试完每个应聘者后，如果该应聘者比当前的办公助理更合适，就会辞掉当前的办公助理，然后聘用新的</li>
</ul>
</li>
</ul>
<ul>
<li><p>伪代码</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HIRE-ASSISTANT(n)</span><br><span class="line">best = 0</span><br><span class="line">for i = 1 to n</span><br><span class="line">    interview candidate i</span><br><span class="line">    if candidate i is better than candidate best</span><br><span class="line">        best = i</span><br><span class="line">        hire condidate i</span><br></pre></td></tr></table></figure>
</li>
<li><p>每次雇佣员工都会产生一笔费用，我们的任务是估算该费用会是多少</p>
</li>
</ul>
<h4 id="5-1-2-最坏情形分析"><a href="#5-1-2-最坏情形分析" class="headerlink" title="5.1.2 最坏情形分析"></a>5.1.2 最坏情形分析</h4><ul>
<li>在最坏的情况下，我们实际上雇佣了每个面试的应聘者，总的费用是O(c<sub>h</sub>n)</li>
</ul>
<h4 id="5-1-3-概率分析"><a href="#5-1-3-概率分析" class="headerlink" title="5.1.3 概率分析"></a>5.1.3 概率分析</h4><ul>
<li><p>大多数情况下我们采用概率分析来分析一个算法的平均运行时间</p>
</li>
<li><p>为了进行概率分析，我们必须使用或者假设关于输入的分布。分析该算法，计算出一个平均情形下的运行时间，其中我们对所有可能的输入分布取平均值</p>
</li>
</ul>
<h4 id="5-1-4-随机算法"><a href="#5-1-4-随机算法" class="headerlink" title="5.1.4 随机算法"></a>5.1.4 随机算法</h4><ul>
<li><p>当一个算法的行为不仅由输入决定，而且也由随机数生成器产生的数值决定，则称这个算法是随机的</p>
</li>
<li><p>当分析一个随机算法的运行时间时，我们以运行时间的期望值衡量，我们将一个随机算法的运行时间称为<strong>期望运行时间</strong></p>
</li>
<li><p>一般而言，当概率分布是在算法的输入上时，我们讨论的是平均运行时间；当算法本身做出随机选择时，我们讨论其期望运行时间</p>
</li>
</ul>
<hr>
<h3 id="5-2-指示器随机变量"><a href="#5-2-指示器随机变量" class="headerlink" title="5.2 指示器随机变量"></a>5.2 指示器随机变量</h3><ul>
<li><p>指示器随机变量</p>
<ul>
<li>它为概率与期望之间的转换提供了一个便利的方法</li>
<li>定义<ul>
<li>给定一个样本空间S和一个事件A，那么事件A对应的指示器随机变量I{A}定义为  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I(A) = 1 如果A发生</span><br><span class="line">I(A) = 0 如果A不发生</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>定理</p>
<ul>
<li>E[IA] = P(A)</li>
</ul>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-10-序列的修改、散列和切片/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-10-序列的修改、散列和切片/" itemprop="url">[流畅的Python][9][序列的修改、散列和切片]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:49:56+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-10-序列的修改、散列和切片/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-10-序列的修改、散列和切片/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第10章-序列的修改、散列和切片"><a href="#第10章-序列的修改、散列和切片" class="headerlink" title="第10章 序列的修改、散列和切片"></a>第10章 序列的修改、散列和切片</h2><blockquote>
<p>不要检查它是不是鸭子，它的叫声像不像鸭子、它的走路姿势像不像鸭子，等等。具体检查什么取决于你想使用语言的哪些行为</p>
</blockquote>
<ul>
<li>在大量代码之间，我们将穿插讨论一个概念：把协议当作正式接口。我们将说明协议与鸭子类型之间的关系，以及对自定义类型的实际影响</li>
</ul>
<h3 id="10-1-Vector类：用户定义的序列类型"><a href="#10-1-Vector类：用户定义的序列类型" class="headerlink" title="10.1 Vector类：用户定义的序列类型"></a>10.1 Vector类：用户定义的序列类型</h3><ul>
<li><p>我们将使用组合模式实现<code>Vector</code>类，而不使用继承</p>
</li>
<li><p>向量的分量存储在浮点数数组中，而且还将实现不可变扁平序列所需的方法</p>
</li>
</ul>
<hr>
<h3 id="10-2-Vector类第1版：与Vector2d类兼容"><a href="#10-2-Vector类第1版：与Vector2d类兼容" class="headerlink" title="10.2 Vector类第1版：与Vector2d类兼容"></a>10.2 Vector类第1版：与Vector2d类兼容</h3><ul>
<li><p>示例：第 1 版 <code>Vector</code> 类的实现代码</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> reprlib</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># self._components是“受保护的”实例属性，把Vector的分量保存在一个数组中</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, components)</span>:</span></span><br><span class="line">        self._components = array(self.typecode, components)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了迭代，我们使用self._components构建一个迭代器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> iter(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 使用reprlib.repr()函数获取self._components的有限长度表示形式(如array('d', [0.0, 1.0, 2.0, 3.0, ...]))</span></span><br><span class="line">        components = reprlib.repr(self._components)</span><br><span class="line">        <span class="comment"># 把字符串插入Vector的构造方法调用之前，去掉前面的 array('d' 和后面的 )</span></span><br><span class="line">        components = components[components.find(<span class="string">'('</span>):<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Vector(&#123;&#125;)'</span>.format(components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 直接使用self._components构建bytes对象</span></span><br><span class="line">        <span class="keyword">return</span> bytes([ord(self.typecode)]) + bytes(self._components)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 先计算各分量的平方之和，然后再使用sqrt方法开平方</span></span><br><span class="line">        <span class="keyword">return</span> math.sqrt(sum(x * x <span class="keyword">for</span> x <span class="keyword">in</span> self))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">        typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">        memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">        <span class="keyword">return</span> cls(memv)</span><br></pre></td></tr></table></figure>
</li>
<li><p>对 <code>repr()</code>函数的理解</p>
<ul>
<li>调用<code>repr()</code>函数的目的是调试，因此绝对不能抛出异常</li>
<li>如果<code>__repr__</code>方法的实现有问题，那么必须处理，尽量输出有用的内容，让用户能够识别目标对象</li>
</ul>
</li>
<li><p>使用<code>reprlib.repr()</code>的方式</p>
<ul>
<li>这个函数用于生成大型结构或递归结构的安全表示形式</li>
<li>它会限制输出字符串的长度，用’…’表示截断的部分</li>
</ul>
</li>
<li><p>示例：测试 <code>Vector.__init__</code> 和 <code>Vector.__repr__</code></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">3.1</span>, <span class="number">4.2</span>])</span><br><span class="line">Vector([<span class="number">3.1</span>, <span class="number">4.2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">Vector([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector(range(<span class="number">10</span>))</span><br><span class="line">Vector([<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>, ...])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="10-3-协议和鸭子类型"><a href="#10-3-协议和鸭子类型" class="headerlink" title="10.3 协议和鸭子类型"></a>10.3 协议和鸭子类型</h3><ul>
<li>协议<ul>
<li>在Python中创建功能完善的序列类型无需使用<strong>继承</strong>，只需<strong>实现符合序列协议的方法</strong></li>
<li>在面向对象编程中，<strong>协议</strong>是非正式的<strong>接口</strong>，只在文档中定义，在代码中不定义</li>
<li>例如，Python的序列协议只需要 <code>__len__</code> 和 <code>__getitem__</code>两个方法。任何类，只要使用标准的签名和语义实现了这两个方法，就能用在任何期待序列的地方</li>
</ul>
</li>
</ul>
<ul>
<li><p>鸭子类型</p>
<ul>
<li>不要检查它是不是鸭子，它的叫声像不像鸭子、它的走路姿势像不像鸭子，等等。具体检查什么取决于你想使用语言的哪些行为</li>
<li>我们说它是序列，因为它的行为像序列，这才是重点</li>
</ul>
</li>
<li><p>另外</p>
<ul>
<li>协议是非正式的，没有强制力。因此如果你知道类的具体使用场景，通常只需要实现一个协议的部分</li>
<li>例如，为了支持迭代，只需要实现 <code>__getitem__</code> 方法，没必要提供 <code>__len__</code> 方法</li>
</ul>
</li>
</ul>
<hr>
<h3 id="10-4-Vector类第2版：可切片的序列"><a href="#10-4-Vector类第2版：可切片的序列" class="headerlink" title="10.4 Vector类第2版：可切片的序列"></a>10.4 Vector类第2版：可切片的序列</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-9-符合Python风格的对象/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-9-符合Python风格的对象/" itemprop="url">[流畅的Python][9][符合Python风格的对象]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:46:31+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-9-符合Python风格的对象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-9-符合Python风格的对象/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第9章-符合Python风格的对象"><a href="#第9章-符合Python风格的对象" class="headerlink" title="第9章 符合Python风格的对象"></a>第9章 符合Python风格的对象</h2><blockquote>
<p>绝对不要使用两个前导下划线，这是很烦人的自私行为—Ian Bicking</p>
</blockquote>
<ul>
<li><p>得益于Python数据模型，自定义类型的行为可以像内置类型那样自然</p>
</li>
<li><p>实现如此自然的行为，靠的不是继承，而是鸭子类型：我们只需按照行为实现对象所需的方法即可</p>
</li>
</ul>
<hr>
<h3 id="9-1-对象的表示形式"><a href="#9-1-对象的表示形式" class="headerlink" title="9.1 对象的表示形式"></a>9.1 对象的表示形式</h3><ul>
<li><p>Python提供两种<strong>获取对象的字符串表示形式</strong>的标准方法</p>
<ul>
<li><code>repr()</code>:以便于开发者理解的方式返回对象的字符串表示形式</li>
<li><code>str()</code>:以便于用户理解的方式返回对象的字符串表示形式</li>
<li>我们可以通过实现<code>__repr__</code>和<code>__str__</code>特殊方法，为<code>repr()</code>和<code>str()</code>提供支持</li>
</ul>
</li>
<li><p>Python还为对象提供了其他的表示形式</p>
<ul>
<li><code>bytes()</code>函数调用对象的<code>__byte__</code>方法来获取对象的字节序列表示形式</li>
<li><code>format</code>函数调用对象的<code>__format__</code>，使用特殊的格式代码显示对象的字符串表示形式</li>
</ul>
</li>
<li><p>注意</p>
<ul>
<li>在 Python 3 中,<code>__repr__</code>、<code>__str__</code> 和 <code>__format__</code> 都必须返回 Unicode 字符串(<code>str</code> 类型)</li>
<li>只有 <code>__bytes__</code> 方法应该返回字节序列(<code>bytes</code> 类型)</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-2-再谈向量类"><a href="#9-2-再谈向量类" class="headerlink" title="9.2 再谈向量类"></a>9.2 再谈向量类</h3><ul>
<li><p>为了说明用于生成对象表示形式的众多方法,我们将使用一个 <code>Vector2d</code> 类</p>
</li>
<li><p>我们期望 Vector2d 实例具有的基本行为如下所示</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># Vector2d 实例的分量可以直接通过属性访问(无需调用读值方法)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1.x, v1.y) </span><br><span class="line"><span class="number">3.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="comment"># Vector2d 实例可以拆包成变量元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y = v1 </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="comment"># repr 函数调用 Vector2d 实例,得到的结果类似于构建实例的源码</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 </span><br><span class="line">Vector2d(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="comment"># 这里使用 eval 函数,表明 repr 函数调用 Vector2d 实例得到的是对构造方法的准确表述</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1_clone = eval(repr(v1)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 == v1_clone </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># print 函数会调用 str 函数,对 Vector2d 来说,输出的是一个有序对</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(v1) </span><br><span class="line">(<span class="number">3.0</span>, <span class="number">4.0</span>)</span><br><span class="line"><span class="comment"># bytes 函数会调用 __bytes__ 方法,生成实例的二进制表示形式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = bytes(v1) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets</span><br><span class="line"><span class="string">b'd\\x00\\x00\\x00\\x00\\x00\\x00\\x08@\\x00\\x00\\x00\\x00\\x00\\x00\\x10@'</span></span><br><span class="line"><span class="comment"># abs 函数会调用 __abs__ 方法,返回 Vector2d 实例的模</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(v1) </span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="comment"># bool 函数会调用 __bool__ 方法,如果 Vector2d 实例的模为零,返回 False,否则返回 True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bool(v1), bool(Vector2d(<span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line"><span class="keyword">True</span>, <span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们对vector2d类的实现如下所示，现在,Vector2d 用到了几个特殊方法,这些方法提供的操作是 Python 高手期待设计良好的对象所提供的</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> array <span class="keyword">import</span> array</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># typecode 是类属性,在 Vector2d 实例和字节序列之间转换时使用</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 在 __init__ 方法中把 x 和 y 转换成浮点数,尽早捕获错误,以防调用 Vector2d 函数时传入不当参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = float(x)</span><br><span class="line">        self.y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义 __iter__ 方法,把 Vector2d 实例变成可迭代的对象,这样才能拆包(例如,x, y = my_vector)。这个方法的实现方式很简单,直接调用生成器表达式一个接一个产出分量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __repr__ 方法使用 &#123;!r&#125; 获取各个分量的表示形式,然后插值,构成一个字符串;因为 Vector2d 实例是可迭代的对象,所以 *self 会把 x 和 y 分量提供给 format 函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        class_name = type(self).__name__</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&#123;&#125;(&#123;!r&#125;, &#123;!r&#125;)'</span>.format(class_name, *self)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从可迭代的 Vector2d 实例中可以轻松地得到一个元组,显示为一个有序对</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(tuple(self))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了生成字节序列,我们把 typecode 转换成字节序列,然后迭代 Vector2d 实例,得到一个数组,再把数组转换成字节序列</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bytes__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bytes([ord(self.typecode)]) + bytes(array(self.typecode, self))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为了快速比较所有分量,在操作数中构建元组</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> tuple(self) == tuple(other)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 模是 x 和 y 分量构成的直角三角形的斜边长</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__abs__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> math.hypot(self.x, self.y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># __bool__ 方法使用 abs(self) 计算模,然后把结果转换成布尔值,因此,0.0 是 False,非零值是 True</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bool__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> bool(abs(self))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="9-3-备选构造方法"><a href="#9-3-备选构造方法" class="headerlink" title="9.3 备选构造方法"></a>9.3 备选构造方法</h3><ul>
<li>我们可以把Vector2d实例转换成字节序列；同理，应该能从字节序列转换成Vector2d实例，如下所示  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类方法使用classmethod装饰器修饰</span></span><br><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="comment"># 不用传入self参数；相反，要通过cls传入类本身</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">frombytes</span><span class="params">(cls, octets)</span>:</span></span><br><span class="line">    <span class="comment"># 从第一个字节中读取typecode</span></span><br><span class="line">    typecode = chr(octets[<span class="number">0</span>])</span><br><span class="line">    <span class="comment"># 使用传入的octets字节序列创建一个memoryview，然后使用typecode转换，就是转换成typecode表示的类型</span></span><br><span class="line">    memv = memoryview(octets[<span class="number">1</span>:]).cast(typecode)</span><br><span class="line">    <span class="comment"># 拆包转换后的memoryview，得到构造方法所需的一对参数</span></span><br><span class="line">    <span class="keyword">return</span> cls(*memv)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="9-4-classmethod与staticmethod"><a href="#9-4-classmethod与staticmethod" class="headerlink" title="9.4 classmethod与staticmethod"></a>9.4 classmethod与staticmethod</h3><h4 id="9-4-1-classmethod"><a href="#9-4-1-classmethod" class="headerlink" title="9.4.1 classmethod"></a>9.4.1 classmethod</h4><ul>
<li><p>用来定义操作类(而不是操作实例)的方法</p>
</li>
<li><p>classmethod改变了调用方法的方式，因此类方法的第一个参数是类本身，而不是实例</p>
</li>
<li><p>classmethod最常用的用途是定义备选构造方法，如上一节所示</p>
</li>
<li><p>按照约定，类方法的第一个参数名为cls(但是Python不介意具体怎么命名)</p>
</li>
</ul>
<h4 id="9-4-2-staticmethod"><a href="#9-4-2-staticmethod" class="headerlink" title="9.4.2 staticmethod"></a>9.4.2 staticmethod</h4><ul>
<li><p>staticmethod装饰器也会改变方法的调用方式，但是第一个参数不是特殊的值</p>
</li>
<li><p>其实静态方法就是普通的函数，只是碰巧在类的定义体中，而不是在模块层定义</p>
</li>
<li><p>staticmethod不是特别有用</p>
<ul>
<li>如果想定义不需要与类交互的函数,那么在模块中定义就好了</li>
<li>有时,函数虽然从不处理类,但是函数的功能与类紧密相关,因此想把它放在近处</li>
<li>即便如此,在同一模块中的类前面或后面定义函数也就行了</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-5-格式化显示"><a href="#9-5-格式化显示" class="headerlink" title="9.5 格式化显示"></a>9.5 格式化显示</h3><ul>
<li><p>内置的<code>format()</code>函数和<code>str.format()</code>方法把各个类型的格式化方法委托给相应的<code>.__format__(format_spec)</code>方法</p>
</li>
<li><p><code>format_spec</code>是格式说明符，它是:</p>
<ul>
<li><code>format(my_obj, format_spec)</code>的第二个参数</li>
<li><code>str.format()</code>方法的格式字符串,{}里代换字段中冒号后面的部分</li>
</ul>
</li>
<li><p>示例:<code>format</code>和<code>str.format</code>的使用方法</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl = <span class="number">1</span>/<span class="number">2.43</span> <span class="comment"># BRL到USD的货币兑换比价</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>brl</span><br><span class="line"><span class="number">0.4115226337448559</span></span><br><span class="line"><span class="comment"># 格式说明符是 '0.4f'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(brl, <span class="string">'0.4f'</span>) </span><br><span class="line"><span class="string">'0.4115'</span></span><br><span class="line"><span class="comment"># 格式说明符是 '0.2f'。代换字段中的 'rate' 子串是字段名称,与格式说明符无关,但是它决定把 .format() 的哪个参数传给代换字段</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'1 BRL = &#123;rate:0.2f&#125; USD'</span>.format(rate=brl)</span><br><span class="line"><span class="string">'1 BRL = 0.41 USD'</span></span><br></pre></td></tr></table></figure>
<p>  ‘{0.mass:5.3e}’ 这样的格式字符串其实包含两部分,冒号左边的 ‘0.mass’ 在代换字段句法中是字段名,冒号后面的 ‘5.3e’ 是格式说明符</p>
</li>
<li><p>格式规范微语言为一些内置类型提供了专用的表示代码</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">42</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="string">'101010'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>format(<span class="number">2</span>/<span class="number">3</span>, <span class="string">'.1%'</span>)</span><br><span class="line"><span class="string">'66.7%'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(format(<span class="number">2</span>/<span class="number">3</span>, <span class="string">'.1%'</span>))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>格式规范微语言是可扩展的，因为各个类可以自行决定如何解释<code>format_spec</code>参数</p>
</li>
<li><p>相关文献：<a href="https://docs.python.org/3/library/string.html#formatspec" target="_blank" rel="noopener">“Format Specification Mini-<br>Language”</a></p>
</li>
</ul>
<hr>
<h3 id="9-6-可散列的Vector2d"><a href="#9-6-可散列的Vector2d" class="headerlink" title="9.6 可散列的Vector2d"></a>9.6 可散列的Vector2d</h3><ul>
<li><p>为了把Vector2d实例变成可散列的</p>
<ul>
<li>必须使用<code>__hash__</code>方法和<code>__eq__</code>方法</li>
<li>此外，还要让向量是不可变的，我们可以把x和y分量设置为只读特性，这样向量就不可变了</li>
</ul>
</li>
<li><p>实例9-7:让向量不可变</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    typecode = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        <span class="comment"># 使用两个前导下划线，把属性设为私有的</span></span><br><span class="line">        self.__x = float(x)</span><br><span class="line">        self.__y = float(y)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># property装饰器把读值方法标记为特性</span></span><br><span class="line">    <span class="comment"># 读值方法与公开属性同名，都是x</span></span><br><span class="line"><span class="meta">    @ property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">x</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line"><span class="meta">    @ property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">y</span><span class="params">(self)</span></span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">self</span>.<span class="title">__y</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    # 这里使用<span class="title">self</span>.<span class="title">x</span>而不是<span class="title">self</span>.<span class="title">__x</span>是为了保持访问一致性</span></span><br><span class="line"><span class="function">    <span class="title">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (i <span class="keyword">for</span> i <span class="keyword">in</span> (self.x, self.y))</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面我们只要实现<code>__hash__</code>方法即可，这个方法返回一个整数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__hash__</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="comment"># 我们使用运算符异或(^)混合各分量的散列值，我觉得这种方法有一些问题,hash值会重复</span></span><br><span class="line">    <span class="keyword">return</span> hash(self.x) ^ hash(self.y)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果定义的类型有标量数值，可能还要实现<code>__int__</code>和<code>__float__</code>方法(分别被<code>int()</code>和<code>float()</code>构造函数调用)，以便在某些情况下进行强制类型转换</p>
</li>
</ul>
<h3 id="9-7-Python的私有属性和”受保护的”属性"><a href="#9-7-Python的私有属性和”受保护的”属性" class="headerlink" title="9.7 Python的私有属性和”受保护的”属性"></a>9.7 Python的私有属性和”受保护的”属性</h3><ul>
<li><p>Python不能像Java那样使用private修饰符创建私有属性，但是Python有个简单的机制，能避免子类意外覆盖”私有属性”</p>
</li>
<li><p><strong>名称改写—用来避免子类意外覆盖”私有属性”</strong></p>
<ul>
<li>举个例子：<ul>
<li>有人编写了一个名为 Dog 的类， 这个类的内部用到了 mood实例属性， 但是没有将其开放</li>
<li>现在， 你创建了 Dog 类的子类： Beagle</li>
<li>如果你<strong>在毫不知情的情况下又创建了名为 mood 的实例属性</strong>， 那么在继承的方法中就<strong>会把 Dog 类的 mood 属性覆盖掉</strong>。 这是个难以调试的问题。</li>
</ul>
</li>
<li>解决方法<ul>
<li>如果以 <code>__mood</code> 的形式（两个前导下划线， 尾部没有或最多有一个下划线） 命名实例属性， Python 会把属性名存入实例的 <code>__dict__</code> 属性中， 而且会在前面加上一个下划线和类名。 </li>
<li>因此， 对Dog 类来说， <code>__mood</code> 会变成 <code>_Dog__mood</code>； 对 Beagle 类来说， 会变成<code>_Beagle__mood</code>。 这个语言特性叫<strong>名称改写（name mangling）</strong></li>
</ul>
</li>
<li>注意：<ul>
<li>名称改写是一种安全措施，不能保证万无一失，它的目的是避免意外访问</li>
<li>如下图<br><img src="/2020/02/01/流畅的Python-9-符合Python风格的对象/把手上的盖子.png" alt=""></li>
<li>只要知道改写私有属性名的机制，任何人都能直接读取和修改私有属性  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.__dict__</span><br><span class="line">&#123;<span class="string">'_Vector2d__y'</span>: <span class="number">4.0</span>, <span class="string">'_Vector2d_x'</span>: <span class="number">3.0</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d_x</span><br><span class="line"><span class="number">3.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1._Vector2d_x = <span class="number">7</span></span><br><span class="line"><span class="number">7.0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>约定俗成的”受保护”属性</strong></p>
<ul>
<li>不是所有 Python 程序员都喜欢名称改写功能， 也不是所有人都喜欢self.__x 这种不对称的名称。</li>
<li>有些人不喜欢这种句法， 他们约定使用一个下划线前缀编写“受保护”的属性（如 self._x）</li>
<li>Python 解释器不会对使用单个下划线的属性名做特殊处理， 不过这是很多 Python 程序员严格遵守的约定， 他们不会在类外部访问这种属性</li>
<li>遵守使用一个下划线标记对象的私有属性很容易，就像遵守使用全大写字母编写常量那样容易</li>
</ul>
</li>
</ul>
<hr>
<h3 id="9-8-使用slot属性节省空间"><a href="#9-8-使用slot属性节省空间" class="headerlink" title="9.8 使用slot属性节省空间"></a>9.8 使用<strong>slot</strong>属性节省空间</h3><ul>
<li><p>背景</p>
<ul>
<li>默认情况下，Python在各个实例中名为<code>__dict__</code>的字典里存储实例属性</li>
<li>然后为了使用底层的散列表提升访问速度，字典会消耗大量内存(散列表一般装不满，所以会浪费内存)</li>
<li>如果要处理<strong>数百万个属性不多</strong>的实例，通过<code>__slots__</code>类属性，能节省大量内存</li>
</ul>
</li>
<li><p>如何使用<code>__slot__</code>属性</p>
<ul>
<li><p>定义 <code>__slots__</code> 的方式是， 创建一个类属性， 使用 <code>__slots__</code> 这个名字， 并把它的值设为一个字符串构成的可迭代对象， 其中各个元素表示各个实例属性,如下所示</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vector2d</span>:</span></span><br><span class="line">    __slots__ = (<span class="string">'__x'</span>, <span class="string">'__y'</span>)</span><br><span class="line">    typecode = <span class="string">'d'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在类中定义 <code>__slots__</code> 属性的目的是告诉解释器： “这个类中的所有实例属性都在这儿了！ ”这样， Python 会在各个实例中使用类似元组的结构存储实例变量， 从而避免使用消耗内存的 <code>__dict__</code> 属性</p>
</li>
</ul>
</li>
<li><p>注意</p>
<ol>
<li>继承自超类的<code>__slots__</code>属性没有效果，Python只会使用各个类中定义的<code>__slots__</code>属性</li>
<li>在类中定义<code>__slots__</code>属性之后，实例不能再有<code>__slots__</code>中所列出名称之外的其他属性</li>
<li>如果类中定义了 <code>__slots__</code> 属性， 而且想把实例作为弱引用的目标， 那么要把 <code>__weakref__</code> 添加到 <code>__slots__</code> 中</li>
</ol>
</li>
</ul>
<hr>
<h3 id="9-9-覆盖类属性"><a href="#9-9-覆盖类属性" class="headerlink" title="9.9 覆盖类属性"></a>9.9 覆盖类属性</h3><ul>
<li><p>背景</p>
<ul>
<li>Python 有个很独特的特性： <strong>类属性可用于为实例属性提供默认值</strong> </li>
<li><code>Vector2d</code> 中有个 <code>typecode</code> 类属性， <code>__bytes__</code> 方法两次用到了它， 而且都故意使用 <code>self.typecode</code> 读取它的值 </li>
<li>因为 <code>Vector2d</code> 实例本身没有 <code>typecode</code> 属性， 所以 <code>self.typecode</code> 默认获取的是<code>Vector2d.typecode</code> 类属性的值</li>
</ul>
</li>
<li><p>可以为各个实例的 <code>typecode</code> 属性定制不同的值</p>
<ul>
<li>如果为不存在的实例属性赋值， 会新建实例属性</li>
<li>假如我们为 <code>typecode</code> 实例属性赋值， 那么同名类属性不受影响,然而，自此之后，实例读取的 <code>self.typecode</code> 是实例属性 <code>typecode</code>， 也就是把同名类属性遮盖了</li>
<li>借助这一特性， 可以为各个实例的 <code>typecode</code> 属性定制不同的值,如下所示  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector2d_v3 <span class="keyword">import</span> Vector2d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1 = Vector2d(<span class="number">1.1</span>, <span class="number">2.2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd = bytes(v1)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpd</span><br><span class="line"><span class="string">b'd\x9a\x99\x99\x99\x99\x99\xf1?\x9a\x99\x99\x99\x99\x99\x01@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpd) </span><br><span class="line"><span class="number">17</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>v1.typecode = <span class="string">'f'</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dumpf = bytes(v1)&gt;&gt;&gt; dumpf</span><br><span class="line"><span class="string">b'f\xcd\xcc\x8c?\xcd\xcc\x0c@'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(dumpf) </span><br><span class="line"><span class="number">9</span>&gt;</span><br><span class="line">&gt;&gt; Vector2d.typecode </span><br><span class="line"><span class="string">'d'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>如果想修改类属性的值，必须直接在类上修改，如下所示</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Vector2d.typecode = <span class="string">'f'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过创建一个只用于定制类的数据属性的子类，也可以修改类属性，并且更符合Python风格</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> vector2d_v3 <span class="keyword">import</span> Vector2d</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">ShortVector2d</span><span class="params">(Vector2d)</span>:</span> </span><br><span class="line"><span class="meta">... </span>typecode = <span class="string">'f'</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sv = ShortVector2d(<span class="number">1</span>/<span class="number">11</span>, <span class="number">1</span>/<span class="number">27</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sv</span><br><span class="line">ShortVector2d(<span class="number">0.09090909090909091</span>, <span class="number">0.037037037037037035</span>)</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="9-10-本章小结"><a href="#9-10-本章小结" class="headerlink" title="9.10 本章小结"></a>9.10 本章小结</h3>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/" itemprop="url">[流畅的Python][8][对象引用、可变性和垃圾回收]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:43:46+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第8章-对象引用、可变性和垃圾回收"><a href="#第8章-对象引用、可变性和垃圾回收" class="headerlink" title="第8章 对象引用、可变性和垃圾回收"></a>第8章 对象引用、可变性和垃圾回收</h2><blockquote>
<p>“你不开心,”白骑士用一种忧虑的声调说,“让我给你唱一首歌安<br>慰你吧……这首歌的曲名叫作 :《黑线鳕的眼睛》。”<br>“哦,那是一首歌的曲名,是吗?”爱丽丝问道,她试着使自己感到<br>有兴趣。<br>“不,你不明白,”白骑士说,看来有些心烦的样子,“那是人家这<br>么叫的曲名。真正的曲名是《老而又老的老头儿》。”(改编自第<br>8 章“这是我自己的发明”)<br>——Lewis Carroll《爱丽丝镜中奇遇记》</p>
</blockquote>
<hr>
<h3 id="8-1-变量不是盒子"><a href="#8-1-变量不是盒子" class="headerlink" title="8.1 变量不是盒子"></a>8.1 变量不是盒子</h3><ul>
<li><p>引子</p>
<ul>
<li>人们经常使用”变量是盒子”这样的比喻，但是这有碍于理解面向对象语言中的引用式变量</li>
<li>Python变量类似于Java中的引用式变量，因此最好把它们理解为<strong>附加在对象上的标注</strong></li>
</ul>
</li>
<li><p>示例 8-1 变量<code>a</code>和<code>b</code>引用同一个列表，而不是那个列表的副本</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a.append(<span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>如图<br>  <img src="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/变量不是盒子.png" alt=""></p>
</li>
<li><p>变量的赋值方式</p>
<ul>
<li>对引用式变量来说，说把变量分配给对象更合理，反过来说就有问题。毕竟，<strong>对象在赋值之前就创建了</strong></li>
<li>为了理解Python中的赋值语句，应该始终先读右边。对象在右边创建或获取，在此之后左边的变量才会绑定到对象上，就像为对象贴上便利贴一样</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-2-标识、相等性和别名"><a href="#8-2-标识、相等性和别名" class="headerlink" title="8.2 标识、相等性和别名"></a>8.2 标识、相等性和别名</h3><ul>
<li><p>别名</p>
<ul>
<li>因为变量不过是标注，所以无法阻止为对象贴上多个标注</li>
<li>贴的多个标注，就是别名</li>
</ul>
</li>
<li><p>示例 </p>
<ul>
<li>背景：Lewis Carroll 是 Charles Lutwidge Dodgson 教授的笔名。Carroll 先生指的就是 Dodgson 教授,二者是同一个人。然而,假如有冒充者(姑且叫他 Alexander Pedachenko 博士)生于 1832年,声称他是 Charles L. Dodgson。这个冒充者的证件可能一样,但 Pedachenko 博士不是Dodgson 教授</li>
<li>如图<br><img src="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/不同的绑定.png" alt=""></li>
<li>代码  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>&#125;</span><br><span class="line"><span class="comment"># lewis 是 charles 的别名</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lewis = charles </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lewis <span class="keyword">is</span> charles</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># is 运算符和 id 函数确认了这一点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(charles), id(lewis) </span><br><span class="line">(<span class="number">4300473992</span>, <span class="number">4300473992</span>)</span><br><span class="line"><span class="comment"># 向 lewis 中添加一个元素相当于向 charles 中添加一个元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lewis[<span class="string">'balance'</span>] = <span class="number">950</span> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charles</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'balance'</span>: <span class="number">950</span>, <span class="string">'born'</span>: <span class="number">1832</span>&#125;</span><br><span class="line"><span class="comment"># alex 指代的对象与赋值给 charles 的对象内容一样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex = &#123;<span class="string">'name'</span>: <span class="string">'Charles L. Dodgson'</span>, <span class="string">'born'</span>: <span class="number">1832</span>, <span class="string">'balance'</span>: <span class="number">950</span>&#125;</span><br><span class="line"><span class="comment"># 比较两个对象,结果相等,这是因为 dict 类的 __eq__ 方法就是这样实现的</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex == charles </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># 但它们是不同的对象。这是 Python 说明标识不同的方式:a is not b</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>alex <span class="keyword">is</span> <span class="keyword">not</span> charles </span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>标识</p>
<ul>
<li>每个对象都有标识、类型和值</li>
<li><strong>对象一旦创建,它的标识绝不会变</strong>;你可以把标识理解为对象在内存中的地址</li>
<li><code>is</code> 运算符比较两个对象的标识</li>
<li><code>id()</code> 函数返回对象标识的整数表示,在CPython中<code>id()</code>返回对象的内存地址</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-2-1-在-和-is-之间选择"><a href="#8-2-1-在-和-is-之间选择" class="headerlink" title="8.2.1 在 == 和 is 之间选择"></a>8.2.1 在 == 和 is 之间选择</h4><ul>
<li><p>简介</p>
<ul>
<li><code>==</code> ： 比较的是两个对象的值(对象中保存的数据)</li>
<li><code>is</code><ul>
<li>比较的是对象的标识</li>
<li>在变量和单例值之间比较时，应该用 <code>is</code>  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span></span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li><p>比较</p>
<ul>
<li><code>is</code> 运算符比 <code>==</code> 速度快,因为它不能重载,所以 Python 不用寻找并调用特殊方法,而是直接比较两个整数 ID</li>
<li>而 <code>a == b</code> 是语法糖,等同于<code>a.__eq__(b)</code></li>
<li>继承自 <code>object</code> 的 <code>__eq__</code> 方法比较两个对象的 ID,结果与 <code>is</code> 一样</li>
<li>但是多数内置类型使用更有意义的方式覆盖了 <code>__eq__</code>方法,会考虑对象属性的值</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-2-2-元组的相对不可变性"><a href="#8-2-2-元组的相对不可变性" class="headerlink" title="8.2.2 元组的相对不可变性"></a>8.2.2 元组的相对不可变性</h4><ul>
<li><p>简介</p>
<ul>
<li>元组与多数 Python 集合(列表、字典、集,等等)一样,保存的是对象的引用</li>
<li>如果引用的元素是可变的,即便元组本身不可变,元素依然可变</li>
<li>也就是说,元组的不可变性其实是指 <code>tuple</code> 数据结构的<strong>物理内容(即保存的引用)</strong>不可变,与<strong>引用的对象无关</strong></li>
</ul>
</li>
<li><p>示例 元组中不可变的是元素的标识，元组的值会随着引用的可变对象的变化而变</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># t1 不可变,但是 t1[-1] 可变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="comment"># 构建元组 t2,它的元素与 t1 一样</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t2 = (<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>])</span><br><span class="line"><span class="comment"># 虽然 t1 和 t2 是不同的对象,但是二者相等——与预期相符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2 </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># 查看 t1[-1] 列表的标识</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>]) </span><br><span class="line"><span class="number">4302515784</span></span><br><span class="line"><span class="comment"># 就地修改 t1[-1] 列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1[<span class="number">-1</span>].append(<span class="number">99</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">99</span>])</span><br><span class="line"><span class="comment"># t1[-1] 的标识没变,只是值变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(t1[<span class="number">-1</span>]) </span><br><span class="line"><span class="number">4302515784</span></span><br><span class="line"><span class="comment"># 现在,t1 和 t2 不相等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t1 == t2 </span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>元组的相对不可变性解释了 2.6.1 节的谜题。这也是<strong>有些元组不可散列</strong>(参见 3.1 节中的“什么是可散列的数据类型”附注栏)的原因</p>
</li>
</ul>
<hr>
<h3 id="8-3-默认做浅复制"><a href="#8-3-默认做浅复制" class="headerlink" title="8.3 默认做浅复制"></a>8.3 默认做浅复制</h3><h4 id="8-3-1-浅复制"><a href="#8-3-1-浅复制" class="headerlink" title="8.3.1 浅复制"></a>8.3.1 浅复制</h4><ul>
<li><p>浅复制</p>
<ul>
<li>只复制最外层容器，副本中的元素是源容器中元素的引用</li>
<li>如果所有元素都是不可变的，那么这样没有什么问题，还能节省内存</li>
<li>但是如果有可变元素，可能导致意想不到的问题</li>
</ul>
</li>
<li><p>示例： 如何进行浅复制</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment"># 使用构造方法进行浅复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = list(l1)</span><br><span class="line"><span class="comment"># 使用[:]进行浅复制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l3 = l1[:]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2</span><br><span class="line">[<span class="number">3</span>, [<span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="comment"># 副本与源列表相等</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 == l1 </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="comment"># 但是二者指代不同的对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 <span class="keyword">is</span> l1 </span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 ： 浅复制导致的问题</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l1 = [<span class="number">3</span>, [<span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>], (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">l2 = list(l1)</span><br><span class="line"><span class="comment"># l2 是 l1 的浅复制副本。此时的状态如下图所示</span></span><br><span class="line">l1.append(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 把 100 追加到 l1 中,对 l2 没有影响</span></span><br><span class="line">l1[<span class="number">1</span>].remove(<span class="number">55</span>)</span><br><span class="line"><span class="comment"># 把内部列表 l1[1] 中的 55 删除。这对 l2 有影响,因为 l2[1] 绑定的列表与 l1[1] 是同一个</span></span><br><span class="line">print(<span class="string">'l1:'</span>, l1)</span><br><span class="line">print(<span class="string">'l2:'</span>, l2)</span><br><span class="line"><span class="comment"># 对可变的对象来说,如 l2[1] 引用的列表,+= 运算符就地修改列表。这次修改在 l1[1] 中也有体现,因为它是 l2[1] 的别名</span></span><br><span class="line">l2[<span class="number">1</span>] += [<span class="number">33</span>, <span class="number">22</span>] </span><br><span class="line"><span class="comment"># 对元组来说,+= 运算符创建一个新元组,然后重新绑定给变量l2[2]</span></span><br><span class="line">l2[<span class="number">2</span>] += (<span class="number">10</span>, <span class="number">11</span>) </span><br><span class="line">print(<span class="string">'l1:'</span>, l1)</span><br><span class="line">print(<span class="string">'l2:'</span>, l2)</span><br></pre></td></tr></table></figure>
<p>  <img src="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/浅复制1.png" alt=""><br>  <img src="/2020/02/01/流畅的Python-8-对象引用、可变性和垃圾回收/浅复制2.png" alt=""></p>
</li>
<li><p>所以，浅复制虽然容易操作，但是有时得到的结果并不是你想要的</p>
</li>
</ul>
<hr>
<h4 id="8-3-2-为任意对象做深复制和浅复制"><a href="#8-3-2-为任意对象做深复制和浅复制" class="headerlink" title="8.3.2 为任意对象做深复制和浅复制"></a>8.3.2 为任意对象做深复制和浅复制</h4><ul>
<li><p>深复制：副本不共享内部对象的引用</p>
</li>
<li><p>copy模块</p>
<ul>
<li>copy 模块提供的 deepcopy 和 copy 函数能为任意对象做深复制和浅复制</li>
</ul>
</li>
<li><p>一般来说,深复制不是件简单的事。如果对象有循环引用,那么这个朴素的算法会进入无限循环。deepcopy 函数会记住已经复制的对象,因此能优雅地处理循环引用</p>
</li>
<li><p>深复制有时可能太深了。例如,对象可能会引用不该复制的外部资源或单例值。我们可以实现特殊方法 <code>__copy__()</code> 和<code>__deepcopy__()</code>,控制 copy 和 deepcopy 的行为</p>
</li>
</ul>
<hr>
<h3 id="8-4-函数的参数作为引用时"><a href="#8-4-函数的参数作为引用时" class="headerlink" title="8.4 函数的参数作为引用时"></a>8.4 函数的参数作为引用时</h3><ul>
<li><p>Python传参的方案</p>
<ul>
<li>Python唯一支持的传参方式是共享传参(call by sharing)</li>
<li>共享传参是指：函数的各个形式参数获得实参中各个引用的副本，也就是说，函数内部的形参是实参的别名</li>
<li>这种方案的结果是，函数可能修改作为参数传入的可变对象，但是无法修改那些对象的标识。也就是说<strong>传入的参数可能会受到函数的影响而改变</strong></li>
</ul>
</li>
<li><p>示例：函数可能会修改接收到的可变对象</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(a, b)</span>:</span></span><br><span class="line"><span class="meta">... </span>    a += b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> a</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(x, y)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 数字x没变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x, y</span><br><span class="line"><span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = [<span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(a, b)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 列表a变了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a, b</span><br><span class="line">([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = (<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>u = (<span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f(t, u)</span><br><span class="line">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># 元组t没变</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t, u</span><br><span class="line">((<span class="number">10</span>, <span class="number">20</span>), (<span class="number">30</span>, <span class="number">40</span>))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="8-4-1-不要使用可变类型作为参数的默认值"><a href="#8-4-1-不要使用可变类型作为参数的默认值" class="headerlink" title="8.4.1 不要使用可变类型作为参数的默认值"></a>8.4.1 不要使用可变类型作为参数的默认值</h4><ul>
<li><p>背景：可选参数可以有默认值,这是 Python 函数定义的一个很棒的特性,这样我们的 API 在进化的同时能保证向后兼容。然而,我们应该避免使用可变的对象作为参数的默认值</p>
</li>
<li><p>示例：幽灵列车，它将说明为什么应该避免使用可变的对象作为参数的默认值</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HautedBus</span>:</span></span><br><span class="line">    <span class="string">"""备受幽灵乘客折磨的校车"""</span></span><br><span class="line">    <span class="comment"># 如果没传入 passengers 参数,使用默认绑定的列表对象,一开始是空列表</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, passengers=[])</span>:</span></span><br><span class="line">        <span class="comment"># 这个赋值语句把 self.passengers 变成 passengers 的别名,而没有传入 passengers 参数时,后者又是默认列表的别名</span></span><br><span class="line">        self.passengers = passengers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 在 self.passengers 上调用 .remove() 和 .append() 方法时,修改的其实是默认列表,它是函数对象的一个属性</span></span><br><span class="line">        self.passengers.append(name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.passengers.remove(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 一开始,bus1 是空的,因此把默认的空列表赋值给self.passengers</span></span><br><span class="line">    bus1 = HautedBus()</span><br><span class="line">    bus1.pick(<span class="string">'peter'</span>)</span><br><span class="line">    <span class="comment"># bus2 一开始也是空的,因此还是赋值默认的列表</span></span><br><span class="line">    <span class="comment"># 但是默认列表不为空!</span></span><br><span class="line">    bus2 = HautedBus()</span><br><span class="line">    bus2.pick(<span class="string">'alice'</span>)</span><br><span class="line">    <span class="comment"># bus1和bus2共享了乘客</span></span><br><span class="line">    print(bus1.passengers)</span><br><span class="line">    print(bus2.passengers)</span><br><span class="line">    print(bus1.passengers <span class="keyword">is</span> bus2.passengers)</span><br><span class="line">    <span class="comment"># 最后发现默认参数实际上是绑定在类的init方法的defaults属性上,作为一个类的属性,它只有一份,不会拷贝</span></span><br><span class="line">    print(bus1.passengers <span class="keyword">is</span> HautedBus.__init__.__defaults__[<span class="number">0</span>])</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释：为什么应该避免使用可变的对象作为参数的默认值</p>
<ul>
<li>默认值在定义函数时计算(通常在加载模块时),因此默认值变成了<strong>函数对象的属性</strong>(上例中是<code>HautedBus</code>类的<code>init</code>方法上的<code>default属性</code>)</li>
<li>因此,如果默认值是可变对象,而且修改了它的值,那么后续的函数调用都会受到影响</li>
<li>其实<code>bus1.passengers</code>和<code>bus2.passengers</code>都是别名,它绑定到<code>HauntedBus.__init__.__defaults__</code>属性的第一个元素上</li>
</ul>
</li>
</ul>
<hr>
<h4 id="8-4-2-防御可变参数"><a href="#8-4-2-防御可变参数" class="headerlink" title="8.4.2 防御可变参数"></a>8.4.2 防御可变参数</h4><ul>
<li><p>简介</p>
<ul>
<li>如果定义的函数接收可变参数，应该谨慎考虑调用者是否期望改变传入的参数</li>
<li>例如，如果函数接收一个字典，而且在处理的过程中要修改它，那么这个副作用要不要体现到函数外部</li>
</ul>
</li>
<li><p>示例：消失的篮球队</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># basketball_team 中有 5 个学生的名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team = [<span class="string">'Sue'</span>, <span class="string">'Tina'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>, <span class="string">'Pat'</span>]</span><br><span class="line"><span class="comment"># 使用这队学生实例化 TwilightBus</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus = TwilightBus(basketball_team)</span><br><span class="line"><span class="comment"># 一个学生从 bus 下车了,接着又有一个学生下车了 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Tina'</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bus.drop(<span class="string">'Pat'</span>)</span><br><span class="line"><span class="comment"># 下车的学生从篮球队中消失了</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>basketball_team </span><br><span class="line">[<span class="string">'Sue'</span>, <span class="string">'Maya'</span>, <span class="string">'Diana'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>TwilightBus 违反了设计接口的最佳实践,即“最少惊讶原则”</li>
<li>学生从校车中下车后,她的名字就从篮球队的名单中消失了</li>
</ul>
</li>
<li><p>解决：</p>
<ul>
<li>除非这个方法确实想修改通过参数传入的对象,否则在类中直接把参数赋值给实例变量之前一定要三思</li>
<li>因为这样会为参数对象创建别名</li>
<li>如果不确定,那就创建副本。这样客户会少些麻烦</li>
</ul>
</li>
</ul>
<hr>
<h3 id="8-5-del和垃圾回收"><a href="#8-5-del和垃圾回收" class="headerlink" title="8.5 del和垃圾回收"></a>8.5 del和垃圾回收</h3><blockquote>
<p>对象绝不会自行销毁；然而，无法得到对象时，可能会被当做垃圾回收</p>
</blockquote>
<ul>
<li><p><code>del</code>简介</p>
<ul>
<li><code>del</code>语句删除名称，而不是对象</li>
<li><code>del</code> 命令可能会导致对象被当作垃圾回收,但是仅当删除的变量保存的是对象的最后一个引用,或者无法得到对象时</li>
</ul>
</li>
<li><p><code>__del__</code>特殊方法</p>
<ul>
<li>有个 <code>__del__</code> 特殊方法,但是它不会销毁实例,不应该在代码中调用</li>
<li>即将销毁实例时,Python 解释器会调用 <code>__del__</code> 方法,给实例最后的机会,释放外部资源</li>
</ul>
</li>
<li><p>垃圾回收算法</p>
<ul>
<li>在 CPython 中,垃圾回收使用的主要算法是引用计数</li>
<li>实际上,每个对象都会统计有多少引用指向自己</li>
<li>当引用计数归零时,对象立即就被销毁:CPython 会在对象上调用 <code>__del__</code> 方法(如果定义了),然后释放分配给对象的内存</li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li><code>del</code>不会删除对象，但是执行<code>del</code>操作后可能导致对象不可获取从而被删除</li>
</ul>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
