<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/6/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/6/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-7-函数装饰器和闭包/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-7-函数装饰器和闭包/" itemprop="url">[流畅的Python][7][函数装饰器和闭包]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:42:08+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-7-函数装饰器和闭包/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-7-函数装饰器和闭包/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第七章-函数装饰器和闭包"><a href="#第七章-函数装饰器和闭包" class="headerlink" title="第七章 函数装饰器和闭包"></a>第七章 函数装饰器和闭包</h2><ul>
<li><p>函数装饰器用于在源码中”标记”函数，以某种方式增强函数的行为</p>
</li>
<li><p><code>nonlocal</code>是新近出现的保留关键字，如果想实现函数装饰器必须了解<code>nonlocal</code></p>
</li>
<li><p>除了在装饰器中有用处之外，闭包还是回调式异步编程和函数式编程风格的基础</p>
</li>
</ul>
<hr>
<h3 id="7-1-装饰器基础知识"><a href="#7-1-装饰器基础知识" class="headerlink" title="7.1 装饰器基础知识"></a>7.1 装饰器基础知识</h3><ul>
<li><p>简介</p>
<ul>
<li>装饰器是可调用的对象，其参数是另一个函数(被装饰的函数)。</li>
<li>装饰器可能会处理被装饰的函数，然后把它返回，或者将其替换成另一个函数或可调用对象</li>
</ul>
</li>
<li><p>严格来说，装饰器就是一种语法糖</p>
<ul>
<li><p>下面两种写法的效果是一样的</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br></pre></td></tr></table></figure>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running target()'</span>)</span><br><span class="line">target = decorate(target)</span><br></pre></td></tr></table></figure>
</li>
<li><p>如上所示装饰器可以像常规的可调用对象那样调用，其参数是另一个函数</p>
</li>
</ul>
</li>
<li><p>示例：装饰器通常把函数替换为另一个函数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">deco</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>            print(<span class="string">'running inner()'</span>)</span><br><span class="line">        <span class="comment"># deco返回inner函数对象</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># 使用deco装饰target</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>@deco</span><br><span class="line"><span class="meta">... </span><span class="function"><span class="keyword">def</span> <span class="title">target</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">'running target()'</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="comment"># 调用被装饰的target实际会运行inner</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target()</span><br><span class="line">running inner()</span><br><span class="line"><span class="comment"># 审查对象，发现target现在是inner的引用</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>target</span><br><span class="line">&lt;function deco.&lt;locals&gt;.inner at <span class="number">0x7f8fc02efb70</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>装饰器的两个特性</p>
<ol>
<li>能把被装饰的函数替换为其他函数</li>
<li>装饰器在加载模块时立即执行</li>
</ol>
</li>
</ul>
<hr>
<h3 id="7-2-Python何时执行装饰器"><a href="#7-2-Python何时执行装饰器" class="headerlink" title="7.2 Python何时执行装饰器"></a>7.2 Python何时执行装饰器</h3><ul>
<li><p>装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时</p>
</li>
<li><p>示例：registration.py模块</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用registry保存被@register装饰的函数引用</span></span><br><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># register的参数是一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register (%s)'</span> % func)</span><br><span class="line">    <span class="comment"># 把func传入registry</span></span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="comment"># 返回func:必须返回函数,这里返回的函数与通过参数传入的一样</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># f1和f2被register装饰</span></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f1()"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f2()"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># f3没有被register装饰</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"running f3()"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># main显示registry,然后调用f1(),f2()和f3()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line">    f1()</span><br><span class="line">    f2()</span><br><span class="line">    f3()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">running register (&lt;function f1 at 0x7f43d476a510&gt;)</span></span><br><span class="line"><span class="string">running register (&lt;function f2 at 0x7f43d476a7b8&gt;)</span></span><br><span class="line"><span class="string">running main()</span></span><br><span class="line"><span class="string">registry -&gt; [&lt;function f1 at 0x7f43d476a510&gt;, &lt;function f2 at 0x7f43d476a7b8&gt;]</span></span><br><span class="line"><span class="string">running f1()</span></span><br><span class="line"><span class="string">running f2()</span></span><br><span class="line"><span class="string">running f3()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>函数装饰器在导入模块时立即执行</li>
<li>而被装饰的函数只在明确调用时执行</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-3-使用装饰器改进策略模式"><a href="#7-3-使用装饰器改进策略模式" class="headerlink" title="7.3 使用装饰器改进策略模式"></a>7.3 使用装饰器改进策略模式</h3><ul>
<li><p>使用注册装饰器可以改进6.1节中的电商促销折扣示例</p>
</li>
<li><p>示例:使用装饰器来实现策略模式</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># promos列表最初是空的</span></span><br><span class="line">promos = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># promotion把promo_func添加到promos列表中,然后原封不动地将其返回</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">promotion</span><span class="params">(promo_func)</span>:</span></span><br><span class="line">    promos.append(promo_func)</span><br><span class="line">    <span class="keyword">return</span> promo_func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 被@promotion装饰的函数都会添加到promos列表中</span></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的顾客提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@promotion</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个方案的优点</p>
<ol>
<li>促销策略函数无需使用特殊的名称(即不用以_promo结尾)</li>
<li><code>@promotion</code>装饰器突出了被装饰函数的作用，还便于临时禁用某个促销策略：只需要把装饰器注释掉</li>
<li>促销折扣策略可以在其他模式中定义，在系统的任何地方都行，只要使用<code>@promotion</code>装饰即可</li>
</ol>
</li>
</ul>
<hr>
<h3 id="7-4-变量作用域规则"><a href="#7-4-变量作用域规则" class="headerlink" title="7.4 变量作用域规则"></a>7.4 变量作用域规则</h3><ul>
<li><p>变量的类型</p>
<ul>
<li>全局变量：直接在模块中定义的变量，即在函数或方法等可调用对象外部定义的变量</li>
<li>局部变量：也称全局变量，在函数或方法等可调用对象外部定义的变量</li>
</ul>
</li>
<li><p>第一个例子：读取一个局部变量和一个全局变量</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># b是一个全局变量</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(a)</span>:</span></span><br><span class="line">        <span class="comment"># a是函数f1内部的变量,是局部变量</span></span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f1(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>第二个例子：一个让人吃惊的例子</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(a)</span>:</span></span><br><span class="line"><span class="meta">... </span>    print(a)</span><br><span class="line"><span class="meta">... </span>    print(b)</span><br><span class="line"><span class="meta">... </span>    b = <span class="number">9</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f2(<span class="number">3</span>)</span><br><span class="line"><span class="number">3</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">3</span>, <span class="keyword">in</span> f2</span><br><span class="line">UnboundLocalError: local variable <span class="string">'b'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
<ul>
<li>解释<ul>
<li>在这个例子中,b被当做了局部变量</li>
<li>因为在函数中给它赋值了</li>
<li>所以报错，<code>引用在赋值之前</code></li>
</ul>
</li>
<li>这不是缺陷，而是设计选择<ul>
<li>Python不要求声明变量，但是假定在函数定义体中赋值的变量是局部变量</li>
<li>这比JavaScript的行为要好得多，JavaScript也不要求声明变量，但是如果忘记把变量声明为局部变量(使用var),可能会在不知情的情况下获取全局变量</li>
</ul>
</li>
<li>如果想在函数赋值中把b当做全局变量，要使用global声明<code>global b</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-5-闭包"><a href="#7-5-闭包" class="headerlink" title="7.5 闭包"></a>7.5 闭包</h3><ul>
<li><p>闭包定义</p>
<ul>
<li>闭包指延伸了作用域的函数，其中包含函数定义体中引用、但是不在定义体中定义的非全局变量</li>
<li>函数是不是匿名的没有关系，关键是它能访问定义体之外定义的的非全局变量</li>
</ul>
</li>
<li><p>举例</p>
<ul>
<li>背景：假如有个名为avg的函数，它的作用是计算不断增加的系列值的均值</li>
<li><p>使用方式</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line"><span class="number">10.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">11</span>)</span><br><span class="line"><span class="number">10.5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">12</span>)</span><br><span class="line"><span class="number">11.0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数式实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line">    series = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line">        series.append(new_value)</span><br><span class="line">        total = sum(series)</span><br><span class="line">        <span class="keyword">return</span> total / len(series)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> averager</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用类实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Averager</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.series = []</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, new_value)</span>:</span></span><br><span class="line">        self.series.append(new_value)</span><br><span class="line">        total = sum(self.series)</span><br><span class="line">        <span class="keyword">return</span> total / len(self.serious)</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个示例的共通之处</p>
<ul>
<li>调用Averager()或make_averager()得到一个可调用对象avg,它会更新历史值，然后计算当前均值</li>
<li>我们都需要把n放到系列值中，然后重新计算均值</li>
</ul>
</li>
<li><p>问题：那么函数式实现时是怎么找到<code>series</code>的呢</p>
<ul>
<li>在averager函数中，series是自由变量</li>
<li>自由变量：指未在本地作用域中绑定的变量</li>
<li>也就是说，虽然定义这个变量的函数已经返回了，但是这个变量被绑定到了内部函数上</li>
</ul>
</li>
</ul>
</li>
<li><p>综上</p>
<ul>
<li>闭包是一种函数，它会保留定义函数时存在的自由变量的绑定</li>
<li>这样调用函数时，虽然定义作用域不可用了，但是仍然使用那些绑定</li>
<li>只有嵌套在其他函数中的函数才可能需要处理不在全局作用域中的外部变量</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-6-nonlocal声明"><a href="#7-6-nonlocal声明" class="headerlink" title="7.6 nonlocal声明"></a>7.6 nonlocal声明</h3><ul>
<li><p>背景</p>
<ul>
<li>前面实现make_averager函数的方法效率不高</li>
<li>更好的实现方式是，只存储目前的总值和元素个数，然后使用这两个数计算均值</li>
</ul>
</li>
<li><p>一种有缺陷的实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>            total += new_value</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> total / count</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg = make_averager()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>avg(<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">5</span>, <span class="keyword">in</span> averager</span><br><span class="line">UnboundLocalError: local variable <span class="string">'count'</span> referenced before assignment</span><br></pre></td></tr></table></figure>
</li>
<li><p>问题</p>
<ul>
<li><code>count += 1</code>为count赋值，所以count被当做局部变量而不是自由变量，<code>count += 1</code>相当于<code>count = count + 1</code>,<code>count + 1</code>先于<code>count</code>执行，所以报错了<code>local variable &#39;count&#39; referenced before assignment</code></li>
</ul>
</li>
<li><p>解决方法</p>
<ul>
<li>python3引入了nonlocal关键字，如同global关键字，它的作用是把变量标记为自由变量</li>
<li>即使在函数中为变量赋予新值了，也会变成自由变量</li>
</ul>
</li>
<li><p>对上面有缺陷实现的改进</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">````py</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">make_averager</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    count = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    total = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span>    <span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">(new_value)</span>:</span></span><br><span class="line"><span class="meta">... </span>            <span class="keyword">nonlocal</span> count, total</span><br><span class="line"><span class="meta">... </span>            count += <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>            total += new_value</span><br><span class="line"><span class="meta">... </span>            <span class="keyword">return</span> total / count</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> averager</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="7-7-实现一个简单的装饰器"><a href="#7-7-实现一个简单的装饰器" class="headerlink" title="7.7 实现一个简单的装饰器"></a>7.7 实现一个简单的装饰器</h3><ul>
<li><p>示例1：定义了一个装饰器,它会在每次调用被装饰的函数时计时,然后把经过的时间、传入的参数和调用的结果打印出来。</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 定义内部函数clocked,它接受任何个定位参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args)</span>:</span></span><br><span class="line">        t0 = time.perf_counter()</span><br><span class="line">        <span class="comment"># 下面的代码可以执行,因为clocked闭包包含自由变量func</span></span><br><span class="line">        result = func(*args)</span><br><span class="line">        elapsed = time.perf_counter() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args)</span><br><span class="line">        print(<span class="string">'[%0.8fs]%s(%s) -&gt; %r'</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="comment"># 返回内部函数，取代被装饰的函数</span></span><br><span class="line">    <span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例2：对示例1的使用</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling snooze(.123)'</span>)</span><br><span class="line">    snooze(<span class="number">.123</span>)</span><br><span class="line">    print(<span class="string">'*'</span> * <span class="number">40</span>, <span class="string">'Calling snooze(6)'</span>)</span><br><span class="line">    print(<span class="string">'6! ='</span>, factorial(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">**************************************** Calling snooze(.123)</span></span><br><span class="line"><span class="string">[0.12314407s]snooze(0.123) -&gt; None</span></span><br><span class="line"><span class="string">**************************************** Calling snooze(6)</span></span><br><span class="line"><span class="string">[0.00000057s]factorial(1) -&gt; 1</span></span><br><span class="line"><span class="string">[0.00001018s]factorial(2) -&gt; 2</span></span><br><span class="line"><span class="string">[0.00001566s]factorial(3) -&gt; 6</span></span><br><span class="line"><span class="string">[0.00002063s]factorial(4) -&gt; 24</span></span><br><span class="line"><span class="string">[0.00002564s]factorial(5) -&gt; 120</span></span><br><span class="line"><span class="string">[0.00003240s]factorial(6) -&gt; 720</span></span><br><span class="line"><span class="string">6! = 720</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>工作原理</p>
<ul>
<li>factorial会作为func参数传给clock.然后clock函数返回clocked函数，python解释器在背后将clocked赋值给factorial</li>
<li>自此,每次调用factorial(n)执行的都是clocked(n)</li>
<li>clocked(n)大致做了下面几件事<ol>
<li>记录初始时间 t0。</li>
<li>调用原来的 factorial 函数,保存结果。</li>
<li>计算经过的时间。</li>
<li>格式化收集的数据,然后打印出来。</li>
<li>返回第 2 步保存的结果。</li>
</ol>
</li>
</ul>
</li>
<li><p>装饰器的典型行为</p>
<ul>
<li>如上例，装饰器往往会把被装饰的函数替换成新函数,二者接受相同的参数,而且(通常)返回被装饰的函数本该返回的值</li>
<li>但是通常还会做些额外操作</li>
</ul>
</li>
<li><p>示例1的缺点</p>
<ol>
<li>不支持关键字参数</li>
<li>遮盖了被装饰函数的 <code>__name__</code> 和 <code>__doc__</code> 属性</li>
</ol>
</li>
<li><p>示例3：使用<code>functools.wraps</code>装饰器把相关的属性从<code>func</code>复制到<code>clocked</code>中，并且可以处理关键字参数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># clockdeco2.py</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        t0 = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        elapsed = time.time() - t0</span><br><span class="line">        name = func.__name__</span><br><span class="line">        arg_lst = []</span><br><span class="line">        <span class="keyword">if</span> args:</span><br><span class="line">            arg_lst.append(<span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> args))</span><br><span class="line">        <span class="keyword">if</span> kwargs:</span><br><span class="line">            pairs = [<span class="string">'%s=%r'</span> % (k, w) <span class="keyword">for</span> k, w <span class="keyword">in</span> sorted(kwargs.items())]</span><br><span class="line">        arg_lst.append(<span class="string">', '</span>.join(pairs))</span><br><span class="line">        arg_str = <span class="string">', '</span>.join(arg_lst)</span><br><span class="line">        print(<span class="string">'[%0.8fs] %s(%s) -&gt; %r '</span> % (elapsed, name, arg_str, result))</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">return</span> clocked</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="7-8-标准库中的装饰器"><a href="#7-8-标准库中的装饰器" class="headerlink" title="7.8 标准库中的装饰器"></a>7.8 标准库中的装饰器</h3><ul>
<li><p>Python内置了三个用于装饰方法的装饰器<code>property</code>、<code>classmethod</code> 和 <code>staticmethod</code></p>
</li>
<li><p><code>functools</code>模块中几个好用的装饰器</p>
<ul>
<li><code>functools.wraps</code></li>
<li><code>functools.lru_cache</code></li>
<li><code>functools.singledispatch</code></li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-8-1-使用functools-lru-cache做备忘"><a href="#7-8-1-使用functools-lru-cache做备忘" class="headerlink" title="7.8.1 使用functools.lru_cache做备忘"></a>7.8.1 使用functools.lru_cache做备忘</h4><ul>
<li><p>简介</p>
<ul>
<li><code>functools.lru_cache</code> 是非常实用的装饰器,它实现了备忘(memoization)功能。</li>
<li>这是一项优化技术,它把耗时的函数的结果保存起来,避免传入相同的参数时重复计算。</li>
<li>LRU 三个字母是“Least Recently Used”的缩写,表明缓存不会无限制增长,一段时间不用的缓存条目会被扔掉。</li>
<li>例如，<code>fibonacci</code>中著名的指数爆炸问题，可以通过<code>functools.lru_cache</code>建立缓存来解决</li>
</ul>
</li>
<li><p>示例:使用缓存来优化<code>fibonacci</code>算法</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> clockdeco <span class="keyword">import</span> clock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意，这里必须加上括号来调用，原因参见7.10</span></span><br><span class="line"><span class="meta">@functools.lru_cache()</span></span><br><span class="line"><span class="comment"># 这里叠放了装饰器：@lru_cache()应用到@clock返回的函数，具体参见7.9</span></span><br><span class="line"><span class="meta">@clock</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">2</span>) + fibonacci(n - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(fibonacci(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的输出显示，因为递归导致的大量重复计算的问题得到了解决</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">/usr/bin/python3.6 /home/tough/code/pycharm/helloworld/fibonacci_cache_version.py</span></span><br><span class="line"><span class="string">[0.00000046s]fibonacci(0) -&gt; 0</span></span><br><span class="line"><span class="string">[0.00000050s]fibonacci(1) -&gt; 1</span></span><br><span class="line"><span class="string">[0.00003141s]fibonacci(2) -&gt; 1</span></span><br><span class="line"><span class="string">[0.00000100s]fibonacci(3) -&gt; 2</span></span><br><span class="line"><span class="string">[0.00004295s]fibonacci(4) -&gt; 3</span></span><br><span class="line"><span class="string">[0.00000067s]fibonacci(5) -&gt; 5</span></span><br><span class="line"><span class="string">[0.00005414s]fibonacci(6) -&gt; 8</span></span><br><span class="line"><span class="string">8</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>lru_cache的两个可选参数</p>
<ul>
<li>完整的函数签名:<code>functools.lru_cache(maxsize=128, typed=False)</code></li>
<li><code>maxsize</code><ul>
<li><code>maxsize</code>参数指定存储多少个调用的结果</li>
<li>缓存满了之后,旧的结果会被扔掉,腾出空间</li>
<li>为了得到最佳性能,<code>maxsize</code>应该设为2的幂</li>
</ul>
</li>
<li><code>typed</code><ul>
<li><code>typed</code> 参数如果设为 <code>True</code>,把不同参数类型得到的结果分开保存,即把通常认为相等的浮点数和整数参数(如 1 和 1.0)区分开。</li>
</ul>
</li>
<li>顺便说一下:因为 <code>lru_cache</code> 使用字典存储结果,而且键根据调用时传入的定位参数和关键字参数创建,所以被 <code>lru_cache</code> 装饰的函数,它的所有参数都必须是<strong>可散列的</strong>。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-8-2-单分派泛函数"><a href="#7-8-2-单分派泛函数" class="headerlink" title="7.8.2 单分派泛函数"></a>7.8.2 单分派泛函数</h4><ul>
<li><p>背景</p>
<ul>
<li>假设我们在开发一个调试 Web 应用的工具,我们想生成 HTML,显示不同类型的 Python 对象</li>
<li>这个函数适用于任何 Python 类型,但是它需要使用特别的方式显示某些类型<ul>
<li>str:把内部的换行符替换为 <code>&#39;&lt;br&gt;\n&#39;</code>;不使用 <code>&lt;pre&gt;</code>,而是使用 <code>&lt;p&gt;</code></li>
<li>int:以十进制和十六进制显示数字</li>
<li>list:输出一个 HTML 列表,根据各个元素的类型进行格式化</li>
</ul>
</li>
<li>我们想要的行为如下所示  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>htmlize(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;) </span><br><span class="line"><span class="string">'&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>htmlize(abs)</span><br><span class="line"><span class="string">'&lt;pre&gt;&lt;built-in function abs&gt;&lt;/pre&gt;'</span></span><br><span class="line"><span class="comment"># 字符串格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>htmlize(<span class="string">'Heimlich &amp; Co.\n- a game'</span>) </span><br><span class="line"><span class="string">'&lt;p&gt;Heimlich &amp; Co.&lt;br&gt;\n- a game&lt;/p&gt;'</span></span><br><span class="line"><span class="comment"># 数字格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>htmlize(<span class="number">42</span>) </span><br><span class="line"><span class="string">'&lt;pre&gt;42 (0x2a)&lt;/pre&gt;'</span></span><br><span class="line"><span class="comment"># 列表格式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(htmlize([<span class="string">'alpha'</span>, <span class="number">66</span>, &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;]))</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;li&gt;&lt;p&gt;alpha&lt;/p&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;66 (0x42)&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;li&gt;&lt;pre&gt;&#123;1, 2, 3&#125;&lt;/pre&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>分析</p>
<ol>
<li>因为 Python 不支持重载方法或函数,所以我们不能使用不同的签名定义htmlize 的变体,也无法使用不同的方式处理不同的数据类型。</li>
<li>在 Python 中,一种常见的做法是把 htmlize 变成一个分派函数<ul>
<li>使用一串 if/elif/elif,调用专门的函数,如 htmlize_str、htmlize_int,等等</li>
<li>这样不便于模块的用户扩展,还显得笨拙:时间一长,分派函数 htmlize 会变得很大,而且它与各个专门函数之间的耦合也很紧密。</li>
</ul>
</li>
<li>Python 3.4 新增的 functools.singledispatch 装饰器可以把整体方案拆分成多个模块<ul>
<li>使用<code>@singledispatch</code>装饰的普通函数会变成泛函数(generic function)</li>
<li>泛函数：根据第一个参数的类型,以不同方式执行相同操作的一组函数。</li>
</ul>
</li>
</ol>
</li>
<li><p>解决：示例：<code>singledispatch</code>创建一个自定义的<code>htmlize.register</code>装饰器,把多个函数绑在一起组成一个泛函数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"><span class="keyword">import</span> numbers</span><br><span class="line"><span class="keyword">import</span> html</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @singledispatch标注处理object类型的基函数</span></span><br><span class="line"><span class="meta">@singledispatch</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">htmlize</span><span class="params">(obj)</span>:</span></span><br><span class="line">    content = html.escape(repr(obj))</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;&#125;&lt;/pre&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 各个专门函数使用 @«base_function».register(«type») 装饰</span></span><br><span class="line"><span class="comment"># 专门函数的名称无关紧要; _是个不错的选择,简单明了</span></span><br><span class="line"><span class="meta">@htmlize.register(str)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(text)</span>:</span></span><br><span class="line">    content = html.escape(text).replace(<span class="string">'\n'</span>, <span class="string">'&lt;br&gt;\n'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;p&gt;&#123;0&#125;&lt;/p&gt;'</span>.format(content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为每个需要特殊处理的类型注册一个函数。numbers.Integral 是 int 的虚拟超类</span></span><br><span class="line"><span class="meta">@htmlize.register(numbers.Integral)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;pre&gt;&#123;0&#125; (0x&#123;0:x&#125;)&lt;/pre&gt;'</span>.format(n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以叠放多个 register 装饰器,让同一个函数支持不同类型</span></span><br><span class="line"><span class="meta">@htmlize.register(tuple)</span></span><br><span class="line"><span class="meta">@htmlize.register(abc.MutableSequence)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(seq)</span>:</span></span><br><span class="line">    inner = <span class="string">'&lt;/li&gt;\n&lt;li&gt;'</span>.join(htmlize(item) <span class="keyword">for</span> item <span class="keyword">in</span> seq)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'&lt;ul&gt;\n&lt;li&gt;'</span> + inner + <span class="string">'&lt;/li&gt;\n&lt;/ul&gt;'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>优点</p>
<ul>
<li><code>singledispatch</code>机制的一个显著特征是,你可以在系统的任何地方和任何模块中注册专门函数。如果后来在新的模块中定义了新的类型,可以轻松地添加一个新的专门函数来处理那个类型。</li>
<li>此外,你还可以为不是自己编写的或者不能修改的类添加自定义函数。</li>
<li><code>singledispath</code>支持模块化扩展:各个模块可以为它支持的各个类型注册一个专门函数。</li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-9-叠放装饰器"><a href="#7-9-叠放装饰器" class="headerlink" title="7.9 叠放装饰器"></a>7.9 叠放装饰器</h3><ul>
<li>简介<ul>
<li>即可以在已经被装饰的函数上应用装饰器</li>
<li>把<code>@d1</code>和<code>@d2</code>两个装饰器按顺序应用到<code>f</code>函数上,作用相当于<code>f=d1(d2(f))</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="7-10-参数化装饰器"><a href="#7-10-参数化装饰器" class="headerlink" title="7.10 参数化装饰器"></a>7.10 参数化装饰器</h3><ul>
<li>背景<ul>
<li>解析源码中的装饰器时,Python 把被装饰的函数作为第一个参数传给装饰器函数。</li>
<li>那怎么让装饰器接受其他参数呢?<ul>
<li>答案是，创建一个装饰器工厂函数,</li>
<li>把参数传给它,返回一个装饰器,然后再把它应用到要装饰的函数上</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-10-1-一个参数化的注册装饰器"><a href="#7-10-1-一个参数化的注册装饰器" class="headerlink" title="7.10.1 一个参数化的注册装饰器"></a>7.10.1 一个参数化的注册装饰器</h4><ul>
<li><p>我们首先看一个最简单的装饰器</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">registry = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">'running register(%s)'</span> % func)</span><br><span class="line">    registry.append(func)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line">    print(<span class="string">'running main()'</span>)</span><br><span class="line">    print(<span class="string">'registry -&gt;'</span>, registry)</span><br><span class="line"></span><br><span class="line">f1()</span><br></pre></td></tr></table></figure>
</li>
<li><p>假如需要为register提供一个可选的active参数,当设为false时，不注册被装饰的函数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">registry = set() </span><br><span class="line"></span><br><span class="line"><span class="comment"># register 接受一个可选的关键字参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span><span class="params">(active=True)</span>:</span> </span><br><span class="line">    <span class="comment"># decorate 这个内部函数是真正的装饰器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span> </span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (active, func))</span><br><span class="line">        <span class="comment"># 只有 active 参数的值(从闭包中获取)是 True 时才注册 func</span></span><br><span class="line">        <span class="keyword">if</span> active:</span><br><span class="line">        registry.add(func)</span><br><span class="line">        <span class="comment"># 如果 active 不为真,而且 func 在 registry 中,那么把它删除</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">        registry.discard(func)</span><br><span class="line">        <span class="comment"># decorate 是装饰器,必须返回一个函数</span></span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line">    <span class="comment"># register 是装饰器工厂函数,因此返回 decorate</span></span><br><span class="line">    <span class="keyword">return</span> decorate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># @register 工厂函数必须作为函数调用,并且传入所需的参数</span></span><br><span class="line"><span class="meta">@register(active=False) </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 即使不传入参数,register 也必须作为函数调用</span></span><br><span class="line"><span class="meta">@register() </span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">print(<span class="string">'running f2()'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>所以为什么调用时一定要加括号，是因为<code>register</code>此时并不是装饰器函数而是装饰器的工厂函数，只有加<code>()</code>才可以返回真正的装饰器函数</li>
</ul>
</li>
</ul>
<hr>
<h4 id="7-10-2-参数化clock装饰器"><a href="#7-10-2-参数化clock装饰器" class="headerlink" title="7.10.2 参数化clock装饰器"></a>7.10.2 参数化clock装饰器</h4><ul>
<li><p>本节再次讨论clock装饰器,为它添加一个功能：让用户传入一个格式字符串，控制被装饰函数的输出</p>
</li>
<li><p>示例：参数化clock装饰器</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">DEFAULT_FMT = <span class="string">'[&#123;elapsed:0.8f&#125;s] &#123;name&#125;(&#123;args&#125;) -&gt; &#123;result&#125;'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clock</span><span class="params">(fmt=DEFAULT_FMT)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorate</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">clocked</span><span class="params">(*_args)</span>:</span> </span><br><span class="line">            t0 = time.time()</span><br><span class="line">            _result = func(*_args) </span><br><span class="line">            elapsed = time.time() - t0</span><br><span class="line">            name = func.__name__</span><br><span class="line">            args = <span class="string">', '</span>.join(repr(arg) <span class="keyword">for</span> arg <span class="keyword">in</span> _args)</span><br><span class="line">            result = repr(_result) </span><br><span class="line">            print(fmt.format(**locals()))</span><br><span class="line">            <span class="keyword">return</span> _result </span><br><span class="line">        <span class="keyword">return</span> clocked </span><br><span class="line">    <span class="keyword">return</span> decorate </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="meta">    @clock()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">snooze</span><span class="params">(seconds)</span>:</span></span><br><span class="line">    time.sleep(seconds)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        snooze(<span class="number">.123</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>装饰器还可以通过实现__call_方法的类实现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">register</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, active=True)</span>:</span></span><br><span class="line">        self.active = active</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        print(<span class="string">'running register(active=%s)-&gt;decorate(%s)'</span> % (self.active, func))</span><br><span class="line">        <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@register(active=False)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f1()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果这里可以给一个类的实例或许不需要加括号</span></span><br><span class="line"><span class="comment"># 即使不传入参数,register 也必须作为函数调用</span></span><br><span class="line"><span class="meta">@register()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'running f2()'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(type(f1))</span><br><span class="line">    f1()</span><br><span class="line">    print(type(f2))</span><br><span class="line">    f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">running register(active=False)-&gt;decorate(&lt;function f1 at 0x7f269489be18&gt;)</span></span><br><span class="line"><span class="string">running register(active=True)-&gt;decorate(&lt;function f2 at 0x7f2692aab840&gt;)</span></span><br><span class="line"><span class="string">running f1()</span></span><br><span class="line"><span class="string">running f2()</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-6-使用一等函数实现设计模式/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-6-使用一等函数实现设计模式/" itemprop="url">[流畅的Python][6][使用一等函数实现设计模式]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:39:56+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-6-使用一等函数实现设计模式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-6-使用一等函数实现设计模式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第六章-使用一等函数实现设计模式"><a href="#第六章-使用一等函数实现设计模式" class="headerlink" title="第六章 使用一等函数实现设计模式"></a>第六章 使用一等函数实现设计模式</h2><blockquote>
<p>符合模式并不表示做得对.————————Ralph Johnson</p>
</blockquote>
<ul>
<li><p>虽然设计模式与语言无关，但这并不意味着每一个模式都能在每一门语言中使用</p>
</li>
<li><p>《设计模式：可复用面向对象软件的基础》的作者在引言中承认，所用的语言决定了哪些模式可用</p>
</li>
<li><p>具体而言</p>
<ul>
<li>Norvig建议在有一等函数的语言中重新审视”策略”、”命令”、”模板方法”和”访问者”模式</li>
<li>通常，我们可以把这些模式中涉及的某些类的实例替换成简单的函数，从而减少样本代码</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-1-案例分析：重构策略模式"><a href="#6-1-案例分析：重构策略模式" class="headerlink" title="6.1 案例分析：重构策略模式"></a>6.1 案例分析：重构策略模式</h3><ul>
<li>如果合理利用作为一等对象的函数，某些设计模式可以简化，”策略”模式就是其中一个很好的例子</li>
</ul>
<h4 id="6-1-1-经典的策略模式"><a href="#6-1-1-经典的策略模式" class="headerlink" title="6.1.1 经典的策略模式"></a>6.1.1 经典的策略模式</h4><ul>
<li><p>下图指出了策略模式对类的编排<br>  <img src="/2020/02/01/流畅的Python-6-使用一等函数实现设计模式/策略模式类图.jpg" alt=""></p>
</li>
<li><p>策略模式的定义</p>
<blockquote>
<p>定义一系列算法，把它们一一封装起来，并且使它们可以相互替换。本模式使得算法可以独立于使用它的客户而变换</p>
</blockquote>
</li>
<li><p>策略模式的组成部分</p>
<ul>
<li>上下文：把一些计算委托给不同算法的可互换组件，它提供服务</li>
<li>策略：实现不同算法的</li>
</ul>
</li>
<li><p>策略模式的注意事项</p>
<ul>
<li>按照《设计模式：可复用面向对象软件的基础》一书中的说明，具体策略由上下文类的客户选择</li>
<li>具体怎么选择策略，不在这个模式的职责范围内</li>
</ul>
</li>
<li><p>示例：实现Order类，支持插入式折扣策略</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion.discount(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promotion</span><span class="params">(ABC)</span>:</span>  <span class="comment"># 策略:抽象基类</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="string">"""返回折扣金额(正值)"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FidelityPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第一个具体策略</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的用户提供5%折扣"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulkItemPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第二个具体策略</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">            <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">                discount += item.total() * <span class="number">.1</span></span><br><span class="line">        <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LargeOrderPromo</span><span class="params">(Promotion)</span>:</span>  <span class="comment"># 第三个具体策略</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">discount</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">        <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">            <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="6-1-2-使用函数实现策略模式"><a href="#6-1-2-使用函数实现策略模式" class="headerlink" title="6.1.2 使用函数实现策略模式"></a>6.1.2 使用函数实现策略模式</h4><ul>
<li><p>背景</p>
<ul>
<li>在前一节的示例中，每个具体策略都是一个类，而且都只定义了一个方法，即discount.此外，策略实例是没有状态的</li>
<li>也就是说它们看起来像普通的函数，所以没有理由不把具体策略换成简单的函数，并且去掉Promo抽象类</li>
</ul>
</li>
<li><p>示例: Order类和使用函数实现的折扣策略</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Customer = namedtuple(<span class="string">'Customer'</span>, <span class="string">'name fidelity'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LineItem</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, product, quantity, price)</span>:</span></span><br><span class="line">        self.product = product</span><br><span class="line">        self.quantity = quantity</span><br><span class="line">        self.price = price</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.quantity</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span>  <span class="comment"># 上下文</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, customer, cart, promotion=None)</span>:</span></span><br><span class="line">        self.customer = customer</span><br><span class="line">        self.cart = list(cart)</span><br><span class="line">        self.promotion = promotion</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(self, <span class="string">'__total'</span>):</span><br><span class="line">            self.__total = sum(item.total() <span class="keyword">for</span> item <span class="keyword">in</span> self.cart)</span><br><span class="line">        <span class="keyword">return</span> self.__total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">due</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.promotion <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">            discount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            discount = self.promotion(self)</span><br><span class="line">        <span class="keyword">return</span> self.total() - discount</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        fmt = <span class="string">'&lt;order total: &#123;:.2f&#125; due: &#123;:.2f&#125;&gt;'</span></span><br><span class="line">        <span class="keyword">return</span> fmt.format(self.total(), self.due())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fidelity_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""为积分为1000或以上的用户提供5%折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> order.total() * <span class="number">.05</span> <span class="keyword">if</span> order.customer.fidelity &gt;= <span class="number">1000</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bulk_item_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""单个商品为20个或以上时提供10%折扣"""</span></span><br><span class="line">    discount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> order.cart:</span><br><span class="line">        <span class="keyword">if</span> item.quantity &gt;= <span class="number">20</span>:</span><br><span class="line">            discount += item.total() * <span class="number">.1</span></span><br><span class="line">    <span class="keyword">return</span> discount</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">large_order_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""订单中的不同商品达到10个或以上时提供7%折扣"""</span></span><br><span class="line">    distinct_items = &#123;item.product <span class="keyword">for</span> item <span class="keyword">in</span> order.cart&#125;</span><br><span class="line">    <span class="keyword">if</span> len(distinct_items) &gt;= <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">return</span> order.total() * <span class="number">.07</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>享元模式与函数的讨论</p>
<ul>
<li>值得注意的是，《设计模式：可复用面向对象软件的基础》一书的作者指出：“策略对象通常是很好的享元(flyweight)。”</li>
<li>那本书的另一部分对“享元”下了定义：享元是可共享的对象，可以同时在多个上下文中使用</li>
<li>共享是推荐的做法，这样不必在每个新的上下文中使用相同的策略时不断新建具体策略对象，从而减少消耗</li>
<li>函数比用户定义的类的实例轻量，而且无需使用享元模式，因为各个策略函数在Python编译模块时只会创建一次。普通的函数也是”可共享的对象”，可以同时在多个上下文中使用</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-1-3-选择最佳策略：简单的方式"><a href="#6-1-3-选择最佳策略：简单的方式" class="headerlink" title="6.1.3 选择最佳策略：简单的方式"></a>6.1.3 选择最佳策略：简单的方式</h4><ul>
<li><p>示例:best_promo迭代一个函数列表，并找出折扣额度最大的</p>
<ul>
<li><p>代码</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># promos列出以函数实现的各个策略</span></span><br><span class="line">promos = [fidelity_promo, bulk_item_promo, large_order_promo]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="comment"># 使用生成器表达式把order传个promos列表中的各个函数，返回计算出的最大折扣额度</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释</p>
<ul>
<li>promos是函数列表。习惯函数是一等对象之后，自然而然就会构建这种结构存储函数</li>
</ul>
</li>
<li>缺点<ul>
<li>若想添加新的促销策略，要定义相应的函数，还要记得把它添加到promos列表中</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="6-1-4-找出模块中的全部策略"><a href="#6-1-4-找出模块中的全部策略" class="headerlink" title="6.1.4 找出模块中的全部策略"></a>6.1.4 找出模块中的全部策略</h4><ul>
<li><p>Python中的模块</p>
<ul>
<li>在Python中模块也是一等对象，而且标准库提供了几个处理模块的函数</li>
<li>内置函数<code>globals()</code><ul>
<li>返回一个字典，表示当前的全局符号表</li>
<li>这个符号表始终针对当前模块(对函数或方法来说，是指定义它们的模块，而不是调用它们的模块)</li>
</ul>
</li>
</ul>
</li>
<li><p>方案一:使用globals函数来自动寻找其他可用的*_promo函数</p>
<ul>
<li><p>示例：内省模块中的全局命名空间，构建promos列表</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promos = [globals()[name] <span class="keyword">for</span> name <span class="keyword">in</span> globals() <span class="keyword">if</span> name.endwith(<span class="string">'_promo'</span>) <span class="keyword">and</span> name != <span class="string">'best_promo'</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">best_promo</span><span class="params">(order)</span>:</span></span><br><span class="line">    <span class="string">"""选择可用的最佳折扣"""</span></span><br><span class="line">    <span class="keyword">return</span> max(promo(order) <span class="keyword">for</span> promo <span class="keyword">in</span> promos)</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释</p>
<ul>
<li>通过迭代globals()来找到所用的_promo函数</li>
<li>过滤掉best_promo自身，防止无限递归</li>
<li>best_promo内部的代码没有变化</li>
</ul>
</li>
</ul>
</li>
<li><p>方案二</p>
<ul>
<li>在一个单独的模块中保存所有的策略函数，并把best_promo排除在外</li>
<li>通过内省这个模块来构建策略函数列表</li>
</ul>
</li>
<li><p>另外</p>
<ul>
<li>动态收集促销折扣函数更为显示的一种方案是使用简单的修饰器</li>
</ul>
</li>
</ul>
<hr>
<h3 id="6-2-命令模式"><a href="#6-2-命令模式" class="headerlink" title="6.2 命令模式"></a>6.2 命令模式</h3><ul>
<li><p>命令模式也可以通过把函数作为参数传递而简化</p>
</li>
<li><p>命令模式简介</p>
<ul>
<li>命令模式的目的是解耦调用操作的对象(调用者)和提供实现的对象(接收者)</li>
<li>命令模式的做法是在调用者和接收者之间放一个Command对象，让它实现只有一个方法的接口，调用接收者中的方法执行所需的操作。这样，调用者无需理解接收者的接口，而且不同的接收者可以适应不同的Command子类</li>
</ul>
</li>
<li><p>命令模式的类图如下</p>
</li>
<li><p>Python对命令模式的简化</p>
<ul>
<li>我们可以不为调用者提供一个Command实例，而是给它一个函数，就如我们对策略模式做的那样</li>
</ul>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-5-一等函数/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-5-一等函数/" itemprop="url">[流畅的Python][5][一等函数]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:38:22+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-5-一等函数/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-5-一等函数/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第5章-一等函数"><a href="#第5章-一等函数" class="headerlink" title="第5章 一等函数"></a>第5章 一等函数</h2><blockquote>
<p>不管别人怎么说或怎么想，我从未觉得Python受到来自函数式语言的太多影响。我非常熟悉命令式语言，如C和Algol68，虽然我把函数定为一等对象，但是我并不把Python当成函数式编程语言      —————Guido van Rossum</p>
</blockquote>
<ul>
<li><p>在Python中，函数是一等对象</p>
</li>
<li><p>编程语言理论家把“一等函数”定义为满足下述条件的程序实体</p>
<ol>
<li>运行时创建</li>
<li>能赋值给变量或数据结构中的元素</li>
<li>能作为参数传给函数</li>
<li>能作为函数的返回结果</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-1-把函数视为对象"><a href="#5-1-把函数视为对象" class="headerlink" title="5.1 把函数视为对象"></a>5.1 把函数视为对象</h3><ul>
<li><p>示例 5-1：函数是一等对象</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 这是一个控制台会话，因此我们在运行时创建了一个函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(n)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="string">'''returns n'''</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="number">1</span> <span class="keyword">if</span> n &lt; <span class="number">2</span> <span class="keyword">else</span> n * factorial(n - <span class="number">1</span>)</span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial(<span class="number">42</span>)</span><br><span class="line"><span class="number">1405006117752879898543142606244511569936384000000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __doc__是函数对象众多属性中的一个，用于生成对象的帮助文档</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>factorial.__doc__</span><br><span class="line"><span class="string">'returns n'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># factorial是function类的一个实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(factorial)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">function</span>'&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__doc__</code>属性生成对象的帮助文档。在Python交互式控制台中，可以调用help(obj)命令来查看这个文档</p>
</li>
<li><p>示例 5-2：将函数赋值给变量，再把函数作为参数传递</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact = factorial</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact</span><br><span class="line">&lt;function factorial at <span class="number">0x7f84012f8e18</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>map(factorial, range(<span class="number">11</span>))</span><br><span class="line">&lt;map object at <span class="number">0x7f83ff510860</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">11</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>, <span class="number">720</span>, <span class="number">5040</span>, <span class="number">40320</span>, <span class="number">362880</span>, <span class="number">3628800</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>以上两个示例可以充分说明在Python中函数是一等对象</p>
</li>
</ul>
<hr>
<h3 id="5-2-高阶函数"><a href="#5-2-高阶函数" class="headerlink" title="5.2 高阶函数"></a>5.2 高阶函数</h3><ul>
<li><p>高阶函数的定义：接受函数为参数，或者把函数作为结果返回的函数就是高阶函数(higher-order function)</p>
</li>
<li><p>例如：内置函数map和内置函数sorted</p>
</li>
<li><p>示例 5-3：高阶函数sorted的使用方法1</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key=len)</span><br><span class="line">[<span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'banana'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>]</span><br></pre></td></tr></table></figure>
<ul>
<li>任何单参数函数都能作为key参数的值</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5-2-1-map、filter和reduce的现代替代品"><a href="#5-2-1-map、filter和reduce的现代替代品" class="headerlink" title="5.2.1 map、filter和reduce的现代替代品"></a>5.2.1 map、filter和reduce的现代替代品</h4><ul>
<li><p>函数式语言通常会提供map、filter和reduce三个高阶函数</p>
</li>
<li><p>在Python3中，map和filter还是内置函数，但是由于引入了列表推导和生成器表达式，它们变得不再那么重要</p>
</li>
<li><p>示例 5-5：map、filter与列表推导的对比</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, range(<span class="number">6</span>)))</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">24</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(fact, filter(<span class="keyword">lambda</span> n: n % <span class="number">2</span>, range(<span class="number">6</span>))))</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[fact(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">6</span>) <span class="keyword">if</span> n % <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">6</span>, <span class="number">120</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Python2中，reduce是内置函数，但是在Python3中放到了functools模块中</p>
</li>
<li><p>示例 5-6：使用reduce和sum计算0-99的和</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> operator <span class="keyword">import</span> add</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(add, range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(range(<span class="number">100</span>))</span><br><span class="line"><span class="number">4950</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sum和reduce的通用思想是把某个操作连续应用到序列的元素上，累计之前的结果，把一系列的值归约为一个值</li>
</ul>
</li>
<li><p>归约函数</p>
<ul>
<li>把某个操作连续应用到序列的元素上，累计之前的结果，把一系列的值归约为一个值</li>
<li>例如<ul>
<li><code>sum(iterable)</code>：对iterable中各个元素求和</li>
<li><code>reduce()</code></li>
<li><code>all(iterable)</code>:如果iterable的每个元素都是真值，返回True,all([])返回True</li>
<li><code>any(iterable)</code>：只要iterable中有元素时真值，就返回True,any([])返回False</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-3-匿名函数"><a href="#5-3-匿名函数" class="headerlink" title="5.3 匿名函数"></a>5.3 匿名函数</h3><ul>
<li><p>匿名函数存在的原因：为了使用高阶函数，有时创建一次性的小型函数更便利</p>
</li>
<li><p>匿名函数简介</p>
<ul>
<li>lambda关键字在Python表达式内创建匿名函数</li>
<li>然而，Python简单的句法限制了lambda函数的定义体只能使用纯表达式。也就是，lambda函数的定义体中不能赋值，也不能使用while和try等Python语句</li>
</ul>
</li>
<li><p>示例5-7：使用lambda表达式反转拼写，然后依次给单词列表排序</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fruits = [<span class="string">'strawberry'</span>, <span class="string">'fig'</span>, <span class="string">'apple'</span>, <span class="string">'cherry'</span>, <span class="string">'raspberry'</span>, <span class="string">'banana'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(fruits, key = <span class="keyword">lambda</span> word: word[::<span class="number">-1</span>])</span><br><span class="line">[<span class="string">'banana'</span>, <span class="string">'apple'</span>, <span class="string">'fig'</span>, <span class="string">'raspberry'</span>, <span class="string">'strawberry'</span>, <span class="string">'cherry'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>匿名函数的限制</p>
<ul>
<li>除了作为参数传给高阶函数之外，Python很少使用匿名函数</li>
<li>由于句法上的限制，非平凡的lambda表达式要么难以阅读，要么无法写出</li>
</ul>
</li>
<li><p>Lundh提出的lambda表达式重构秘籍</p>
<ol start="0">
<li>如果使用lambda表达式导致一段代码难以理解,Fredrik Lundh建议像下面这样重构</li>
<li>编写注释，说明lambda表达式的作用</li>
<li>研究一会儿注释，病找出一个名称来概括注释</li>
<li>把lambda表达式转换成def，使用那个名称命名函数</li>
<li>删除注释</li>
</ol>
</li>
</ul>
<hr>
<h3 id="5-4-可调用对象"><a href="#5-4-可调用对象" class="headerlink" title="5.4 可调用对象"></a>5.4 可调用对象</h3><hr>
<ul>
<li><p>可调用对象简介</p>
<ul>
<li>可以运用调用运算符(即())调用的对象叫做可调用对象</li>
<li>如果想判断一个对象是否可调用，可以使用内置的<code>callable()</code>函数</li>
<li>可调用对象一共有7种</li>
</ul>
</li>
<li><p>可调用对象分类</p>
<p>  | 可调用对象 | 简介 |<br>  | ——| —— |<br>  | 用户定义的函数 | 使用<code>def</code>语句或<code>lambda</code>表达式创建 |<br>  | 内置函数 | 使用C语言(CPython)实现的函数，如<code>len</code>或<code>time.strftime</code> |<br>  | 内置方法 | 使用C语言实现的方法，如<code>dict.get</code> |<br>  | 方法 | 在类的定义体中定义的函数 |<br>  | 类 | 调用类时会产生类似构造方法的效果，返回一个此类的实体 |<br>  | 类的实例 | 如果类定义了<code>__call__</code>方法，那么它的实例可以作为函数调用 |<br>  | 生成器函数 | 使用<code>yield</code>关键字的函数或方法 |</p>
</li>
</ul>
<hr>
<h3 id="5-5-用户定义的可调用类型"><a href="#5-5-用户定义的可调用类型" class="headerlink" title="5.5 用户定义的可调用类型"></a>5.5 用户定义的可调用类型</h3><ul>
<li><p>简介</p>
<ul>
<li>不仅Python函数是真正的对象，任何Python对象都可以表现得像函数</li>
<li>为此，只需实现实例方法<code>__call__</code></li>
</ul>
</li>
<li><p>示例:实现了<strong>call</strong>方法的类，BingoCage</p>
<ul>
<li><p>源代码</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BingoCase</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># __init__接受任何可迭代对象;在本地构建一个副本,防止列表参数的意外副作用</span></span><br><span class="line">        self._item = list(item)</span><br><span class="line">        <span class="comment"># shuffle定能完成工作,因为self._item是列表</span></span><br><span class="line">        random.shuffle(self._item)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 起主要作用的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pick</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> self._item.pop()</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="comment"># 如果self._item为空,抛出异常,并且设定错误信息</span></span><br><span class="line">            <span class="keyword">raise</span> LookupError(<span class="string">'pick from empty BingoCage'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># bingo.pick()的快捷方式是bingo()</span></span><br><span class="line">        <span class="keyword">return</span> self.pick()</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> bingocall</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo = bingocall.BingoCase(range(<span class="number">3</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo.pick()</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bingo()</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>callable(bingo)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>实现<code>__call__</code>方法的类是创建函数类对象的简便方法，此时必须在内部维护一个状态，让它在调用之间可用，例如BingoCage中的剩余元素</li>
<li>创建保有内部状态的函数，还有一种截然不同的方式————使用闭包</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-6-函数内省"><a href="#5-6-函数内省" class="headerlink" title="5.6 函数内省"></a>5.6 函数内省</h3><ul>
<li><p>除了<code>__doc__</code>，函数对象还有很多属性，使用<code>dir</code>函数可以探知factorial具有下述属性</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(fun)</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__call__'</span>, <span class="string">'__class__'</span>, <span class="string">'__closure__'</span>, <span class="string">'__code__'</span>, <span class="string">'__defaults__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__eq__'</span>, <span class="string">'__format__'</span>, <span class="string">'__ge__'</span>, <span class="string">'__get__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__globals__'</span>, <span class="string">'__gt__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__init_subclass__'</span>, <span class="string">'__kwdefaults__'</span>, <span class="string">'__le__'</span>, <span class="string">'__lt__'</span>, <span class="string">'__module__'</span>, <span class="string">'__name__'</span>, <span class="string">'__ne__'</span>, <span class="string">'__new__'</span>, <span class="string">'__qualname__'</span>, <span class="string">'__reduce__'</span>, <span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>]</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>__dict__</code>属性</p>
<ul>
<li>函数使用<code>__dict__</code>属性储存赋予它的用户属性</li>
<li><p>例如</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fun</span><span class="params">()</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line"><span class="meta">... </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.name = <span class="string">"haha"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun.__dict__</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'haha'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，为函数赋予属性不是很常见的做法</p>
</li>
</ul>
</li>
<li><p>用户定义的函数的属性<br>  | 名称 | 类型 | 说明 |<br>  | ——| —— | —— |<br>  | <code>__annotations__</code> | <code>dict</code> | 参数和返回值的注释 |<br>  | <code>__call__</code> | <code>method-wrapper</code> | 实现<code>()</code>运算符；即可调用对象协议 |<br>  | <code>__closure__</code> | <code>tuple</code> | 函数闭包，即自由变量的绑定 |<br>  | <code>__code__</code> | <code>code</code> | 编译成字节码的函数元数据和函数定义体 |<br>  | <code>__defaults__</code> | <code>tuple</code> | 形式参数的默认值 |<br>  | <code>__get__</code> | <code>method-wrapper</code> | 实现制度描述符协议 |<br>  | <code>__globals__</code> | <code>dict</code> | 函数所在模块中的全局变量 |<br>  | <code>__kwdefaults__</code> | <code>dict</code> | 仅限关键字形式参数的默认值 |<br>  | <code>__name__</code> | <code>str</code> | 函数名称 |<br>  | <code>__qualname__</code> | <code>str</code> | 函数的限定名称，如<code>Random.choice</code> |</p>
</li>
</ul>
<hr>
<h3 id="5-7-从定位参数到仅限关键字参数"><a href="#5-7-从定位参数到仅限关键字参数" class="headerlink" title="5.7 从定位参数到仅限关键字参数"></a>5.7 从定位参数到仅限关键字参数</h3><ul>
<li><p>Python最好的特性之一是提供了及其灵活的参数处理机制</p>
</li>
<li><p>形式参数的分类</p>
<ul>
<li>定位参数：<ul>
<li>调用函数时根据函数定义的参数位置来传递参数</li>
</ul>
</li>
<li>关键字参数<ul>
<li>用于函数调用，通过“键-值”形式加以指定</li>
<li>可以让函数更加清晰、容易使用，同时也清除了参数的顺序需求</li>
<li>并且可以在函数声明时为其制定默认值</li>
</ul>
</li>
<li>可变参数：<ul>
<li>定义函数时，有时候我们不确定调用的时候会传递多少个参数(不传参也可以)</li>
<li>此时，可用包裹(<code>*</code>或<code>**</code>)位置参数，或者包裹关键字参数，来进行参数传递，会显得非常方便</li>
</ul>
</li>
</ul>
</li>
<li><p><code>*</code>与<code>**</code></p>
<ul>
<li><code>*</code><ul>
<li>其他”剩余”参数会被放到一个元组中，被赋予带<code>*</code>的参数</li>
<li>一个函数声明中只能有一个带<code>*</code>的参数</li>
</ul>
</li>
<li><code>**</code><ul>
<li>带<code>**</code>的参数是一个字典，它会收集所有剩余关键字参数并放入一个字典中</li>
<li>一个函数声明中只能有一个带<code>**</code>的参数</li>
</ul>
</li>
</ul>
</li>
<li><p>示例 5-10:tag函数定义部分,tag函数用来生成HTML标签</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> tag</span><br><span class="line"><span class="comment"># 传入单个定位参数,生成一个指定名称的空标签</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.tag(<span class="string">'br'</span>)</span><br><span class="line"><span class="string">'&lt;br /&gt;'</span></span><br><span class="line"><span class="comment"># 第一个参数后面的任意个参数会被*content捕获,存入一个元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.tag(<span class="string">'p'</span>, <span class="string">'hello'</span>)</span><br><span class="line"><span class="string">'&lt;p&gt;hello&lt;/p&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, id=<span class="number">33</span>)</span><br><span class="line"><span class="string">'&lt;p id="33"&gt;hello&lt;/p&gt;'</span></span><br><span class="line"><span class="comment"># tag函数签名中没有明确指定名称的关键字参数会被**attrs捕获，存入一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tag.tag(<span class="string">'p'</span>, <span class="string">'hello'</span>, <span class="string">'world'</span>, cls=<span class="string">'sidebar'</span>))</span><br><span class="line">&lt;p class="sidebar"&gt;hello&lt;/p&gt;</span><br><span class="line">&lt;p class="sidebar"&gt;world&lt;/p&gt;</span><br><span class="line"><span class="comment"># 调用tag函数时，即使第一个定位参数也能作为关键字参数传入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.tag(content=<span class="string">'testing'</span>, name=<span class="string">'img'</span>)</span><br><span class="line"><span class="string">'&lt;img content="testing" /&gt;'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>my_tag = &#123;<span class="string">'name'</span>: <span class="string">'img'</span>, <span class="string">'title'</span>: <span class="string">'Sunset Boulevard'</span>, <span class="string">'src'</span>: <span class="string">'sunset.jpg'</span>, <span class="string">'cls'</span>: <span class="string">'framed'</span>&#125;</span><br><span class="line"><span class="comment"># 在my_tag前面加入**,字典中的所有元素作为单个参数传入，同名键会绑定到对应的具名参数上，余下的会被**attrs捕获</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tag.tag(**my_tag)</span><br><span class="line"><span class="string">'&lt;img class="framed" src="sunset.jpg" title="Sunset Boulevard" /&gt;'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="5-8-获取关于参数的信息"><a href="#5-8-获取关于参数的信息" class="headerlink" title="5.8 获取关于参数的信息"></a>5.8 获取关于参数的信息</h3><ul>
<li><p>举例：HTTP微框架Bobo中有个使用<strong>函数内省</strong>的好例子</p>
<ul>
<li><p>示例 5-12 <code>Bobo</code>知道<code>hello</code>需要<code>person</code>参数，并且从HTTP请求中获取它 </p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bobo</span><br><span class="line"><span class="meta">@bobo.query('/)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(person)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello %s!'</span> % person</span><br></pre></td></tr></table></figure>
</li>
<li><p>解释</p>
<ul>
<li><code>bobo.query</code>装饰器把一个普通的函数(如<code>hello</code>)与框架的请求处理机制集成起来了</li>
<li>Bobo会内省<code>hello</code>函数，发现它需要一个名为<code>person</code>的参数，然后从请求中获取那个名称对应的参数，将其传给<code>hello</code>函数，因此程序员<strong>根本不需要</strong>触碰请求对象</li>
</ul>
</li>
</ul>
</li>
<li><p>那么问题来了</p>
<ul>
<li>Bobo是怎么知道函数需要哪个参数的呢？它又是怎么知道参数有没有默认值呢</li>
<li>解答<ul>
<li>函数对象有个<code>__default__</code>属性，它的值是一个元组，里面保存了定位参数和关键字参数的默认值</li>
<li>仅限关键字参数的默认值在<code>__kwdefault__</code>属性中</li>
<li>参数的名称在<code>__code__</code>属性中，它的值是一个code对象引用，自身也有很多属性</li>
<li>但是这种组织信息的方式并不便利，我们可以使用<code>inspect</code>模块来更好的提取参数信息</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-9-函数注解"><a href="#5-9-函数注解" class="headerlink" title="5.9 函数注解"></a>5.9 函数注解</h3><ul>
<li><p>函数注解的用法</p>
<ul>
<li>函数声明中的各个参数可以在<code>:</code>之后增加注解表达式</li>
<li>如果参数有默认值，注解放在参数名和<code>=</code>之间</li>
<li>如果想注解返回值，在<code>)</code>和函数声明末尾的<code>:</code>之间添加<code>-&gt;</code>和一个表达式。那个表达式可以是任意类型。注解中常用的类型是类(如str或int)和字符串(如’int &gt; 0’)</li>
</ul>
</li>
<li><p>示例</p>
<ul>
<li><p>不加注解的函数声明版本</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(text, max_len)</span>:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加注解的函数声明版本</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clip</span><span class="params">(text:str, max_len:<span class="string">'int &gt; 0'</span>=<span class="number">80</span>)</span> -&gt; str:</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Python对注解所做的处理</p>
<ul>
<li>Python对注解所做的唯一的事情就是把它们存储在函数的<strong>annotations</strong>属性里，仅此而已</li>
<li>Python不做检查，不做强制，不做验证，什么操作都不做</li>
<li>注解在Python解释器中没有任何意义，注解只是元数据，可以供IDE、框架和装饰器等工具使用</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-10-本章小结"><a href="#5-10-本章小结" class="headerlink" title="5.10 本章小结"></a>5.10 本章小结</h3><ol>
<li><p>本章的目标是探讨Python函数的一等本性。这意味着，我们可以把函数赋值给变量、传给其他函数、存储在数据结构中，以及访问函数的属性，供框架和一些工具使用</p>
</li>
<li><p>高阶函数</p>
</li>
<li><p>Python有7种可调用对象，这些可调用对象都能通过内置的<code>callable()</code>函数检测</p>
</li>
<li><p>每种可调用对象都支持使用相同的丰富句法声明形式参数，包括仅限关键字参数和注解</p>
</li>
<li><p>Python函数及其注解有丰富的属性，在inspect模块的帮助下，可以读取它们</p>
</li>
<li><p>函数式编程可以使用<code>operator</code>模块中的一些函数，以及<code>functools.partial</code>函数</p>
</li>
</ol>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-4-文本和字节序列/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-4-文本和字节序列/" itemprop="url">[流畅的Python][4][文本和字节序列]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:35:52+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-4-文本和字节序列/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-4-文本和字节序列/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第4章-文本和字节序列"><a href="#第4章-文本和字节序列" class="headerlink" title="第4章 文本和字节序列"></a>第4章 文本和字节序列</h2><blockquote>
<p>人类使用文本，计算机使用字节序列。————————Esther Nam和Travis Fischer</p>
</blockquote>
<ul>
<li>Python3明确地区分了人类可读的文本字符串和原始的字节序列</li>
</ul>
<hr>
<h3 id="4-1-字符问题"><a href="#4-1-字符问题" class="headerlink" title="4.1 字符问题"></a>4.1 字符问题</h3><ul>
<li><p>字符串：字符串是一个简单的概念，一个<strong>字符串</strong>就是一个<strong>字符序列</strong></p>
</li>
<li><p>字符：字符的最佳定义就是Unicode字符</p>
</li>
<li><p>Unicode标准把<strong>字符的标识</strong>和<strong>具体的字节表述</strong>进行了如下的明确区分</p>
<ul>
<li><p><strong>字符的标识</strong></p>
<ul>
<li>即<strong>码位</strong>，是0-1114111的数字(十进制)，在Unicode标准中以4-6个十六进制数字表示，而且加上前缀“U+”</li>
<li>例如，字母A的码位是<code>U+0041</code>，欧元符号的码位是<code>U+20AC</code>，高音谱号的码位是<code>U+1D11E</code></li>
<li>大约<code>10%</code>的有效码位有对应的字符</li>
<li>使用内置的<code>ord()</code>函数可以查看码位的具体值</li>
</ul>
</li>
<li><p><strong>字符的具体表述</strong></p>
<ul>
<li>字符的具体表述取决于所用的<strong>编码</strong></li>
<li><strong>编码</strong>是<strong>在码位和字节序列之间转换时使用的算法</strong></li>
<li>例如，A(<code>U+0041</code>)的码位编码成单个字节<code>\x41</code>，而在UTF-16LE编码中编码成两个字节<code>\x41\x00</code></li>
<li>再例如，欧元符号(<code>U+20AC</code>)再UTF-8编码中是三个字节:<code>\xe2\x82\xac</code>，而在UTF-16LE中编码成两个字节：<code>\xac\x200</code></li>
</ul>
</li>
</ul>
</li>
<li><p>把码位转换成字节序列的过程叫做<strong>编码</strong>，把字节序列转换成码位的过程是<strong>解码</strong></p>
</li>
<li><p>示例：编码与解码</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'café'</span></span><br><span class="line">&gt;&gt;&gt;len(s)</span><br><span class="line"><span class="number">4</span>                                                                                                                                     </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = s.encode(<span class="string">'utf8'</span>)                                                                                                </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b                                                                                                                   </span><br><span class="line"><span class="string">b'caf\xc3\xa9'</span></span><br><span class="line">&gt;&gt;&gt;len(b)</span><br><span class="line"><span class="number">5</span>                                                                                                          </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b.decode(<span class="string">'utf8'</span>)                                                                                                    </span><br><span class="line"><span class="string">'café'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="4-2-字节概要"><a href="#4-2-字节概要" class="headerlink" title="4.2 字节概要"></a>4.2 字节概要</h3><ul>
<li><p>首先要知道，Python内置了两种基本的二进制序列类型：Python3引入的不可变bytes类型和Python2.6添加的可变bytearray类型</p>
</li>
<li><p>bytes和bytearray对象的各个元素是介于0-255（含）之间的整数</p>
</li>
<li><p>示例：包含5个字节的bytes和bytearray对象</p>
 <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bytes对象可以从str对象使用给定的编码构建</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe = bytes(<span class="string">'café'</span>, encoding=<span class="string">'U8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe</span><br><span class="line"><span class="string">b'caf\xc3\xa9'</span></span><br><span class="line"><span class="comment"># 各个元素是range(256)内的整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe[<span class="number">0</span>]</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="comment"># bytes对象的切片还是bytes对象，即使是只有一个字节的切片</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe[:<span class="number">1</span>]</span><br><span class="line"><span class="string">b'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_array = bytearray(cafe)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_array</span><br><span class="line"><span class="comment"># bytearray没有字面量句法，而是以bytearray()和字节序列字面量参数的形式表示</span></span><br><span class="line">bytearray(<span class="string">b'caf\xc3\xa9'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_array[<span class="number">0</span>]</span><br><span class="line"><span class="number">99</span></span><br><span class="line"><span class="comment"># bytearray对象的切片还是bytearray对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cafe_array[:<span class="number">1</span>]</span><br><span class="line">bytearray(<span class="string">b'c'</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>注意</p>
<ul>
<li>my_bytes[0]获得的是一个整数，而my_bytes[:1]返回的是一个长度为1的bytes对象——————这一点应该不会十分意外</li>
<li>对于除了str之外的其他序列类型,s[i]返回的都是一个元素，而s[i:i+1]则返回一个序列，里面只有s[i]这个元素</li>
<li>对于str来说,s[i] == s[i:i+1]，它们返回的都是一个只有一个字符的字符串</li>
</ul>
</li>
<li><p>在bytes或者bytearray中，各个字节的值可能会使用下列三种不同的方式显示</p>
<ul>
<li>方式<ol>
<li>可打印的ASCII范围内的字节(从空格到~)，使用ASCII字符本身</li>
<li>制表符、换行符、回车符和<code>\</code>对应的字节，使用转义序列<code>\t</code>、<code>\n</code>、<code>\r</code>、<code>\\</code></li>
<li>其他字节的值，使用十六进制转义序列(例如，\x00是空字节)</li>
</ol>
</li>
<li>例如:字符序列<code>&#39;café&#39;</code>的使用uft8编码的字节序列为<code>b&#39;caf\xc3\xa9&#39;</code>，前3个字节<code>b&#39;caf&#39;</code>在可打印的ASCII范围内，后两个字节则不然</li>
</ul>
</li>
<li><p>除了格式化方法和几个处理unicode数据的方法之外，str类型的其他方法都支持bytes和bytearray类型</p>
</li>
<li><p>构建bytes或bytearay实例可以调用各自的构造方法，传入下述参数</p>
<ul>
<li>一个str对象和一个encoding关键字参数</li>
<li>一个可迭代对象，提供0~255之间的数值</li>
<li>一个实现了缓冲协议的对象(如bytes、bytearray、memoryview、array.array)；此时，把源对象中的字节序列复制到新建的二进制序列中</li>
</ul>
</li>
<li><p>结构体和内存视图</p>
<ul>
<li>struct模块<ul>
<li>struct模块提供了一些函数，把打包的字节序列转换成不同类型的字段组成的元组</li>
<li>struct模块能处理bytes、bytearray和memoryview对象</li>
</ul>
</li>
<li>memoryview类<ul>
<li>memoryview类不是用来创建或储存字节序列，而是共享内存，让你访问其他二进制序列、打包的数组和缓冲中的数据切片，而无需复制字节序列</li>
</ul>
</li>
<li>示例：使用memoryview和struct提取一个GIF图像的宽度和高度  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"><span class="comment"># 结构体的格式：&lt;是小字节符，3s3s是两个3字节序列，HH是两个16位二进制整数</span></span><br><span class="line">fmt = <span class="string">'&lt;3s3sHH'</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'fil.gif'</span>,<span class="string">'rb'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="comment"># 使用内存中的文件内容创建一个memoryview对象</span></span><br><span class="line">    img = memoryview(fp.read())</span><br><span class="line">    <span class="comment"># 使用它的切片再创建一个memoryview对象；这里不会复制字节序列</span></span><br><span class="line">    header = img[:<span class="number">10</span>]</span><br><span class="line">    <span class="comment"># 转换为字节序列</span></span><br><span class="line">    print(bytes(header))</span><br><span class="line">    <span class="comment"># 拆包memoryview对象，得到一个元组，包含类型、版本、宽度和高度</span></span><br><span class="line">    print(struct.unpack(fmt, header))</span><br><span class="line">    <span class="comment"># 删除引用，释放memoryview实例所占用的内存</span></span><br><span class="line">    <span class="keyword">del</span> header</span><br><span class="line">    <span class="keyword">del</span> img</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">b'GIF98a+\x02\xe6\x00'</span></span><br><span class="line"><span class="string">(b'GIF', b'89a', 555, 230)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-基本的编解码器"><a href="#4-3-基本的编解码器" class="headerlink" title="4.3 基本的编解码器"></a>4.3 基本的编解码器</h3><hr>
<ul>
<li><p>Python自带超过100种编解码器(codec, encoder/decoder)，用于在文本和字节之间相互转换</p>
</li>
<li><p>每个编解码器有一个名称，如’utf_8’，而且经常有几个别名，如’utf8’,’utf-8’和’U8’</p>
</li>
<li><p>这些名称可以传给<code>open()</code>、<code>str.encode()</code>、<code>bytes.decode()</code>等函数的encoding参数</p>
</li>
<li><p>示例：使用3个编解码器编码字符串’中国’，而得到的字节序列差异很大</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> codec <span class="keyword">in</span> [<span class="string">'gb2312'</span>, <span class="string">'utf-8'</span>, <span class="string">'utf-16'</span>]:</span><br><span class="line"><span class="meta">... </span>    print(codec, <span class="string">'中国'</span>.encode(codec), sep=<span class="string">'\t'</span>)</span><br><span class="line">...</span><br><span class="line">gb2312  <span class="string">b'\xd6\xd0\xb9\xfa'</span></span><br><span class="line">utf<span class="number">-8</span>   <span class="string">b'\xe4\xb8\xad\xe5\x9b\xbd'</span></span><br><span class="line">utf<span class="number">-16</span>  <span class="string">b'\xff\xfe-N\xfdV'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一些典型的编码</p>
<ul>
<li>如图<br><img src="/2020/02/01/流畅的Python-4-文本和字节序列/编码方式.jpg" alt=""></li>
<li>编码<ol>
<li>latin1(即iso8859_1)：一种重要的编码，是其他编码的基础，例如cp1252和Unicode</li>
<li>cp1252：Microsoft指定的latin1的超集，添加了许多有用的符号</li>
<li>cp437：IBM PC最初的字符集，包含框图符号。与后面出现的latin1不兼容</li>
<li>gb2312：用于编码简体中文的陈旧标准</li>
<li>utf-8：目前web中最常用的8位编码；与ASCII兼容(纯ASCII文本是有效地UTF-8文本)</li>
<li>utf-16le：UTF-16是16位编码方案的一种形式</li>
</ol>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-4-了解编解码问题"><a href="#4-4-了解编解码问题" class="headerlink" title="4.4 了解编解码问题"></a>4.4 了解编解码问题</h3><ul>
<li>简介<ul>
<li>虽然有个一般性的UnicodeError异常，但是报告错误时几乎都会指明具体的异常</li>
<li>UnicodeEncodeError:把字符串转换为二进制序列时发生的异常</li>
<li>UnicodeDecodeError:把二进制序列转换为字符串时发生的异常</li>
<li>SyntaxError:如果源码的编码与预期不符，加载Python模块时还可能抛出SyntaxError</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-4-1-处理UnicodeEncodeError"><a href="#4-4-1-处理UnicodeEncodeError" class="headerlink" title="4.4.1 处理UnicodeEncodeError"></a>4.4.1 处理UnicodeEncodeError</h4><ul>
<li><p>简介</p>
<ul>
<li>多数非UTF编解码器只能处理Unicode字符的小部分子集</li>
<li>把文本转换为字节序列时，如果目标编码中没有定义某个字符，就会抛出UnicodeEncodeError异常，除非把errors参数传给编码方法或函数，对错误进行特殊处理</li>
</ul>
</li>
<li><p>示例：编码成字节序列：成功和错误处理</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>city = <span class="string">'São paulo'</span></span><br><span class="line"><span class="comment"># utf编码可以处理任何字符串</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'utf8'</span>)</span><br><span class="line"><span class="string">b'S\xc3\xa3o paulo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'utf16'</span>)</span><br><span class="line"><span class="string">b'\xff\xfeS\x00\xe3\x00o\x00 \x00p\x00a\x00u\x00l\x00o\x00'</span></span><br><span class="line"><span class="comment"># cp437无法处理'ã'字符，从而抛出UnicodeEncodeError异常</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'cp437'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">File <span class="string">"/usr/lib/python3.6/encodings/cp437.py"</span>, line <span class="number">12</span>, <span class="keyword">in</span> encode</span><br><span class="line">    <span class="keyword">return</span> codecs.charmap_encode(input,errors,encoding_map)</span><br><span class="line">UnicodeEncodeError: <span class="string">'charmap'</span> codec can<span class="string">'t encode character '</span>\xe3<span class="string">' in position 1: character maps to &lt;undefined&gt;</span></span><br><span class="line"><span class="string"># error='</span>ignore<span class="string">'方法悄无声息的跳过无法编码的字符，这样做通常不很妥当</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; city.encode('</span>cp437<span class="string">', errors='</span>ignore<span class="string">')</span></span><br><span class="line"><span class="string">b'</span>So paulo<span class="string">'</span></span><br><span class="line"># error='replace'把无法编码的字符替换成'?'；数据损坏了，但是用户知道出现了问题</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'replace'</span>)</span><br><span class="line"><span class="string">b'S?o paulo'</span></span><br><span class="line"><span class="comment"># 'xmlcharrefreplace'把无法编码的字符替换成了XML实体</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>city.encode(<span class="string">'cp437'</span>, errors=<span class="string">'xmlcharrefreplace'</span>)</span><br><span class="line"><span class="string">b'S&amp;#227;o paulo'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>另外</p>
<ul>
<li>编解码器的错误处理方式时可扩展的。你可以为errors参数注册额外的字符串</li>
<li>方法是把一个名称和一个错误处理函数传给<code>codecs.register_error</code>函数</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-4-2-处理UnicodeDecodeError"><a href="#4-4-2-处理UnicodeDecodeError" class="headerlink" title="4.4.2 处理UnicodeDecodeError"></a>4.4.2 处理UnicodeDecodeError</h4><ul>
<li><p>简介</p>
<ul>
<li>不是每个字节都包含有效的ASCII字符，也不是每个字符序列都是有效的UTF-8或者UTF-16</li>
<li>因此，把二进制序列转换为文本时，如果假设是UTF-8或者UTF-16中的一个，遇到无法转换的字节序列时会抛出UnicodeDecodeError</li>
<li>另一方面，许多陈旧的8位编码——如’cp1252’、’iso8859-1’、’koi8_r’等——能解码任何字节序列流而不抛出错误，因此，如果程序使用错误的8位编码，解码过程悄无声息，而得到的是无用输出</li>
</ul>
</li>
<li><p>鬼符(gremlin)：乱码字符称为鬼符</p>
</li>
<li><p>示例：把字节序列解码成字符串：成功和错误处理</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这些字节序列是使用latin1编码的"Montréal"；'\xe9'字节对应'é'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets = <span class="string">b'Montr\xe9al'</span></span><br><span class="line"><span class="comment"># 可以使用'cp1252'解码，因为它是latin1的有效超集</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'cp1252'</span>)</span><br><span class="line"><span class="string">'Montréal'</span></span><br><span class="line"><span class="comment"># ISO-8859-7用于编码希腊文，因此无法正确解释'\xe9'字节，而且没有抛出错误</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'iso8859_7'</span>)</span><br><span class="line"><span class="string">'Montrιal'</span></span><br><span class="line"><span class="comment"># KOI8-R用来编码俄文，这里'\xe9'对应西里尔字母'И'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'koi8_r'</span>)</span><br><span class="line"><span class="string">'MontrИal'</span></span><br><span class="line"><span class="comment"># 'utf-8'编解码器检测到octets不是有效的utf-8字符串，抛出UnicodeDecodeError</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>octets.decode(<span class="string">'utf_8'</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">UnicodeDecodeError: <span class="string">'utf-8'</span> codec can<span class="string">'t decode byte 0xe9 in position 5: invalid continuation byte</span></span><br><span class="line"><span class="string"># 使用'</span>replace<span class="string">'错误处理方式，`\xe9`替换成了"�"(码位是U+FFFD)，这是官方指定的REPLACEMENT CHARACTER(替换字符)，表示未知字符</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; octets.decode('</span>utf_8<span class="string">', errors='</span>replace<span class="string">')</span></span><br><span class="line"><span class="string">'</span>Montr�al<span class="string">'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="4-4-3-使用预期之外的编码加载模块时抛出的SyntaxError"><a href="#4-4-3-使用预期之外的编码加载模块时抛出的SyntaxError" class="headerlink" title="4.4.3 使用预期之外的编码加载模块时抛出的SyntaxError"></a>4.4.3 使用预期之外的编码加载模块时抛出的SyntaxError</h4><ul>
<li><p>Python源码的默认编码</p>
<ul>
<li>Python3默认使用utf-8编码源码</li>
<li>Python2默认使用ASCII</li>
</ul>
</li>
<li><p>如果加载的.py模块中包含utf-8之外的数据会产生SyntaxError异常</p>
<ul>
<li>为了修正这个问题有两种解决办法<ol>
<li>在文件顶部添加一个神奇的coding注释<ul>
<li>例如:<code># coding: cp1252</code></li>
</ul>
</li>
<li>将这个源码的编码方式直接转换成UTF8</li>
</ol>
</li>
</ul>
</li>
<li><p>源码中能否使用非ASCII名称</p>
<ul>
<li>Python3允许源码中使用非ASCII标识符，但是通常Python2不允许这么做</li>
<li>如果代码是开源的，那么标识符应该使用英文，也就是只能使用ASCII字符</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-4-4-如何找出字节序列的编码"><a href="#4-4-4-如何找出字节序列的编码" class="headerlink" title="4.4.4 如何找出字节序列的编码"></a>4.4.4 如何找出字节序列的编码</h4><ul>
<li><p>如何找出字节序列的编码</p>
<ul>
<li>简单来说，不能。必须有人告诉你</li>
</ul>
</li>
<li><p>有些通信协议和文件格式，比如HTTP和XML，包含明确制定内容编码的首部</p>
</li>
<li><p>统一字符编码侦测包Chardet</p>
<ul>
<li>它通过试探和分析编码中字节的特点来确定编码的类型</li>
<li>可以识别所支持的30种编码</li>
<li>Chardet是个Python库，可以在程序中使用，不过它也提供了命令行工具chardetext</li>
</ul>
</li>
</ul>
<hr>
<h4 id="4-4-5-BOM-有用的鬼符"><a href="#4-4-5-BOM-有用的鬼符" class="headerlink" title="4.4.5 BOM:有用的鬼符"></a>4.4.5 BOM:有用的鬼符</h4><ul>
<li>BOM<ul>
<li>就是字节序标识(byte-order mark)，指明编码时使用Intel CPU的大字节序还是小字节序</li>
<li>例如:u16编码开头的`b’\xff\xfe’</li>
</ul>
</li>
<li><p>小字节序和大字节序</p>
<ul>
<li>在小字节序设备中，各个码位的最低有效字节在前面<ul>
<li>例如:字母”E”的码位是U+0049，十进制为69，所以在字节偏移的第二位和第三位编码为69和0</li>
</ul>
</li>
<li>在大字节序CPU中，编码顺序相反</li>
</ul>
</li>
<li><p>为了避免混淆，UTF-16编码在要编码的文本钱吗需要加上特殊的不可见字符ZERO WIDTH NO-BREAK SPACE(U+FEFF)。在小字节序系统中，这个字符编码为<code>b\xff\xfe</code>；而在大字节序系统中，这个编码时<code>b\xfe\xff</code>，以此来进行区分。</p>
</li>
<li><p>UTF-16有两个变种:UTF-16LE，显式地指出使用小字节序；UTF-16BE，显式地指出使用大字节序。如果使用这两种编码，不会生成BOM</p>
</li>
<li><p>与字节序有关个问题只对一个字(word)占多个字节的编码(如utf-16和utf-32)有影响；UTF-8不管使用什么字节序，生成的字节序列都是一致的，所以不需要使用BOM</p>
</li>
</ul>
<hr>
<h3 id="4-5-处理文本文件"><a href="#4-5-处理文本文件" class="headerlink" title="4.5 处理文本文件"></a>4.5 处理文本文件</h3><ul>
<li><p>Unicode三明治</p>
<ul>
<li>处理文本的最佳实践就是”Unicode三明治”</li>
<li>意思是<ol>
<li>要尽早把输入的字节序列解码为字符串</li>
<li>程序的业务逻辑部分只负责处理字符串</li>
<li>对输出来说，要尽量晚地把字符串编码成字节序列</li>
</ol>
</li>
<li>多数web框架都是这样做的，使用框架时很少接触字节序列</li>
</ul>
</li>
<li><p>Python3中的Unicode三明治</p>
<ul>
<li>在Python3中能轻松地采纳Unicode三明治的建议</li>
<li>因为内置的<code>open</code>函数会在读取文件的时候进行必要的解码，以文本模式写入文件的时候还会进行必要的编码</li>
<li>所以调用<code>my_file.read()</code>得到的以及传给<code>my_file.write(text)</code>方法的都是字符串对象</li>
</ul>
</li>
<li><p>默认编码问题</p>
<ul>
<li>如果在打开文件的时候没有指定编码，将使用当前环境的默认编码</li>
<li>在Windows环境下的默认编码是(windows 1252)，而在GNU/Linux或Mac OS X中的默认编码时utf-8</li>
<li>所以需要在多台设备或者多种场合下运行的代码，一定不能依赖默认编码。打开文件时始终应该明确传入<code>encoding=</code>参数</li>
</ul>
</li>
<li><p>继续探究</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认情况下,open函数采用文本模式，返回一个TextIOWrapper对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp = open(<span class="string">'cafe.txt'</span>,<span class="string">'w'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp</span><br><span class="line">&lt;_io.TextIOWrapper name=<span class="string">'cafe.txt'</span> mode=<span class="string">'w'</span> encoding=<span class="string">'utf-8'</span>&gt;</span><br><span class="line"><span class="comment"># 在TextIOWrapper对象上调用write方法返回写入的Unicode字符数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.write(<span class="string">'café'</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> os</span><br><span class="line"><span class="comment"># 在os.stat的报告文件中有5个字节，UTF-8编码的'é'占两个字节:\xc3\xa9</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>os.stat(<span class="string">'cafe.txt'</span>).st_size</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment"># `rb`标识表明在二进制模式中读取文件，返回的是BufferedReader对象而不是TextIOWrapper对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp4 = open(<span class="string">'cafe.txt'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp4</span><br><span class="line">&lt;_io.BufferedReader name=<span class="string">'cafe.txt'</span>&gt;</span><br><span class="line"><span class="comment"># 读取得到的是字节序列，符合预期</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fp4.read()</span><br><span class="line"><span class="string">b'caf\xc3\xa9'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>注意</p>
<ul>
<li>除非想判断编码，否则不要在二进制模式下打开文本文件</li>
<li>即使如此，也应该使用Chardet，而不是重新发明轮子</li>
</ul>
</li>
<li><p>Windows系统的编码问题</p>
<ul>
<li>在Windows中，不仅同一个系统中使用不同的编码(如cp850和cp1252)</li>
<li>还有只支持ASCII和127个额外的字符的代码页，而且不同代码页之间增加的字符也有所不同</li>
</ul>
</li>
<li><p>关于编码默认值的最佳建议是:别依赖默认值，如果遵从Unicode三明治建议，而且始终在程序中显式指定编码，将避免很多问题</p>
</li>
</ul>
<hr>
<h3 id="4-6-为了正确比较而规范化的Unicode字符串"><a href="#4-6-为了正确比较而规范化的Unicode字符串" class="headerlink" title="4.6 为了正确比较而规范化的Unicode字符串"></a>4.6 为了正确比较而规范化的Unicode字符串</h3><ul>
<li><p>因为unicode有组合字符(变音符号和附加到前一个字符上的记号，打印时作为一个整体)，所以字符串比较起来很麻烦</p>
<ul>
<li>例如:<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 = <span class="string">'café'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s2 = <span class="string">'cafe\u0301'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1, s2</span><br><span class="line">(<span class="string">'café'</span>, <span class="string">'café'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>len(s1),len(s2)</span><br><span class="line">(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s1 == s2</span><br><span class="line"><span class="keyword">False</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>这个问题的解决方案是使用unicodedata.normalize函数提供的Unicode规范化，这个函数的第一个参数是这4个字符串中的一个</p>
<ul>
<li>NFC:使用最少的码位构建等价的字符串</li>
<li>NFD：把组合字符分解为基字符和单独的组合字符</li>
<li>NFKC和NFKD：会进行一定的字符替换(略)</li>
</ul>
</li>
<li><p>使用<code>str.casefold()</code>可以把所有的文本都变成小写</p>
</li>
<li><p>使用<code>nfc_equal</code>和<code>fold_equal</code>可以对字符串进行规范化或小写化之后再比较</p>
</li>
</ul>
<hr>
<h3 id="4-7-Unicode文本排序"><a href="#4-7-Unicode文本排序" class="headerlink" title="4.7 Unicode文本排序"></a>4.7 Unicode文本排序</h3><ul>
<li><p>Python比较任何类型的序列时，会一一比较序列里的各个元素，对于字符串来说，比较的是码位</p>
</li>
<li><p>然而不同的地区采用的排序规则可能有所区别</p>
</li>
<li><p>在Python中，非ASCII文本的标准排序方式是使用locale.strxfrm函数，它会把字符串转换成适合所在地域进行比较的形式</p>
</li>
<li><p>PyUCA库使用纯Python实现了Unicode排序算法，它没有考虑地区设置</p>
</li>
</ul>
<h3 id="4-8-Unicode数据库"><a href="#4-8-Unicode数据库" class="headerlink" title="4.8 Unicode数据库"></a>4.8 Unicode数据库</h3><ul>
<li><p>Unicode标准提供了一个完整的数据库</p>
<ul>
<li>不仅包括码位与字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系</li>
<li>例如,Unicode数据库记录了字符是否可以打印，是不是字母、是不是数字，或者是不是其他数值符号</li>
</ul>
</li>
<li><p>unicodedata模块中有几个函数用来获取字符的元数据</p>
<ul>
<li>例如<ul>
<li>字符在标准中的官方名称是不是组合字符</li>
<li>符号对应的人类可读数值(不是码位)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-9-本章小结"><a href="#4-9-本章小结" class="headerlink" title="4.9 本章小结"></a>4.9 本章小结</h3><ul>
<li><p>本章首先澄清了人们对一个字符等于一个字节的误解，我们必须把文本字符串和它们在文件中的二进制序列标书区分开</p>
</li>
<li><p>bytes和bytearray是两种二进制序列类型</p>
</li>
<li><p>编码和解码</p>
</li>
<li><p>UnicodeEncodeError、UnicodeDecodeError和由于Python源码文件编码错误导致的SyntaxError</p>
</li>
<li><p>Chardet包用于检测元数据使用的是什么编码</p>
</li>
<li><p>在打开文件时，encoding-关键字参数不是必需的，但是应该指定。不然不一致的默认编码会导致跨平台不兼容性</p>
</li>
<li><p>文本比较很复杂，因为Unicode为某些字符提供了不同的表示，所以匹配文本之前一定要先规范化</p>
</li>
<li><p>Unicode数据库包括码位与字符名称之间的映射，还有各个字符的元数据，以及字符之间的关系</p>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/流畅的Python-3-字典和集合/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/流畅的Python-3-字典和集合/" itemprop="url">[流畅的Python][3][字典和集合]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T20:34:21+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/流畅的Python/" itemprop="url" rel="index">
                    <span itemprop="name">流畅的Python</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/流畅的Python-3-字典和集合/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/流畅的Python-3-字典和集合/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第3章-字典和集合"><a href="#第3章-字典和集合" class="headerlink" title="第3章 字典和集合"></a>第3章 字典和集合</h2><blockquote>
<p>字典这个数据结构活跃在所有的python程序背后，即便你的源码中并没有直接用到它。—A.M.Kuching</p>
</blockquote>
<ul>
<li><p>dict类型不但在各种程序里广泛使用，它也是Python语言的基石</p>
</li>
<li><p>模块的命名空间、实例的属性和函数的关键字参数里都可以看到字典的影子</p>
</li>
<li><p>正因为字典至关重要，Python对它的实现做了高度优化，而散列表则是字典类型性能出众的根本原因</p>
</li>
<li><p>集合(set)的实现也依赖于散列表</p>
</li>
</ul>
<hr>
<h3 id="3-1-泛映射类型"><a href="#3-1-泛映射类型" class="headerlink" title="3.1 泛映射类型"></a>3.1 泛映射类型</h3><ul>
<li><p>抽象基类</p>
<ul>
<li><p>collections.abc模块中有Maping和MutableMapping这两个抽象基类，它们的作用是为dict和其他类似的类型定义<strong>形式接口</strong>，如图<br>![]</p>
</li>
<li><p>然而，非抽象映射类型一般不会直接继承这些抽象基类，它们会直接对dict或是collections.UserDict进行扩展。这些抽象基类的主要作用是作为形式化文档，它们定义了构建一个映射类型所需要的最基本的接口。</p>
</li>
<li><p>他们还可以跟isinstance一起被用来判定某个数据是不是广义上的映射类型</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_dict = &#123;&#125;</span><br><span class="line">print(isinstance(my_dict,abc.Mapping))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>标准库里的所有映射类型都是利用<strong>dict</strong>来实现的，因此它们有个共同的限制，即只有<strong>可散列的数据类型</strong>才能作为这些映射里的键</p>
</li>
<li><p>什么是可散列的数据类型</p>
<ul>
<li>如果一个对象是可散列的，那么在这个对象的生命周期中，它的散列值是不变的，而且这个对象需要实现<code>__hash()__</code>方法</li>
<li>另外可散列对象还要有<code>__eq()__</code>方法，这样才能跟其他键做比较</li>
<li><strong>原子不可变数据类型</strong>都是可散列的,如：<code>str</code>、<code>bytes</code>和数值类型</li>
<li><strong>元组</strong>的话，只有当一个元组包含的所有元素都是可散列类型的情况下，它才是可散列的</li>
<li>一般来讲<strong>用户自定义的数据类型</strong>都是可散列的，散列值就是它们的<code>id()</code>函数的返回值，所以所有这些对象在比较的时候都是不相等的</li>
</ul>
</li>
<li><p>字典的多种<strong>构造方法</strong></p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = dict(one=<span class="number">1</span>, two=<span class="number">2</span>, three=<span class="number">3</span>)</span><br><span class="line">b = &#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;</span><br><span class="line">c = dict(zip([<span class="string">'one'</span> ,<span class="string">'two'</span> ,<span class="string">'three'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))</span><br><span class="line">d = dict([(<span class="string">'two'</span>, <span class="number">2</span>), (<span class="string">'one'</span>, <span class="number">1</span>), (<span class="string">'three'</span>,<span class="number">3</span>)])</span><br><span class="line">e = dict(&#123;<span class="string">'one'</span>: <span class="number">1</span>, <span class="string">'two'</span>: <span class="number">2</span>, <span class="string">'three'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">print(a==b==c==d==e)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-2-字典推导"><a href="#3-2-字典推导" class="headerlink" title="3.2 字典推导"></a>3.2 字典推导</h3><ul>
<li><p>字典推导可以从任何以键值对作为元素的可迭代对象中构建出字典</p>
</li>
<li><p>dictcompDemo</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DIAL_CODES = [</span><br><span class="line">    (<span class="number">86</span>, <span class="string">'China'</span>),</span><br><span class="line">    (<span class="number">91</span>, <span class="string">'India'</span>),</span><br><span class="line">    (<span class="number">1</span>, <span class="string">'United States'</span>),</span><br><span class="line">    (<span class="number">62</span>, <span class="string">'Indonesia'</span>),</span><br><span class="line">    (<span class="number">55</span>, <span class="string">'Brazil'</span>),</span><br><span class="line">    (<span class="number">92</span>, <span class="string">'Pakistan'</span>),</span><br><span class="line">    (<span class="number">880</span>, <span class="string">'Bangladesh'</span>),</span><br><span class="line">    (<span class="number">234</span>, <span class="string">'Nigeria'</span>),</span><br><span class="line">    (<span class="number">7</span>, <span class="string">'Russia'</span>),</span><br><span class="line">    (<span class="number">81</span>, <span class="string">'Japan'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里使用国家名作为key,国家码作为value</span></span><br><span class="line">country_code = &#123;country: code <span class="keyword">for</span> code, country <span class="keyword">in</span> DIAL_CODES&#125;</span><br><span class="line">print(country_code)</span><br><span class="line"><span class="comment"># 这里用国家码作为key,并且将国家名称转化为大写,过滤掉区域码大于或等于66的地区</span></span><br><span class="line">code_country = &#123;code: country.upper() <span class="keyword">for</span> country, code <span class="keyword">in</span> country_code.items() <span class="keyword">if</span> code &lt; <span class="number">66</span>&#125;</span><br><span class="line">print(code_country)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">&#123;'China': 86, 'India': 91, 'United States': 1, 'Indonesia': 62, 'Brazil': 55, 'Pakistan': 92, 'Bangladesh': 880, 'Nigeria': 234, 'Russia': 7, 'Japan': 81&#125;</span></span><br><span class="line"><span class="string">&#123;1: 'UNITED STATES', 62: 'INDONESIA', 55: 'BRAZIL', 7: 'RUSSIA'&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-3-常见的映射方法"><a href="#3-3-常见的映射方法" class="headerlink" title="3.3 常见的映射方法"></a>3.3 常见的映射方法</h3><hr>
<ul>
<li><p>dict、defaultdict和OrderedDict的常见方法</p>
<ul>
<li>如图<br><img src="" alt=""></li>
<li>update方法处理参数m的方式，是典型的“鸭子类型”<ol>
<li>函数首先检查m是否有keys方法，如果有，那么update函数就把它当作映射对象来处理</li>
<li>否则，函数会退一步，转而把m当作包含了键值对(key, value)元素的迭代器</li>
<li>因此你既可以用一个映射对象来新建一个映射对象，也可以用包含(key, value)元素的可迭代对象来初始化一个映射对象</li>
</ol>
</li>
</ul>
</li>
<li><p>用setdefault处理找不到的键</p>
<ul>
<li>d.setdefault(k, [default])：若字典中有键k，则直接返回k所对应的值；若无，则让d[k]=default，然后返回default</li>
<li>setdefaultDemo  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段程序用来从文件中统计每个单词出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个选择单词的正则式</span></span><br><span class="line">WORD_RE = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化index字典</span></span><br><span class="line">index = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并按行迭代每个单词</span></span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> enumerate(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            <span class="comment"># 获得这个单词的列坐标</span></span><br><span class="line">            column_no = match.start() + <span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># 获得单词的出现情况表，如果单词不存在，把单词和一个空列表放进映射，然后返回这个空列表，这样就能在不进行第二次查找的情况下更新列表了</span></span><br><span class="line">            index.setdefault(word, []).append(location)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sorted(index, key=str.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li></li>
</ul>
<hr>
<h3 id="3-4-映射的弹性键查询"><a href="#3-4-映射的弹性键查询" class="headerlink" title="3.4 映射的弹性键查询"></a>3.4 映射的弹性键查询</h3><ul>
<li><p>就算某个键在映射中不存在，我们还是希望在通过这个键读取值的时候能得到一个默认值</p>
</li>
<li><p>有两种途径可以帮我们达到这个目的</p>
<ol>
<li>通过defaultdict这个类型而不是普通的dict</li>
<li>给自己定义一个dict的子类，然后在子类中实现<code>__missing__</code>方法</li>
</ol>
</li>
</ul>
<hr>
<h4 id="3-4-1-defaultdict-处理找不到的键的一个选择"><a href="#3-4-1-defaultdict-处理找不到的键的一个选择" class="headerlink" title="3.4.1 defaultdict:处理找不到的键的一个选择"></a>3.4.1 defaultdict:处理找不到的键的一个选择</h4><ul>
<li><p>简介：</p>
<ul>
<li>在实例化一个defaultdict的时候，需要给构造方法提供一个可调用对象</li>
<li>这个可调用对象会在<strong>getitem</strong>碰到找不到的键的时候被调用，让<code>__getitem__</code>返回某种默认值</li>
</ul>
</li>
<li><p>例如:我们新建一个这样的字典,<code>dd = defaultdict(list)</code>，如果键’new-key’在dd中不存在的话，表达式<code>dd[&#39;new-key&#39;]</code>会按照以下步骤来行事</p>
<ol>
<li>调用list()来建立一个新列表</li>
<li>把这个新列表作为值，’new-key’作为它的键，放在dd中</li>
<li>返回这个列表的引用</li>
</ol>
</li>
<li><p>如果在创建defaultdict的时候没有指定default_factory，查询不存在的键会触发keyError</p>
</li>
<li><p>defaultdict里的default_factory只会在<code>__getitem__</code>里被调用，在其他方法里完全不会发挥作用</p>
<ul>
<li>比如，dd是个defaultdict,k是个找不到的键，dd[k]这个表达式会调用default_factory来创建一个默认值，而dd.get(k)则会返回None</li>
</ul>
</li>
<li><p>defaultdictDemo</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这段程序用来从文件中统计每个单词出现的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 声明一个选择单词的正则式</span></span><br><span class="line">WORD_RE = re.compile(<span class="string">r'\w+'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化index字典</span></span><br><span class="line">index = collections.defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开文件并按行迭代每个单词</span></span><br><span class="line"><span class="keyword">with</span> open(sys.argv[<span class="number">1</span>], encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> fp:</span><br><span class="line">    <span class="keyword">for</span> line_no, line <span class="keyword">in</span> enumerate(fp, <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> match <span class="keyword">in</span> WORD_RE.finditer(line):</span><br><span class="line">            word = match.group()</span><br><span class="line">            <span class="comment"># 获得这个单词的列坐标</span></span><br><span class="line">            column_no = match.start() + <span class="number">1</span></span><br><span class="line">            location = (line_no, column_no)</span><br><span class="line">            <span class="comment"># 获得此单词在字典中的value,若之前不存在就设置为[],并返回</span></span><br><span class="line">            index[word].append(location)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看结果</span></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> sorted(index, key=str.upper):</span><br><span class="line">    print(word, index[word])</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-4-2-特殊方法-missing"><a href="#3-4-2-特殊方法-missing" class="headerlink" title="3.4.2 特殊方法__missing__"></a>3.4.2 特殊方法<code>__missing__</code></h4><ul>
<li><p>所有的映射类型在处理找不到的键的时候，都会牵扯到<code>__missing__</code>方法</p>
</li>
<li><p>虽然基类dict并没有定义这个方法，但是dict是知道有这么个东西存在的</p>
<ul>
<li>也就是说，如果有一个类继承了dict，然后这个继承类提供了<code>__missing__</code>方法，那么在<code>__getitem__</code>碰到找不到的键的时候，Python会自动调用它，而不是抛出一个KeyError异常</li>
</ul>
</li>
<li><p><code>__missing__</code>方法只会被<code>__getitem__</code>调用，提供<strong>missing</strong>方法对<code>get</code>或者<code>__contains__</code>这些方法的使用没有影响</p>
</li>
<li><p>missingDemo</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># StrKeyDict在查询的时候会把非字符串的键转换为字符串</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># StrKeyDict继承自dict</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict0</span><span class="params">(dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 如果找不到的键本身就是字符串,那就抛出KeyError异常</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="comment"># 如果找不到的键不是字符串,就把它转换为字符串再查找</span></span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, key, default=None)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># get方法把查找工作用self[key]的形式委托给`__getitem__`，这样就宣布了查找失败之前,还能通过`__missing__`再给某个键一个机会</span></span><br><span class="line">            <span class="keyword">return</span> self[key]</span><br><span class="line">        <span class="keyword">except</span> KeyError:</span><br><span class="line">            <span class="comment"># 如果抛出异常,那么说明__missing__也失败了,于是返回default</span></span><br><span class="line">            <span class="keyword">return</span> default</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 先按照传入键的原本的值来查找，如果没有找到，再用str()方法把键转换成字符串再查找一次</span></span><br><span class="line">        <span class="keyword">return</span> item <span class="keyword">in</span> self.keys() <span class="keyword">or</span> str(item) <span class="keyword">in</span> self.keys()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用尝试1</span></span><br><span class="line">d = StrKeyDict0([(<span class="string">'2'</span>, <span class="string">'two'</span>), (<span class="number">4</span>, <span class="string">'four'</span>)])</span><br><span class="line">print(d[<span class="string">'2'</span>])</span><br><span class="line">print(d[<span class="number">4</span>])</span><br><span class="line">print(d[<span class="number">1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string">four</span></span><br><span class="line"><span class="string">Traceback (most recent call last):</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">KeyError: '1'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用尝试2</span></span><br><span class="line">print(d.get(<span class="string">'2'</span>))</span><br><span class="line">print(d.get(<span class="number">4</span>))</span><br><span class="line">print(d.get(<span class="number">1</span>, <span class="string">'N/A'</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">two</span></span><br><span class="line"><span class="string">four</span></span><br><span class="line"><span class="string">N/A</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用尝试3</span></span><br><span class="line">print(<span class="number">2</span> <span class="keyword">in</span> d)</span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> d)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">True</span></span><br><span class="line"><span class="string">False</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>像 k in my_dict().keys()这种操作在Python3中是很快的，因为dict.keys()的返回值是一个’视图’，’视图’就像一个集合，而且跟字典类似的是，在视图里查找一个元素的速度很快</p>
</li>
</ul>
<hr>
<h3 id="3-5-字典的变种"><a href="#3-5-字典的变种" class="headerlink" title="3.5 字典的变种"></a>3.5 字典的变种</h3><ol>
<li><p>collections.OrderedDict</p>
<ul>
<li>这个类型在添加键的时候会保持顺序，因此键的迭代次序总是一致的</li>
</ul>
</li>
<li><p>collectinos.ChainMap</p>
<ul>
<li>该类型可以容纳数个不同的映射对象，然后在进行键查找操作的时候，这些对象会被当作一个整体被逐个查找，直到键被找到为止</li>
<li>例如<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> builtins</span><br><span class="line">pylookup = ChainMap(local(), <span class="keyword">global</span>(), vars(builtins))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>collections.Counter</p>
<ul>
<li>这个映射类型会给键准备一个整数计数器</li>
<li>每次更新一个键的时候都会增加这个计数器</li>
<li>所以这个类型可以用来给可散列对象计数，或者被当成多重集来用</li>
<li>demo<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> collections</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct = collections.Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">5</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'r'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.update(<span class="string">'aaaaazzz'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct</span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'z'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>, <span class="string">'r'</span>: <span class="number">2</span>, <span class="string">'c'</span>: <span class="number">1</span>, <span class="string">'d'</span>: <span class="number">1</span>&#125;)</span><br><span class="line"><span class="comment"># most_common会按照次序返回映射中最常用的n个键和它们的计数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ct.most_common(<span class="number">2</span>)</span><br><span class="line">[(<span class="string">'a'</span>, <span class="number">10</span>), (<span class="string">'z'</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>collections.UserDict</p>
<ul>
<li>这个类其实就是把标准dict用纯Python的方式又实现了一编</li>
</ul>
</li>
</ol>
<hr>
<h3 id="3-6-子类化UserDict"><a href="#3-6-子类化UserDict" class="headerlink" title="3.6 子类化UserDict"></a>3.6 子类化UserDict</h3><hr>
<ul>
<li><p>就创造自定义映射类型来说，以UserDict作为基类，总比以普通的dict作为基类要来得方便</p>
</li>
<li><p>更倾向于从UserDict而不是dict继承的原因是,后者有时会在某些方法的实现上走一些捷径，导致我们不得不在它的子类中重写这些方法，但是UserDict就不会带来这些问题</p>
</li>
<li><p>另外一个值得注意的地方是，UserDict并不是dict的子类，但是UserDict有一个叫做data的属性，是dict的实例，这个属性实际上是UserDict最终存储数据的地方</p>
</li>
<li><p>demo：StrKeyDict</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># StrKeyDict是对UserDict的扩展</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrKeyDict</span><span class="params">(collections.UserDict)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__missing__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(key, str):</span><br><span class="line">            <span class="keyword">raise</span> KeyError(key)</span><br><span class="line">        <span class="keyword">return</span> self[str(key)]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># contains比上一章的实现要简单,因为通过重写setitem,此时可以默认所有的key都是字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__contains__</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> str(key) <span class="keyword">in</span> self.data</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># setitem会把所有的键都转换为字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        self.data[str(key)] = value</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># get方法与父类的get方法完全一致,所以不用再实现一遍</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为UserDict继承的是MutableMapping，所以StrKeyDict里剩下的那些映射类型的方法都是从UserDict、MutableMapping和Mapping这些超类继承而来的</p>
</li>
</ul>
<hr>
<h3 id="3-7-不可变映射类型"><a href="#3-7-不可变映射类型" class="headerlink" title="3.7 不可变映射类型"></a>3.7 不可变映射类型</h3><hr>
<ul>
<li><p>从Python3.3开始，types模块中引入了一个封装类名为MappingProxyType</p>
<ul>
<li>如果给这个类一个映射，它会返回一个只读的映射视图</li>
<li>虽然是个只读视图，但它是动态的</li>
<li>这意味着如果对原映射作出了改动，我们可以通过这个视图观察到，但无法通过这个视图对原映射作出修改</li>
</ul>
</li>
<li><p>demo:用MappingProxyType来获取字典的只读实例mappingproxy</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> types <span class="keyword">import</span> MappingProxyType</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = &#123;<span class="number">1</span>:<span class="string">'A'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy = MappingProxyType(d)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>&#125;)</span><br><span class="line"><span class="comment"># d中的内容在d_proxy中可以看到</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">1</span>]</span><br><span class="line"><span class="string">'A'</span></span><br><span class="line"><span class="comment"># 但是通过d_proxy不能对它作出任何修改</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>] = <span class="string">'B'</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'mappingproxy'</span> object does <span class="keyword">not</span> support item assignment</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d[<span class="number">2</span>] = <span class="string">'B'</span></span><br><span class="line"><span class="comment"># d_proxy是动态的，也就是说对d所做的任何改动都会反馈到它的上面</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy</span><br><span class="line">mappingproxy(&#123;<span class="number">1</span>: <span class="string">'A'</span>, <span class="number">2</span>: <span class="string">'B'</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d_proxy[<span class="number">2</span>]</span><br><span class="line"><span class="string">'B'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h3 id="3-8-集合论"><a href="#3-8-集合论" class="headerlink" title="3.8 集合论"></a>3.8 集合论</h3><ul>
<li><p>set和它的不可变姊妹类型frozenset直到Python2.3才首次以模块的形式出现,然后在Python2.6中它们升级为内置类型</p>
</li>
<li><p>集合的本质是许多唯一对象的聚集。因此，集合可以用来去重:</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'spam'</span>, <span class="string">'spam'</span>, <span class="string">'eggs'</span>, <span class="string">'spam'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(l)</span><br><span class="line">&#123;<span class="string">'spam'</span>, <span class="string">'eggs'</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(set(l))</span><br><span class="line">[<span class="string">'spam'</span>, <span class="string">'eggs'</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>集合中的元素必须是可散列的，set类型本身是不可散列的，但是frozenset可以，因此可以创建一个包含不同frozenset的set</p>
</li>
<li><p>除了保证唯一性，集合还实现了许多基础的中缀运算符</p>
<ul>
<li><code>a | b</code> 返回它们的合集</li>
<li><code>a &amp; b</code> 得到的是交集</li>
<li><code>a - b</code> 得到的是差集</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-8-1-集合字面量"><a href="#3-8-1-集合字面量" class="headerlink" title="3.8.1 集合字面量"></a>3.8.1 集合字面量</h4><ul>
<li><p>除了空集之外，集合的字面量—————{1}、{1, 2}，等等，看起来跟它的数学形式一模一样；如果是空集，那么必须写成set()形式</p>
</li>
<li><p>如果要创建一个空集，必须使用不带任何参数的构造方法set()。如果只是写成{}的形式，跟以前一样，你创建的其实是空字典</p>
</li>
<li><p>除了空集，集合的字符串表示形式总是以{…}的形式出现</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = &#123;<span class="number">1</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(s)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">set</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">s</span></span></span><br><span class="line">&#123;1&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.pop()</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s</span><br><span class="line">set()</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>像{1, 2, 3}这样字面量句法相比于构造方法<code>set([1, 2, 3])</code>要更快且更易读</p>
<ul>
<li>针对{1, 2, 3}这样的字面量，Python会利用一个专门的叫做BUILD_SET的字节码来创建集合</li>
</ul>
</li>
<li><p>由于Python没有针对frozenset的特殊字面量句法，我们只能采用构造函数</p>
  <figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>frozenset(range(<span class="number">10</span>))</span><br><span class="line">frozenset(&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-8-2-集合推导"><a href="#3-8-2-集合推导" class="headerlink" title="3.8.2 集合推导"></a>3.8.2 集合推导</h4><ul>
<li>示例<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从unicodedata模块中导入name函数，用以获得字符的名字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> unicodedata <span class="keyword">import</span> name</span><br><span class="line"><span class="comment"># 把编码在32-255之间的字符的名字里有"SIGN"的单词挑出来，放到一个集合中</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;chr(i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">32</span>, <span class="number">256</span>) <span class="keyword">if</span> <span class="string">'SIGN'</span> <span class="keyword">in</span> name(chr(i), <span class="string">''</span>)&#125;</span><br><span class="line">&#123;<span class="string">'$'</span>, <span class="string">'µ'</span>, <span class="string">'¬'</span>, <span class="string">'÷'</span>, <span class="string">'&lt;'</span>, <span class="string">'§'</span>, <span class="string">'×'</span>, <span class="string">'='</span>, <span class="string">'¢'</span>, <span class="string">'¶'</span>, <span class="string">'%'</span>, <span class="string">'+'</span>, <span class="string">'£'</span>, <span class="string">'±'</span>, <span class="string">'&gt;'</span>, <span class="string">'#'</span>, <span class="string">'®'</span>, <span class="string">'©'</span>, <span class="string">'¤'</span>, <span class="string">'°'</span>, <span class="string">'¥'</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h4 id="3-8-3-集合的操作"><a href="#3-8-3-集合的操作" class="headerlink" title="3.8.3 集合的操作"></a>3.8.3 集合的操作</h4><h3 id="3-9-dict和set的背后"><a href="#3-9-dict和set的背后" class="headerlink" title="3.9 dict和set的背后"></a>3.9 dict和set的背后</h3><hr>
<h4 id="3-9-1-一个关于效率的实验"><a href="#3-9-1-一个关于效率的实验" class="headerlink" title="3.9.1 一个关于效率的实验"></a>3.9.1 一个关于效率的实验</h4><ul>
<li><p>用in运算符在5个不同大小的haystack字典里搜索1000个元素所需要的时间</p>
</li>
<li><p>在5个不同大小的haystack里搜索1000个元素所需要的时间，haystack分别以字典、集合和列表的形式出现</p>
</li>
</ul>
<hr>
<h4 id="3-9-2-字典中的散列表"><a href="#3-9-2-字典中的散列表" class="headerlink" title="3.9.2 字典中的散列表"></a>3.9.2 字典中的散列表</h4><ul>
<li><p>简介</p>
<ul>
<li>散列表其实是一个稀疏数组(总是有空白元素的数组称为稀疏数组)</li>
<li>在一般的数据结构教材中，散列表里的单元叫做表元(bucket)</li>
<li>在dict的散列表当中，每个键值对都占用一个表元</li>
<li>每个表元都有两个部分，一个是对键的引用，另一个是对值的引用</li>
<li>因为所有表元的大小一致，所以可以通过偏移量来读取某个表元</li>
</ul>
</li>
<li><p>Python会设法保证大概还有三分之一的表元是空的，所以在快要达到这个阈值的时候，原有的散列表会被复制到一个更大的空间中</p>
</li>
<li><p>散列值和相等性</p>
<ul>
<li><p>内置的hash()方法可以用在所有的内置类型对象</p>
</li>
<li><p>如果是自定义对象调用hash()的话，实际上运行的是自定义的<strong>hash</strong></p>
</li>
<li><p>如果两个对象在比较的时候是相等的，那它们的散列值必须相等，否则散列表就不能正常运行了</p>
<ul>
<li>例如，如果 1 == 1.0 成立，那么hash(1) == hash(1.0)也必须成立</li>
</ul>
</li>
<li><p>为了让散列表能够胜任散列表索引这一角色，它们必须在索引空间中尽量分散开来</p>
<ul>
<li>最理想的状况下，越是相似但是不相等的对象，它们散列值的差别应该越大</li>
</ul>
</li>
<li><p>加盐</p>
<ul>
<li>str、bytes和datetime对象的散列值计算有随机的”加盐”这一步</li>
<li>所加盐值是Python进程内的一个常量，但是每次启动Python解释器都会生成一个不同的盐值</li>
<li>随机盐值的加入是为了防止dos攻击而采取的一种安全措施</li>
</ul>
</li>
</ul>
</li>
<li><p>散列表算法</p>
<ul>
<li><p>算法的步骤</p>
<ol>
<li>为了获取my_dict[search_key]背后的值，Python首先会调用hash(search_key)来计算search_key的散列值</li>
<li>然后把散列值的最低几位数字作为偏移量，在散列表里查找表元</li>
<li>若找到的表元为空，则抛出KeyError异常</li>
<li>若不是空的，则表元里会有一对found_key:found_value。这时检测search_key是否等于found_key，如果它们相等的话，就返回found_value</li>
</ol>
</li>
<li><p>另外</p>
<ul>
<li>在插入新值的时候，Python可能会按照散列表的拥挤程度来决定是否要重新分配内存为它扩容，这样做的目的是为了减少散列冲突发生的概率</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h4 id="3-9-3-dict的实现及其导致的结果"><a href="#3-9-3-dict的实现及其导致的结果" class="headerlink" title="3.9.3 dict的实现及其导致的结果"></a>3.9.3 dict的实现及其导致的结果</h4><ol>
<li><p>键必须是可散列的</p>
<ul>
<li>一个可散列的对象需要满足的条件<ol>
<li>支持hash()函数，并且通过<strong>hash</strong>()方法得到的散列值是不变的</li>
<li>支持通过<strong>eq</strong>()方法来检测相等性</li>
<li>若 a==b 为真，则 hash(a) == hash(b) 也为真</li>
</ol>
</li>
<li>所有由用户自定义的对象默认都是可散列的，因为它们的散列值有id()来获取，而且它们是不相等的</li>
<li>如果你实现了一个类的<strong>eq</strong>方法，并且希望它是可散列的，那么它一定要有个恰当的<strong>hash</strong>方法，保证在a==b为真的情况下hash(a)==hash(b)也必定为真</li>
</ul>
</li>
<li><p>字典在内存上的开销巨大</p>
<ul>
<li>由于字典使用了散列表，散列表必须是稀疏的，这导致它在空间上的效率低下</li>
<li>在用户自定义的类型中，<strong>slot</strong>属性可以改变实例属性的存储方式，由dict变成tuple</li>
</ul>
</li>
<li><p>键查询很快</p>
<ul>
<li>dict的实现是典型的空间换时间：字典有巨大的内存开销，但它们提供了无视数据量大小的快速访问————只要字典能被放入内存中</li>
</ul>
</li>
<li><p>键的次序取决于添加顺序</p>
<ul>
<li>这是因为当往dict里添加新键而又发生散列冲突的时候，新键可能会被安排存放到另一个位置</li>
<li>但是即使顺序不同，内容相同的字典也被认为是相等的</li>
</ul>
</li>
<li><p>往字典里添加新键可能会改变原有键的顺序</p>
<ul>
<li>因为往字典中添加键可能会导致字典扩容，从而改变原有键的位置和顺序</li>
<li>所以不要在对字典进行迭代的同时进行修改</li>
</ul>
</li>
</ol>
<hr>
<h4 id="3-9-4-set的实现及其导致的结果"><a href="#3-9-4-set的实现及其导致的结果" class="headerlink" title="3.9.4 set的实现及其导致的结果"></a>3.9.4 set的实现及其导致的结果</h4><ul>
<li><p>set和frozenset的实现也依赖散列表，但在它们的散列表中存放的只有元素的引用</p>
</li>
<li><p>集合的特点</p>
<ol>
<li>集合中的元素必须是可散列的</li>
<li>集合很消耗内存</li>
<li>可以很高效地判断元素是否存在于某个集合</li>
<li>元素的次序取决于被添加到集合里的次序</li>
<li>往集合中添加元素，可能会改变集合里已有元素的顺序</li>
</ol>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/31/SSM-7-MyBatis的解析和运行原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/31/SSM-7-MyBatis的解析和运行原理/" itemprop="url">[SSM][7][MyBatis的解析和运行原理]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-31T16:25:37+08:00">
                2020-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/31/SSM-7-MyBatis的解析和运行原理/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/31/SSM-7-MyBatis的解析和运行原理/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-7-章-MyBatis的解析和运行原理"><a href="#第-7-章-MyBatis的解析和运行原理" class="headerlink" title="第 7 章 MyBatis的解析和运行原理"></a>第 7 章 MyBatis的解析和运行原理</h2><p>MyBatis的运行过程分为两大步</p>
<ol>
<li>读取配置文件缓存到<code>Configuration</code>对象，用以创建<code>SqlSessionFactory</code></li>
<li><code>SqlSession</code>的执行过程</li>
</ol>
<h3 id="7-1-构建SqlSessionFactory过程"><a href="#7-1-构建SqlSessionFactory过程" class="headerlink" title="7.1 构建SqlSessionFactory过程"></a>7.1 构建SqlSessionFactory过程</h3><p><code>SqlSessionFactory</code>是<code>MyBatis</code>的核心类之一，其最重要的功能就是提供创建<code>MyBatis</code>的核心接口<code>SqlSession</code>，所以要先创建<code>SqlSessionFactory</code>，为此要提供配置文件和相关的参数。</p>
<p><code>MyBatis</code>采用了<code>Builder</code>模式去创建<code>SqlSessionFactory</code>，在实际中可以通过<code>SqlSessionF actoryBuilder</code>去构建，其构建分为两步。</p>
<ol>
<li>通过<code>XMLConfigBuilder</code>解析配置的<code>XML</code>文件，读出所配置的参数，并将读取的内容存入<code>Configuration</code> 类对象中。</li>
<li>使用<code>Confinguration</code> 对象去创建<code>SqlSessionFactory</code></li>
</ol>
<h4 id="7-1-1-构建Configuration"><a href="#7-1-1-构建Configuration" class="headerlink" title="7.1.1 构建Configuration"></a>7.1.1 构建Configuration</h4><p>在<code>SqlSessionFactory</code>构建中，<code>Configuration</code>是最重要的，它的作用是：</p>
<ul>
<li>读入配置文件，包括基础配置的<code>XML</code>和映射器<code>XML</code>(或注解)。</li>
<li>初始化一些基础配置，比如<code>MyBatis</code>的别名等，一些重要的类对象(比如插件、映<br>射器、<code>Object</code>工厂、<code>typeHandlers</code>对象等)。</li>
<li>提供单例，为后续创建<code>SessionFactorγ</code>服务，提供配置的参数。</li>
<li>执行一些重要对象的初始化方法。</li>
</ul>
<p><code>Configuration</code>是通过<code>XMLConfigBuilder</code>去构建的，首先它会读出所有<code>XML</code>配置的信息，然后把它们解析并保存在<code>Configuration</code>单例中。它会做如下初始化：</p>
<ul>
<li><code>properties</code> 全局参数。</li>
<li><code>typeAliases</code> 别名。</li>
<li><code>Plugins</code> 插件。</li>
<li><code>objectFactory</code> 对象工厂。</li>
<li><code>objectWrapperFactory</code> 对象包装工厂。</li>
<li><code>reflectionFactory</code> 反射工厂。</li>
<li><code>settings</code> 环境设置。</li>
<li><code>environments</code> 数据库环境。</li>
<li><code>databaseldProvider</code> 数据库标识。</li>
<li><code>typeHandlers</code> 类型转换器。</li>
<li><code>Mappers</code> 映射器。</li>
</ul>
<p>它们都会以类似<code>typeHandler</code>注册那样的方法被存放到<code>Configuration</code>单例中，以便未来将其取出。</p>
<h4 id="7-1-2-构建映射器的内部组成"><a href="#7-1-2-构建映射器的内部组成" class="headerlink" title="7.1.2 构建映射器的内部组成"></a>7.1.2 构建映射器的内部组成</h4><p>当<code>XMLConfigBuilder</code>解析<code>XML</code>时，会将每一个<code>SQL</code>和其配置的内容保存起来。一般而言，在<code>MyBatis</code>中一条<code>SQL</code>和它相关的配置信息是由3个部分组成的，它们分别是<code>MappedStatement</code>、<code>SqlSource</code>和<code>BoundSql</code></p>
<ul>
<li><code>MappedStatement</code>的作用是保存一个映射器节点(<code>select|insert|delete|update</code>)的内容。它是一个类，包括许多我们配置的<code>SQL</code>、<code>SQL</code>的<code>id</code>、缓存信息、<code>resultMap</code>、<code>parameterType</code>、<code>resultType</code>、<code>resultMap</code>、<code>languageDriver</code>等重要配置内容。</li>
<li><code>SqlSource</code>是提供<code>BoundSql</code>对象的地方，它是<code>MappedStatement</code>的一个属性。它的作用是根据上下文和参数解析生成需要的<code>SQL</code></li>
<li><code>BoundSql</code>是一个结果对象，也就是<code>SqlSource</code>通过解析得到的<code>SQL</code>和参数</li>
</ul>
<p><img src="/2020/01/31/SSM-7-MyBatis的解析和运行原理/200131_0.png" alt=""></p>
<p>对于最终的参数和SQL 都反映在<code>BoundSql</code>类对象上，在插件中往往需要拿到它进而可以拿到当前运行的<code>SQL</code>和参数，从而对运行过程做出必要的修改，来满足特殊的需求</p>
<p><code>BoundSql</code>会提供3个主要的属性：<code>parameterMappings</code>、<code>parameterObject</code>和<code>sql</code></p>
<ol>
<li><code>parameterObject</code>为参数本身，可以传递简单对象、<code>POJO</code>或者<code>Map</code>、<code>＠Param</code>注解的参数</li>
<li><code>parameterMappings</code>是一个<code>List</code>，它的每一个元素都是<code>ParameterMapping</code>对象。对象会描述参数，参数包括属性名称、表达式、<code>javaType</code>、<code>jdbcType</code>、<code>typeHandler</code>等重要信息</li>
<li><code>sql</code>属性就是书写在映射器里面的一条被<code>SqlSource</code>解析后的<code>SQL</code></li>
</ol>
<h3 id="7-2-SqlSession运行过程"><a href="#7-2-SqlSession运行过程" class="headerlink" title="7.2 SqlSession运行过程"></a>7.2 SqlSession运行过程</h3><h4 id="7-2-1-映射器-Mapper-的动态代理"><a href="#7-2-1-映射器-Mapper-的动态代理" class="headerlink" title="7.2.1 映射器(Mapper)的动态代理"></a>7.2.1 映射器(Mapper)的动态代理</h4><p>略(没看懂)</p>
<h4 id="7-2-2-SqlSession下的四大对象"><a href="#7-2-2-SqlSession下的四大对象" class="headerlink" title="7.2.2 SqlSession下的四大对象"></a>7.2.2 SqlSession下的四大对象</h4><p><code>SqlSession</code>的执行过程是通过<code>Executor</code>、<code>StatementHandler</code>、<code>ParameterHandler</code>和<code>ResultSetHandler</code>来完成数据库操作和结果返回的</p>
<ul>
<li><code>Executor</code>代表执行器，由它调度<code>StatementHandler</code>、<code>ParameterHandler</code>、<code>ResultSetHandler</code><br>等来执行对应的<code>SQL</code>。其中<code>StatementHandler</code>是最重要的。</li>
<li><code>StatementHandler</code>的作用是使用数据库的<code>Statement</code>执行操作</li>
<li><code>ParameterHandler</code>是用来处理<code>SQL</code>参数的。</li>
<li><code>ResultSetHandler</code>是进行数据集<code>ResultSet</code>的封装返回处理的，它相当复杂，好在我们不常用它。</li>
</ul>
<h4 id="7-2-3-SqlSession的运行"><a href="#7-2-3-SqlSession的运行" class="headerlink" title="7.2.3 SqlSession的运行"></a>7.2.3 SqlSession的运行</h4><p><img src="/2020/01/31/SSM-7-MyBatis的解析和运行原理/200131_1.png" alt=""></p>
<p><code>SqlSession</code>是通过执行器<code>Executor</code>调度<code>StatementHandler</code>来运行的。而<code>StatementHandler</code>经过3步</p>
<ul>
<li><code>prepared</code>预编译<code>SQL</code></li>
<li><code>parameterize</code>设置参数</li>
<li><code>query/update</code>执行<code>SQL</code></li>
</ul>
<p>其中，<code>parameterize</code>是调用<code>parameterHandler</code>的方法设置的，而参数是根据类型处理器<code>typeHandler</code>处理的。<code>query/update</code>方法通过<code>ResultSetHandler</code>进行处理结果的封装，如果是<code>update</code>语句，就返回整数，否则就通过<code>typeHandler</code>处理结果类型，然后用<code>ObjectFactory</code>提供的规则组装对象，返回给调用者</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/31/SSM-6-动态SQL/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/31/SSM-6-动态SQL/" itemprop="url">[SSM][6][动态SQL]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-31T11:10:49+08:00">
                2020-01-31
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/31/SSM-6-动态SQL/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/31/SSM-6-动态SQL/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第6章-动态SQL"><a href="#第6章-动态SQL" class="headerlink" title="第6章 动态SQL"></a>第6章 动态SQL</h2><p>如果使用<code>JDBC</code>或者类似于<code>Hibernate</code>的其他框架，很多时候要根据需要去拼装<code>SQL</code>,这是一个麻烦的事情。因为某些查询需要许多条件，比如查询角色，可以根据角色名称或者备注等信息查询，当不输入名称时使用名称作条件就不合适了。</p>
<p>通常使用其他框架需要大量的<code>Java</code>代码进行判断，可读性比较差，而<code>MyBatis</code>提供对<code>SQL</code>语句动态的组装能力，使用<code>XML</code>的几个简单的元素，便能完成动态<code>SQL</code>的功能。大量的判断都可以在<code>MyBatis</code>的映射<code>XML</code>里面配置，以达到许多需要大量代码才能实现的功能，大大减少了代码量，这体现了<code>MyBatis</code>的灵活、高度可配置性和可维护性。</p>
<h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><p>MyBatis的动态SQL包括以下一个元素</p>
<table>
<thead>
<tr>
<th>元素</th>
<th>作用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>if</td>
<td>判断语句</td>
<td>单条件分支判断</td>
</tr>
<tr>
<td>choose(when, otherwise)</td>
<td>相当于JAVA中的switch和case语句</td>
<td>多条件分支判断</td>
</tr>
<tr>
<td>trim(where, set)</td>
<td>辅助元素，用于处理特定的SQL组装问题，比如去掉多余的and、or等</td>
<td>用于处理SQL拼装的问题</td>
</tr>
<tr>
<td>foreach</td>
<td>循环语句</td>
<td>在in语句等列举条件常用</td>
</tr>
</tbody>
</table>
<h3 id="6-2-if元素"><a href="#6-2-if元素" class="headerlink" title="6.2 if元素"></a>6.2 if元素</h3><p><code>if</code>元素相当于<code>Java</code>中的<code>if</code>语句，它常与<code>test</code>属性联合使用</p>
<p>下面用一个场景来说明，根据角色名称(<code>roleName</code>)来查找角色，如果<code>roleName</code>不为空，则采取构造对<code>roleName</code>的模糊查询，否则不要去构造这个条件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRoles"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultMap</span>=<span class="string">"roleResultMap"</span>&gt;</span></span><br><span class="line">    select role_no, role_name, note from t_role where 1 = 1</span><br><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName != null and roleName != ''"</span>&gt;</span></span><br><span class="line">        and role_name like concat('%', #&#123;roleName&#125;, '%')</span><br><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-3-choose、when、otherwise元素"><a href="#6-3-choose、when、otherwise元素" class="headerlink" title="6.3 choose、when、otherwise元素"></a>6.3 choose、when、otherwise元素</h3><p><code>choose、when、otherwise</code>元素相当于<code>java</code>中的<code>switch...case...default..</code></p>
<p>下面用一个场景来说明</p>
<ul>
<li>如果角色编号(<code>roleNo</code>)不为空，则只用角色编号作为条件查询。</li>
<li>当角色编号为空，而角色名称不为空，则用角色名称作为条件进行模糊查询。</li>
<li>当角色编号和角色名称都为空，则要求角色备注不为空。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRoles"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span> <span class="attr">resultMap</span>=<span class="string">"roleResultMap"</span>&gt;</span></span><br><span class="line">    select role_no, role_name, note from t_role</span><br><span class="line">    where 1=1</span><br><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"roleNo != null and roleNo != ''"</span>&gt;</span></span><br><span class="line">            and role_no = #&#123;roleNo&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"roleName != null and roleName !=''"</span>&gt;</span></span><br><span class="line">            and role_name like concat('%', #&#123;roleName&#125;, '%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            and note is not null</span><br><span class="line">        <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-4-trim、where、set元素"><a href="#6-4-trim、where、set元素" class="headerlink" title="6.4 trim、where、set元素"></a>6.4 trim、where、set元素</h3><h4 id="6-4-1-where元素"><a href="#6-4-1-where元素" class="headerlink" title="6.4.1 where元素"></a>6.4.1 where元素</h4><p>在6.3节的<code>SQL</code>语句上的动态元素的<code>SQL</code>中都加入了一个条件<code>1=1</code>，如果没有加入这个条件，那么可能就变为了这样一条错误的语句：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select role_no, role_name, note from t_role where and role_name like concat('%', #&#123;roleName&#125;, '%')</span><br></pre></td></tr></table></figure></p>
<p>我们可以使用<code>where</code>元素来避免加入<code>1=1</code>这个条件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRoles"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span> <span class="attr">resultMap</span>=<span class="string">"roleResultMap"</span>&gt;</span></span><br><span class="line">    select role_no, role_name, note from t_role</span><br><span class="line">    <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName != null and roleName !=''"</span>&gt;</span></span><br><span class="line">            and role_name like concat('%', #&#123;roleName&#125;, '%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null and note !=''"</span>&gt;</span></span><br><span class="line">            and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当<code>where</code>元素里面的条件成立时，才会加入<code>where</code>这个<code>SQL</code>关键字到组装的<code>SQL</code>里面，否则就不加入</p>
<h4 id="6-4-2-trim元素"><a href="#6-4-2-trim元素" class="headerlink" title="6.4.2 trim元素"></a>6.4.2 trim元素</h4><p>有时候要去掉的是一些特殊的<code>SQL</code>语法，比如常见的<code>and</code>、<code>or</code>。而使用<code>trim</code>元素也可以达到预期效果</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRoles"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultMap</span>=<span class="string">"roleResultMap"</span>&gt;</span></span><br><span class="line">    select role_no, role_name, note from t_role</span><br><span class="line">    <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName != null and roleName !=''"</span>&gt;</span></span><br><span class="line">            and role_name like concat('%', #&#123;roleName&#125;, '%')</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>trim</code>代表要去掉一些特殊的字符串</li>
<li><code>prefix</code>代表的是语句的前缀，而<code>prefixOverrides</code>代表的是要去掉哪种字符串</li>
</ul>
<h4 id="6-4-3-set元素"><a href="#6-4-3-set元素" class="headerlink" title="6.4.3 set元素"></a>6.4.3 set元素</h4><p>在<code>Hibernate</code>中常常因为要更新某一对象，而发送所有的字段给持久对象，而现实中的场景是，只想更新某一个字段。在<code>MyBatis</code>中， 常常可以使用<code>set</code>元素来避免这样的问题，比如要更新一个角色的数据<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    update t_role</span><br><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"roleName != null and roleName !=''"</span>&gt;</span></span><br><span class="line">            role_name = #&#123;roleName&#125;,</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"note != null and note != ''"</span>&gt;</span></span><br><span class="line">            note = #&#123;note&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    where role_no = #&#123;roleNo&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="6-5-foreach元素"><a href="#6-5-foreach元素" class="headerlink" title="6.5 foreach元素"></a>6.5 foreach元素</h3><p><code>foreach</code>元素是一个循环语旬，它的作用是遍历集合，它能够很好地支持数组和<code>List</code>、<code>Set</code>接口的集合，对此提供遍历功能。它往往用于<code>SQL</code>中的<code>in</code>关键字。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findUserBySex"</span> <span class="attr">resultType</span>=<span class="string">"user"</span>&gt;</span></span><br><span class="line">    select * from t role where role no in</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"roleNo"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"roleNoList"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;roleNo&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>collection</code>配置的<code>roleNoList</code>是传递进来的参数名称，它可以是一个数组、<code>List</code>、<code>Set</code>等集合</li>
<li><code>index</code>配置的是循环中当前的元素</li>
<li><code>index</code>配置的是当前元素在集合的位置下标</li>
<li><code>open</code>和<code>close</code>配置的是以什么符号将这些集合元素包装起来</li>
<li><code>separator</code>是各个元素的间隔符</li>
</ul>
<p>在<code>SQL</code>中常常用到<code>in</code>语句，但是对于大量数据的<code>in</code>语句要特别注意，因为它会消耗大量的性能</p>
<h3 id="6-6-用test的属性判断字符串"><a href="#6-6-用test的属性判断字符串" class="headerlink" title="6.6 用test的属性判断字符串"></a>6.6 用test的属性判断字符串</h3><p><code>test</code>用于条件判断语句，作用相当于判断真假</p>
<h3 id="6-7-bind元素"><a href="#6-7-bind元素" class="headerlink" title="6.7 bind元素"></a>6.7 bind元素</h3><p>在进行模糊查询时，如果是<code>MySQL</code>数据库，常常用到的是一个<code>concat</code>，它用<code>%</code>和参数相连。然而在<code>Oracle</code>数据库则没有，<code>Oracle</code>数据库用连接符号<code>||</code>，这样<code>SQL</code>就需要提供两种形式去实现。但是有了<code>bind</code>元素，就不必使用数据库的语言，而是使用<code>MyBatis</code>的动态<code>SQL</code>即可完成。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRole"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"com.bean.RoleBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"pattern"</span> <span class="attr">value</span>=<span class="string">"'%' + _parameter + '%'"</span>&gt;</span></span><br><span class="line">    SELECT id, role_name as roleName, create_date as createDate, end_date as endFlag, note FROM t_role</span><br><span class="line">    WHERE role_name like #&#123;pattern&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的<code>_parameter</code>代表的是传递进来的参数，它和通配符(<code>%</code>)连接后赋给了<code>pattern</code>,然后就可以在<code>select</code>语句中使用这个变量进行模糊查询了。无论是<code>MySQL</code>还是<code>Oracle</code>都可以使用这样的语旬，提高了代码的可移植性。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/30/SSM-5-映射器/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/30/SSM-5-映射器/" itemprop="url">[SSM][5][映射器]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-30T17:30:16+08:00">
                2020-01-30
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/30/SSM-5-映射器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/30/SSM-5-映射器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第5章-映射器"><a href="#第5章-映射器" class="headerlink" title="第5章 映射器"></a>第5章 映射器</h2><p>映射器由一个接口加上 <code>XML</code> 文件(或者注解)组成。在映射器中可以配置参数、各类的<code>SQL</code>语句、存储过程、缓存、级联等复杂的内容，并且通过简易的映射规则映射到指定的<code>POJO</code>或者其他对象上，映射器能有效消除<code>JDBC</code>底层的代码。</p>
<p><code>MyBatis</code>的映射器也可以使用注解完成，但是应用不广，原因主要来自3个方面</p>
<ol>
<li>面对复杂性，<code>SQL</code>会显得无力，尤其是长<code>SQL</code></li>
<li>注解的可读性较差</li>
<li>在功能上，注解丢失了XML 上下文相互引用的功能</li>
</ol>
<h3 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h3><p>映射器的配备元素如下</p>
<table>
<thead>
<tr>
<th>元素名称</th>
<th>描述</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>select</td>
<td>查询语句</td>
<td>可以自定义参数，返回结果集等</td>
</tr>
<tr>
<td>insert</td>
<td>插入语句</td>
<td>执行后返回一个整数，代表插入的条数</td>
</tr>
<tr>
<td>update</td>
<td>更新语句</td>
<td>执行后返回一个整数，代表删除的条数</td>
</tr>
<tr>
<td>sql</td>
<td>允许定义一部分SQL，然后在其他地方引用它</td>
<td>例如，一张表列名，一次定义，可以在多个SQL语句中使用</td>
</tr>
<tr>
<td>resultMap</td>
<td>用来描述从数据库结果集中来加载对象</td>
<td>它将提供映射规则</td>
</tr>
<tr>
<td>cache</td>
<td>给定命名空间的缓存配置</td>
<td>无</td>
</tr>
<tr>
<td>cache-ref</td>
<td>其他命名空间缓存配置的引用</td>
<td>无</td>
</tr>
</tbody>
</table>
<h3 id="5-2-select元素-查询语句"><a href="#5-2-select元素-查询语句" class="headerlink" title="5.2 select元素(查询语句)"></a>5.2 select元素(查询语句)</h3><h4 id="5-2-1-简单的select元素的应用"><a href="#5-2-1-简单的select元素的应用" class="headerlink" title="5.2.1 简单的select元素的应用"></a>5.2.1 简单的select元素的应用</h4><p>先学习一个简单的例子: 统计用户表中同一个姓氏的用户数量<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"countUserByFirstName"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">    select count(*) total from t_user</span><br><span class="line">    where user_name like concat(#&#123;firstName&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后解释这个例子</p>
<ul>
<li><code>id</code>配合<code>Mapper</code>的全限定名，联合成为一个唯一的标识符，标识这条<code>SQL</code></li>
<li><code>parameterType</code>表示这条<code>SQL</code>接受的参数类型，可以是<code>MyBatis</code>系统定义或自定义的别名，也可以是类的全限定名</li>
<li><code>resultType</code>表示这条<code>SQL</code>返回的结果类型</li>
<li><code>#{firstName}</code>是被传递进去的参数</li>
</ul>
<h4 id="5-2-2-自动映射和驼峰映射"><a href="#5-2-2-自动映射和驼峰映射" class="headerlink" title="5.2.2 自动映射和驼峰映射"></a>5.2.2 自动映射和驼峰映射</h4><p><code>MyBatis</code>提供了自动映射功能，在默认情况下自动映射功能是开启的，使用它的好处是能有效减少大量的映射配置，从而减少工作量</p>
<p>在<code>setting</code>元素中有两个可以配置的选项<code>autoMappingBehavior</code>和<code>mapUnderscoreToCamelCase</code>，它们是控制自动映射和驼峰映射的开关</p>
<p>举个简单的例子来说明自动映射和驼峰映射</p>
<p>首先给出一个简单的<code>POJO</code>，<code>Role</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/**setter and getter**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面通过自动映射完成需求: 通过角色编号获取角色的信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultType</span>=<span class="string">"com.edu.neu.pojo.Role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里原来的列名<code>role_name</code>被别名<code>roleName</code>代替，这样就和<code>POJO</code>上的属性名称保持一致了</li>
</ul>
<p>如果系统都严格按照驼峰命名法，(例如，数据库字段<code>role_name</code>，对应<code>POJO</code>属性名为<code>roleName</code>)，此时可以改写为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id, role_name, note from t_role where id = #&#123;id&#125;</span><br></pre></td></tr></table></figure></p>
<p>自动映射和驼峰映射都建立在SQL列名和POJO属性名的映射关系上，而现实中会更加复杂，此时<code>resultType</code>元素是无法满足这些需求的。如果需要更为强大的映射规则，则需要考虑使用<code>resultMap</code></p>
<h4 id="5-2-3-传递多个参数"><a href="#5-2-3-传递多个参数" class="headerlink" title="5.2.3 传递多个参数"></a>5.2.3 传递多个参数</h4><p>在现实需求中，经常需要传递多个参数。传参方法有4种</p>
<h5 id="5-2-3-1-使用map接口传递多个参数"><a href="#5-2-3-1-使用map接口传递多个参数" class="headerlink" title="5.2.3.1 使用map接口传递多个参数"></a>5.2.3.1 使用map接口传递多个参数</h5><p>可以使用<code>Map</code>接口通过键值对传递多个参数，把接口方法定义为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByMap</span><span class="params">(Map&lt;String, Object&gt; parameterMap)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此时传递给映射器的是一个<code>map</code>对象，使用它在SQL中设置对应的参数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByMap"</span> <span class="attr">parameterType</span>=<span class="string">"map"</span> <span class="attr">resultYpe</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role</span><br><span class="line">    where role_name like concat('%', #&#123;roleName&#125;, '%') and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="5-2-3-2-使用注解传递多个参数"><a href="#5-2-3-2-使用注解传递多个参数" class="headerlink" title="5.2.3.2 使用注解传递多个参数"></a>5.2.3.2 使用注解传递多个参数</h5><p>使用<code>map</code>传递参数的弊病是可读性差，为此<code>MyBatis</code>为开发者提供了一个注解<code>＠Param</code>，可以通过它去定义映射器的参数名称，使用它可以得到更好的可读性，把接口方法定义为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByAnnotation</span> <span class="params">(@Param (<span class="string">"roleName"</span>)</span> String rolename, @<span class="title">Param</span> <span class="params">(<span class="string">"note "</span>)</span> String note)</span>;</span><br></pre></td></tr></table></figure></p>
<p>此时映射文件可以定义为，此时并不需要给出<code>parameterType</code>属性，让<code>MyBatis</code>自动探索即可<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByAnnotation"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role</span><br><span class="line">    where role_name like concat ('%', #&#123;roleName&#125;, '%')</span><br><span class="line">    and note like concat ('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但是这会带来一个麻烦。如果<code>SQL</code>很复杂，拥有大于10个参数，那么接口方法的参数个数就多了，使用起来就很不容易</p>
<h5 id="5-2-3-3-通过JavaBean传递多个参数"><a href="#5-2-3-3-通过JavaBean传递多个参数" class="headerlink" title="5.2.3.3 通过JavaBean传递多个参数"></a>5.2.3.3 通过JavaBean传递多个参数</h5><p>可以通过传递<code>Java Bean</code>的方式来处理参数过多的问题</p>
<p>先定义一个参数的<code>POJO</code>:<code>RoleParams</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleParams</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="comment">/**set ter and getter**/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>把接口方法定义为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findRolesByBean</span><span class="params">(RoleParams roleParam)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>此时映射文件定义为：其中<code>parameterType</code>设置为上文定义的POJO的路径</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findRolesByBean"</span> <span class="attr">parameterType</span>= <span class="string">"com.learn.ssm.chapterS.param.RoleParams"</span></span></span><br><span class="line"><span class="tag"><span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role name as roleName, note from t role</span><br><span class="line">    where role name like concat ('%', #&#123;roleName&#125;, '%')</span><br><span class="line">    and note like concat ('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>引用<code>JavaBean</code>定义的属性作为参数，然后查询<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">RoleParams roleParams = <span class="keyword">new</span> RoleParams();</span><br><span class="line">roleParams.setRoleName(<span class="string">"1"</span>);</span><br><span class="line">roleParams.setNote(<span class="string">"1"</span>);</span><br><span class="line">List&lt;Role&gt; roles = roleMapper.findRolesByBean(roleParams);</span><br></pre></td></tr></table></figure></p>
<h5 id="5-2-3-4-混合使用"><a href="#5-2-3-4-混合使用" class="headerlink" title="5.2.3.4 混合使用"></a>5.2.3.4 混合使用</h5><p>略</p>
<h5 id="5-2-3-5-总结"><a href="#5-2-3-5-总结" class="headerlink" title="5.2.3.5 总结"></a>5.2.3.5 总结</h5><ul>
<li>使用<code>map</code>传递参数导致了业务可读性的丧失，导致后续扩展和维护的困难，在实际的应用中要果断废弃这种方式。</li>
<li>使用<code>@Param</code>注解传递多个参数，受到参数个数(n)的影响。当<code>n&lt;=5</code>时，这是最佳的传参方式，它比用<code>Java Bean</code>更好，因为它更加直观；当<code>n&gt;5</code>时，多个参数将给调用带来困难，此时不推荐使用它。</li>
<li>当参数个数多于5个时，建议使用<code>Java Bean</code>方式。</li>
<li>对于使用混合参数的，要明确参数的合理性。</li>
</ul>
<h4 id="5-2-4-使用resultMap映射结果集"><a href="#5-2-4-使用resultMap映射结果集" class="headerlink" title="5.2.4 使用resultMap映射结果集"></a>5.2.4 使用resultMap映射结果集</h4><p>为了支持复杂的映射，<code>select</code>元素提供了<code>resultMap</code>属性，例子如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.xxx.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleMap"</span> <span class="attr">type</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRoleUseResultMap"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select id, role_name, note from t_role where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>resultMap</code>元素定义了一个<code>roleMap</code>，它的属性<code>id</code>代表它的标识，<code>type</code>代表使用哪个类作为其映射的类</li>
<li>子元素<code>id</code>代表<code>resultMap</code>的主键，而<code>result</code>代表其属性，<code>id</code>和<code>result</code>元素的属性<code>property</code>代表<code>POJO</code>的属性名称，而<code>column</code>代表<code>SQL</code>的列名</li>
<li>在<code>select</code>元素中的属性<code>resultMap</code>制定了采用哪个<code>resultMap</code>作为其映射规则</li>
</ul>
<h4 id="5-2-5-分页参数RowBounds"><a href="#5-2-5-分页参数RowBounds" class="headerlink" title="5.2.5 分页参数RowBounds"></a>5.2.5 分页参数RowBounds</h4><p><code>MyBatis</code>支持分页，它还内置了一个专门处理分页的类<code>RowBounds</code>，使用它十分的简单，只要给接口增加一个<code>RowBounds</code>参数即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Role&gt; <span class="title">findByRowBounds</span><span class="params">(@Param(<span class="string">"roleName"</span>)</span> String rolename, @<span class="title">Param</span><span class="params">(<span class="string">"note"</span>)</span> String note, RowBounds rowBounds)</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findByRowBounds"</span> <span class="attr">resultType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    select id, role_name as roleName, note from t_role</span><br><span class="line">    where role_name like concat('%', #&#123;roleName&#125;, '%')</span><br><span class="line">    and note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意上面代码并没有任何关于<code>RowBounds</code>参数的消息，它是<code>MyBatis</code>的一个附加参数，<code>MyBatis</code>会自动识别它，据此进行分页，测试程序如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RoleMapper roleMapper = sqlSession.getMapper(RoleMapper.class);</span><br><span class="line">RowBounds rowBounds = <span class="keyword">new</span> RowBounds(<span class="number">0</span>, <span class="number">20</span>);</span><br><span class="line">List&lt;Role&gt; roleList = roleMapper.findByRowBounds(<span class="string">"role_name"</span>, <span class="string">"note"</span>, rowBounds);</span><br></pre></td></tr></table></figure>
<p>但是要注意<code>RowBounds</code>分页运用的场景，它只适用于一些小数据量的查询。<code>RowBounds</code>分页的原理是执行<code>SQL</code>的查询后，按照偏移量和限制条数返回查询结果，所以对于大量的数据查询，它的性能并不佳，此时可以通过分页插件去处理，详情可参考本书第8章的内容。</p>
<h3 id="5-3-insert元素-插入语句"><a href="#5-3-insert元素-插入语句" class="headerlink" title="5.3 insert元素(插入语句)"></a>5.3 insert元素(插入语句)</h3><h4 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h4><p>插入数据依赖于<code>insert</code>语句</p>
<h4 id="5-3-2-简单的insert语句的应用"><a href="#5-3-2-简单的insert语句的应用" class="headerlink" title="5.3.2 简单的insert语句的应用"></a>5.3.2 简单的insert语句的应用</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    insert into t_role(role_name, note) values (#&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code>标识出这条<code>SQL</code></li>
<li><code>parameterType</code>代表传入参数类型</li>
</ul>
<h4 id="5-3-3-主键回填"><a href="#5-3-3-主键回填" class="headerlink" title="5.3.3 主键回填"></a>5.3.3 主键回填</h4><p>大多数场景下，我们会为<code>MySQL</code>中的表配置自增主键。而有时候我们需要取出新插入元素的自增主键。</p>
<p><code>JDBC</code>中的<code>Statement</code>对象在执行插入的<code>SQL</code>后，可以通过<code>getGeneratedKeys</code>方法获得数据库生成的主键(需要数据库驱动支持)，这样便能达到获取主键的功能。在<code>insert</code>语句中有一个开关属性<code>useGeneratedKeys</code>，用来控制是否打开这个功能，它的默认值为<code>false</code>。当打开了这个开关，还要配置其属性<code>keyProperty</code>或<code>keyColumn</code>，告诉系统把生成的主键放入哪个属性中，</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line">    insert into t_role(role_name, note) values(#&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="5-3-4-自定义主键"><a href="#5-3-4-自定义主键" class="headerlink" title="5.3.4 自定义主键"></a>5.3.4 自定义主键</h4><p>有时候主键可能依赖于某些规则，比如取消角色表(t_role)的<code>id</code>的递增规则，而将其规则修改为:</p>
<ul>
<li>当角色表记录为空时，<code>id</code>设置为<code>1</code>。</li>
<li>当角色表记录不为空时，<code>id</code>设置为当前<code>id</code>加3<br><code>MyBatis</code>对这样的场景也提供了支持，它主要依赖于<code>selectKey</code>元素进行支持，它允许自定义键值的生成规则。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insertRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">selectKey</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> <span class="attr">resultType</span>=<span class="string">"long"</span> <span class="attr">order</span>=<span class="string">"BEFORE"</span>&gt;</span></span><br><span class="line">        select if(max(id) = null, 1, max(id) + 3) from t_role</span><br><span class="line">    <span class="tag">&lt;/<span class="name">selectKey</span>&gt;</span></span><br><span class="line">    insert into t_role(id, role_name, note) values(#&#123;id&#125;, #&#123;roleName&#125;, #&#123;note&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>它定义了<code>selectKey</code>元素，它的<code>keyProperty</code>指定了采用哪个属性作为<code>POJO</code>的主键。</li>
<li><code>resultType</code>告诉<code>MyBatis</code>将返回一个<code>long</code>型的结果集，而<code>order</code>设置为<code>BEFORE</code>，说明它将于当前定义的<code>SQL</code>前执行。</li>
<li>这里的<code>order</code>配置为<code>BEFORE</code>，说明它会在插入之前会先执行生成主键的<code>SQL</code>，然后插入数据。</li>
</ul>
<h3 id="5-4-update元素和delete元素"><a href="#5-4-update元素和delete元素" class="headerlink" title="5.4 update元素和delete元素"></a>5.4 update元素和delete元素</h3><p><code>update</code>和<code>delete</code>执行完会返回一个整数，用以标识该SQL语句影响数据库的记录行数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateRole"</span> <span class="attr">parameterType</span>=<span class="string">"role"</span>&gt;</span></span><br><span class="line">    update t_role set role_name= #&#123;roleName&#125;, note = #&#123;note&#125;</span><br><span class="line">    where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span>&gt;</span></span><br><span class="line">    delete from t_role where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-5-sql元素"><a href="#5-5-sql元素" class="headerlink" title="5.5 sql元素"></a>5.5 sql元素</h3><p>sql元素的作用在于可以定义一条<code>SQL</code>的一部分，方便后面的SQL引用它，比如最典型的列名。通常情况下要在<code>select</code>、<code>insert</code>等语句中反复编写它们，特别是那些字段较多的表更是如此。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>= <span class="string">"com.RoleMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>= <span class="string">"roleMap"</span> <span class="attr">type</span>= <span class="string">"role"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>= <span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"rolesCols"</span>&gt;</span></span><br><span class="line">        id, role_name, note</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">        select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"rolesCols"</span>/&gt;</span> </span><br><span class="line">        from t_role where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>sql元素还支持变量传递<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"roleCols"</span>&gt;</span></span><br><span class="line">    $&#123;alias&#125;.id, $&#123;alias&#125;.role_name, $&#123;alias&#125;.note</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getRole"</span> <span class="attr">parameterType</span>=<span class="string">"long"</span> <span class="attr">resultMap</span>=<span class="string">"roleMap"</span>&gt;</span></span><br><span class="line">    select <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"roleCols"</span>&gt;</span><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"alias"</span> <span class="attr">value</span>=<span class="string">"r"</span>/&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    from t_role r where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-6-参数"><a href="#5-6-参数" class="headerlink" title="5.6 参数"></a>5.6 参数</h3><h4 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h4><p>一些数据库字段返回为<code>null</code>，而<code>MyBatis</code>系统又检测不到使用何种<code>jdbcType</code>进行处理时，会发生异常的情况，这个时候执行对应的<code>typeHandler</code>进行处理，<code>MyBatis</code>就知道采取哪个<code>typeHandler</code>进行处理了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into t_role(id, role_name, note) values(#&#123;id&#125; , #&#123;roleName, typeHandler=StringTypeHandler&#125;, #&#123;note&#125;)</span><br></pre></td></tr></table></figure></p>
<p>而事实是，大部分情况下都不需要这样编写，因为<code>MyBatis</code>会根据<code>javaType</code>和<code>jdbcType</code>去检测使用哪个<code>typeHandler</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#&#123;age, javaType=int, jdbcType=NUMERIC, typeHandler=MyTypeHandler&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-6-2-存储过程参数支持"><a href="#5-6-2-存储过程参数支持" class="headerlink" title="5.6.2 存储过程参数支持"></a>5.6.2 存储过程参数支持</h4><p>MyBatis对存储过程也进行了支持，在存储过程中存在：输入(IN)参数、输出(OUT)参数和输入输出(INOUT)参数3种类型。</p>
<h4 id="5-6-3-特殊字符串的替换和处理"><a href="#5-6-3-特殊字符串的替换和处理" class="headerlink" title="5.6.3 特殊字符串的替换和处理"></a>5.6.3 特殊字符串的替换和处理</h4><p>在现实中，由于一些因素会造成构成<code>SQL</code>查询的列名发生变化，比如产品类型为大米，查询的列名是重量，而产品类型为灯具，查询的列名是数量，这时候需要构建动态列名。有些企业会将一张很大的数据库表按年份拆分，比如购买记录表(<code>t_purchase records</code>) 。现实中由于记录比较多，可能为了方便按年份拆分为<code>t_purchase_records_ 2016</code> 、<code>t_purchase_records_ 2017</code> 、<code>t_purchase_records_2018</code>等，这时往往需要构建动态表名。</p>
<p>在<code>MyBatis</code>中，构建动态列名常常要传递类似于字符串的<code>columns＝&quot;coll, col2, col3 ...&quot;</code>给<code>SQL</code>，让其组装成为<code>SQL</code>语句。如果不想被<code>MyBatis</code>像处理普通参数一样把它设为<code>&quot;coll, col2, col3 ...&quot;</code>，那么可以写成<code>select ${columns} from t_tablename</code>，这样<code>MyBatis</code>就不会转译<code>columns</code>，而不是作为<code>SQL</code> 的参数进行设置了，这句<code>SQL</code>就会变为<code>select col1, col2, col3 ... from t_tablename</code>。</p>
<h3 id="5-7-resultMap元素"><a href="#5-7-resultMap元素" class="headerlink" title="5.7 resultMap元素"></a>5.7 resultMap元素</h3><p><code>resultMap</code>的作用是定义映射规则、级联的更新、定制类型转化器等。<code>resultMap</code>定义的主要是一个结果集的映射关系，也就是<code>SQL</code>到<code>Java Bean</code>的映射关系定义，它也支持级联等特性。只是<code>MyBatis</code>现有的版本只支持<code>resultMap</code>查询，不支持更新或者保存，</p>
<h4 id="5-7-1-resultMap元素的构成"><a href="#5-7-1-resultMap元素的构成" class="headerlink" title="5.7.1 resultMap元素的构成"></a>5.7.1 resultMap元素的构成</h4><p><code>resultMap</code>元素的子元素<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">idArg</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">arg</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">constructor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">association</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">case</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-7-2-使用map存储结果集"><a href="#5-7-2-使用map存储结果集" class="headerlink" title="5.7.2 使用map存储结果集"></a>5.7.2 使用map存储结果集</h4><p>一般而言，任何<code>select</code>语句都可以使用<code>map</code>存储<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"findColorByNote"</span> <span class="attr">parameterType</span>=<span class="string">"string"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select id, color, note from t_color where note like concat('%', #&#123;note&#125;, '%')</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用map原则上是可以匹配所有的结果集的，但是使用map接口就意味着可读性的下降</p>
<h4 id="5-7-3-使用POJO存储结果集"><a href="#5-7-3-使用POJO存储结果集" class="headerlink" title="5.7.3 使用POJO存储结果集"></a>5.7.3 使用POJO存储结果集</h4><p>使用<code>map</code>方式就意味着可读性的丢失，<code>POJO</code>是最常用的方式。有时候需要更为复杂的映射或者级联，这个时候还可以使用<code>select</code>语句的<code>resultMap</code>属性配置映射集合<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"roleResultMap"</span> <span class="attr">type</span>=<span class="string">"com.learn.Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">column</span>=<span class="string">"id"</span> ／&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"roleName"</span> <span class="attr">column</span>=<span class="string">"role_name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">property</span>=<span class="string">"note"</span> <span class="attr">column</span>=<span class="string">"note"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p><code>resultMap</code>元素的属性<code>id</code>代表这个<code>resultMap</code>的标识，<code>type</code>代表着需要映射的<code>POJO</code>，这里可以使用<code>MyBatis</code>定义好的类的别名，也可以使用自定义的类的全限定名。在映射关系中，<code>id</code>元素表示这个对象的主键，<code>property</code>代表着<code>POJO</code>的属性名称，<code>column</code>表示数据库<code>SQL</code>的列名，于是<code>POJO</code>就和数据库<code>SQL</code>的结果一一对应起来了</p>
<h3 id="5-8-级联"><a href="#5-8-级联" class="headerlink" title="5.8 级联"></a>5.8 级联</h3><p>级联是一个数据库实体的概念。比如角色就需要存在用户与之对应，这样就有角色用户表，一个角色可能有多个用户，这就是一对多的级联；除此之外，还有一对一的级联，比如身份证和公民是一对一的关系。在MyBatis中还有一种被成为鉴定器的级联，它是一种可以选择具体实现类的级联</p>
<p>级联不是必须的，级联的好处是获取关联数据十分便捷，但是级联过多会增加系统的复杂度，同时降低系统的性能</p>
<h4 id="5-8-1-MyBatis中的级联"><a href="#5-8-1-MyBatis中的级联" class="headerlink" title="5.8.1 MyBatis中的级联"></a>5.8.1 MyBatis中的级联</h4><p><code>MyBatis</code>的级联分为3种。</p>
<ul>
<li>鉴别器(<code>discriminator</code>)：它是一个根据某些条件决定采用具体实现类级联的方案，比如体检表要根据性别去区分。</li>
<li>一对一(<code>association</code>)：比如学生证和学生就是一种一对一的级联，雇员和工牌表也是一种一对一的级联。</li>
<li>一对多(<code>collection</code>)：比如班主任和学生就是一种一对多的级联。</li>
</ul>
<p>为了更好地阐述级联，先给出一个雇员级联模型<br><img src="/2020/01/30/SSM-5-映射器/200130_0.png" alt=""></p>
<h4 id="5-8-2-N-1问题"><a href="#5-8-2-N-1问题" class="headerlink" title="5.8.2 N+1问题"></a>5.8.2 N+1问题</h4><p>通过级联，我们可以拿出所有关联数据，但这样会引发性能问题。因为有些性能并不常用，加载它们会多执行几条毫无用处的<code>SQL</code>，导致数据库资源的损耗和系统性能的下降，这就是N+1问题</p>
<p>为了应对N+1问题，MyBatis提供了延迟加载功能</p>
<h4 id="5-8-3-延迟加载"><a href="#5-8-3-延迟加载" class="headerlink" title="5.8.3 延迟加载"></a>5.8.3 延迟加载</h4><p>在<code>MyBatis</code>的<code>setting</code>配置中存在两个元素可以配置级联</p>
<p><code>lazyLoadingEnabled</code>是一个开关，决定开不开启延迟加载，默认值为<code>false</code>，则不开启延迟加载</p>
<p><code>aggressiveLazyLoading</code>配置项是一个层级开关，当设置为<code>true</code>时，它是一个开启了层级开关的延迟加载</p>
<p>此外，在<code>MyBatis</code>中使用<code>fetchType</code>属性，可以处理全局定义无法处理的问题，<code>fetchType</code>出现在级联元素(<code>association</code>、<code>collection</code>)，它存在两个值</p>
<ul>
<li><code>eager</code>，获取当前<code>POJO</code>后立即加载对应数据</li>
<li><code>lazy</code>，获取当前<code>POJO</code>后延迟加载对应的数据</li>
</ul>
<h3 id="5-9-缓存"><a href="#5-9-缓存" class="headerlink" title="5.9 缓存"></a>5.9 缓存</h3><p>在<code>MyBatis</code>中允许使用缓存， 缓存一般都放置在可高速读／写的存储器上，比如服务器的内存，它能够有效提高系统的性能。一般只会把那些常用且命中率高的数据缓存起来，以便将来使用，而不缓存那些不常用且命中率低的数据缓存。</p>
<h4 id="5-9-1-一级续存和二级缓存"><a href="#5-9-1-一级续存和二级缓存" class="headerlink" title="5.9.1 一级续存和二级缓存"></a>5.9.1 一级续存和二级缓存</h4><p>一级缓存是在<code>SqlSession</code>上的缓存，二级缓存是在<code>SqlSessionFactory</code>上的缓存。默认情况下，也就是没有任何配置的情况下，<code>MyBatis</code>系统会开启一级缓存，也就是对于<code>SqlSession</code> 层面的缓存，这个缓存不需要<code>POJO</code>对象可序列化。</p>
<p>为了使<code>SqlSession</code>对象之间共享相同的缓存，有时候需要开启二级缓存，开启二级缓存很简单，只要在映射文件(<code>RoleMapper.xml</code>)上加入代码：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候<code>MyBatis</code>会序列化和反序列化对应的<code>POJO</code>，也就要求<code>POJO</code>是一个可序列化的对象，那么它就必须实现<code>java.io.Serializable</code> 接口。</p>
<h4 id="5-9-2-自定义缓存"><a href="#5-9-2-自定义缓存" class="headerlink" title="5.9.2 自定义缓存"></a>5.9.2 自定义缓存</h4><p><code>MyBatis</code>可以使用自定义的缓存，只是实现类需要实现<code>MyBatis</code>的接口<code>org.apache.ibatis.cache.Cache</code>，让我们看看<code>Cache</code>接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.cache;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"><span class="comment">//获取缓存ID</span></span><br><span class="line"><span class="function">String <span class="title">getld</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//保存对象， key 为键， value 为值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key , Object value)</span></span>;</span><br><span class="line"><span class="comment">//获取缓存数据， key 为键</span></span><br><span class="line"><span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">//删除缓存key 为键</span></span><br><span class="line"><span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"><span class="comment">//清除缓存</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="comment">//获得缓存大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>;</span><br><span class="line"><span class="comment">//获取读／写锁，需要考虑多线程的场景</span></span><br><span class="line"><span class="function">ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>;</span><br></pre></td></tr></table></figure>
<p>在现实中，我们可以使用<code>Redis</code>,<code>MongoDB</code>或者其他常用的缓存，假设存在一个<code>Redis</code>的缓存实现类<code>com.ssm.chapter5.cache.RedisCache</code> ，那么可以这样配置它：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cache</span> <span class="attr">type</span> =<span class="string">"com.ssm.chapterS.cache.RedisCache"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"host"</span> <span class="attr">value</span>=<span class="string">"localhost"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cache</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="5-10-存储过程"><a href="#5-10-存储过程" class="headerlink" title="5.10 存储过程"></a>5.10 存储过程</h3><p>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/24/SSM-4-MyBatis配置/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/24/SSM-4-MyBatis配置/" itemprop="url">[SSM][4][MyBatis配置]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-01-24T10:44:28+08:00">
                2020-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/01/24/SSM-4-MyBatis配置/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/01/24/SSM-4-MyBatis配置/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第4章-MyBatis配置"><a href="#第4章-MyBatis配置" class="headerlink" title="第4章 MyBatis配置"></a>第4章 MyBatis配置</h2><h3 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h3><p>MyBatis配置文件中所有元素清单如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;? xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;properties/&gt;&lt;!--属性--&gt;</span><br><span class="line">    &lt;settings/&gt;&lt;!--设置--&gt;</span><br><span class="line">    &lt;typeAliases/&gt;&lt;!--类型命名--&gt;</span><br><span class="line">    &lt;typeHandlers&gt;&lt;!--类型处理器--&gt;</span><br><span class="line">    &lt;objectFactory/&gt;&lt;!--对象工厂--&gt;</span><br><span class="line">    &lt;plugins/&gt;&lt;!--插件--&gt;</span><br><span class="line">    &lt;environments&gt;&lt;!--配置环境--&gt;</span><br><span class="line">        &lt;environment&gt;&lt;!--环境变量--&gt;</span><br><span class="line">            &lt;transactionManager/&gt;&lt;!--事务管理器--&gt;</span><br><span class="line">            &lt;dataSource/&gt;&lt;!--数据源--&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;environments&gt;</span><br><span class="line">    &lt;databaseIdProvider/&gt;&lt;!--数据库厂商标识--&gt;</span><br><span class="line">    &lt;mappers/&gt;&lt;!--映射器--&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></p>
<p>MyBatis配置项的顺序不能颠倒，否则在启动阶段会发生异常</p>
<h3 id="4-2-properties属性"><a href="#4-2-properties属性" class="headerlink" title="4.2 properties属性"></a>4.2 properties属性</h3><p>properties属性可以给系统配置一些运行参数，可以放在XML文件中，便于参数修改</p>
<p>MyBatis提供3种方式来使用properties</p>
<ul>
<li><code>property</code>子元素</li>
<li><code>properties</code>文件</li>
<li>程序代码传递</li>
</ul>
<h4 id="4-2-1-property子元素"><a href="#4-2-1-property子元素" class="headerlink" title="4.2.1 property子元素"></a>4.2.1 property子元素</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database.driver"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database.url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/mybatisdemo?serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database.username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"database.password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">type</span>=<span class="string">"MyBatisDemo.pojo.Role"</span> <span class="attr">alias</span>=<span class="string">"role"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;database.driver&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;database.url&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;database.username&#125;"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;database.password&#125;"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"MybatisDemo/mapper/RoleMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里使用了元素<code>&lt;properties&gt;</code>下的子元素<code>&lt;property&gt;</code>定义，用字符串<code>database.username</code>定义数据库用户名，然后就可以在数据库定义中引入这个已经定义好的属性参数，如<code>${database.username}</code>，这样可以定义一次到处引用</p>
<h4 id="4-2-2-使用properties文件"><a href="#4-2-2-使用properties文件" class="headerlink" title="4.2.2 使用properties文件"></a>4.2.2 使用properties文件</h4><p>我们可以配置多个键值放在一个properties文件中，也可以把多个键值放到多个properties文件中。</p>
<p>先定义文件jdbc.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">database.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">database.url=jdbc:mysql://localhost:3306/mybatisdemo?serverTimezone=UTC</span><br><span class="line">database.username=root</span><br><span class="line">database.password=123456</span><br></pre></td></tr></table></figure></p>
<p>然后在mybatis中通过<code>&lt;properties&gt;</code>的属性<code>resource</code>来引入这个文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-2-3-使用程序传递方式传递参数"><a href="#4-2-3-使用程序传递方式传递参数" class="headerlink" title="4.2.3 使用程序传递方式传递参数"></a>4.2.3 使用程序传递方式传递参数</h4><p>略</p>
<h4 id="4-2-4-总结"><a href="#4-2-4-总结" class="headerlink" title="4.2.4 总结"></a>4.2.4 总结</h4><p>这三种方式是具有优先级顺序的，MyBatis会根据优先级来覆盖原先配置的属性值。最优先的是使用程序传递的方式，其次是使用<code>properties</code>文件的方式，最后是使用<code>property</code>子元素的方式。</p>
<h3 id="4-3-settings设置"><a href="#4-3-settings设置" class="headerlink" title="4.3 settings设置"></a>4.3 settings设置</h3><p>settings可以深刻影响MyBatis底层的运行，但是在大部分情况下使用默认值就可以运行，所以不需要大量配置，只需要修改常用的规则即可</p>
<p>比如关于缓存的<code>cacheEnabled</code>，关于级联的<code>lazyLoadingEnabled</code>和<code>aggressiveLazyLoading</code>，关于自动映射的<code>autoMappingBehavior</code>和<code>mapUnderscoreToCamelCase</code>等等</p>
<h3 id="4-4-typeAliases别名"><a href="#4-4-typeAliases别名" class="headerlink" title="4.4 typeAliases别名"></a>4.4 typeAliases别名</h3><p>由于类的全限定名很长，所以在大量使用时，一般采用一个简写来代表这个类，这就是别名</p>
<p>在MyBatis的初始化过程中，系统自动初始化了一些别名，例如<code>_int</code>、<code>_int[]</code>、<code>list</code>等，同时，<code>Configure</code>对象也对一些常用的配置类设置了别名，比如事务方式别名、数据源类型别名、缓存策略别名、语言驱动别名等。</p>
<p>MyBatis也提供了用户自定义别名的规则。我们可以通过<code>TypeAliasRegister</code>类的<code>registerAlias</code>方法注册，也可以采用配置文件或者扫描方式来自定义它。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"role"</span> <span class="attr">type</span>=<span class="string">"com.neu.edu.pojo.Role"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"user"</span> <span class="attr">type</span>=<span class="string">"com.neu.edu.pojo.User"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果有很多类需要定义别名，可以通过扫描包的方式来实现<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.neu.edu.pojo"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Mybatis会扫描这个包中的类，将其第一个字母变为小写作为其别名，例如<code>Role</code>的别名会变为<code>role</code>。若出现重名的情况，<code>Mybatis</code>允许使用注解<code>@Alias(&quot;role2&quot;)</code>的方式来进行避免<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">package com.neu.edu.pojo</span><br><span class="line">@Alias(&quot;Role2&quot;)</span><br><span class="line">public Class Role&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="4-5-typeHandler类型转换器"><a href="#4-5-typeHandler类型转换器" class="headerlink" title="4.5 typeHandler类型转换器"></a>4.5 typeHandler类型转换器</h3><p><code>typeHandler</code>的作用是完成<code>jdbcType</code>和<code>javaType</code>之间的相互转换，其中<code>jdbcType</code>用于定义数据库类型，而<code>javaType</code>用来定义Java类型。</p>
<p>系统提供的<code>typeHandler</code>可以覆盖大部分场景的要求，假如有特殊需求，也可以自己定义特殊的转换规则</p>
<p><img src="/2020/01/24/SSM-4-MyBatis配置/200124_0.png" alt=""></p>
<h4 id="4-5-1-系统定义的TypeHandler"><a href="#4-5-1-系统定义的TypeHandler" class="headerlink" title="4.5.1 系统定义的TypeHandler"></a>4.5.1 系统定义的TypeHandler</h4><p>在<code>MyBatis</code>中<code>typeHandler</code>都要实现接口<code>org.apache.ibatis.type.TypeHandler</code>，此接口的定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeHandler</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, T parameter, jdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">T <span class="title">getResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>其中<code>T</code>是泛型，专指<code>javaType</code>，比如我们需要<code>String</code>的时候，实现类可以写为<code>implements TypeHandler&lt;String&gt;</code></li>
<li><code>setParameter</code>方法，是使用<code>typeHandler</code>通过<code>PreparedStatement</code>对象进行设置SQL参数的时候使用的具体方法</li>
<li><code>getResult</code>方法，是从JDBC结果集中获取数据并进行转换，要么使用列名，要么使用下标</li>
</ul>
<p>而<code>MyBatis</code>系统提供的<code>typeHandler</code>都继承了<code>org.apache.ibatis.type.BaseTypeHandler</code></p>
<p>然后，采用<code>org.apache.ibatis.type.TypeHandlerRegister</code>类对象中的<code>register</code>方法进行注册</p>
<h4 id="4-5-2-自定义的TypeHandler"><a href="#4-5-2-自定义的TypeHandler" class="headerlink" title="4.5.2 自定义的TypeHandler"></a>4.5.2 自定义的TypeHandler</h4><ol>
<li><p>首先要自定义一个类，要么实现<code>TypeHandler</code>接口，要么继承<code>BaseTypeHandler</code>类</p>
</li>
<li><p>然后在配置文件中对这个新建的<code>typeHandler</code>进行注册</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> <span class="attr">javaType</span>=<span class="string">"string"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">handler</span>=<span class="string">"com.edu.neu.typeHandler.MyTypeHandler"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置完成后系统就会读取它，当<code>jdbcType</code>和<code>javaType</code>与<code>MyTypeHandler</code>对应的时候，就会启动<code>MyTypeHandler</code></p>
</li>
</ol>
<h4 id="4-5-3-枚举typeHandler"><a href="#4-5-3-枚举typeHandler" class="headerlink" title="4.5.3 枚举typeHandler"></a>4.5.3 枚举typeHandler</h4><p>MyBatis对数据库的Blob字段也进行了支持，它提供了一个<code>BlobTypeHandler</code></p>
<p>在现实中，一次性将大量数据加载到<code>JVM</code>中，会给服务器带来很大压力，所以在更多的时候要考虑使用文件流的形式，这时要将<code>POJO</code>的属性修改为<code>InputStream</code></p>
<h3 id="4-6-ObjectFactory-对象工厂"><a href="#4-6-ObjectFactory-对象工厂" class="headerlink" title="4.6 ObjectFactory(对象工厂)"></a>4.6 ObjectFactory(对象工厂)</h3><p>当创建结果集时，<code>MyBatis</code>会使用一个对象工厂来完成创建这个结果集实例。在默认情况下，<code>MyBatis</code>会使用其定义的对象工厂<code>DefaultObjectFactory</code>来完成对应的工作</p>
<p>MyBatis也允许注册自定义的<code>ObjectFactory</code></p>
<ol>
<li>实现<code>ObjectFactory</code>接口或者继承<code>DefaultObjectFactory</code>类</li>
<li>在配置文件中注册 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">objectFactory</span> <span class="attr">type</span>=<span class="string">"com.edu.neu.MyObjectFactory"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prop1"</span> <span class="attr">value</span>=<span class="string">"value1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">objectFactory</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-7-插件"><a href="#4-7-插件" class="headerlink" title="4.7 插件"></a>4.7 插件</h3><p>插件是<code>MyBatis</code>中最强大和灵活的组件，同时也是最复杂、最难使用的组件，它十分危险，会覆盖<code>MyBatis</code>底层对象的核心方法和属性</p>
<h3 id="4-8-运行环境-Environment"><a href="#4-8-运行环境-Environment" class="headerlink" title="4.8 运行环境(Environment)"></a>4.8 运行环境(Environment)</h3><p>在<code>MyBatis</code>中，运行环境主要的作用是配置数据库信息，它可以配置多个数据库，一般而言只需要配置其中的一个就可以</p>
<p>它下面又分为两个可配置的元素：事务管理器(<code>transactionManager</code>)和数据源(<code>dataSource</code>)</p>
<h4 id="4-8-1-transactionManager-事务管理器"><a href="#4-8-1-transactionManager-事务管理器" class="headerlink" title="4.8.1 transactionManager(事务管理器)"></a>4.8.1 transactionManager(事务管理器)</h4><p>transactionManager提供两个实现类，它需要实现接口<code>Transaction`</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Transaction</span></span>&#123;</span><br><span class="line">    <span class="function">Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">    <span class="function">Integer <span class="title">getTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>它的主要工作就是提交(commit)、回滚(rollback)和关闭(close)</li>
<li><code>MyBatis</code>为<code>Transaction</code>提供了两个实现类:<code>JdbcTransaction</code>和<code>ManagedTransaction</code></li>
<li><code>JdbcTransaction</code>是以JDBC的方式对数据库的提交和回滚进行操作</li>
<li><code>ManagedTransaction</code>的提交和回滚不用任何操作，而是把事务交给容器处理</li>
</ul>
<p>在配置文件中，可以通过如下配置，决定使用哪种<code>Transaction</code>方式<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"MANAGED"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-8-2-environment-数据源环境"><a href="#4-8-2-environment-数据源环境" class="headerlink" title="4.8.2 environment(数据源环境)"></a>4.8.2 environment(数据源环境)</h4><p>environment的主要作用是配置数据库<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"UNPOOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"JNDI"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="4-8-2-1-UNPOOLED"><a href="#4-8-2-1-UNPOOLED" class="headerlink" title="4.8.2.1 UNPOOLED"></a>4.8.2.1 UNPOOLED</h5><p><code>UNPOOLED</code>采用非数据库池的管理方式，每次请求会打开一个新的数据库连接，所以创建会比较慢，在一些对性能没有很高要求的场合可以使用它</p>
<p><code>UNPOOLED</code>类型的数据源可以配置如下几个属性</p>
<ul>
<li><code>driver</code>数据库驱动名</li>
<li><code>url</code>连接数据库的URL</li>
<li><code>username</code>用户名</li>
<li><code>passowrd</code>密码</li>
<li><code>defaultTransactionIsolationLevel</code>默认的连接事务隔离级别</li>
</ul>
<h5 id="4-8-2-2-POOLED"><a href="#4-8-2-2-POOLED" class="headerlink" title="4.8.2.2 POOLED"></a>4.8.2.2 <code>POOLED</code></h5><p>数据源<code>POOLED</code>利用池的概念将<code>JDBC</code>的<code>Connection</code>对象组织起来，它开始会有一些空置并且已经连接好的数据库连接，所以请求时，无须再建立和验证，省去去了创建新的连接实例时所必须的初始化和认证时间</p>
<h5 id="4-8-2-3-JNDI"><a href="#4-8-2-3-JNDI" class="headerlink" title="4.8.2.3 JNDI"></a>4.8.2.3 <code>JNDI</code></h5><p>数据源<code>JNDI</code>的实现是为了能在如<code>EJB</code>或应用服务器这类容器中使用</p>
<h3 id="4-9-databaseIdProvider数据库厂商标识"><a href="#4-9-databaseIdProvider数据库厂商标识" class="headerlink" title="4.9 databaseIdProvider数据库厂商标识"></a>4.9 databaseIdProvider数据库厂商标识</h3><p>此元素主要是支持多种不同厂商的数据库，来提升可移植性</p>
<h3 id="4-10-引入映射器的方法"><a href="#4-10-引入映射器的方法" class="headerlink" title="4.10 引入映射器的方法"></a>4.10 引入映射器的方法</h3><ol>
<li><p>用文件路径引入映射器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resourse</span>=<span class="string">"com/learn/ssm/mapper/roleMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用包名引入映射器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.learn.ssm.mapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用类注册引入映射器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.learn.ssm.mapper.UserMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">class</span>=<span class="string">"com.learn.ssm.mapper.RoleMapper"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用<code>userMapper.xml</code>引入映射器</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/com/learn/ssm/mapper/roleMapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">url</span>=<span class="string">"file:///var/mappers/com/learn/ssm/mapper/userMapper.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/25/SSM-10-装配SpringBean/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/25/SSM-10-装配SpringBean/" itemprop="url">[SSM][10][装配SpringBean]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-12-25T13:01:39+08:00">
                2019-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/12/25/SSM-10-装配SpringBean/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/12/25/SSM-10-装配SpringBean/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="10-装配SpringBean"><a href="#10-装配SpringBean" class="headerlink" title="10 装配SpringBean"></a>10 装配SpringBean</h2><h3 id="10-1-依赖注入的3种方式"><a href="#10-1-依赖注入的3种方式" class="headerlink" title="10.1 依赖注入的3种方式"></a>10.1 依赖注入的3种方式</h3><ul>
<li><p>Spring主要使用依赖注入的方式来完成IoC</p>
</li>
<li><p>依赖注入可以分为3种方式</p>
<ul>
<li>构造器注入</li>
<li><code>setter</code>注入</li>
<li>接口注入</li>
</ul>
</li>
</ul>
<h4 id="10-1-构造器注入"><a href="#10-1-构造器注入" class="headerlink" title="10.1 构造器注入"></a>10.1 构造器注入</h4><ul>
<li><p>简介</p>
<ul>
<li>构造器注入依赖于构造方法的实现</li>
<li>为了让<code>Spring</code>完成对应的构造注入，我们有必要去描述具体的类、构造方法并设置对应的参数，这样<code>Spring</code>就可以通过对应的信息用反射的形式创建对象</li>
</ul>
</li>
<li><p>实例: 构造器注入</p>
<ol>
<li><p>创建一个只有有参构造器的<code>POJO</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">(String roleName, String note)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roleName = roleName;</span><br><span class="line">        <span class="keyword">this</span>.note = note;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*getter and setter*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在<code>spring-config.xml</code>中配置对象</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role1"</span> <span class="attr">class</span>=<span class="string">"Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"总经理"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">value</span>=<span class="string">"公司管理者"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p>构造器配置</p>
<ul>
<li><code>constructor-arg</code>元素用于定义类构造方法的参数</li>
<li><code>index</code>用于定义参数的位置</li>
<li><code>value</code>则是设置值</li>
<li>通过这样的定义Spring便知道使用<code>Role(String, String)</code>这样的构造方法去创建对象</li>
</ul>
</li>
</ul>
<h4 id="10-1-2-使用setter注入"><a href="#10-1-2-使用setter注入" class="headerlink" title="10.1.2 使用setter注入"></a>10.1.2 使用setter注入</h4><ul>
<li><p>简介</p>
<ul>
<li><code>setter</code>注入是Spring中最主流的注入方式，它利用<code>Java Bean</code>规范所定义的<code>setter</code>方法来完成注入，灵活且可读性高</li>
<li>通过Java反射技术,Spring会调用没有参数的构造方法来生成对象，同时通过反射对应的<code>setter</code>注入配置的值</li>
</ul>
</li>
<li><p>实例:配置<code>setter</code>注入</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role2"</span> <span class="attr">class</span>=<span class="string">"Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"高级工程师"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"重要人员"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="10-1-3-接口注入"><a href="#10-1-3-接口注入" class="headerlink" title="10.1.3 接口注入"></a>10.1.3 接口注入</h4><ul>
<li>简介<ul>
<li>有些时候资源并非来自于自身系统，而是来自于外界</li>
<li>比如数据库连接资源完全可以在Tomcat下配置，然后通过JNDI的方式去获取它</li>
</ul>
</li>
</ul>
<h3 id="10-2-装配Bean概述"><a href="#10-2-装配Bean概述" class="headerlink" title="10.2 装配Bean概述"></a>10.2 装配Bean概述</h3><ul>
<li><p>本节需要学习的是如何将自己开发的<code>Bean</code>装配到<code>Spring IoC</code>容器中</p>
</li>
<li><p>Spring提供了3种方法进行配置</p>
<ul>
<li>在XML中显式配置</li>
<li>在Java的接口和类中实现配置</li>
<li>隐式Bean的发现机制和自动装配原则</li>
</ul>
</li>
<li><p>3种方法的优先级</p>
<ol>
<li>基于约定优于配置的原则，最优先的应该是通过隐式Bean的发现机制和自动装配的原则。这样的好处是减少程序开发者的决定权，简单而不失灵活</li>
<li>在没有办法使用自动装配原则的情况下应该优先考虑Java接口和类中实现配置，这样的好处是避免XML配置的泛滥</li>
<li>在上述方法都无法使用的情况下，只能选择XML去配置Spring IoC容器</li>
</ol>
</li>
</ul>
<h3 id="10-3-通过XML配置装配Bean"><a href="#10-3-通过XML配置装配Bean" class="headerlink" title="10.3 通过XML配置装配Bean"></a>10.3 通过XML配置装配Bean</h3><ul>
<li><p>首先给出XML文件的模板</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring Bean 配置代码 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在上述代码中引入了一个<code>beans</code>的定义，它是一个根元素，而XSD文件也被引入了</li>
</ul>
</li>
</ul>
<h4 id="10-3-1-装配简易值"><a href="#10-3-1-装配简易值" class="headerlink" title="10.3.1 装配简易值"></a>10.3.1 装配简易值</h4><ul>
<li><p>示例1: 简易XML装配<code>bean</code></p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"role2"</span> <span class="attr">class</span>=<span class="string">"Role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"roleName"</span> <span class="attr">value</span>=<span class="string">"高级工程师"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"note"</span> <span class="attr">value</span>=<span class="string">"重要人员"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>id</code>属性是<code>Spring</code>对于这个<code>Bean</code>的编号，如果没有显式指定<code>id</code>，则<code>Spring</code>将采用<code>全限定名#{number}</code>的格式生成编号</li>
<li><code>class</code>是一个类的全限定名</li>
<li><code>property</code>元素是定义类的属性，其中<code>name</code>属性定义的是属性名称，而<code>value</code>是属性值</li>
</ul>
</li>
<li><p>示例2: 有时需要向类A中注入自定义的类B</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"source"</span> <span class="attr">class</span>=<span class="string">"Source"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"fruit"</span> <span class="attr">value</span>=<span class="string">"橙汁"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sugar"</span> <span class="attr">value</span>=<span class="string">"少糖"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"size"</span> <span class="attr">value</span>=<span class="string">"大杯"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"juiceMaker"</span> <span class="attr">class</span>=<span class="string">"JuiceMaker"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"beverageShop"</span> <span class="attr">value</span>=<span class="string">"贡茶"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"source"</span> <span class="attr">ref</span>=<span class="string">"source"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过<code>ref</code>属性来引用对应的<code>Bean</code></li>
</ul>
</li>
</ul>
<h4 id="10-3-2-装配集合"><a href="#10-3-2-装配集合" class="headerlink" title="10.3.2 装配集合"></a>10.3.2 装配集合</h4><ul>
<li><p>Spring主要使用下列标签完成对集合的装配</p>
<ol>
<li><code>List</code>标签为对应的<code>&lt;list&gt;</code>元素进行装配，然后通过多个<code>&lt;value&gt;</code>元素设值</li>
<li><code>Map</code>属性为对应的<code>&lt;map&gt;</code>元素进行装配，然后通过多个<code>&lt;entry&gt;</code>元素设值，只是<code>entry</code>包含一个键(key)和一个值(value)的设置。</li>
<li><code>Properties</code>属性，为对应的<code>&lt;properties&gt;</code>元素进行装配，通过多个<code>&lt;property&gt;</code>元素设置，只是<code>prop</code> 元素有一个必填属性<code>key</code>，然后可以设置值。</li>
<li><code>Set</code>属性为对应的<code>&lt;set&gt;</code>元素进行装配，然后通过多个<code>&lt;value&gt;</code>元素设值。</li>
<li>对于数组而言，可以使用<code>&lt;array&gt;</code>设置值，然后通过多个<code>&lt;value&gt;</code>元素设值。</li>
</ol>
</li>
<li><p>示例: 装配集合类</p>
<ol>
<li><p>首先定义一个复杂的类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComplexAssembly</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Long id;</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"><span class="keyword">private</span> Map&lt;String, String&gt; map;</span><br><span class="line"><span class="keyword">private</span> Properties prop;</span><br><span class="line"><span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"><span class="keyword">private</span> String[] array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*getter and setter*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>装配这个集合类</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"complexAssembly"</span> <span class="attr">class</span>=<span class="string">"ComplexAssembly"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">value</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_list_1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_list_2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_list_3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key1"</span> <span class="attr">value</span>=<span class="string">"value_key_1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key2"</span> <span class="attr">value</span>=<span class="string">"value_key_2"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"key3"</span> <span class="attr">value</span>=<span class="string">"value_key_3"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prop"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop1"</span>&gt;</span>value_prop_1<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop2"</span>&gt;</span>value_prop_2<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"prop3"</span>&gt;</span>value_prop_3<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"set"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_set_1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_set_2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_set_3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"array"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_array_1<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_array_2<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>value_array_3<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<h4 id="10-3-3-命名空间装配"><a href="#10-3-3-命名空间装配" class="headerlink" title="10.3.3 命名空间装配"></a>10.3.3 命名空间装配</h4><h3 id="10-4-通过注解装配Bean"><a href="#10-4-通过注解装配Bean" class="headerlink" title="10.4 通过注解装配Bean"></a>10.4 通过注解装配<code>Bean</code></h3><ul>
<li><p>简介: 注解功能更加强大，它既可以实现<code>XML</code>的功能，也提供了自动装配的功能</p>
</li>
<li><p>在<code>Spring</code>中，它提供了两种方式来让<code>Spring IoC</code>容器发现<code>Bean</code></p>
<ul>
<li>组件扫描: 通过定义资源的方式，让<code>Spring IoC</code>容器扫描对应的包，从而把<code>Bean</code>装配进来</li>
<li>自动装配: 通过注解定义，使得一些依赖关系可以通过注解完成</li>
</ul>
</li>
<li><p>通过扫描和自动装配，大部分的工程都可以用<code>Java</code>配置完成，而不是<code>XML</code>，这样可以有效减少配置和引入大量<code>XML</code></p>
</li>
</ul>
<h4 id="10-4-1-使用-Component装配Bean"><a href="#10-4-1-使用-Component装配Bean" class="headerlink" title="10.4.1 使用@Component装配Bean"></a>10.4.1 使用<code>@Component</code>装配<code>Bean</code></h4><ul>
<li><p>示例1: 使用注解装配简单的<code>Bean</code></p>
<ol>
<li><p>定义<code>POJO</code></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Role</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"1"</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"role_name_1"</span>)</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"role_note_1"</span>)</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br></pre></td></tr></table></figure>
<ul>
<li>注解<code>@Component</code>代表<code>Spring IoC</code>会把这个类扫描生成<code>Bean</code>实例，其中的<code>value</code>属性代表这个类在<code>Spring</code>中的<code>id</code></li>
<li>注解<code>@Value</code>代表的是值的注入，这里只是注入了一些简单值</li>
</ul>
</li>
<li><p>定义<code>Java Config</code>类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ComponentScan</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这个类的作用是告诉<code>Spring IoC</code>去哪里扫描对象</li>
<li>注解<code>@ComponentScan</code>代表进行扫描，默认是扫描当前包的路径，<code>POJO</code>的包名和它保持一致时才能扫描</li>
</ul>
</li>
<li>使用注解生成<code>Spring IoC</code>容器 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(PojoConfig.class);</span><br><span class="line">        Role role = ctx.getBean(Role.class);</span><br><span class="line">        System.out.println(role.getNote());</span><br><span class="line">        ((AnnotationConfigApplicationContext) ctx).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li><p><code>@ComponentScan</code>存在着两个配置项</p>
<ul>
<li><code>basePackages</code>: 它可以配置一个Java包的数组，<code>Spring</code>会根据它的配置扫描对应的包和子包，将配置好的<code>Bean</code>装配进来</li>
<li><code>basePackageClasses</code>: 它可以配置多个类，<code>Spring</code>会根据配置的类所在的包，为包和子包进行扫描装配对应的配置<code>Bean</code></li>
<li>如果采用多个<code>@ComponentScan</code>去定义对应的包，但是每定义一个<code>@ComponentScan</code>，<code>Spring</code>就会为所定义的类产生一个新的对象</li>
<li>对于<code>basePackages</code>和<code>basePackageClasses</code>来说，前一种可读性更好，所以会在项目中优先选择前一种</li>
</ul>
</li>
</ul>
<h4 id="10-4-2-自动装配-Autowired"><a href="#10-4-2-自动装配-Autowired" class="headerlink" title="10.4.2 自动装配---@Autowired"></a>10.4.2 自动装配---@Autowired</h4><ul>
<li><p>自动装配简介</p>
<ul>
<li><code>Spring</code>一般先完成<code>Bean</code>的定义和生成，然后再寻找需要注入的资源</li>
<li>当<code>Spring</code>生成所有的<code>Bean</code>后，如果发现这个注解，它就会再<code>Bean</code>中查找，然后找到对应的类型，将其注入进来，这样就完成了依赖注入</li>
<li>所谓自动装配技术是一种由<code>Spring</code>自己发现对应的<code>Bean</code>，自动完成装配工作的方式，它会应用到一个十分常见的注解<code>@Autowired</code></li>
</ul>
</li>
<li><p>示例: 一个简单的自动装配例子</p>
<ol>
<li>定义<code>POJO</code>: 如前文的<code>Role</code>类</li>
<li><p>定义<code>RoleService</code>接口</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>RoleServiceImpl</code>实现类</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"roleServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Role role = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id = "</span> + role.getId());</span><br><span class="line">        System.out.println(<span class="string">"roleName = "</span> + role.getRoleName());</span><br><span class="line">        System.out.println(<span class="string">"note = "</span> + role.getNote());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义<code>Java Config</code>类:略</p>
</li>
<li>测试:略</li>
</ol>
</li>
<li><p>其他</p>
<ul>
<li><code>@Autowired</code>的注解表示在<code>Spring IoC</code>定位所有的<code>Bean</code>后，这个字段需要按类型注入，这样<code>IoC</code>容器会寻找资源，然后将其注入</li>
<li>IoC容器有时候会寻找失败，在默认的情况下寻找失败它就会抛出异常<ul>
<li>通过<code>@Autowired(required=false)</code>配置，可以在找不到资源时，不注入，但这样会产生空指针问题</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="10-4-3-自动装配的歧义性-Primary和-Quaifier"><a href="#10-4-3-自动装配的歧义性-Primary和-Quaifier" class="headerlink" title="10.4.3 自动装配的歧义性(@Primary和@Quaifier)"></a>10.4.3 自动装配的歧义性(<code>@Primary</code>和<code>@Quaifier</code>)</h4><ul>
<li><p>背景: 在java中一个接口可能有多个实现类，这个时候<code>@Autowired</code>注解无法判断应该把哪个实现类的对象注入进来，从而抛出异常</p>
</li>
<li><p>方案1: 注解<code>@Primary</code></p>
<ul>
<li>这个注解会告诉<code>Spring IoC</code>容器，优先使用拥有此注解的类注入</li>
<li>例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Primary</span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"roleService3"</span>)</span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceImpl3</span> <span class="keyword">implements</span> <span class="title">RoleService</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>方案2:注解<code>@Qualifier</code></p>
<ul>
<li>这个注解会使用名称查找而不是类型查找的方式</li>
<li>例如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"roleService3"</span>)</span><br><span class="line">    <span class="keyword">private</span> RoleService roleService = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="10-4-4-装载带有参数的构造方法类"><a href="#10-4-4-装载带有参数的构造方法类" class="headerlink" title="10.4.4 装载带有参数的构造方法类"></a>10.4.4 装载带有参数的构造方法类</h4><ul>
<li><p>背景: 某些时候构造方法是有参数的，对于带参数的构造方法，我们也可以通过注解进行注入</p>
</li>
<li><p>方案: 使用<code>@Autowired</code>或者<code>@Qualifer</code>来修饰参数</p>
</li>
<li><p>例如</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RoleController</span><span class="params">(@Autowired RoleService roleService)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.roleService = roleService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="10-4-5-使用-Bean装配Bean"><a href="#10-4-5-使用-Bean装配Bean" class="headerlink" title="10.4.5 使用@Bean装配Bean"></a>10.4.5 使用<code>@Bean</code>装配<code>Bean</code></h4><ul>
<li><p>背景: 对于java来说，大部分开发都需要引入第三方的包，而且往往没有这些包的源码，这时候无法为这些包的类加入<code>@Component</code>注解，让它们成为开发环境中的<code>Bean</code></p>
</li>
<li><p>方案:这个时候Spring给予一个注解<code>@Bean</code>，它可以注解到方法上，并且将方法返回的对象作为<code>Spring</code>的<code>Bean</code>，存放到<code>IoC</code>容器中</p>
</li>
<li><p>例如: 通过注解<code>@Bean</code>装配<code>DataSource</code>的<code>Bean</code></p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"dataSource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">    props.setProperty(<span class="string">"driver"</span>,<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">    DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这里还配置了<code>@Bean</code>的<code>name</code>选项为<code>dataSource</code>，这就意味着Spring生成该<code>Bean</code>的时候就会使用<code>dataSource</code>作为其<code>BeanName</code>。和其他<code>Bean</code>一样，它也可以通过<code>@Autowired</code>或者<code>@Qualifier</code>等注解注入到别的<code>Bean</code>中</p>
</li>
</ul>
<h3 id="10-5-装配的混合使用"><a href="#10-5-装配的混合使用" class="headerlink" title="10.5 装配的混合使用"></a>10.5 装配的混合使用</h3><p>Spring同时支持XML和注解两种装配方式，无论采用哪种，本质都是将<code>Bean</code>装配到<code>Spring IoC</code>容器中</p>
<p>建议</p>
<ol>
<li>在自己的工程中所开发的类尽量使用注解方法，因为使用它更为简单</li>
<li>对于引入第三方或者服务的类，尽量使用<code>XML</code>方式，这样可以尽量减少对第三方包细节的理解，更清晰</li>
</ol>
<p>如何将<code>xml</code>定义的<code>bean</code>引入<code>java</code>配置中?</p>
<ul>
<li>可以使用注解<code>@ImportResourse</code>，它可以配置多个<code>XML</code>配置文件，将这些文件中定义的<code>bean</code>全部引入</li>
<li>例如  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.annotation.config</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.anotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.anotation.ImportResource;</span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages=&#123;<span class="string">"com.ssm.chapter10.annotation"</span>&#125;)</span><br><span class="line"><span class="meta">@ImportResource</span>(&#123;<span class="string">"classpath:spring-dataSource.xml"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationConfig</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="10-6-使用Profile"><a href="#10-6-使用Profile" class="headerlink" title="10.6 使用Profile"></a>10.6 使用Profile</h3><p>背景: 在软件开发中，可能开发人员使用一套环境，而测试人员使用另一套环境，这就有了在不同的环境中进行切换的需求。Spring也对这样的场景进行了支持，在Spring中可以定义<code>Bean</code>的<code>Profile</code>，方式有两种</p>
<ol>
<li>使用注解<code>@Profile</code>配置</li>
<li>使用<code>xml</code>定义<code>Profile</code></li>
</ol>
<h4 id="10-6-1-使用注解-Profile配置"><a href="#10-6-1-使用注解-Profile配置" class="headerlink" title="10.6.1 使用注解@Profile配置"></a>10.6.1 使用注解@Profile配置</h4><p>例子如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ssm.chapter10.profile;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProfileDataSource</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"devDataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"dev"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDevDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Properties props= <span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">"driver"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://localhost:3306/chapter12"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"username"</span>, <span class="string">"root"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"testDataSource"</span>)</span><br><span class="line">    <span class="meta">@Profile</span>(<span class="string">"test"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">getTestDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Properties props=<span class="keyword">new</span> Properties();</span><br><span class="line">        props.setProperty(<span class="string">"driver"</span>, <span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"url"</span>, <span class="string">"jdbc:mysql://localhost:3306/chapter13"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"username"</span>, <span class="string">"root"</span>);</span><br><span class="line">        props.setProperty(<span class="string">"password"</span>, <span class="string">"123456"</span>);</span><br><span class="line">        DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            dataSource = BasicDataSourceFactory.createDataSource(props);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> dataSource;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-6-2-使用xml定义Profile"><a href="#10-6-2-使用xml定义Profile" class="headerlink" title="10.6.2 使用xml定义Profile"></a>10.6.2 使用xml定义Profile</h4><p>例子如下<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"devDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BaseDataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/chapter12"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">beans</span> <span class="attr">profile</span>=<span class="string">"dev"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"devDataSource"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbcp.BaseDataSource"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/chapter13"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123456"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="10-6-3-启动Profile"><a href="#10-6-3-启动Profile" class="headerlink" title="10.6.3 启动Profile"></a>10.6.3 启动Profile</h4><p>当启动<code>Java</code>配置或者<code>XML</code>配置<code>Profile</code>时，可以发现这两个<code>Bean</code>并不会被加载到<code>SpringIoC</code>容器中，需要自行激活<code>Profile</code>。激活<code>Profile</code>的方法有5种</p>
<ol>
<li>在使用<code>SpringMVC</code>的情况下可以配置<code>web</code>上下文参数，或者<code>DispatchServlet</code>参数</li>
<li>作为<code>JNDI</code>条目</li>
<li>配置环境变量</li>
<li>配置<code>JVM</code>启动参数。</li>
<li>在集成测试环境中使用<code>＠ActiveProfiles</code></li>
</ol>
<h3 id="10-7-加载属性-properties-文件"><a href="#10-7-加载属性-properties-文件" class="headerlink" title="10.7 加载属性(properties)文件"></a>10.7 加载属性(properties)文件</h3><p>略</p>
<h3 id="10-8-条件化装配Bean"><a href="#10-8-条件化装配Bean" class="headerlink" title="10.8 条件化装配Bean"></a>10.8 条件化装配Bean</h3><p>背景: 在某些条件下需要进行条件判断，判断是否需要装配<code>Bean</code>。</p>
<p>方案: 这时<code>Spring</code>提供了注解<code>@Conditional</code>去配置，通过它可以配置一个或多个实现了<code>Condition</code>接口的类</p>
<p>例子:</p>
<ol>
<li><p>如何放置条件判断</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name=<span class="string">"dataSource"</span>)</span><br><span class="line"><span class="meta">@Condition</span>(&#123;DataSourceCondition.class&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>条件判断类的实现</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSourceCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span></span>&#123;</span><br><span class="line">        <span class="comment">//....</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>这里要求实现接口<code>Condition</code>的<code>matches</code>方法。如果此方法返回<code>true</code>则<code>Spring</code>会创建对应的<code>Bean</code></li>
</ul>
</li>
</ol>
<h3 id="10-9-Bean的作用域"><a href="#10-9-Bean的作用域" class="headerlink" title="10.9 Bean的作用域"></a>10.9 Bean的作用域</h3><p>在默认情况下,<code>SpringIoc</code>容器只会对一个<code>Bean</code>创建一个实例，有时候我们希望容器可以产生多实例，就需要修改<code>Spring</code>的作用域</p>
<p><code>Spring</code>提供4种作用域</p>
<ul>
<li>单例(singleton): 默认选项，在整个应用中，<code>Spring</code>只会为其生成一个<code>Bean</code>实例</li>
<li>原型(prototype): 当每次通过容器获取<code>Bean</code>时都会创建一个实例</li>
<li>会话(session): 在会话过程中<code>spring</code>只创建一个实例</li>
<li>请求(request): 在一个请求中<code>spring</code>只创建一个实例</li>
</ul>
<h3 id="10-10-使用Spring表达式-SpringEL"><a href="#10-10-使用Spring表达式-SpringEL" class="headerlink" title="10.10 使用Spring表达式(SpringEL)"></a>10.10 使用Spring表达式(SpringEL)</h3><p>SpringEL的主要功能</p>
<ul>
<li>使用<code>Bean</code>的<code>id</code>来引用<code>Bean</code></li>
<li>使用指定对象的方法和访问对象的属性</li>
<li>进行运算</li>
<li>提供正则表达式进行匹配</li>
<li>集合配置</li>
</ul>
<p>也就是为注解提供一定的逻辑运算功能，具体使用方式略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
