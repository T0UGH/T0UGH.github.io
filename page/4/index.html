<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/09/SpringBoot-11-构建REST风格的网站/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/09/SpringBoot-11-构建REST风格的网站/" itemprop="url">[SpringBoot][11][构建REST风格的网站]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-09T12:03:38+08:00">
                2020-02-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/09/SpringBoot-11-构建REST风格的网站/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/09/SpringBoot-11-构建REST风格的网站/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-11-章-构建REST风格网站"><a href="#第-11-章-构建REST风格网站" class="headerlink" title="第 11 章 构建REST风格网站"></a>第 11 章 构建REST风格网站</h2><p>在<code>HTTP</code>协议发展的过程中，提出了很多的规则，但是这些规则有些烦琐，于是又提出了一种风格约定，它便是<code>REST</code>风格。实际上严格地说它不是一种标准，而是一种风格。在现今互联网的世界中这种风格己经被广泛使用起来了。尤其是现今流行的微服务中，这样的风格甚至被推荐为各个微服务系统之间用于交互的方式。</p>
<p>首先在<code>REST</code>风格中，每一个资源都只是对应着一个网址，而一个代表资源的网址应该是一个名词，且不存在动词，这代表对一个资源的操作。在这样的风格下对于简易参数则尽量通过网址进行传递。例如，要获取<code>id</code>为<code>l</code>的用户的<code>URL</code>可能就设计<code>http//localhost:8080/user/1</code></p>
<h3 id="11-1-REST简述"><a href="#11-1-REST简述" class="headerlink" title="11.1 REST简述"></a>11.1 REST简述</h3><h4 id="11-1-1-REST名词解释"><a href="#11-1-1-REST名词解释" class="headerlink" title="11.1.1 REST名词解释"></a>11.1.1 REST名词解释</h4><p><code>REST</code>按其英文名称(<code>Representational State Transfer</code>)可翻译为表现层状态转换。首先需要有资源才能表现，所以第一个名词是”资源”。有了资源也要根据需要以合适的形式表现资源，这就是第二个名词是”表现层”。最后是资源可以被新增、修改、删除等，也就是第三个名词“状态转换”</p>
<ul>
<li>资源: 它可以是系统权限用户、角色和菜单等，也可以是一些媒体类型，如文本、图片、歌曲，总之它就是一个具体存在的对象。每个资源对应一个独一无二的<code>URI</code>。在<code>REST</code>中，<code>URI</code>也可以称为端点(<code>EndPoint</code>)。</li>
<li>表现层: 有了资源还需要确定如何表现这个资源。例如，一个用户可以使用<code>JSON</code>、<code>XML</code>或者其他的形式表现出来</li>
<li>状态转换: 现实中资源并不是一成不变的， 它是一个变化的过程，一个资源可以经历创建(<code>create</code>)、访问)(<code>visit</code>) 、修改(<code>update</code>)和删除(<code>delete</code>)的过程</li>
</ul>
<p>综上我们可以总结<code>REST</code>风格架构的特点</p>
<ul>
<li>服务器存在一系列的资源，每一个资源通过单独唯一的<code>URI</code>进行标识</li>
<li>客户端和服务器之间可以相互传递资源，而资源会以某种表现层得以展示</li>
<li>客户端通过<code>HTTP</code>协议所定义的动作对资源进行操作，以实现资源的状态转换</li>
</ul>
<h4 id="11-1-2-HTTP的动作"><a href="#11-1-2-HTTP的动作" class="headerlink" title="11.1.2 HTTP的动作"></a>11.1.2 HTTP的动作</h4><p>可以用<code>HTTP</code>请求的类型，来代表对资源的<code>CRUD</code>的行为</p>
<ul>
<li><code>GET</code>: <code>READ</code>，访问服务器资源</li>
<li><code>POST</code>: <code>CREATE</code>，在服务器创建新的资源</li>
<li><code>PUT</code>: <code>UPDATE</code>，修改服务器已经存在的资源，使用<code>PUT</code>时需要把资源的全部属性一并提交</li>
<li><code>PATCH</code>: <code>UPDATE</code>，修改服务器已经存在的资源，使用<code>PATCH</code>时只需要将部分资源属性提交</li>
<li><code>DELETE</code>: <code>DELETE</code>，从服务器将资源删除</li>
</ul>
<p>下面举几个<code>REST</code>风格的例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 获取用户信息，1代表用户编号</span><br><span class="line">GET /user/1</span><br><span class="line"># 查询多个用户信息</span><br><span class="line">GET /users/&#123;userName&#125;/&#123;note&#125;</span><br><span class="line"># POST 创建用户</span><br><span class="line">POST /user/&#123;userName&#125;/&#123;sex&#125;/&#123;note&#125;</span><br><span class="line"># 修改用户全部属性</span><br><span class="line">PUT /user/&#123;id&#125;/&#123;userName&#125;/&#123;sex&#125;/&#123;note&#125;</span><br><span class="line"># 修改用户名称</span><br><span class="line">PATCH /user/&#123;id&#125;/&#123;userName&#125;</span><br></pre></td></tr></table></figure></p>
<p>在<code>URI</code>中并没有出现动词，而对于参数主要通过<code>URI</code>设计去获取。对于参数数量超过5个的可以考虑使用传递<code>JSON</code>的方式来传递参数</p>
<h4 id="11-1-3-REST风格的一些误区"><a href="#11-1-3-REST风格的一些误区" class="headerlink" title="11.1.3 REST风格的一些误区"></a>11.1.3 REST风格的一些误区</h4><ol>
<li><p>REST风格的URI中不存在动词，例如<code>GET /user/get/1</code>，应改为<code>GET /user/1</code></p>
</li>
<li><p>URI中不应该加入版本号，例如下面<code>GET /v1/user/1</code>，如果存在版本号应设置在请求头中</p>
</li>
<li><p>类似这种<code>PUT users?userName=user_name&amp;note=note</code>是不推荐使用的，应改为<code>PUT users/{userName}/{note}</code></p>
</li>
</ol>
<h3 id="11-2-使用SpringMVC开发REST风格端点"><a href="#11-2-使用SpringMVC开发REST风格端点" class="headerlink" title="11.2 使用SpringMVC开发REST风格端点"></a>11.2 使用SpringMVC开发REST风格端点</h3><p><code>Spring</code>对<code>REST</code>风格的支持是基于<code>SpringMVC</code>设计基础上的，在<code>Spring 4.3</code>之后则有更多的注解引入使得<code>REST</code>风格的开发更为便捷。</p>
<h4 id="11-2-1-SpringMVC整合REST"><a href="#11-2-1-SpringMVC整合REST" class="headerlink" title="11.2.1 SpringMVC整合REST"></a>11.2.1 SpringMVC整合REST</h4><p>只要把<code>URI</code>设计为符合<code>REST</code>风格规范，那么显然就己经满足<code>REST</code>风格了。不过为了更为便捷地支持<code>REST</code>风格的开发，<code>Spring 4.3</code>之后除了<code>@RequestMapping</code>外，还可以使用以下5个注解，这5个注解主要是针对<code>HTTP</code>的动作而言的，通过它们就能够有效地支持<code>REST</code>风格的规范</p>
<ul>
<li><code>@GetMapping</code>: 对应<code>HTTP</code>的<code>GET</code>请求，获取资源</li>
<li><code>@PostMapping</code>: 对应<code>HTTP</code>的<code>POST</code>请求，创建资源</li>
<li><code>@PutMapping</code>: 对应<code>HTTP</code>的<code>PUT</code>请求，提交所有资源属性以修改资源</li>
<li><code>@PatchMapping</code>: 对应<code>HTTP</code>的<code>PATCH</code>请求，提交资源部分修改的属性</li>
<li><code>@DeleteMapping</code>: 对应<code>HTTP</code>的<code>DELETE</code>请求，删除服务器端的资源</li>
</ul>
<p>在<code>REST</code>风格的设计中，如果是简单的参数，往往会通过<code>URL</code>直接传递，在<code>SpringMVC</code>可以使用注解<code>@PathVariable</code>进行获取，对于那些复杂的参数，可以考虑使用请求体<code>JSON</code>的方式提交给服务器，这样就可以使用注解<code>@RequestBody</code>将<code>JSON</code>数据集转换为<code>Java</code>对象。</p>
<p>在现今的开发中，数据转化为<code>JSON</code>是最常见的方式，这个时候可以考虑使用注解<code>@ResponseBody</code>，这样<code>SpringMVC</code>就会通过<code>MappingJackson2HttpMessageConverter</code>最终将数据转换为<code>JSON</code>数据集，而在<code>SpringMVC</code>对<code>REST</code>风格的设计中，甚至可以使用注解<code>@RestController</code>让整个控制器都默认转换为<code>JSON</code>数据集。</p>
<h4 id="11-2-2-使用Spring开发REST风格端点"><a href="#11-2-2-使用Spring开发REST风格端点" class="headerlink" title="11.2.2 使用Spring开发REST风格端点"></a>11.2.2 使用Spring开发REST风格端点</h4><p>我们可以使用<code>POST</code>动作来创建资源<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">insertUser</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.insertUser(user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>@PostMapping</code>表示采用<code>POST</code>动作提交用户信息</li>
<li><code>@ReguestBody</code>代表接收的是一个<code>JSON</code>数据集参数</li>
<li><code>@ResponseBody</code>代表会将函数的返回值转化为<code>JSON</code>格式传递给前端</li>
</ul>
<p>接下来就是使用<code>GET</code>动作来获取对象了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value=<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>采用注解<code>@GetMapping</code>声明<code>HTTP</code>的<code>GET</code>请求，并且把参数编号(<code>id</code>)以<code>URI</code>的形式传递，这符合了<code>REST</code>风格的要求</li>
<li>在<code>getUser</code>方法中使用了注解<code>@PathVariable</code>从<code>URI</code>中获取参数</li>
<li><code>@ResponseBody</code>代表会将函数的返回值转化为<code>JSON</code>格式传递给前端</li>
</ul>
<p>更新和删除操作也与上面的例子类似，这里略</p>
<h4 id="11-2-3-使用-RestController"><a href="#11-2-3-使用-RestController" class="headerlink" title="11.2.3 使用@RestController"></a>11.2.3 使用@RestController</h4><p>因为现在前后端分离，所以使用<code>JSON</code>作为前后端交互已经十分普遍。如果每一个方法都加入<code>@ResponseBody</code>才能将数据模型转换为<code>JSON</code>，显然有些冗余。<code>SpringMVC</code>还存在一个注解<code>@RestController</code>，它可以修饰控制器类，将类中的方法返回值转化为<code>JSON</code>数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(value=<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-2-4-渲染结果"><a href="#11-2-4-渲染结果" class="headerlink" title="11.2.4 渲染结果"></a>11.2.4 渲染结果</h4><p>在<code>@RequestMapping</code>、<code>GetMapping</code>等注解中还存在<code>consumes</code>和<code>produces</code>两个属性。其中<code>consumes</code><br>代表的是限制该方法接收什么类型的请求体(body), <code>produces</code>代表的是限定返回的媒体类型，仅当<code>request</code>请求头中的(<code>Accept</code>)类型中包含该指定类型才返回。</p>
<p>假如我们想要某个方法返回一个字符串，而不是JSON的话，可以采用如下方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value=<span class="string">"/user/name/&#123;id&#125;"</span>, produces=MediaType.TEXT_PLAIN_VALUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="keyword">return</span> user.getUserName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>对于<code>getUserName</code>方法，因为<code>@GetMapping</code>的属性<code>produces</code>声明为普通文本类型，也就是修改了原有<code>@RestController</code>默认的<code>JSON</code>类型，同样结果也会被<code>SpringMVC</code>自身注册好的<code>StringHttpMessageConverter</code>拦截， 这样就可以转变为一个简单的字符串。</li>
</ul>
<h4 id="11-2-5-处理HTTP状态码、异常和响应头"><a href="#11-2-5-处理HTTP状态码、异常和响应头" class="headerlink" title="11.2.5 处理HTTP状态码、异常和响应头"></a>11.2.5 处理HTTP状态码、异常和响应头</h4><p>当发生资源找不到或者处理逻辑发生异常时， 需要考虑的是返回给客户端的<code>HTTP</code>状态码和错误消息的问题。为了简化这些开发，<code>Spring</code>提供了实体封装类<code>ResponseEntity</code>和注解<code>@ResponseStatus</code>。<code>ResponseEnti ty</code>可以有效封装错误消息和状态码，通过<code>@ResponseStatus</code>可以配置指定的响应码给客户端。</p>
<p>下面我们修改插入用户的方法，将状态码修改为201，并且插入响应头的属性来标识这次请求的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/user2/entity"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;UserVo&gt; <span class="title">insertUserEntity</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        @RequestBody UserVo userVo)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    UserVo result = <span class="keyword">this</span>.changeToVo(user);</span><br><span class="line">    HttpHeaders headers = <span class="keyword">new</span> HttpHeaders();</span><br><span class="line">    String success = </span><br><span class="line">        (result == <span class="keyword">null</span> || result.getId() == <span class="keyword">null</span>) ? <span class="string">"false"</span> : <span class="string">"true"</span>;</span><br><span class="line">    <span class="comment">// 设置响应头，比较常用的方式</span></span><br><span class="line">    headers.add(<span class="string">"success"</span>, success);</span><br><span class="line">    <span class="comment">// 返回创建成功的状态码</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ResponseEntity&lt;UserVo&gt;(result, headers, HttpStatus.CREATED);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@PostMapping</span>(value = <span class="string">"/user2/annotation"</span>)</span><br><span class="line"><span class="comment">// 指定状态码为201（资源已经创建）</span></span><br><span class="line"><span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line"><span class="function"><span class="keyword">public</span> UserVo <span class="title">insertUserAnnotation</span><span class="params">(@RequestBody UserVo userVo)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">this</span>.changeToPo(userVo);</span><br><span class="line">    userService.insertUser(user);</span><br><span class="line">    UserVo result = <span class="keyword">this</span>.changeToVo(user);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>insertUserEntity</code>方法中定义返回为一个<code>ResponseEntity&lt;User&gt;</code>的对象，这里还生成了响应头( <code>HttpHeaders</code>对象)，并且添加了属性<code>success</code>来表示请求是否成功，在最后返回的时刻生成了一个<code>ResponseEntity&lt;User&gt;</code>对象，然后将查询到的用户对象和响应头捆绑上，并且指定状态码为201(创建资源成功)</li>
<li>在<code>insertUserAnnotation</code>方法上则使用了<code>@ResponseStatus</code>注解将<code>HTTP</code>的响应码标注为201(创建资源成功)，所以在方法正常返回时<code>Spring</code>就会将响应码设置为<code>20l</code></li>
</ul>
<p>但是有时候会出现一些异常，例如，按照<code>id</code>查找用户，可能查找不到数据，这个时候就不能以正常返回去处理了，又或者在执行的过程中产生了异常，这也是需要我们进行处理的。通过<code>@ControllerAdvice</code>和<code>@ExceptionHandler</code>注解可以通过控制器通知的方式对异常情况进行处理</p>
<p>首先我们自定义一个查找失败异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotFoundException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	<span class="comment">// 异常编码</span></span><br><span class="line">	<span class="keyword">private</span> Long code;</span><br><span class="line">	<span class="comment">// 异常自定义信息</span></span><br><span class="line">	<span class="keyword">private</span> String customMsg;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">NotFoundException</span><span class="params">(Long code, String customMsg)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>();</span><br><span class="line">		<span class="keyword">this</span>.code = code;</span><br><span class="line">		<span class="keyword">this</span>.customMsg = customMsg;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//getter and setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后自定义一个控制器通知，来自定义异常的处理<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制器通知</span></span><br><span class="line"><span class="meta">@ControllerAdvice</span>(</span><br><span class="line">		<span class="comment">// 指定拦截包的控制器</span></span><br><span class="line">		basePackages = &#123; <span class="string">"com.springboot.chapter11.controller.*"</span> &#125;,</span><br><span class="line">		<span class="comment">// 限定被标注为@Controller或者@RestController的类才被拦截</span></span><br><span class="line">		annotations = &#123; Controller.class, RestController.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoControllerAdvice</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 异常处理，可以定义异常类型进行拦截处理</span></span><br><span class="line">	<span class="meta">@ExceptionHandler</span>(value=NotFoundException.class)</span><br><span class="line">	<span class="comment">// 以JSON表达方式响应</span></span><br><span class="line">	<span class="meta">@ResponseBody</span></span><br><span class="line">	<span class="comment">// 定义为服务器错误状态码</span></span><br><span class="line">	<span class="meta">@ResponseStatus</span>(HttpStatus.INTERNAL_SERVER_ERROR)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">exception</span><span class="params">(HttpServletRequest request, NotFoundException ex)</span> </span>&#123;</span><br><span class="line">		Map&lt;String, Object&gt; msgMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">		<span class="comment">// 获取异常信息</span></span><br><span class="line">		msgMap.put(<span class="string">"code"</span>, ex.getCode());</span><br><span class="line">		msgMap.put(<span class="string">"message"</span>, ex.getCustomMsg());</span><br><span class="line">		<span class="keyword">return</span> msgMap;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里使用了<code>@ControllerAdvice</code>来标注类，说明在定义一个控制器通知。</li>
<li><code>basePackages</code>配置了它所拦截的包，<code>annotations</code>限定了拦截的那些被标注为注解<code>@Controller</code>和<code>@RestController</code>的控制器，</li>
<li>这里的<code>@ExceptionHandler</code>定义了拦截<code>NotFoundException</code>的异常</li>
<li><code>@ResponseBody</code>定义了响应的信息以<code>JSON</code>格式表达</li>
<li><code>@ResponseStatus</code>定义了状态码为<code>500</code>(服务器内部错误)，这样就会把这个状态码传达给请求者</li>
</ul>
<p>最后我们让前文定义的<code>getUser</code>方法抛出异常，这样完成了当发生资源找不到或者处理逻辑发生异常这种情况下的处理逻辑<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(value=<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span>Long id)</span>&#123;</span><br><span class="line">    User user = userService.getUser(id);</span><br><span class="line">    <span class="keyword">if</span>(user == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException(<span class="number">1L</span>, <span class="string">"找不到用户["</span>+id+<span class="string">"]信息"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> userService.getUser(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样当发生异常时，就可以返回<code>500</code>状态码和异常信息字符串了</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/" itemprop="url">[SpringBoot][6][SpringBoot整合数据库事务]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-08T17:22:59+08:00">
                2020-02-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-6-章-SpringBoot整合数据库事务"><a href="#第-6-章-SpringBoot整合数据库事务" class="headerlink" title="第 6 章 SpringBoot整合数据库事务"></a>第 6 章 SpringBoot整合数据库事务</h2><p>在互联网数据库的使用中，对于那些电商和金融网站，最关注的内容毫无疑问就是数据库事务。它们的业务存在高并发，数据库的数据一般在一个多事务的场景下运行，如果不采取一定手段就会造成数据的不一致。面对这样的高井发场景，掌握数据库事务机制是至关重要的，它能够帮助我们在一定程度上保证数据的一致性，并且有效提高系<br>统性能，避免系统产生宕机。</p>
<p>在<code>Spring</code>中，数据库事务是通过<code>AOP</code>技术来提供服务的。它擦除了<code>JDBC</code>中的大量冗余代码。</p>
<p>在<code>Spring</code>数据库事务中可以使用编程式事务，也可以使用声明式事务(<code>@Transactional</code>)。大部分的情况下，会使用更加简单的声明式事务。</p>
<h3 id="6-1-JDBC的数据库事务"><a href="#6-1-JDBC的数据库事务" class="headerlink" title="6.1 JDBC的数据库事务"></a>6.1 JDBC的数据库事务</h3><p>首先看看如何以<code>JDBC</code>的方式完成插入用户的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcServiceimpl</span> <span class="keyword">implements</span> <span class="title">JdbcService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(String userName , String note)</span></span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//获取连接</span></span><br><span class="line">            conn = dataSource.getConnection();</span><br><span class="line">            <span class="comment">//开启事务</span></span><br><span class="line">            conn.setAutoCornrnit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">//设置隔离级别</span></span><br><span class="line">            conn.setTransactionIsolation(TransactionIsolationLevel.READ_COMMITTED.getLevel());</span><br><span class="line">            <span class="comment">//执行SQL</span></span><br><span class="line">            PreparedStatement ps = conn.prepareStatement(<span class="string">"insert into t_user(user name, note) values(?, ?)"</span>);</span><br><span class="line">            ps.setString(<span class="number">1</span>, userName);</span><br><span class="line">            ps.setString(<span class="number">2</span>, note);</span><br><span class="line">            result=ps.executeUpdate();</span><br><span class="line">            <span class="comment">//提交事务</span></span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//回滚事务</span></span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    conn.rollback();</span><br><span class="line">                &#125;<span class="keyword">catch</span>(SQLException el)&#123;</span><br><span class="line">                    el.printStackTrace();</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                    <span class="comment">//关闭数据库连接</span></span><br><span class="line">                    <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="keyword">if</span>(conn !=<span class="keyword">null</span> &amp;&amp; !conn.isClosed())&#123;</span><br><span class="line">                            conn.close() ;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (SQLException e)&#123;</span><br><span class="line">                        e.printStackTrace ();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们看到了数据库连接的获取和关闭以及事务的提交和回滚、大量的<code>try...catch ...finally...</code>语句。于是人们就开始不断地优化，使用<code>Hibernate</code>、<code>MyBatis</code>都可以减少这些代码，但是依旧不能完全去除开闭数据库连接和事务控制的代码，而<code>AOP</code>允许我们把那些公共的代码抽取出来，单独实现，如下面流程图所示<br><img src="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/200208_0.png" alt=""></p>
<p>这个流程与我们<code>AOP</code>约定流程十分接近，而在图中，有业务逻辑的部分也只是执行<code>SQL</code>那一步骤，其他的步骤都是比较固定的，按照<code>AOP</code>的设计思想，就可以把除执行<code>SQL</code>这步之外的步骤抽取出来单独实现，这便是<code>Spring</code>数据库事务编程的思想。</p>
<h3 id="6-2-Spring声明式事务的使用"><a href="#6-2-Spring声明式事务的使用" class="headerlink" title="6.2 Spring声明式事务的使用"></a>6.2 Spring声明式事务的使用</h3><h4 id="6-2-1-Spring声明式数据库事务约定"><a href="#6-2-1-Spring声明式数据库事务约定" class="headerlink" title="6.2.1 Spring声明式数据库事务约定"></a>6.2.1 Spring声明式数据库事务约定</h4><p>对于声明式事务，需要通过<code>@Transactional</code>进行标注的，告诉<code>Spring</code>在什么地方启用数据库事务功能。这个注解可以标注在类或者方法上，当它标注在类上时，代表这个类所有公共(<code>public</code>)非静态的方法都将启用事务功能。</p>
<p>在<code>@Transactional</code>中，还允许配置许多的属性，如事务的隔离级别、异常类型和传播行为等。这些配置内容，是<code>Spring IoC</code>容器在加载时就会将这些配置信息解析出来，然后它把这些信息存到<code>TransactionDefinition</code>里，并且记录哪些类或者方法需要启动事务功能，采取什么策略去执行事务等。</p>
<p><code>Spring</code>数据库事务约定如下<br><img src="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/200208_1.png" alt=""></p>
<p>当<code>Spring</code>的上下文开始调用被<code>@Transactional</code>标注的类或者方法时，<code>Spring</code>就会产生<code>AOP</code>的功能。那么当它启动事务时，就会根据事务定义器内的配置去设置事务，首先是根据传播行为去确定事务的策略然后是隔离级别、超时时间、只读等内容的设置，设置事务并不需要开发者完成，而是Spring事务拦截器(<code>Interpretor</code>)根据<code>@Transactional</code>配置的内容来完成的。<code>Spring</code>就会开始调用开发者编写的业务代码。执行开发者的业务代码。如果都没有发生异常，<code>Spring</code>拦截器就会帮助我们提交事务，如果发生异常，就要判断一次事务定义器内的配置，如果事务定义器己经约定了该类型的异常不回滚事务就提交事务，如果没有任何配置，则会回滚事务，并且将异常抛出。无论发生异常与否，<code>Spring</code>都会释放事务资源，以保证数据库连接池正常可用。</p>
<p>一个使用<code>@Transaction</code>的例子。仅仅是使用一个<code>@Transactional</code>注解，标识<code>insertUser</code>方法需要启动事务机制，那么<code>Spring</code>就会按照上图那样，把<code>insertUser</code>方法织入约定的流程中，这样对于数据库连接的闭合、事务提交与回滚都不再需要我们编写任何代码了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserDao userDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userDao.insertUser(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-2-2-Transcational的配置项"><a href="#6-2-2-Transcational的配置项" class="headerlink" title="6.2.2 @Transcational的配置项"></a>6.2.2 @Transcational的配置项</h4><p>下面我们之前通过源码，查看<code>@Transcational</code>标签的配置项</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.annotation.AliasFor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transactional &#123;</span><br><span class="line">    <span class="comment">//通过bean name指定事务管理器</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//同上</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    <span class="function">String <span class="title">transactionManager</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定传播行为</span></span><br><span class="line">    <span class="function">Propagation <span class="title">propagation</span><span class="params">()</span> <span class="keyword">default</span> Propagation.REQUIRED</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定隔离级别</span></span><br><span class="line">    <span class="function">Isolation <span class="title">isolation</span><span class="params">()</span> <span class="keyword">default</span> Isolation.DEFAULT</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//是否只读事务</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">readOnly</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定发生哪些异常时回滚</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] rollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定发生哪些异常时回滚</span></span><br><span class="line">    String[] rollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定发生哪些异常时不回滚</span></span><br><span class="line">    Class&lt;? extends Throwable&gt;[] noRollbackFor() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定发生哪些异常时不回滚</span></span><br><span class="line">    String[] noRollbackForClassName() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-2-3-Spring事务管理器"><a href="#6-2-3-Spring事务管理器" class="headerlink" title="6.2.3 Spring事务管理器"></a>6.2.3 Spring事务管理器</h4><p>在<code>Spring</code>事务流程中，事务的打开、回滚和提交是由事务管理器来完成的。事务管理器相关类图如下，其顶层接口为<code>PlatformTransactionManager</code>，最常用到的事务管理器是<code>DataSourceTransactionManager</code>。类图如下</p>
<p><img src="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/200208_2.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span></span>&#123;</span><br><span class="line">    <span class="comment">//获取事务</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Spring</code>在事务管理时，就是将这些方法按照约定织入对应的流程中的，在<code>SpringBoot</code>中，当你依赖于<code>mybatis-spring-boot-starter</code>之后，它会自动创建一个<code>DataSourceTransactionManager</code>对象作为事务管理器。如果依赖于<code>spring-boot-starter-data-jpa</code>，则它会自动创建<code>JpaTransactionManager</code>对象作为事务管理器，所以我们一般不需要自己创建事务管理器而直接使用它们即可。</p>
<h3 id="6-3-隔离级别"><a href="#6-3-隔离级别" class="headerlink" title="6.3 隔离级别"></a>6.3 隔离级别</h3><h4 id="6-3-1-丢失更新"><a href="#6-3-1-丢失更新" class="headerlink" title="6.3.1 丢失更新"></a>6.3.1 丢失更新</h4><p>在多个事务同时操作数据的情况下，会引发丢失更新的场景。</p>
<p>第一类丢失更新是指一个事务回滚另外一个事务提交而引发的数据不一致的情况。例子如下表所示，<code>T5</code>时刻事务l回滚，导致原本库存为<code>99</code>的变为了<code>100</code>，显然事务2的结果就丢失了，这就是一个错误的值。然而目前大部分数据库已经克服了第一类丢失更新的问题。</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>初始库存100</td>
<td>初始库存100</td>
</tr>
<tr>
<td>T2</td>
<td>扣减库存，余99</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存，余99</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>提交事务，库存变为99</td>
</tr>
<tr>
<td>T5</td>
<td>回滚事务，库存100</td>
</tr>
</tbody>
</table>
<p>第二类丢失更新是指多个事务都提交引发的丢失更新，这是我们互联网系统需要关注的重点内容。例子如下表所示，<code>T5</code>时刻提交的事务。因为在事务l中，无法感知事务2的操作，这样它就不知道事务2己经修改过了数据，因此它依旧认为只是发生了一笔业务，所以库存变为了99 ，而这个结果又是一个错误的结果。</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>初始库存100</td>
<td>初始库存100</td>
</tr>
<tr>
<td>T2</td>
<td>扣减库存，余99</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存，余99</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>提交事务，库存变为99</td>
</tr>
<tr>
<td>T5</td>
<td>提交事务，库存变为99</td>
</tr>
</tbody>
</table>
<h4 id="6-3-2-详解隔离级别"><a href="#6-3-2-详解隔离级别" class="headerlink" title="6.3.2 详解隔离级别"></a>6.3.2 详解隔离级别</h4><p>为了压制丢失更新，数据库标准提出了4类隔离级别，在不同的程度上压制丢失更新，这4类隔离级别是未提交读、读写提交、可重复读和串行化</p>
<h5 id="6-3-2-1-未提交读"><a href="#6-3-2-1-未提交读" class="headerlink" title="6.3.2.1 未提交读"></a>6.3.2.1 未提交读</h5><p>未提交读(<code>read uncommitted</code>)是最低的隔离级别，其含义是允许一个事务读取另外一个事务没有提交的数据。<br>它的最大坏处是出现脏读。让我们看看可能发生的脏读场景，如下表所示。</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td></td>
<td>商品库存初始化为2</td>
</tr>
<tr>
<td>T2</td>
<td>读取库存为2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存</td>
<td>库存为1</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>读取库存为1</td>
<td>因为开启了未提交读，可以读取事务1中的库存为1</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>扣减库存</td>
<td>事务2库存为0</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
<td>数据库更新为0</td>
</tr>
<tr>
<td>T7</td>
<td>回滚事务</td>
<td></td>
<td>由于第一类丢失更新已经克服，此时不会回滚为2，库存为0，结束</td>
</tr>
</tbody>
</table>
<p>因为采用未提交读，所以事务2可以读取事务l未提交的库存数据为1,这里当它扣减库存后则数据为0，然后它提交了事务，库存就变为了0，而事务l在T7时刻回滚事务，因为第一类丢失更新已经被克服，所以它不会将库存回滚到2，那么最后的结果就变为了0，这样就出现了错误。</p>
<h5 id="6-3-2-2-读写提交"><a href="#6-3-2-2-读写提交" class="headerlink" title="6.3.2.2 读写提交"></a>6.3.2.2 读写提交</h5><p>读写提交(<code>read committed</code>)隔离级别，是指一个事务只能读取另外一个事务已经提交的数据，不能读取未提交的数据。它可以克服脏读，如下表所示</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td></td>
<td>商品库存初始化为2</td>
</tr>
<tr>
<td>T2</td>
<td>读取库存为2</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存</td>
<td>库存为1</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>读取库存为2</td>
<td>因为开启了读写提交，读取数据库中的库存为2</td>
</tr>
<tr>
<td>T5</td>
<td></td>
<td>扣减库存</td>
<td>事务2库存为1</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>提交事务</td>
<td>数据库更新为1</td>
</tr>
<tr>
<td>T7</td>
<td>回滚事务</td>
<td></td>
<td>由于第一类丢失更新已经克服，此时不会回滚为2，库存为1，结束</td>
</tr>
</tbody>
</table>
<p>在T4时刻，由于采用了读写提交的隔离级别，因此事务2不能读取到事务l中未提交的库存1,所以扣减库存的结果依旧为1，然后它提交事务，则库存在T6时刻就变为了l。T7时刻，事务l回滚，因为第一类丢失更新己经克服，所以最后结果库存为1，这是一个正确的结果。</p>
<p>但是读写提交可能会发生不可重复读的问题</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td></td>
<td>商品库存初始化为1</td>
</tr>
<tr>
<td>T2</td>
<td>读取库存为1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存</td>
<td>此时不提交事务</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>读取库存为1</td>
<td>认为可扣除</td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
<td>数据库库存为0</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>扣除库存</td>
<td>失败，不可扣除，也因为此时库存已经是0</td>
</tr>
</tbody>
</table>
<p>这里的问题在于事务2之前认为可以扣减，而到扣减那一步却发现已经不可以扣减</p>
<h5 id="6-3-2-3-可重复读"><a href="#6-3-2-3-可重复读" class="headerlink" title="6.3.2.3 可重复读"></a>6.3.2.3 可重复读</h5><p>可重复读的目标是克服读写提交中出现的不可重复读的现象，当尝试读取其他事务正在操作但未提交的数据时，数据库会阻塞这次读取，如下表所示</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td></td>
<td></td>
<td>商品库存初始化为1</td>
</tr>
<tr>
<td>T2</td>
<td>读取库存为1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td></td>
<td>扣减库存</td>
<td>此时不提交事务</td>
</tr>
<tr>
<td>T4</td>
<td></td>
<td>尝试读取库存</td>
<td>不允许读取，等待事务1提交，阻塞事务2</td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
<td>库存为0</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>读取库存</td>
<td>库存为0</td>
</tr>
</tbody>
</table>
<p>但是可重复读无法克服最后一个问题——幻读，下面举一个例子，假设现在商品交易正在进行中，而后台有人也在<br>进行查询分析和打印的业务，如下表</p>
<table>
<thead>
<tr>
<th>时刻</th>
<th>事务1</th>
<th>事务2</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>T1</td>
<td>读取库存50件</td>
<td></td>
<td>商品库存初始化为100，现在已经销售50笔，库存50件</td>
</tr>
<tr>
<td>T2</td>
<td></td>
<td>查询(<code>count</code>)销售记录50笔</td>
<td></td>
</tr>
<tr>
<td>T3</td>
<td>扣减库存</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T4</td>
<td>插入1笔提交记录</td>
<td></td>
<td></td>
</tr>
<tr>
<td>T5</td>
<td>提交事务</td>
<td></td>
<td>库存为49件，销售记录51笔</td>
</tr>
<tr>
<td>T6</td>
<td></td>
<td>打印销售记录51笔</td>
<td>这里与查询的不一致，在事务2看来有1笔是虚幻的，与之前查询的不一致</td>
</tr>
</tbody>
</table>
<p>因为<code>销售记录</code>的笔数是通过<code>count</code>统计销售记录表得到的，而商品库存则是存储在商品表中的字段。所以可重复读并不能进行阻塞，这就导致了幻读的问题</p>
<h5 id="6-3-2-4-串行化"><a href="#6-3-2-4-串行化" class="headerlink" title="6.3.2.4 串行化"></a>6.3.2.4 串行化</h5><p>串行化(<code>Serializable</code>)是数据库最高的隔离级别，它会要求所有的<code>SQL</code>都会按照顺序执行，这样就可以克服上述隔离级别出现的各种问题，所以它能够完全保证数据的一致性。</p>
<h5 id="6-3-2-5-使用合理的隔离等级"><a href="#6-3-2-5-使用合理的隔离等级" class="headerlink" title="6.3.2.5 使用合理的隔离等级"></a>6.3.2.5 使用合理的隔离等级</h5><p>上述内容可总结为下表</p>
<table>
<thead>
<tr>
<th>项目类型</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>未提交读</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>读写提交</td>
<td>no</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>可重复读</td>
<td>no</td>
<td>no</td>
<td>yes</td>
</tr>
<tr>
<td>串行化</td>
<td>no</td>
<td>no</td>
<td>no</td>
</tr>
</tbody>
</table>
<p>追求更高的隔离级别，它能更好地保证了数据的一致性，但是也要付出锁的代价。有了锁，就意味着性能的丢失，<br>而且隔离级别越高，性能就越是直线地下降。在现实中一般而言，选择隔离级别会以读写提交为主，它能够防止脏读，而不能避免不可重复读和幻读。为了克服数据不一致和性能问题，程序开发者还设计了乐观锁，甚至不再使用数据库而使用其他的手段。例如，使用<code>Redis</code>作为数据载体。</p>
<p>使用隔离级别很简单，只需要在<code>@Transactional</code>配置对应即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserDao userDao = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Transactional</span>(isolation=Isolation.SERIALIZABLE)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userDao.insertUser(user);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时候一个个地指定隔离级别会很不方便，也可以通过<code>SpringBoot</code>配置文件指定默认的隔离级别。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 隔离级别数字配置的含义</span><br><span class="line"># -1 数据库默认隔离级别</span><br><span class="line"># 1 未提交读</span><br><span class="line"># 2 读写提交</span><br><span class="line"># 4 可重复读</span><br><span class="line"># 8 串行化</span><br><span class="line">#tomcat 数据源默认隔离级别</span><br><span class="line">spring.datasource.tomcat.default-traηsaction-isolation=2</span><br><span class="line">#dbcp2 数据库连接池默认隔离级别</span><br><span class="line">#spring.datasource dbcp2.default-traηsaction-isolation=2</span><br></pre></td></tr></table></figure></p>
<h3 id="6-4-传播行为"><a href="#6-4-传播行为" class="headerlink" title="6.4 传播行为"></a>6.4 传播行为</h3><p>传播行为是方法之间调用事务采取的策略问题。在绝大部分的情况下，我们会认为数据库事务要么全部成功， 要么全部失败。但现实中也许会有特殊的情况。例如，执行一个批量程序，它会处理很多的交易，绝大部分交易是可以顺利完成的，但是也有极少数的交易不能完成而发生异常，这时我们不应该因为极少数的交易不能完成而回滚批量任务调用的其他交易，应该只是回滚那些出现异常的交易，而不是整个批量任务，如下图所示</p>
<p><img src="/2020/02/08/SpringBoot-6-SpringBoot整合数据库事务/200208_3.png" alt=""></p>
<p>在<code>Spring</code>中，当一个方法调用另外一个方法时，可以让事务采取不同的策略工作，批量任务我们称之为当前方法，那么批量事务就称为当前事务，当它调用单个交易时，称单个交易为子方法，当前方法调用子方法的时候，让每一个子方法不在当前事务中执行，而是创建一个新的事务去执行子方法，我们就说当前方法调用子方法的传播行为为新建事务。此外， 还可能让子方法在无事务、独立事务中执行，这些完全取决于你的业务需求。</p>
<h4 id="6-4-1-传播行为的定义"><a href="#6-4-1-传播行为的定义" class="headerlink" title="6.4.1 传播行为的定义"></a>6.4.1 传播行为的定义</h4><p>在<code>Spring</code>事务机制中队数据库存在7种传播机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.transaction.annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Propagation&#123;</span><br><span class="line">    <span class="comment">//需要事务，它是默认传播行为，如果当前存在事务，就沿用当前事务，否则新建一个事务来运行子方法</span></span><br><span class="line">    REQUIRED(<span class="number">0</span>),</span><br><span class="line">    <span class="comment">//支持事务，如果当前存在事务，就沿用当前事务，否则继续采用无事务的方式运行子方法</span></span><br><span class="line">    SUPPORTS(<span class="number">1</span>),</span><br><span class="line">    <span class="comment">//必须使用事务，如果当前存在事务，就沿用当前事务，否则抛出异常</span></span><br><span class="line">    MANDATORY(<span class="number">2</span>),</span><br><span class="line">    <span class="comment">//无论当前事务是否存在，都会创建新事物运行方法，与当前事务相互独立</span></span><br><span class="line">    REQUIRES_NEW(<span class="number">3</span>),</span><br><span class="line">    <span class="comment">//不支持事务，当前存在事务时，会挂起事务，运行方法</span></span><br><span class="line">    NOT_SUPPORTED(<span class="number">4</span>),</span><br><span class="line">    <span class="comment">//不支持事务，如果当前方法存在事务，则抛出异常，否则继续使用无事务机制运行</span></span><br><span class="line">    NEVER(<span class="number">5</span>),</span><br><span class="line">    <span class="comment">//在当前方法调用子方法时，如果子方法发生异常，只回滚子方法执行过的SQL，而不回滚当前方法的事务</span></span><br><span class="line">    NESTED(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Propagation</span><span class="params">(<span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-4-2-测试传播行为"><a href="#6-4-2-测试传播行为" class="headerlink" title="6.4.2 测试传播行为"></a>6.4.2 测试传播行为</h4><p>上述传播行为中，只有<code>REQUIRED</code>，<code>REQUIRES_NEW</code>和<code>NESTED</code>比较常用</p>
<p>下面我们用批量插入用户为例，演示传播行为的用法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserBatchService</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUsers</span><span class="params">(List&lt;User&gt; userList)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBatchServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserBatchService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUsers</span><span class="params">(List&lt;User&gt; userList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">            count += userService.insertUser(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span>(isolation=Isolation.READ_COMMITTED, propagation=Propagation.Nested)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们使用<code>UserBatchService</code>调用<code>UserService</code>，会使用<code>UserService</code>的传播行为:<code>NESTED</code></p>
<h3 id="6-5-Transcational自调用失效问题"><a href="#6-5-Transcational自调用失效问题" class="headerlink" title="6.5 @Transcational自调用失效问题"></a>6.5 @Transcational自调用失效问题</h3><p><code>@Transcatoinal</code>在某些场景下会失效，类之间自己方法的调用称为自调用，自调用不会启动<code>AOP</code>，从而导致事务失效<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span></span>&#123;</span><br><span class="line">    <span class="meta">@Transactional</span>(isolation=Isolation.READ_COMMITTED, propagation=Propagation.Nested)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.insertUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Transactional</span>(isolation=Isolation.READ_COMMITTED, propagation=Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUsers</span><span class="params">(List&lt;User&gt; userList)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(User user : userList)&#123;</span><br><span class="line">            <span class="comment">// 调用自己类的方法，产生自调用问题</span></span><br><span class="line">            count += insertUser(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了克服自调用问题，最好像6.4中那样，用一个<code>Service</code>去调用另一个<code>Service</code>，这样可以正常启用<code>AOP</code></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/07/SpringBoot-5-SpringBoot与数据库编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/SpringBoot-5-SpringBoot与数据库编程/" itemprop="url">[SpringBoot][5][SpringBoot与数据库编程]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T20:39:43+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/07/SpringBoot-5-SpringBoot与数据库编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/07/SpringBoot-5-SpringBoot与数据库编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-5-章-SpringBoot与数据库编程"><a href="#第-5-章-SpringBoot与数据库编程" class="headerlink" title="第 5 章 SpringBoot与数据库编程"></a>第 5 章 SpringBoot与数据库编程</h2><p>对于数据库开发，一直以来都是Java 开发的核心内容之一。在<code>Java</code>的发展历史中，数据库持久层的主流技术随着时代的变化也发生了变化。</p>
<p>在<code>Java</code>中访问数据库是<code>SUN</code>公司提出的<code>JDBC</code>规范，但是因为它需要的冗余代码比较多，加上流程和资源比较难以控制，如烦琐的<code>try...catch...finally...</code>语句，使得当时的<code>Java EE</code>的开发受到了很大的质疑， 所以使用<code>JDBC</code>开发的模式很快就走到了尽头。<code>SUN</code>公司早年推出的<code>EJB</code>，虽然能够支持持久化，但是因为配置极为烦琐，所以很快就被新兴的<code>Hibernate</code>框架取代。再后来<code>Sun</code>公司为了简化持久层，吸收了很多<code>Hibernate</code>的成果，制定了<code>JPA</code>规范，并且<code>JPA</code>规范在<code>EJB 3.0</code>得以支持。但<code>EJB 3.0</code>并没有能兴旺起来，而<code>Hibernate 3.2</code>则对<code>JPA</code>实现了完全支持。<code>EJB</code>同样是一个失败的产品，被埋没在历史的长河之中。</p>
<p>对于全映射框架<code>Hibernate</code>，在以管理系统为主的时代，它的模型化十分有利于公司业务的分析和理解，但是在近年兴起的移动互联网时代，这样的模式却走到了尽头。<code>Hibernate</code>的模式重模型和业务分析，移动互联网虽然业务相对简单，但却更关注大数据和大并发下的性能问题。全表映射规则下的<code>Hibernate</code>巳无法满足<code>SQL</code>优化和互联网灵活多变的业务，于是<code>Hibernate</code>近年来受到新兴的持久框架<code>MyBatis</code>的严重冲击，现今<code>MyBatis</code> 己经成为移动互联网时代的主流持久层框架，在移动互联网和一些新兴项目中<code>MyBatis</code>的占有率不断提升， <code>Hibernate</code>则是不断萎缩。<code>MyBatis</code>是一个不屏蔽<code>SQL</code>且提供动态<code>SQL</code>、接口式编程和简易<code>SQL</code>绑定<code>POJO</code>的半自动化框架，它的使用十分简单，而且能非常容易定制<code>SQL</code>，以提高网站性能，因此在移动互联网兴起的时代，它占据了强势的地位。</p>
<p><code>Spring</code>支持<code>JdbcTemplate</code>的数据库访问模式，但这个用法一直未被很多企业采用。不过正如<code>Spring</code>所倡导的理念，它并不排斥其他优秀的框架，而是通过提供各种各样的模板，使得这些框架能够整合到<code>Spring</code>中来，并且更加方便开发者的使用。</p>
<h3 id="5-1-配置数据源"><a href="#5-1-配置数据源" class="headerlink" title="5.1 配置数据源"></a>5.1 配置数据源</h3><p>不过一切开始之前，都要先完成数据源的配置。在<code>SpringBoot</code>中，己经自动默认数据源的配置，下面我们来了解这方面的细节。</p>
<h4 id="5-1-1-启动默认数据源"><a href="#5-1-1-启动默认数据源" class="headerlink" title="5.1.1 启动默认数据源"></a>5.1.1 启动默认数据源</h4><p>在依赖于<code>SpringBoot</code>的<code>spring-boot-starter-data-jpa</code>后，它就会默认为你配置数据源，这些默认<br>的数据源主要是内存数据库，如<code>h2</code>、<code>hqldb</code>和<code>Derby</code>等内存数据</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.h2database<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>h2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>这样我们就可以在不使用任何配置数据库的情况下运行<code>SpringBoot</code>工程了，因为<code>h2</code>是内嵌式数据库，当然我们也可以将数据源配置为<code>hqldb</code>或者<code>Derby</code>，它会随着<code>SpringBoot</code>项目的启动而启动，并不需要任何的配置，但这显然不是我们期待的。因为这样的内存数据库在应用上并不广泛</li>
</ul>
<h4 id="5-1-2-配置自定义数据源"><a href="#5-1-2-配置自定义数据源" class="headerlink" title="5.1.2 配置自定义数据源"></a>5.1.2 配置自定义数据源</h4><p>下面以<code>MySQL</code>为例配置自定义数据源。</p>
<p>首先添加<code>Mysql</code>的依赖和<code>JDBC</code>的依赖<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons.dbcp2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>然后配置<code>application.properties</code>文件以配置数据源<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/cosmetic_store?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里注释掉了驱动器的配置，但它仍可以连接数据源，<code>SpringBoot</code>会尽可能地去判断数据源是什么类型，然后根据其默认地情况匹配驱动类</li>
</ul>
<p>接下来我们配置<code>application.properties</code>文件以配置DBCP连接池<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#指定连接池的类型</span><br><span class="line">spring.datasource.type=org.apache.commons.dbcp2.BasicDataSource</span><br><span class="line">#最大等待连接中的数量，设 0 为没有限制</span><br><span class="line">spring.datasource.dbcp2.max-idle=10</span><br><span class="line">#最大连接活动数</span><br><span class="line">spring.datasource.dbcp2.max-total=50</span><br><span class="line">#最大等待毫秒数，单位为ms，超过时间会出错误信息</span><br><span class="line">spring.datasource.dbcp2.max-wait-millis=10000</span><br><span class="line">#数据库连接池初始化连接数</span><br><span class="line">spring.datasource.dbcp2.initial-size=5</span><br></pre></td></tr></table></figure></p>
<h3 id="5-2-使用JdbcTemplate操作数据库"><a href="#5-2-使用JdbcTemplate操作数据库" class="headerlink" title="5.2 使用JdbcTemplate操作数据库"></a>5.2 使用JdbcTemplate操作数据库</h3><p>在配置数据源后，<code>SpringBoot</code>通过其自动配置机制配置好了<code>JdbcTemplate</code>, <code>JdbcTemplate</code>模板是<code>Spring</code>框架提供的。准确来说，<code>JdbcTemplate</code>这种方式也不算成功，</p>
<p>下面先创建一个Service接口和它对应的实现类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.chapter5.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.chapter5.pojo.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">JdbcTmplUserService</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">(Long id)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser3</span><span class="params">(Long id)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.springboot.chapter5.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.RowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.springboot.chapter5.enumeration.SexEnum;</span><br><span class="line"><span class="keyword">import</span> com.springboot.chapter5.pojo.User;</span><br><span class="line"><span class="keyword">import</span> com.springboot.chapter5.service.JdbcTmplUserService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**** imports ****/</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTmplUserServiceImpl</span> <span class="keyword">implements</span> <span class="title">JdbcTmplUserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> JdbcTemplate jdbcTemplate = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取映射关系</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> RowMapper&lt;User&gt; <span class="title">getUserMapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 使用Lambda表达式创建用户映射关系</span></span><br><span class="line">		RowMapper&lt;User&gt; userRowMapper = (ResultSet rs, <span class="keyword">int</span> rownum) -&gt; &#123;</span><br><span class="line">			User user = <span class="keyword">new</span> User();</span><br><span class="line">			user.setId(rs.getLong(<span class="string">"id"</span>));</span><br><span class="line">			user.setUserName(rs.getString(<span class="string">"user_name"</span>));</span><br><span class="line">			<span class="keyword">int</span> sexId = rs.getInt(<span class="string">"sex"</span>);</span><br><span class="line">			SexEnum sex = SexEnum.getEnumById(sexId);</span><br><span class="line">			user.setSex(sex);</span><br><span class="line">			user.setNote(rs.getString(<span class="string">"note"</span>));</span><br><span class="line">			<span class="keyword">return</span> user;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="keyword">return</span> userRowMapper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取对象</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行的SQL</span></span><br><span class="line">		String sql = <span class="string">" select id, user_name, sex, note from t_user where id = ?"</span>;</span><br><span class="line">		<span class="comment">// 参数</span></span><br><span class="line">		Object[] params = <span class="keyword">new</span> Object[] &#123; id &#125;;</span><br><span class="line">		User user = jdbcTemplate.queryForObject(sql, params, getUserMapper());</span><br><span class="line">		<span class="keyword">return</span> user;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 查询用户列表</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">findUsers</span><span class="params">(String userName, String note)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行的SQL</span></span><br><span class="line">		String sql = <span class="string">" select id, user_name, sex, note from t_user "</span> + <span class="string">"where user_name like concat('%', ?, '%') "</span></span><br><span class="line">				+ <span class="string">"and note like concat('%', ?, '%')"</span>;</span><br><span class="line">		<span class="comment">// 参数</span></span><br><span class="line">		Object[] params = <span class="keyword">new</span> Object[] &#123; userName, note &#125;;</span><br><span class="line">		<span class="comment">// 使用匿名类实现</span></span><br><span class="line">		List&lt;User&gt; userList = jdbcTemplate.query(sql, params, getUserMapper());</span><br><span class="line">		<span class="keyword">return</span> userList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 插入数据库</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">insertUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		String sql = <span class="string">" insert into t_user (user_name, sex, note) values( ? , ?, ?)"</span>;</span><br><span class="line">		<span class="keyword">return</span> jdbcTemplate.update(sql, user.getUserName(), user.getSex().getId(), user.getNote());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 更新数据库</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行的SQL</span></span><br><span class="line">		String sql = <span class="string">" update t_user set user_name = ?, sex = ?, note = ?  "</span> + <span class="string">" where id = ?"</span>;</span><br><span class="line">		<span class="keyword">return</span> jdbcTemplate.update(sql, user.getUserName(), user.getSex().getId(), user.getNote(), user.getId());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 删除数据</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteUser</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行的SQL</span></span><br><span class="line">		String sql = <span class="string">" delete from t_user where id = ?"</span>;</span><br><span class="line">		<span class="keyword">return</span> jdbcTemplate.update(sql, id);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser2</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 通过Lambda表达式使用StatementCallback</span></span><br><span class="line">	    User result = <span class="keyword">this</span>.jdbcTemplate.execute((Statement stmt) -&gt; &#123;</span><br><span class="line">	        String sql1 = <span class="string">"select count(*) total from t_user where id= "</span> + id;</span><br><span class="line">	        ResultSet rs1 = stmt.executeQuery(sql1);</span><br><span class="line">	        <span class="keyword">while</span> (rs1.next()) &#123;</span><br><span class="line">	            <span class="keyword">int</span> total = rs1.getInt(<span class="string">"total"</span>);</span><br><span class="line">	            System.out.println(total);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// 执行的SQL</span></span><br><span class="line">	        String sql2 = <span class="string">" select id, user_name, sex, note from t_user"</span></span><br><span class="line">	                + <span class="string">" where id = "</span> + id;</span><br><span class="line">	        ResultSet rs2 = stmt.executeQuery(sql2);</span><br><span class="line">	        User user = <span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">while</span> (rs2.next()) &#123;</span><br><span class="line">	            <span class="keyword">int</span> rowNum = rs2.getRow();</span><br><span class="line">	            user= getUserMapper().mapRow(rs2, rowNum);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> user;</span><br><span class="line">	    &#125;);</span><br><span class="line">	    <span class="keyword">return</span> result;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> User <span class="title">getUser3</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">	    <span class="comment">// 通过Lambda表达式使用ConnectionCallback接口</span></span><br><span class="line">	    <span class="keyword">return</span> <span class="keyword">this</span>.jdbcTemplate.execute((Connection conn) -&gt; &#123;</span><br><span class="line">	        String sql1 = <span class="string">" select count(*) as total from t_user"</span></span><br><span class="line">	                + <span class="string">" where id = ?"</span>;</span><br><span class="line">	        PreparedStatement ps1 = conn.prepareStatement(sql1);</span><br><span class="line">	        ps1.setLong(<span class="number">1</span>, id);</span><br><span class="line">	        ResultSet rs1 = ps1.executeQuery();</span><br><span class="line">	        <span class="keyword">while</span> (rs1.next()) &#123;</span><br><span class="line">	            System.out.println(rs1.getInt(<span class="string">"total"</span>));</span><br><span class="line">	        &#125;</span><br><span class="line">	        String sql2 = <span class="string">" select id, user_name, sex, note from t_user "</span></span><br><span class="line">	                + <span class="string">"where id = ?"</span>;</span><br><span class="line">	        PreparedStatement ps2 = conn.prepareStatement(sql2);</span><br><span class="line">	        ps2.setLong(<span class="number">1</span>, id);</span><br><span class="line">	        ResultSet rs2 = ps2.executeQuery();</span><br><span class="line">	        User user = <span class="keyword">null</span>;</span><br><span class="line">	        <span class="keyword">while</span> (rs2.next()) &#123;</span><br><span class="line">	            <span class="keyword">int</span> rowNum = rs2.getRow();</span><br><span class="line">	            user= getUserMapper().mapRow(rs2, rowNum);</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="keyword">return</span> user;</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对<code>JdbcTemplate</code>的映射关系需要开发者自己实现<code>RowMapper</code>接口，以完成数据库数据到<code>POJO</code>对象的映射</li>
<li>而且<code>JdbcTemplate</code>没调用一次就会产生一次数据库连接</li>
<li>也可以通过使用<code>StatementCallback</code>或<code>ConnectionCallback</code>接口来实现在一个连接中执行多条<code>SQL</code></li>
</ul>
<h3 id="5-3-使用JPA-Hibernate-操作数据"><a href="#5-3-使用JPA-Hibernate-操作数据" class="headerlink" title="5.3 使用JPA(Hibernate)操作数据"></a>5.3 使用JPA(Hibernate)操作数据</h3><h4 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h4><p><code>JPA</code>所维护的核心是实体(<code>EntityBean</code>)，而它是通过一个持久化上下文(Persistence Context)来使用的，持久化上下文包括以下3个部分</p>
<ul>
<li>对象关系映射(Object Relational Mapping, ORM)描述，也就是在数据库表和<code>POJO</code>间建立关系</li>
<li>实体操作<code>API</code>，可以实现对实体对象的<code>CRUD</code>操作，来完成对象的持久化和查询</li>
<li>查询语言<code>JPQL</code>(Java Persistence Query Language)来实现更灵活的查询</li>
</ul>
<h4 id="5-3-2-开发JPA"><a href="#5-3-2-开发JPA" class="headerlink" title="5.3.2 开发JPA"></a>5.3.2 开发JPA</h4><p>此处略</p>
<h3 id="5-4-整合MyBatis框架"><a href="#5-4-整合MyBatis框架" class="headerlink" title="5.4 整合MyBatis框架"></a>5.4 整合MyBatis框架</h3><p>目前<code>Java</code>持久层最为主流的技术己经是<code>MyBatis</code>，它比<code>JPA</code>和<code>Hibernate</code>更为简单易用，也更加灵活。移动互联网的时代面对的问题主要是大数据、高并发和性能问题。这正是<code>MyBatis</code>相较于<code>Hibernate</code>的优势</p>
<h4 id="5-4-1-MyBatis简介"><a href="#5-4-1-MyBatis简介" class="headerlink" title="5.4.1 MyBatis简介"></a>5.4.1 MyBatis简介</h4><p><code>MyBatis</code>是基于一种<code>SQL</code>到<code>POJO</code>的模型，它需要我们提供<code>SQL</code>、映射关系和POJO 。但是对于<code>SQL</code>和<code>POJO</code>的映射关系，它提供了自动映射和驼峰映射等，使开发者的开发工作大大减少</p>
<p>由于没有屏蔽SQL，这对于追求高响应和性能的互联网系统是十分重要的， 因此我们可以尽可能地通过<code>SQL</code>去优化性能，也可以做少量的改变以适应灵活多变的互联网应用。</p>
<p>与此同时，它还能支持动态<code>SQL</code>以适应需求的变化。</p>
<h4 id="5-4-2-SpringBoot整合MyBatis"><a href="#5-4-2-SpringBoot整合MyBatis" class="headerlink" title="5.4.2 SpringBoot整合MyBatis"></a>5.4.2 SpringBoot整合MyBatis</h4><p><code>MyBatis</code>是一个基于<code>SqlSessionFactory</code>构建的框架。对于<code>SqlSessionFactory</code>而言，它的作用是生<br>成<code>SqlSession</code>接口对象，这个接口对象是<code>MyBatis</code>操作的核心，而在<code>MyBatis-Spring</code>的结合中甚至可<br>以”擦除”这个对象，使其在代码中”消失”，这样做的意义是重大的，因为<code>SqlSession</code>是一个功能性的代码，”擦除”它之后，就剩下了业务代码，这样就可以使得代码更具可读性。</p>
<p><code>MyBatis</code>的架构图如下所示<br><img src="/2020/02/07/SpringBoot-5-SpringBoot与数据库编程/200207_0.png" alt=""></p>
<p>首先我们先定义一个<code>Mapper</code>接口来完成对数据库中<code>Product</code>表的<code>CRUD</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.hellospringboot.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.neu.hellospringboot.pojo.Product;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Select;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProductDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"select * from product where product_id = #&#123;productId&#125;"</span>)</span><br><span class="line">    <span class="function">Product <span class="title">getProduct</span><span class="params">(<span class="keyword">int</span> productId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是在上面我们可以看到<code>Mapper</code>是一个接口，是不可以使用<code>new</code>为其生成对象实例的。为了方便我们使用， <code>MyBatis</code>社区在与<code>Spring</code>整合的包中提供了两个类和一个注解，它们是<code>MapperFactoryBean</code>和<code>MapperScannerConfigurerMyBatis</code>和注解<code>@MapperScan</code>。它们能够将<code>MyBatis</code>所需的对应接口扫描装配到<code>SpringIoC</code>容器中。</p>
<p>这里我们以<code>@MapperScan</code>接口为例，它是这三种中最常用的。我们在<code>SpringBoot</code>的启动类上加入如下注解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.hellospringboot;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.Mapper;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.annotation.MapperScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(basePackages = <span class="string">"com.edu.neu.hellospringboot.dao"</span>, annotationClass = Mapper.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HellospringbootApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(HellospringbootApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>basePackage</code>定义了要扫描的包</li>
<li><code>annotationClass</code>进行了注解限定，只有要扫描的包中被这个注解标注的接口才会被装载进容器。可以看到我们上面的代码使用了注解<code>@Mapper</code>来修饰<code>ProductDao</code>，所以这里把<code>annotationClass</code>设置为<code>Mapper</code></li>
<li>事实上我们亦可以使用<code>@Repository</code>这个注解</li>
</ul>
<h4 id="5-4-3-MyBatis的其他配置"><a href="#5-4-3-MyBatis的其他配置" class="headerlink" title="5.4.3 MyBatis的其他配置"></a>5.4.3 MyBatis的其他配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#假如我们使用xml来定义mapper可以用它来定义xml的地址</span><br><span class="line">mybatis.mapper-locations=classpath:com/springboot/chapter5/mapper/*.xml</span><br><span class="line">#定义类型转换器</span><br><span class="line">mybatis.type-handlers-package=com.springboot.chapter5.typehandler</span><br><span class="line">#MyBatis配置文件，当你的配置比较复杂的时候，可以使用去指定MyBatis本身的配置文件</span><br><span class="line">mybatis.config-location=xxx</span><br><span class="line">#配置MyBaits 插件</span><br><span class="line">mybatis.configuration.interceptors=xxx</span><br><span class="line">#级联延迟加载属性配置</span><br><span class="line">mybatis.configuration.aggressive-lazyloading=xxx</span><br><span class="line">#属性映射中开启驼峰命名</span><br><span class="line">mybatis.configuration.map-underscore-to-camel-case=true</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/07/SpringBoot-2-SpringBoot开发环境搭建和基本开发/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/07/SpringBoot-2-SpringBoot开发环境搭建和基本开发/" itemprop="url">[SpringBoot][2][SpringBoot开发环境搭建和基本开发]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-07T16:05:44+08:00">
                2020-02-07
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/07/SpringBoot-2-SpringBoot开发环境搭建和基本开发/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/07/SpringBoot-2-SpringBoot开发环境搭建和基本开发/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-2-章-SpringBoot开发环境搭建和基本开发"><a href="#第-2-章-SpringBoot开发环境搭建和基本开发" class="headerlink" title="第 2 章 SpringBoot开发环境搭建和基本开发"></a>第 2 章 SpringBoot开发环境搭建和基本开发</h2><h3 id="2-1-搭建SpringBoot开发环境"><a href="#2-1-搭建SpringBoot开发环境" class="headerlink" title="2.1 搭建SpringBoot开发环境"></a>2.1 搭建SpringBoot开发环境</h3><p><a href="https://blog.csdn.net/lom9357bye/article/details/69677120" target="_blank" rel="noopener">点此链接</a></p>
<h3 id="2-2-SpringBoot的依赖和自动配置"><a href="#2-2-SpringBoot的依赖和自动配置" class="headerlink" title="2.2 SpringBoot的依赖和自动配置"></a>2.2 SpringBoot的依赖和自动配置</h3><p>下面需要讨论为什么<code>SpringBoot</code>项目可以在很少配置下运行</p>
<p>首先我们查看<code>spring-boot-starter-web</code>的<code>pom.xml</code>文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starters<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>Spring Boot Web Starter<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Starter for building web, including RESTful, applications using Spring</span><br><span class="line">		MVC. Uses Tomcat as the default embedded container<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://projects.spring.io/spring-boot/#/spring-boot-parent/spring-boot-starters/spring-boot-starter-web<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">organization</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pivotal Software, Inc.<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://spring.io<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">licenses</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Apache License, Version 2.0<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://www.apache.org/licenses/LICENSE-2.0<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">licenses</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">developers</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developer</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">name</span>&gt;</span>Pivotal<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">email</span>&gt;</span>info@pivotal.io<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organization</span>&gt;</span>Pivotal Software, Inc.<span class="tag">&lt;/<span class="name">organization</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">organizationUrl</span>&gt;</span>https://www.spring.io<span class="tag">&lt;/<span class="name">organizationUrl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">developer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">developers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scm</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">connection</span>&gt;</span>scm:git:git://github.com/spring-projects/spring-boot.git<span class="tag">&lt;/<span class="name">connection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">developerConnection</span>&gt;</span>scm:git:ssh://git@github.com/spring-projects/spring-boot.git<span class="tag">&lt;/<span class="name">developerConnection</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/spring-projects/spring-boot<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">scm</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">system</span>&gt;</span>Github<span class="tag">&lt;/<span class="name">system</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://github.com/spring-projects/spring-boot/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">issueManagement</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--SpringBoot的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--JSON的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-json<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Tomcat的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Hibernate Validator的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-el<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring Web的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--Spring Web MVC的依赖--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>从这里可以看出，当加入<code>spring-boot-starter-web</code>后，它会通过<code>Maven</code>将对应的资源加载到我们的工程中，这样就可以形成依赖</li>
<li>于此同时在<code>spring-boot-autoconfigure</code>包中，<code>SpringBoot</code>帮我们做了很多自动的配置，由下图所示<br><img src="/2020/02/07/SpringBoot-2-SpringBoot开发环境搭建和基本开发/200207_0.png" alt=""></li>
<li>上面两条就是为什么在没有任何配置下<code>Springboot</code>可以启动<code>SpringMVC</code>项目</li>
</ul>
<h3 id="2-3-使用自定义配置"><a href="#2-3-使用自定义配置" class="headerlink" title="2.3 使用自定义配置"></a>2.3 使用自定义配置</h3><p>有的时候，我们需要对<code>Springboot</code>提供的默认配置进行修改来适应个性化的要求，再写可以通过<code>application.properties</code>来实现。</p>
<p>比如我们可以这样定义这个文件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server.port=8090</span><br><span class="line">spring.mvc.view.prefix=/WEB-INF/jsp/</span><br><span class="line">spring.mvc.view.suffix=.jsp</span><br><span class="line"></span><br><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/cosmetic_store?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai&amp;useSSL=false</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123456</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这个文件主要用于我们进行自定义配置</li>
<li>这个配置文件，定义了服务器的端口，<code>springmvc</code>的视图解析器，以及数据库连接等相关内容</li>
</ul>
<h3 id="2-4-开发自己的SpringBoot项目"><a href="#2-4-开发自己的SpringBoot项目" class="headerlink" title="2.4 开发自己的SpringBoot项目"></a>2.4 开发自己的SpringBoot项目</h3><p>具体可见此项目<a href="https://github.com/T0UGH/hellospringboot" target="_blank" rel="noopener">hellospringboot</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/SpringBoot-1-SpringBoot的来临/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/SpringBoot-1-SpringBoot的来临/" itemprop="url">[SpringBoot][1][SpringBoot的来临]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-06T19:00:43+08:00">
                2020-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/06/SpringBoot-1-SpringBoot的来临/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/06/SpringBoot-1-SpringBoot的来临/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-1-章-SpringBoot的来临"><a href="#第-1-章-SpringBoot的来临" class="headerlink" title="第 1 章 SpringBoot的来临"></a>第 1 章 <code>SpringBoot</code>的来临</h2><h3 id="1-1-Spring的历史"><a href="#1-1-Spring的历史" class="headerlink" title="1.1 Spring的历史"></a>1.1 <code>Spring</code>的历史</h3><p>在<code>Spring</code>框架没有开发出来时，<code>JavaEE</code>是以<code>Sun</code>公司所制定的<code>EJB</code>(Enterprise Java Bean)作为标准的。</p>
<p>然后在<code>2004</code>年由<code>RodJohnson</code>主导的<code>Spring</code>项目推出了<code>1.0</code>版本，这彻底地改变了<code>JavaEE</code>开发的世界，很快人们就抛弃了繁重的<code>EJB</code>的标准，迅速地投入到了<code>Spring</code>框架中， 于是<code>Spring</code>成为了现实中<code>JavaEE</code>开发的标准。<code>Spring</code>以强大的控制反转(<code>loC</code>)来管理各类<code>Java</code>资源，从而降低了各种资源的藕合；并且提供了极低的侵入性，也就是使用<code>Spring</code>框架开发的编码，脱离了<code>Spring</code>也可以继续使用；而<code>Spring</code>的面向切面的编程(<code>AOP</code>)通过动态代理技术，允许我们按照约定进行配置编程，进而增强了<code>Bean</code>的功能，它擦除了大量重复的代码使得开发人员能够更加集中精力于业务开发；<code>Spring</code>还提供许多整合了当时非常流行的框架的模板，如持久层<code>Hibernate</code>的<code>HibernateTemplate</code>模板、<code>IBATIS</code>的<code>SqlMapClientTemplate</code>模板等， 极大地融合并简化了当时主流技术的使用， 使得其展示了强有力的生命力， 并延续至今。</p>
<h3 id="1-2-注解还是XML"><a href="#1-2-注解还是XML" class="headerlink" title="1.2 注解还是XML"></a>1.2 注解还是<code>XML</code></h3><p>只是在<code>Spring</code>早期的<code>l.x</code>版本中，由于当时的<code>JDK</code>并不能支持注解，因此只能使用<code>XML</code>。而很快随着<code>JDK</code> 升级到<code>JDK5</code>，它加入了注解的新特性，这样注解就被广泛地使用起来，于是<code>Spring</code>的内部也分为了两派，一派是使用XML 的赞同派，一派是使用注解的赞同派。</p>
<p>为了简化开发，在<code>Spring2.x</code>之后的版本也引入了注解，不过只是少量的注解，如<code>@Component</code>、<code>@Service</code> 等，但是功能还不够强大，因此对于<code>Spring</code>的开发，绝大部分的情况下还是以使用<code>XML</code>为主， 注解为辅。</p>
<p>到了<code>Spring 3.0</code>后，引入了更多的注解功能，于是在<code>Spring</code>中产生了这样一个很大的分歧，即是使用注解还是使用XML？对<code>XML</code>的引入，有些人觉得过于繁复，而对于注解的使用，会使得注解分布得到处都是，难以控制，有时候还需要了解很多框架的内部实现才能准确使用注解开发所需的功能。这个时候大家形成了这样的一个不成文的共识，对于业务类使用注解，例如，对于<code>MVC</code>开发，控制器使用<code>@Controller</code>，业务层使用<code>@Service</code>，持久层使用<code>@Repository</code>；而对于一些公用的<code>Bean</code>，例如，对于数据库(如<code>Redis</code>)、第三方资源等则使用<code>XML</code>进行配置，直至今时今日这样的配置方式还在企业中广泛地使用着。也许使用注解还是<code>XML</code>是一个长期存在的话题，但是无论如何都有道理。</p>
<p>随着注解的功能增强，尤其是<code>Servlet 3.0</code>规范的提出，<code>Web</code>容器可以脱离<code>web.xml</code>的部署，使得<code>Web</code>容器完全可以基于注解开发，对于<code>Spring 3.x</code>和<code>Spring 4.x</code>的版本注解功能越来越强大，对于<code>XML</code>的依赖越来越少，到了<code>4.x</code>的版本后甚至可以完全脱离<code>XML</code>，因此在<code>Spring</code>中使用注解开发占据了主流的地位。与此同时，<code>Pivotal</code>团队在原有<code>Spring</code>的基础上主要通过注解的方式继续简化了<code>Spring</code>框架的开发，它们基于<code>Spring</code>框架开发了<code>Spring Boot</code>，所以<code>Spring Boot</code>并非是代替<code>Spring</code>框架，而是让<code>Spring</code>框架更加容易得到快速的使用。<code>Pivotal</code>团队在2014年推出<code>Spring Boot</code>的<code>1.0</code>版本，该版本使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。在2018年3月<code>SpringBoot</code>推出了<code>2.0.0 GA</code>版本，该版本是基于<code>Spring5</code>的，并引入其最新的功能，能够有效支持<code>Java 9</code>的开发。<code>Spring Boot</code>致力于在蓬勃发展的快速应用开发领域(rapid application development)借助<code>Java EE</code>在企业互联网的强势地位成为业界领导者，它也是近年来<code>Java</code>开发最令人感到惊喜的项目之一。</p>
<h3 id="1-3-SpringBoot的优点"><a href="#1-3-SpringBoot的优点" class="headerlink" title="1.3 SpringBoot的优点"></a>1.3 <code>SpringBoot</code>的优点</h3><p><code>SpringBoot</code>的优点</p>
<ul>
<li>创建独立的<code>Spring</code>应用程序</li>
<li>嵌入的<code>Tomcat</code>、<code>Jetty</code>或者<code>Undertow</code>，无须部署<code>WAR</code>文件</li>
<li>允许通过<code>Maven</code>来根据需要获取<code>starter</code></li>
<li>尽可能地自动配置<code>Spring</code></li>
<li>提供生产就绪型功能，如指标、健康检查和外部配置</li>
<li>绝对没有代码生成，对<code>XML</code>没有要求配置</li>
</ul>
<p>约定优于配置，这是<code>SpringBoot</code>的主导思想。对于<code>SpringBoot</code>而言，大部分情况下存在默认配置，你甚至可以在没有任何定义的情况下使用<code>Spring</code>框架，如果需要自定义也只需要在配置文件配置一些属性便可以，十分便捷。而对于部署这些项目必需的功能，<code>SpringBoot</code>提供<code>starter</code>的依赖，如<code>spring-boot-starter-web</code> 捆绑了<code>SpringMVC</code>所依赖的包，<code>spring-boot-starter-tomcat</code>绑定了内嵌的<code>Tomcat</code>，这样使得开发者能够尽可能快地搭建开发环境，快速进行开发和部署，这就是<code>SpringBoot</code>的特色。</p>
<h3 id="1-4-传统SpringMVC和SpringBoot的对比"><a href="#1-4-传统SpringMVC和SpringBoot的对比" class="headerlink" title="1.4 传统SpringMVC和SpringBoot的对比"></a>1.4 传统<code>SpringMVC</code>和<code>SpringBoot</code>的对比</h3><p>与传统的<code>SpringMVC</code>对比，<code>SpringBoot</code>允许直接进行开发，这就是它的优势。在传统所需要配置的地方， <code>SpringBoot</code>都进行了约定，也就是你可以直接以<code>SpringBoot</code>约定的方式进行开发和运行你的项目。当你需要修改配置的时候，它也提供了一些快速配置的约定，犹如它所承诺的那样，尽可能地配置好<code>Spring</code>项目和绑定对应的服务器，使得开发人员的配置更少，更加直接地开发项目。对于那些微服务而言，更喜欢的就是这样能够快速搭建环境的项目，而<code>SpringBoot</code>提供了这种可能性，同时<code>SpringBoot</code>还提供了监控的功能，随着云技术的<br>到来，微服务成了市场的热点，于是代表<code>Java</code>微服务时代的<code>SpringBoot</code>微服务开发的时代己经到来，结合<code>SpringCloud</code>后它还能很方便地构建分布式系统开发，满足大部分无能力单独开发分布式架构的企业所需，所以这无疑是激动人心的技术。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/06/SSM-15-深入SpringMVC组件/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/06/SSM-15-深入SpringMVC组件/" itemprop="url">[SSM][15][深入SpringMVC组件]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-06T14:56:32+08:00">
                2020-02-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/06/SSM-15-深入SpringMVC组件/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/06/SSM-15-深入SpringMVC组件/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-15-章-深入SpringMVC组件开发"><a href="#第-15-章-深入SpringMVC组件开发" class="headerlink" title="第 15 章 深入SpringMVC组件开发"></a>第 15 章 深入<code>SpringMVC</code>组件开发</h2><p>本章将对工作和学习中常用的组件进行讨论</p>
<h3 id="15-1-控制器接收各类请求参数"><a href="#15-1-控制器接收各类请求参数" class="headerlink" title="15.1 控制器接收各类请求参数"></a>15.1 控制器接收各类请求参数</h3><p><code>SpringMVC</code>提供了诸多的注解来解析参数，其目的是把控制器从复杂的<code>ServletAPI</code>中剥离，这样就可以在非<code>Web</code>容器环境中重用控制器</p>
<h4 id="15-1-1-接收普通请求参数"><a href="#15-1-1-接收普通请求参数" class="headerlink" title="15.1.1 接收普通请求参数"></a>15.1.1 接收普通请求参数</h4><p><code>SpringMVC</code>目前比较智能化，如果传递过来的参数名称和<code>HTTP</code>的保存一致，那么无须任何注解也可以获取参数</p>
<p>下面举一个例子，前端发送来一个<code>form</code>，<code>form</code>里有参数<code>roleName</code>和参数<code>note</code>，下面的方法可以通过保持方法签名的参数名称和<code>HTTP</code>请求参数名称一致来获取参数，如果不一致时则会获得空，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/commonParams"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">commonParams</span><span class="params">(String roleName, String note)</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在参数很多的时候可以考虑使用一个<code>POJO</code>来管理这些参数，但是<code>POJO</code>的属性也要和<code>HTTP</code>请求参数名称保持一致。这样，即使没有注解也可以有效传递参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleParams</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/commonParams"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">commonParams</span><span class="params">(RoleParams roleParams)</span></span>&#123;</span><br><span class="line">    String roleName = roleParams.getRoleName();</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-1-2-使用-RequestParam注解获取参数"><a href="#15-1-2-使用-RequestParam注解获取参数" class="headerlink" title="15.1.2 使用@RequestParam注解获取参数"></a>15.1.2 使用<code>@RequestParam</code>注解获取参数</h4><p>当<code>HTTP</code>参数名和控制器方法的参数名不同时，我们就无法使用上一节的方法了。例如: 前端发送的参数为<code>role_name</code>，而在<code>java</code>中采用驼峰写法一般会将参数名写为<code>roleName</code>，这种情况下，我们可以使用<code>@RequestParam</code>注解来进行转换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/commonParams"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">requestParams</span><span class="params">(@RequestParam(<span class="string">"role_name"</span>)</span> String roleName, String note)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，第14章中提到，如果参数被<code>@RequestParam</code>注解，那么默认情况下该参数不能为空，如果为空则系统抛出异常。如果希望允许它为空，那么要修改它的配置项<code>required</code>为<code>false</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/commonParams"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">requestParams</span><span class="params">(@RequestParam(value=<span class="string">"role_name"</span>, required=<span class="keyword">false</span>)</span> String roleName, String note)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15-1-3-使用URL传递参数"><a href="#15-1-3-使用URL传递参数" class="headerlink" title="15.1.3 使用URL传递参数"></a>15.1.3 使用<code>URL</code>传递参数</h4><p>一些网站使用<code>URL</code>的形式传递参数，这符合<code>RESTful</code>风格，有时我们会将<code>URL</code>写作<code>/params/getRole/1</code>，其中<code>1</code>就是一个参数，它代表的是角色编号。而完成这种参数的读取，需要<code>@RequestMapping</code>和<code>@PathVariable</code>两个注解来共同完成<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">RoleService roleService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&#123;id&#125;代表接收一个参数</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getRole/&#123;id&#125;"</span>)</span><br><span class="line"><span class="comment">//注解@PathVariable表示从URL的请求地址中获取参数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">pathVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    Role role = roleService.getRole(id);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//绑定数据模型</span></span><br><span class="line">    mv.addObject(role);</span><br><span class="line">    <span class="comment">//设置为JSON视图</span></span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>{id}</code>代表处理器需要接受一个由<code>URL</code>组成的参数，且参数名称为<code>id</code>，那么在方法中<code>@PathVariable(&quot;id&quot;)</code>表示将获取这个在<code>@RequestMapping</code>中定义名称为<code>id</code>的参数</li>
<li>运行结果如图<br>  <img src="/2020/02/06/SSM-15-深入SpringMVC组件/200205_0.png" alt=""></li>
<li>注解<code>@PathVariable</code>允许对应的参数为空</li>
</ul>
<h4 id="15-1-4-传递JSON参数"><a href="#15-1-4-传递JSON参数" class="headerlink" title="15.1.4 传递JSON参数"></a>15.1.4 传递<code>JSON</code>参数</h4><p>我们举个具体的例子来说明，假设<code>15.1.1</code>中的例子，除了传递<code>roleName</code>和<code>note</code>，还要传递一个<code>pageParams</code>对象来处理分页，具体的结构如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123;</span><br><span class="line">    roleName: <span class="string">'role'</span>,</span><br><span class="line">    note: <span class="string">'note'</span>,</span><br><span class="line">    pageParams: &#123;</span><br><span class="line">        start: <span class="number">1</span>,</span><br><span class="line">        limit: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">$.post(&#123;</span><br><span class="line">    url: <span class="string">"./params/findRoles.do"</span>,</span><br><span class="line">    contentType: <span class="string">"application/json"</span>,</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我们要想接受这种复杂的数据类型，首先要定义一个POJO，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageParams</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> limit;</span><br><span class="line">    <span class="comment">//setters and getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleParams</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String roleName;</span><br><span class="line">    <span class="keyword">private</span> String note;</span><br><span class="line">    <span class="keyword">private</span> PageParam pageParams = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//setters and getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们可以用注解<code>@RequestBody</code>配合这个<code>POJO</code>来接受参数了，<code>SpringMVC</code>会完成将传递的参数转化为<code>POJO</code>的过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findRoles"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">findRoles</span><span class="params">(@RequestBody RoleParams roleParams)</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15-1-5-接收列表数据和表单序列化"><a href="#15-1-5-接收列表数据和表单序列化" class="headerlink" title="15.1.5 接收列表数据和表单序列化"></a>15.1.5 接收列表数据和表单序列化</h4><p>在一些场景下，需要传递一个数组作为参数，而<code>SpringMVC</code>对这种场景也提供了支持</p>
<p>例如我们要传递一个<code>id</code>的数组，用以一次性删除多个角色，我们通过<code>JSON</code>的字符串化传递给后台<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> idList = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">$.post(&#123;</span><br><span class="line">    url: <span class="string">"./params/deleteRoles.do"</span>,</span><br><span class="line">    contentType: <span class="string">"application/json"</span>,</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(idList),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>我可以像如下代码一样接收参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/deleteRoles"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">deleteRoles</span><span class="params">(@RequestBody List&lt;Long&gt;idList)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//删除角色</span></span><br><span class="line">    <span class="keyword">int</span> total = roleService.deleteRoles(idList);</span><br><span class="line">    <span class="comment">//绑定视图</span></span><br><span class="line">    mv.addObject(<span class="string">"total"</span>, total);</span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里注解<code>@RequestBody</code>表示要求<code>SpringMVC</code>将传递过来的<code>JSON</code>数组数据，转换为对应的<code>Java</code>集合类型</li>
<li>也可以不使用<code>List</code>而是使用简单的<code>Long[]</code>数组</li>
</ul>
<p>有时可能要传递复杂数据类型的数组作为参数，如下所示<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> roleList = [</span><br><span class="line">    &#123;<span class="attr">roleName</span>: <span class="string">'role_name_1'</span>, <span class="attr">note</span>: <span class="string">'note_1'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">roleName</span>: <span class="string">'role_name_2'</span>, <span class="attr">note</span>: <span class="string">'note_2'</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">roleName</span>: <span class="string">'role_name_3'</span>, <span class="attr">note</span>: <span class="string">'note_3'</span>&#125;</span><br><span class="line">];</span><br><span class="line">$.post(&#123;</span><br><span class="line">    url: <span class="string">"./params/insertRoles.do"</span>,</span><br><span class="line">    contentType: <span class="string">"application/json"</span>,</span><br><span class="line">    data: <span class="built_in">JSON</span>.stringify(roleList),</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">result</span>)</span>&#123;&#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>通过如下的方式就可以轻松获取复杂数组了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/insertRoles"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">deleteRoles</span><span class="params">(@RequestBody List&lt;Role&gt;roleList)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    <span class="comment">//新增角色</span></span><br><span class="line">    <span class="keyword">int</span> total = roleService.insertRoles(idList);</span><br><span class="line">    <span class="comment">//绑定视图</span></span><br><span class="line">    mv.addObject(<span class="string">"total"</span>, total);</span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-2-重定向"><a href="#15-2-重定向" class="headerlink" title="15.2 重定向"></a>15.2 重定向</h3><p>首先，我们实现过一个将角色信息转换为JSON视图的功能，只要传递角色信息给它，它就能将信息转化为视图<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/showRoleJsonInfo"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showRoleJsonInfo</span><span class="params">(Long id, String roleName, String note)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    mv.addObject(<span class="string">"id"</span>, id);</span><br><span class="line">    mv.addObject(<span class="string">"roleName"</span>, roleName);</span><br><span class="line">    mv.addObject(<span class="string">"note"</span>, note);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>现在假设我们又有这样一个需求，每当新增一个角色信息时，需要其将数据以<code>JSON</code>视图的形式展示给请求者。在数据保存到数据库后，由数据库返回角色编号，再将角色信息传递给<code>showRoleJsonlnfo</code>方法，就可以展示<code>JSON</code>视图给请求者了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addRole"</span>)</span><br><span class="line"><span class="comment">//Model为重定向数据模型，SpringMVC会自动初始化它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addRole</span><span class="params">(Model model, String roleName, String note)</span></span>&#123;</span><br><span class="line">    Role role = <span class="keyword">new</span> Role();</span><br><span class="line">    role.setRoleName(roleName);</span><br><span class="line">    role.setNote(note);</span><br><span class="line">    <span class="comment">//插入角色后，会回填角色编号</span></span><br><span class="line">    roleService.insertRole(role);</span><br><span class="line">    <span class="comment">//绑定重定向数据模型</span></span><br><span class="line">    model.addAttribute(<span class="string">"roleName"</span>, roleName);</span><br><span class="line">    model.addAttribute(<span class="string">"note"</span>, note);</span><br><span class="line">    model.addAttribute(<span class="string">"id"</span>, role.getid());</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:./showRoleJsonInfo.do"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>Model</code>是个数据模型，用来绑定数据</li>
<li><code>SpringMVC</code>有一个约定，当返回的字符串带有<code>redirect</code>的时候，它会认为需要的是一个重定向</li>
</ul>
<p>此外，我们也可以通过返回视图来实现重定向<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addRole2"</span>)</span><br><span class="line"><span class="comment">//Model为重定向数据模型，SpringMVC会自动初始化它</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">addRole2</span><span class="params">(ModelAndView mv, String roleName, String note)</span></span>&#123;</span><br><span class="line">    Role role = <span class="keyword">new</span> Role();</span><br><span class="line">    role.setRoleName(roleName);</span><br><span class="line">    role.setNote(note);</span><br><span class="line">    <span class="comment">//插入角色后，会回填角色编号</span></span><br><span class="line">    roleService.insertRole(role);</span><br><span class="line">    <span class="comment">//绑定重定向数据模型</span></span><br><span class="line">    mv.addObject(<span class="string">"roleName"</span>, roleName);</span><br><span class="line">    mv.addObject(<span class="string">"note"</span>, note);</span><br><span class="line">    mv.addObject(<span class="string">"id"</span>, role.getid());</span><br><span class="line">    mv.setViewName(<span class="string">"redirect:./showRoleJsonInfo.do"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是有时需要传递一个<code>POJO</code>而不是简单的参数，比如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/showRoleJsonInfo2"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">showRoleJsonInfo</span><span class="params">(Role role)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么问题来了，在<code>URL</code>重定向的过程中，并不能有效传递对象，因为<code>HTTP</code>的重定向参数是以字符串传递的。这个时候<code>SpringMVC</code>提供了一个方法: <code>flash</code>属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/addRole3"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addRole3</span><span class="params">(RedirectAttributes ra, Role role)</span></span>&#123;</span><br><span class="line">    roleService.insertRole(role);</span><br><span class="line">    ra.addFlashAttribute(<span class="string">"role"</span>, role);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:./showRoleJsonInfo2.do"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>使用<code>addFlashAttribute</code>方法后，<code>SpringMVC</code>会将数据保存到<code>Session</code>中，重定向后<code>Session</code>会将其清楚并传递给重定向后的控制器。</li>
</ul>
<p>上述流程如下<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200205_0.png" alt=""></p>
<h3 id="15-3-保存并获取属性参数"><a href="#15-3-保存并获取属性参数" class="headerlink" title="15.3 保存并获取属性参数"></a>15.3 保存并获取属性参数</h3><p>在开发控制器的时候，我们会暂存数据到<code>HTTP</code>的<code>request</code>对象或者<code>Session</code>对象中，或者从<code>HTTP</code>的<code>request</code>对象或者<code>Session</code>对象中获取数据。<code>SpringMVC</code>对此给予了支持</p>
<ul>
<li><code>@RequestAttribute</code>: 获取<code>HTTP</code>的请求(<code>request</code>)对象属性值，用来传递给控制器的参数</li>
<li><code>@SessionAttribute</code>: 将<code>HTTP</code>会话(<code>Session</code>)对象属性值传递给控制器的参数</li>
<li><code>@SessionAttribute</code>: 可以通过它来设置模型中的哪些属性放入到<code>Session</code>中</li>
</ul>
<h4 id="15-3-1-注解-RequestAttribute"><a href="#15-3-1-注解-RequestAttribute" class="headerlink" title="15.3.1 注解@RequestAttribute"></a>15.3.1 注解<code>@RequestAttribute</code></h4><p>假设现在请求对象中有一个<code>id</code>属性，我们可以通过这种方式将其取出，但是对于<code>@RequestAttribute</code>注解的参数，默认不能为空，否则系统会抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/requestAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">reqAttr</span><span class="params">(@RequestAttribute(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    ModelAndView mv=<span class="keyword">new</span> ModelAndView();</span><br><span class="line">    Role role=roleService.getRole(id);</span><br><span class="line">    mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView()) ;</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15-3-2-注解-SessionAttribute和注解-SessionAttributes"><a href="#15-3-2-注解-SessionAttribute和注解-SessionAttributes" class="headerlink" title="15.3.2 注解@SessionAttribute和注解@SessionAttributes"></a>15.3.2 注解<code>@SessionAttribute</code>和注解<code>@SessionAttributes</code></h4><p>在浏览器和服务器保持联系的时候<code>HTTP</code>会创建一个会话对象，这样可以让我们在和服务器会话期间通过它读写会话对象的属性，缓存一定数据信息</p>
<p><code>@SessionAttributes</code>这个注解可以设置会话属性，但只能对类进行注解。它的作用是当这个类被注解后，<code>SpringMVC</code>执行完控制器的逻辑后，将数据模型中对应的属性名称或属性类型保存到<code>HTTP</code>的<code>Session</code>对象中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/attribute"</span>）</span><br><span class="line"><span class="comment">//可以配置数据模型的名称和类型，两者取或关系</span></span><br><span class="line"><span class="meta">@SessionAttributes</span>(names=&#123;<span class="string">"id"</span>&#125;, types=&#123; Role.class&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeController</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/sessionAttributes"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ModelAndViewsessionAttrs</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        Role role = roleService.getRole(id);</span><br><span class="line">        <span class="comment">//根据类型，Session将会保存角色信息</span></span><br><span class="line">        mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">        <span class="comment">//根据名称，Session将会保存id</span></span><br><span class="line">        mv.addObject(<span class="string">"id"</span>, id);</span><br><span class="line">        <span class="comment">//视图名称，定义跳转到一个JSP 文件上</span></span><br><span class="line">        mv.setViewName(<span class="string">"sessionAttribute"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这样就可以避免使用<code>ServletAPI</code>中的<code>HttpSession</code>对象来设置<code>Session</code>的属性</li>
</ul>
<p>通过注解<code>@SessionAttribute</code>可以读取<code>Session</code>中保存的属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/sessionAttribute"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">sessionAttr</span><span class="params">(@SessionAttribute(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="15-3-3-注解-CookieValue和注解-RequestHeader"><a href="#15-3-3-注解-CookieValue和注解-RequestHeader" class="headerlink" title="15.3.3 注解@CookieValue和注解@RequestHeader"></a>15.3.3 注解<code>@CookieValue</code>和注解<code>@RequestHeader</code></h4><p>这两个注解分别可以从<code>Cookie</code>和<code>HTTP</code>请求头中获取对应的请求信息<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/getHeaderAndCookie"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testHeaderAndCookie</span><span class="params">(@RequestHeader(value=<span class="string">"user-Agent"</span>, required=<span class="keyword">false</span>, defaultValue=<span class="string">"attribute"</span>)</span> String userAgent, @<span class="title">CookieValue</span><span class="params">(value=<span class="string">"JSESSIONID"</span>, required=<span class="keyword">true</span>, defaultValue=<span class="string">"MyJsessionId"</span>)</span> String jsessionId)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="15-4-拦截器"><a href="#15-4-拦截器" class="headerlink" title="15.4 拦截器"></a>15.4 拦截器</h3><p>拦截器是<code>SpringMVC</code>中强大的控件，它可以在进入处理器之前做一些操作，或者在处理器完成后进行操作，甚至是在渲染视图后进行操作。<code>SpringMVC</code>会在启动期间就通过<code>@RequestMapping</code>的注解解析<code>URI</code>和处理器的对应关系，在运行的时候通过请求找到对应的<code>HandlerMapping</code>，然后构建<code>HandlerExecutionChain</code>对象，它是一个执行的责任链对象<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_1.png" alt=""><br>责任链对象指向了控制器所对应的方法和拦截器。对于拦截器所需要关注的有两点，一个是它有哪些方法，方法的含义是什么；第二个是它各个方法在流程中执行的顺序是如何。</p>
<h4 id="15-4-1-拦截器的定义"><a href="#15-4-1-拦截器的定义" class="headerlink" title="15.4.1 拦截器的定义"></a>15.4.1 拦截器的定义</h4><p><code>Spring</code>要求处理器的拦截器都要实现接口<code>org.springframework.web.servlet.HandlerInterceptor</code>，这个接口定义了3个方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>preHandle</code>方法: 在处理器之前执行的前置方法，这样<code>SpringMVC</code>就可以在进入处理器前处理一些方法了</li>
<li><code>postHandle</code>方法: 在处理器之后执行的后置方法，处理器的逻辑完成后运行它</li>
<li><code>afterCompletion</code>方法: 无论是否产生异常都会在渲染视图后执行的方法</li>
</ul>
<h4 id="15-4-2-拦截器的执行流程"><a href="#15-4-2-拦截器的执行流程" class="headerlink" title="15.4.2 拦截器的执行流程"></a>15.4.2 拦截器的执行流程</h4><p><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_2.png" alt=""></p>
<h4 id="15-4-3-开发拦截器"><a href="#15-4-3-开发拦截器" class="headerlink" title="15.4.3 开发拦截器"></a>15.4.3 开发拦截器</h4><p>拦截器必须实现<code>HandlerInterceptor</code>接口，而<code>Spring</code>也为增强功能开发了多个拦截器。首先当<code>XML</code>配置文件加入了元素<code>&lt;mvc:annotation-driven&gt;</code>或者使用<code>Java</code>配置使用注解<code>@EnableWebMvc</code>时，系统就会初始化拦截器<code>ConversionServiceExposinglnterceptor</code>，它是个一开始就被<code>SpringMVC</code>系统默认加载的拦截器，它的主要作用是根据配置在控制器上的注解来完成对应的功能。</p>
<p><code>SpringMVC</code>提供的公共拦截器<code>HandlerInterceptorAdapter</code>，<code>Spring</code>之所以那么做，是为了提供适配器，就是当只想实现3个拦截器方法中的1到2个时，那么只要继承它，根据需要覆盖掉原有的方法就可以了。</p>
<p>拦截器部分的继承关系如下<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_3.png" alt=""></p>
<p>下面来实现一个简单的拦截器的例子，第一步定义一个拦截器<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.interceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.handler.HandlerInterceptorAdapter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"preHandle"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"postHandle"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterCompletion"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二步，将这个拦截器配置到<code>SpringMVC</code>中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.edu.neu.Interceptor.RoleInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebMvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        InterceptorRegistration ir = registry.addInterceptor(<span class="keyword">new</span> RoleInterceptor());</span><br><span class="line">        ir.addPathPatterns(<span class="string">"/my/*"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>addPathPatterns</code>匹配的是一个正则式，用来告诉<code>SpringMVC</code>要拦截什么请求</li>
</ul>
<h4 id="15-4-4-多个拦截器的执行顺序"><a href="#15-4-4-多个拦截器的执行顺序" class="headerlink" title="15.4.4 多个拦截器的执行顺序"></a>15.4.4 多个拦截器的执行顺序</h4><p>和责任链的顺序类似，略</p>
<h3 id="15-5-验证表单"><a href="#15-5-验证表单" class="headerlink" title="15.5 验证表单"></a>15.5 验证表单</h3><p>在实际工作中，得到数据后的第一步就是检验数据的正确性，如果存在录入上的问题，一般会通过注解校验，发现错误后返回给用户，但是对于一些逻辑上的错误，比如购买金额＝购买数量×单价，这样的规则就很难使用注解方式进行验证了，这个时候可以使用<code>Spring</code>所提供的验证器<code>Validator</code>规则去验证。</p>
<h4 id="15-5-1-使用JSR300注解验证输入内容"><a href="#15-5-1-使用JSR300注解验证输入内容" class="headerlink" title="15.5.1 使用JSR300注解验证输入内容"></a>15.5.1 使用<code>JSR300</code>注解验证输入内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TradeParams</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Future</span></span><br><span class="line">    <span class="meta">@DateTimeFormat</span>(pattern=<span class="string">"yyyy-MM-dd"</span>)    </span><br><span class="line">    <span class="meta">@NotNull</span></span><br><span class="line">    <span class="keyword">private</span> Date date;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/validate"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValidateController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/annotation"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">annotationValidate</span><span class="params">(@Valid TradeParams tradeParams, Errors errors)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 是否存在错误</span></span><br><span class="line">		<span class="keyword">if</span> (errors.hasErrors()) &#123;</span><br><span class="line">			<span class="comment">// 获取错误信息</span></span><br><span class="line">			List&lt;FieldError&gt; errorList = errors.getFieldErrors();</span><br><span class="line">			<span class="keyword">for</span> (FieldError error : errorList) &#123;</span><br><span class="line">				<span class="comment">// 打印字段错误信息</span></span><br><span class="line">				System.err.println(<span class="string">"fied :"</span> + error.getField() + <span class="string">"\t"</span> + <span class="string">"msg:"</span> + error.getDefaultMessage());</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">		mv.setViewName(<span class="string">"index"</span>);</span><br><span class="line">		<span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="15-5-2-使用验证器"><a href="#15-5-2-使用验证器" class="headerlink" title="15.5.2 使用验证器"></a>15.5.2 使用验证器</h4><p>有时候除了简单的输入格式、非空性等校验，也需要一定的业务校验，Spring 提供了<code>Validator</code>接口来实现检验，它将在进入控制器逻辑之前对参数的合法性进行检验。</p>
<h3 id="15-6-数据模型"><a href="#15-6-数据模型" class="headerlink" title="15.6 数据模型"></a>15.6 数据模型</h3><p>我们一直使用<code>ModelAndView</code>，它既可以定义视图类型，也可以加载数据模型。ModelAndView有一个类型为<code>ModelMap</code>的属性<code>model</code>，它通过键值对的方式来存取数据。相关类图如下<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_6.png" alt=""></p>
<ul>
<li><code>ModelMap</code>的一个实例是<code>ModelAndView</code>中的属性，并且它继承自<code>LinkedHashMap&lt;String, Object&gt;</code></li>
<li>而<code>ExtendedModelMap</code>继承自<code>ModelMap</code>并实现了<code>Model</code>接口，它还有个子类<code>BindingAwareModelMap</code>平时我们实际上使用的是这个类的实例</li>
</ul>
<p>在实际中我们既可以使用<code>Model</code>、<code>ModelMap</code>，也可以使用<code>ModelAndView</code>来存取数据，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value = <span class="string">"/getRoleByModelMap"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getRoleByModelMap</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id, ModelMap modelMap) </span>&#123;</span><br><span class="line">	    Role role = roleService.getRole(id);</span><br><span class="line">	    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	    mv.setViewName(<span class="string">"roleDetails"</span>);</span><br><span class="line">	    modelMap.addAttribute(<span class="string">"role"</span>, role);</span><br><span class="line">	    <span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/getRoleByModel"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getRoleByModel</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id, Model model) </span>&#123;</span><br><span class="line">	    Role role = roleService.getRole(id);</span><br><span class="line">	    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">	    mv.setViewName(<span class="string">"roleDetails"</span>);</span><br><span class="line">	    model.addAttribute(<span class="string">"role"</span>, role);</span><br><span class="line">	    <span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(value = <span class="string">"/getRoleByMv"</span>, method = RequestMethod.GET)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getRoleByMv</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id, ModelAndView mv) </span>&#123;</span><br><span class="line">	    Role role = roleService.getRole(id);</span><br><span class="line">	    mv.setViewName(<span class="string">"roleDetails"</span>);</span><br><span class="line">	    mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">	    <span class="keyword">return</span> mv;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>无论是使用<code>Model</code>还是<code>ModelMap</code>，它都是<code>BindAwareModelMap</code>的实例，这个类实现了<code>Model</code>接口，并且继承了<code>ModelMap</code>类，因此有了相互转化的功能</li>
<li>而上面代码的<code>getRoleByModel</code>和<code>getRoleByModelMap</code>都没有显式地把数据模型绑定给<code>ModelAndView</code>。这一步其实是<code>SpringMVC</code>在完成控制器逻辑后，自动帮我们完成的。</li>
</ul>
<h3 id="15-7-视图和视图解析器"><a href="#15-7-视图和视图解析器" class="headerlink" title="15.7 视图和视图解析器"></a>15.7 视图和视图解析器</h3><h4 id="15-7-1-视图"><a href="#15-7-1-视图" class="headerlink" title="15.7.1 视图"></a>15.7.1 视图</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> org.springframework.lang.Nullable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    String RESPONSE_STATUS_ATTRIBUTE = View.class.getName() + <span class="string">".responseStatus"</span>;</span><br><span class="line">    String PATH_VARIABLES = View.class.getName() + <span class="string">".pathVariables"</span>;</span><br><span class="line">    String SELECTED_CONTENT_TYPE = View.class.getName() + <span class="string">".selectedContentType"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getContentType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">render</span><span class="params">(@Nullable Map&lt;String, ?&gt; Model, HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getContentType</code>表示返回一个字符串，标明给用户什么类型的文件响应，可以是<code>HTML</code>、<code>JSON</code>、<code>PDF</code> 等</li>
<li><code>render</code>方法则是一个渲染视图的方法，通过它就可以渲染视图了<ul>
<li>其中，<code>Model</code>是其数据模型</li>
<li><code>HTTP</code> 请求对象和响应对象用于处理<code>HTTP</code>请求的各类问题</li>
</ul>
</li>
</ul>
<p>在<code>SpringMVC</code>中实现<code>View</code>的类很多，比如<code>JSTL</code>视图<code>JstlView</code>, <code>JSON</code>视图<code>MappingJackson2JsonView</code>等，通过这些<code>View</code>的<code>render</code>方法，<code>SpringMVC</code>就可以将数据模型渲染成为各类视图</p>
<p>下图是各种视图类和它们间的关系<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_4.png" alt=""></p>
<p>视图又可分为逻辑视图和非逻辑视图。</p>
<ul>
<li>例如，<code>MappingJackson2JsonView</code>是个非逻辑视图，它的目的是将数据模型转换为一个<code>JSON</code>视图，展现给用户，无须对视图名称再进一步的解析</li>
<li>而InternalResourceView是一个逻辑视图，对逻辑视图而言它需要一个视图解析器，通过视图名称找到对应的真实视图。</li>
</ul>
<h4 id="15-7-2-视图解析器"><a href="#15-7-2-视图解析器" class="headerlink" title="15.7.2 视图解析器"></a>15.7.2 视图解析器</h4><p>对于逻辑视图而言把视图名称转换为真实视图是一个必备过程，比如<code>IntenalResourceView</code>就是这样的一个视图，当配置了这个视图对应的解析器<code>InternalResourceViewResolver</code>之后，它会被加载到<code>SpringMVC</code>的视图解析器列表中去，当返回<code>ModelAndView</code>的时候，<code>SpringMVC</code>就会在视图解析器列表中遍历，找到对应的视图解析器去解析视图。</p>
<p>对<code>SpringMVC</code>，它配置了多种视图解析器<br><img src="/2020/02/06/SSM-15-深入SpringMVC组件/200206_5.png" alt=""></p>
<h3 id="15-8-上传文件"><a href="#15-8-上传文件" class="headerlink" title="15.8 上传文件"></a>15.8 上传文件</h3><p>略</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/04/SSM-14-SpringMVC的初始化和流程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/04/SSM-14-SpringMVC的初始化和流程/" itemprop="url">[SSM][14][SpringMVC的初始化和流程]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-04T21:45:44+08:00">
                2020-02-04
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/04/SSM-14-SpringMVC的初始化和流程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/04/SSM-14-SpringMVC的初始化和流程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-14-章-SpringMVC的初始化和流程"><a href="#第-14-章-SpringMVC的初始化和流程" class="headerlink" title="第 14 章 SpringMVC的初始化和流程"></a>第 14 章 SpringMVC的初始化和流程</h2><p><code>SpringMVC</code>是<code>Spring</code>提供给<code>web</code>应用的框架设计，而流程和各个组件的应用和改造是<code>springMVC</code>的根本</p>
<h3 id="14-1-MVC设计概述"><a href="#14-1-MVC设计概述" class="headerlink" title="14.1 MVC设计概述"></a>14.1 <code>MVC</code>设计概述</h3><p><code>MVC</code>的设计根本目的在于解耦各个模块</p>
<p>在早期的<code>JavaWeb</code>开发中，主要是<code>JSP+JavaBean</code>模式，如下图。但是很快人们发现<code>JSP</code>和<code>JavaBean</code>之间出现了严重的耦合，<code>Java</code>和<code>HTML</code>也耦合在了一起。这样开发者不仅需要掌握<code>Java</code>，还需要有高超的前端技术，对开发者要求很高。更为严重的是，出现了页面前端和后端相互依赖的糟糕情况，前端需要等待后端完成，而后端也依赖于前端完成，才能进行有效测试。而且每一个场景操作几乎都难以复用，因为业务逻辑基本都是由<code>JSP</code>完成的，还混杂了很多页面逻辑功能。<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_0.png" alt=""></p>
<p>正因为种种弊端，所以很快这种方式被<code>Servlet+JSP+JavaBean</code>给代替，如下图。这种模式多了一个<code>Servlet</code>组件，首先用户的请求到达<code>Servlet</code>，<code>Servlet</code>组件主要作为控制器，这样<code>Servlet</code>就接受了这个请求，可以通过它调度<code>JavaBean</code>，来读写数据库的数据，然后将结果放到<code>JSP</code>中，这样就可以获取数据并展示给用户<br>。使用了<code>MVC</code>后的一个根本好处是前台和后台得到了一定程度的分离，但是依旧存在一定的耦合。对于后端而言，由于控制器和模型层的分离使得大量的<code>Java</code>代码可以得到重用，而这时作为<code>MVC</code>框架的经典:<code>Struts1</code>、<code>Struts2</code>和<code>Hibernate</code>纷纷崛起。<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_1.png" alt=""></p>
<p>它们都存在一些问题。在当今互联网的开发中，随着手机端的兴起，<code>Web</code>页面大部分采用<code>Ajax</code>请求，它们之间的交互只需要<code>JSON</code>数据而己，这样对于<code>JSP</code>的稿合度的依赖就大大降低了。但是无论是<code>Struts1</code>还是<code>Struts2</code>和前端<code>JSP</code>都有着比较紧密的关联，尤其是在<code>Struts1</code>中，更是有大量的关于<code>JSP</code>的<code>jar</code>包， 但是大部分的请求都来自于移动互联的手机端或者平板电脑，对于<code>JSP</code>的依赖己经大大减少，这注定了依赖于页面编程的<code>Struts</code>己经不适合时代的发展了。</p>
<h4 id="14-1-1-SpringMVC的架构"><a href="#14-1-1-SpringMVC的架构" class="headerlink" title="14.1.1 SpringMVC的架构"></a>14.1.1 <code>SpringMVC</code>的架构</h4><p>对于持久层而言，随着软件发展，迁移数据库的可能性很小，所以在大部分情况下都用不到<code>Hibernate</code>的<code>HQL</code>来满足移植数据库的要求。与此同时，性能对于互联网来说更为重要，不可优化<code>SQL</code>、不够灵活成了<code>Hibernate</code>难以治愈的伤痛，这样<code>MyBatis</code>就崛起了。无论是<code>Hibernate</code>还是<code>MyBatis</code>都没处理好数据库事务的编程，同时随着各种<code>NoSQL</code>的强势崛起，使得<code>JavaWeb</code>应用不仅能够在数据库中获取数据，也可以从<code>NoSQL</code>中获取数据，这些不是持久层框架可以处理的了，而<code>SpringMVC</code>给出了方案<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_3.png" alt=""></p>
<p>传统的模型层被拆分为业务层(<code>Service</code>)和数据访问层(<code>DAO, DataAccessObject</code>)。在<code>Service</code>下可以通过<code>Spring</code>的声明式事务操作访问数据访问层，而在业务层上还允许我们访问<code>NoSQL</code>。对于<code>SpringMVC</code>来说，其最大的特点就是结构松散，比如几乎可以在<code>SpringMVC</code>中使用各类视图，包括<code>JSON、JSP、XML、PDF</code>等，所以它能够满足手机端、页面端和平板电脑端的各类请求。</p>
<h4 id="14-1-2-SpringMVC组件与流程"><a href="#14-1-2-SpringMVC组件与流程" class="headerlink" title="14.1.2 SpringMVC组件与流程"></a>14.1.2 <code>SpringMVC</code>组件与流程</h4><p><code>SpringMVC</code>是一种基于<code>Servlet</code>的技术，它提供了核心控制器<code>DispatcherServlet</code>和相关的组件，并制定了松散的结构，以适合各种灵活的需要</p>
<p><code>SpringMVC</code>的组件和流程图如下<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_2.png" alt=""></p>
<p><code>SpringMVC</code>的初始化过程</p>
<ul>
<li><code>SpringMVC</code>框架是围绕着<code>DispatcherServlet</code>工作的，它是一个<code>Servlet</code>，可以拦截<code>HTTP</code>发送过来的请求</li>
<li>在<code>Servlet</code>初始化时，<code>SpringMVC</code>会根据配置，获取配置信息，从而得到统一资源标识符(<code>URI, Uniform Resource Identifier</code>)和处理器(<code>Handler</code>)之间的映射关系(<code>HandlerMapping</code>)</li>
<li>为了更加灵活和增强功能，<code>SpringMVC</code>还会给处理器加入拦截器，所以还可以在处理器执行前后加入自己的代码，这样就构成了一个处理器的执行链(<code>HandlerExecutionChain</code>)</li>
<li>并且还根据上下文初始化视图解析器等内容，当处理器返回的时候就可以通过视图解析器定位视图，然后将数据模型渲染到视图中以响应用户请求</li>
</ul>
<p>当请求到来时，<code>SpringMVC</code>的处理流程</p>
<ol>
<li><code>DispatcherServlet</code>首先通过请求和事先解析好的<code>HandlerMapper</code>配置找到对应的<code>Handler</code>，这样就准备好了处理器和拦截器组成的执行链</li>
<li>而运行处理器需要一个对应的运行环境，这个环境就是适配器(<code>HandlerAdapter</code>)，通过这个适配器就能运行对应的处理器及其拦截器</li>
<li>在处理器返回模型和视图给<code>DispacherServlet</code>后，它会把对应的视图信息传递给视图解析器(<code>ViewResolver)</code>。注意，这一步取决于是否使用逻辑视图，如果是逻辑视图，那么视图解析器就会解析它，然后把模型渲染到视图中去，最后响应用户的请求：如果不是逻辑视图，则不会进行处理，而是直接通过视图渲染数据模型。</li>
</ol>
<p><code>SpringMVC</code>是一个松散的结构，所以可以满足各类请求的需要，为此它也实现了大部分请求所需的类库，拥有较为丰富的类库供我们使用，所以流程中的大部分组件并不需要我们实现</p>
<h4 id="14-1-3-SpringMVC入门的实例"><a href="#14-1-3-SpringMVC入门的实例" class="headerlink" title="14.1.3 SpringMVC入门的实例"></a>14.1.3 <code>SpringMVC</code>入门的实例</h4><p>第一步，首先需要配置<code>WEB</code>工程的<code>web.xml</code>文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcher<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>系统变量<code>contextConfigLocation</code>告诉<code>SpringMVC</code>其<code>SpringIoC</code>的配置文件在哪里，这样<code>Spring</code>就会找到这些配置文件并加载它们</li>
<li><code>ContextLoaderListener</code>实现了接口<code>ServletContextListener</code>，它的作用是可以在整个<code>web</code>工程前后加入自定义代码，所以可以在<code>web</code>工程初始化之前，它先完成对<code>SpringIoC</code>容器的初始化，也可以在<code>web</code>工程关闭之时完成<code>SpringIoC</code>的资源释放</li>
<li>配置<code>DispatcherServlet</code>拦截以后缀<code>do</code>结束的请求，这样所有以后缀<code>do</code>结尾的请求都会被它拦截</li>
</ul>
<p>第二步，在<code>applicationContext.xml</code>中配置<code>SpringIoC</code>，这里先不配置任何<code>bean</code><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>第三步，配置<code>dispatcher-servlet.xml</code>文件，它配置与<code>SpringMVC</code>相关的内容<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/tool"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.edu.neu.controller"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span> <span class="attr">p:prefix</span>=<span class="string">"/WEB-INF/jsp/"</span> <span class="attr">p:suffix</span>=<span class="string">".jsp"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先定义要扫描装载的包，用以加载对应的控制器和其他一些组件</li>
<li>定义视图解析器，解析器中定义了前缀和后缀，这样视图就知道去<code>web</code>工程的<code>/WEB-INF/JSP</code>文件夹中找到对应的<code>JSP</code>文件作为视图响应用户请求</li>
</ul>
<p>第三步，开发一个简单的<code>Controller</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"myController"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/my"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/index"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"index"</span>);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p><code>@Controller</code>说明这个类是一个控制器。<code>SpringMVC</code>扫描的时候就会把它作为控制器加载进来。</p>
</li>
<li><p><code>@RequestMapping</code>指定了对应的请求的URI，<code>SpringMVC</code>在初始化的时候就会将这些信息解析，存放到<code>HandlerMapping</code>中。当发生请求时，<code>SpringMVC</code>就会使用这些信息去找到对应的控制器提供服务</p>
</li>
<li><p>方法返回<code>ModelAndView</code>，在方法中把视图名称定义为<code>index</code>，而在在配置文件中所配置的视图解析器，配置前缀为<code>WEB-INF/jsp／</code>，后缀是<code>.jsp</code>，再加上返回的视图逻辑名称为<code>index</code>，所以它会选择使用<code>/WEB-INF/jsp/index.jsp</code>作为最后的响应</p>
</li>
</ul>
<p>第三步，开发一个简单的<code>jsp</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">          content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;HelloSpringMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello Spring MVC !&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>第四步，启动一个服务器<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_4.png" alt=""></p>
<p>下面是这个例子的完整流程图<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_5.png" alt=""></p>
<ol>
<li>当<code>SpringMVC</code>启动时会去解析<code>MyController</code>的注解，然后生成对应<code>URI</code>和请求的映射关系，并注册对应的方法</li>
<li>请求到来时，首先根据<code>URI</code>找到对应的<code>HandlerMapping</code>，然后组织一个执行链</li>
<li>通过请求类型找到<code>RequestMappingHandlerAdapter</code>，它的实例是在<code>DispatcherServlet</code>初始化的时候进行创建的</li>
<li>然后通过<code>RequestMappingHandlerAdapter</code>去执行<code>HandlerExecutionChain</code>的内容，最终在<code>MyController</code>方法中将<code>index</code>视图返回给<code>DispatcherServlet</code></li>
<li>最后视图解析器通过前后缀找到<code>/WEB-INF/jsp/index.jsp</code>文件作为视图，响应最终的请求</li>
</ol>
<h3 id="14-2-SpringMVC初始化"><a href="#14-2-SpringMVC初始化" class="headerlink" title="14.2 SpringMVC初始化"></a>14.2 <code>SpringMVC</code>初始化</h3><p>这一节我们将看到<code>SpringMVC</code>是如何初始化<code>SpringIoC</code>容器上下文和映射请求上下文。其中映射请求上下文是为了适应<code>JavaWeb</code>工程的需要，由<code>SpringIoC</code>上下文扩展而来的</p>
<h4 id="14-2-1-初始化SpringIOC上下文"><a href="#14-2-1-初始化SpringIOC上下文" class="headerlink" title="14.2.1 初始化SpringIOC上下文"></a>14.2.1 初始化<code>SpringIOC</code>上下文</h4><p><code>Java Web</code>容器提供<code>ServletContextListener</code>接口，这个接口可以在<code>Web</code>容器初始化和结束期中执行一定的逻辑，也就是说，通过实现它可以在<code>DispatcherServlet</code>初始化前就可以完成<code>Spring IoC</code>容器的初始化也可以在结束期完成对<code>Spring IoC</code>容器的销毁。</p>
<p><code>SpringMVC</code>将这个工作交给了类<code>ContextLoaderListener</code>，源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.web.context;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextLoaderListener</span> <span class="keyword">extends</span> <span class="title">ContextLoader</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ContextLoaderListener</span><span class="params">(WebApplicationContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化SpringWebIoC容器</span></span><br><span class="line">        <span class="keyword">this</span>.initWebApplicationContext(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关闭SpringWebIoC容器</span></span><br><span class="line">        <span class="keyword">this</span>.closeWebApplicationContext(event.getServletContext());</span><br><span class="line">        <span class="comment">//清除相关参数</span></span><br><span class="line">        ContextCleanupListener.cleanupAttributes(event.getServletContext());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="14-2-2-初始化映射请求上下文"><a href="#14-2-2-初始化映射请求上下文" class="headerlink" title="14.2.2 初始化映射请求上下文"></a>14.2.2 初始化映射请求上下文</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">initServletBean</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.getServletContext().log(<span class="string">"Initializing Spring "</span> + <span class="keyword">this</span>.getClass().getSimpleName() + <span class="string">" '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"Initializing Servlet '"</span> + <span class="keyword">this</span>.getServletName() + <span class="string">"'"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//初始化SpringIoC容器</span></span><br><span class="line">            <span class="keyword">this</span>.webApplicationContext = <span class="keyword">this</span>.initWebApplicationContext();</span><br><span class="line">            <span class="keyword">this</span>.initFrameworkServlet();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | ServletException var4) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.error(<span class="string">"Context initialization failed"</span>, var4);</span><br><span class="line">            <span class="keyword">throw</span> var4;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</span><br><span class="line">            String value = <span class="keyword">this</span>.enableLoggingRequestDetails ? <span class="string">"shown which may lead to unsafe logging of potentially sensitive data"</span> : <span class="string">"masked to prevent unsafe logging of potentially sensitive data"</span>;</span><br><span class="line">            <span class="keyword">this</span>.logger.debug(<span class="string">"enableLoggingRequestDetails='"</span> + <span class="keyword">this</span>.enableLoggingRequestDetails + <span class="string">"': request parameters and headers will be "</span> + value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isInfoEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.info(<span class="string">"Completed initialization in "</span> + (System.currentTimeMillis() - startTime) + <span class="string">" ms"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> WebApplicationContext <span class="title">initWebApplicationContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    WebApplicationContext rootContext = WebApplicationContextUtils.getWebApplicationContext(<span class="keyword">this</span>.getServletContext());</span><br><span class="line">    WebApplicationContext wac = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//判断是否已经被初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.webApplicationContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果被初始化了，就沿用它</span></span><br><span class="line">        wac = <span class="keyword">this</span>.webApplicationContext;</span><br><span class="line">        <span class="keyword">if</span> (wac <span class="keyword">instanceof</span> ConfigurableWebApplicationContext)&#123;</span><br><span class="line">            ConfigurableWebApplicationContext cwac =(ConfigurableWebApplicationContext)wac;</span><br><span class="line">            <span class="keyword">if</span> (!cwac.isActive()) &#123;</span><br><span class="line">                <span class="comment">//如果SpringIoC容器还没有刷新，那么就进行刷新父容器上下文，设置id等操作</span></span><br><span class="line">                <span class="comment">//处理父容器为空的情况</span></span><br><span class="line">                <span class="keyword">if</span> (cwac.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    cwac.setParent(rootContext);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.configureAndRefreshWebApplicationContex(cwac);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有被初始化，则查找是否有存在的SpringWebIoC容器</span></span><br><span class="line">        <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac = <span class="keyword">this</span>.findWebApplicationContext();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有被初始化，也不存在的SpringWebIoC容器，则自己创建</span></span><br><span class="line">        <span class="keyword">if</span> (wac == <span class="keyword">null</span>) &#123;</span><br><span class="line">            wac = <span class="keyword">this</span>.createWebApplicationContext(rootContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当onRefresh方法没有被调用时，执行onRefresh方法</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.refreshEventReceived) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="keyword">this</span>.onRefreshMonitor) &#123;</span><br><span class="line">                <span class="keyword">this</span>.onRefresh(wac);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.publishContext) &#123;</span><br><span class="line">            <span class="comment">//作为Servlet的上下文属性发布IoC容器</span></span><br><span class="line">            String attrName = <span class="keyword">this</span>.getServletContextAttributeName();</span><br><span class="line">            <span class="keyword">this</span>.getServletContext().setAttribute(attrName, wac);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wac;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上面这段代码主要是说明：当<code>IoC</code>容器没有对应的初始化的时候，<code>DispatcherServlet</code>会尝试去初始化它，最后调度<code>onRefresh</code>方法</li>
</ul>
<p>下面了解一下<code>DispatcherServlet</code>的<code>onRefresh</code>方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRefresh</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.initStrategies(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initStrategies</span><span class="params">(ApplicationContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//初始化文件的解析</span></span><br><span class="line">    <span class="keyword">this</span>.initMultipartResolver(context);</span><br><span class="line">    <span class="comment">//本地解析化</span></span><br><span class="line">    <span class="keyword">this</span>.initLocaleResolver(context);</span><br><span class="line">    <span class="comment">//主题解析</span></span><br><span class="line">    <span class="keyword">this</span>.initThemeResolver(context);</span><br><span class="line">    <span class="comment">//处理器映射</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerMappings(context);</span><br><span class="line">    <span class="comment">//处理器的适配器</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerAdapters(context);</span><br><span class="line">    <span class="comment">//初始化Handler的异常处理解析器</span></span><br><span class="line">    <span class="keyword">this</span>.initHandlerExceptionResolvers(context);</span><br><span class="line">    <span class="comment">//略</span></span><br><span class="line">    <span class="keyword">this</span>.initRequestToViewNameTranslator(context);</span><br><span class="line">    <span class="comment">//初始化视图逻辑名称转换器，即允许返回逻辑视图名称，然后由它来找到真实的视图</span></span><br><span class="line">    <span class="keyword">this</span>.initViewResolvers(context);</span><br><span class="line">    <span class="comment">//初始化flash管理器</span></span><br><span class="line">    <span class="keyword">this</span>.initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码进行初始化的组件都是<code>SpringMVC</code>的核心组件，下面来解释这些组件</p>
<ul>
<li><code>MultipartResolver</code>:文件解析器，用以支持服务器的文件上传</li>
<li><code>LocaleResolver</code>: 国际化解析器，用以提供国际化的功能</li>
<li><code>ThemeResolver</code>: 主题解析器，类似于软件皮肤的转换功能</li>
<li><code>HandlerMapping</code>: 它用以组装用户提供的某个控制器的方法和这个方法对应的一些拦截器</li>
<li><code>HandlerAdapter</code>: 处理器适配器，因为处理器会在不同的上下文中运行，所以在不同的场景中要提供适应当前场景的适配器</li>
<li><code>HandlerExceptionResolver</code>: 处理器异常解析器，如果处理器产生异常，会通过这个解析器去处理这些异常</li>
<li><code>RequestToViewNameTranslator</code>: 视图逻辑名称转换器</li>
<li><code>ViewResolver</code>: 视图解析器，当控制器返回后，通过视图解析器会把逻辑视图名称进行解析，然后定位实际视图</li>
</ul>
<p>而对于这些组件<code>DispatcherServlet</code>会根据其配置文件<code>DispatcherServlet.properties</code>进行初始化。因此我们并不需要很多的配置就可以使用<code>SpringMVC</code></p>
<h4 id="14-2-3-使用注解配置方式初始化"><a href="#14-2-3-使用注解配置方式初始化" class="headerlink" title="14.2.3 使用注解配置方式初始化"></a>14.2.3 使用注解配置方式初始化</h4><p>由于在<code>Servlet3.0</code>之后的规则允许取消<code>web.xml</code>配置，只使用注解方式就可以，所以在<code>Spring3.1</code>之后的版本也提供了注解方式的配置，以<code>14.1.3</code>的例子来看，我们只需要实现两个<code>Java</code>类，就可以去掉这个例子中<code>XML</code>格式的配置文件</p>
<p>第一个类是<code>MyWebAppInitializer</code>类，它继承自<code>AbstractAnnotationConfigDispatcherServletInitializer</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class[] &#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;<span class="string">"*.do"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>getRootConfigClasses</code>方法用来获取<code>SpringIoC</code>容器的Java配置类，用以加载各类<code>SpringBean</code></li>
<li><code>getServletConfigClasses</code>方法获取各类<code>SpringMVC</code>的<code>URI</code>和控制器的配置关系类，用来生成<code>Web</code>请求的上下文，这里加载了我们下文定义的<code>WebConfig</code>类</li>
<li><code>getServletMappings</code>定义了<code>DispatcherServlet</code>拦截的请求</li>
</ul>
<p>第二个类是WebConfig类，它用于配置<code>URI</code>和控制器的映射关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.edu.neu.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.edu.neu.*"</span>)</span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name=<span class="string">"viewResolver"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">initResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver viewResolver = <span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        viewResolver.setPrefix(<span class="string">"/WEB-INF/jsp/"</span>);</span><br><span class="line">        viewResolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">        <span class="keyword">return</span> viewResolver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>首先我们使用<code>@ComponentScan</code>来加载控制器</li>
<li>然后我们定义了一个视图解析器(<code>viewResolver</code>)，并设置了它的前后缀</li>
</ul>
<h3 id="14-3-SpringMVC开发流程详解"><a href="#14-3-SpringMVC开发流程详解" class="headerlink" title="14.3 SpringMVC开发流程详解"></a>14.3 <code>SpringMVC</code>开发流程详解</h3><p>目前的开发过程中，大部分都会采用注解的开发方式。最常用的注解是<code>@Controller</code>和<code>@RequestMapping</code>。<code>@RequestMapping</code>可以配置在类或者方法上，它的作用是指定<code>URI</code>和哪个类作为一个请求的处理器。</p>
<p>为了更加灵活，<code>SpringMVC</code>还定义了处理器的拦截器，当启动<code>SpringMVC</code>时，<code>SpringMVC</code>就会去解析<code>@Controller</code>中的<code>@RequestMapping</code>的配置，再结合所配置的拦截器，组成多个拦截器和一个控制器的形式，存放到一个<code>HandlerMapping</code>中</p>
<h4 id="14-3-1-配置-RequestMapping"><a href="#14-3-1-配置-RequestMapping" class="headerlink" title="14.3.1 配置@RequestMapping"></a>14.3.1 配置<code>@RequestMapping</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Mapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> RequestMapping &#123;</span><br><span class="line">    <span class="comment">//请求路径</span></span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求路径，可以是数组</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"path"</span>)</span><br><span class="line">    String[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求路径，数组</span></span><br><span class="line">    <span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line">    String[] path() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求类型，比如是`HTTP`的`GET`请求还是`POST`请求</span></span><br><span class="line">    RequestMethod[] method() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求参数</span></span><br><span class="line">    String[] params() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求头</span></span><br><span class="line">    String[] headers() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理器类型</span></span><br><span class="line">    String[] consumes() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回结果类型，比如`application/json; charset=UTF-8`、`text/plain`</span></span><br><span class="line">    String[] produces() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里最常用的是请求路径和请求类型，下面是使用<code>@RequestMapping</code>的例子，这个方法对于<code>/my/index2.do</code>的<code>HTTP GET</code>请求提供了响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ModelAndView index2&#123;</span><br><span class="line">    ModerAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setViewName(<span class="string">"index"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="14-3-2-控制器的开发"><a href="#14-3-2-控制器的开发" class="headerlink" title="14.3.2 控制器的开发"></a>14.3.2 控制器的开发</h4><p>控制器的开发一般分为三个步骤</p>
<ol>
<li>获取请求参数</li>
<li>处理业务逻辑</li>
<li>绑定模型和视图</li>
</ol>
<h5 id="14-3-2-1-获取请求参数"><a href="#14-3-2-1-获取请求参数" class="headerlink" title="14.3.2.1 获取请求参数"></a>14.3.2.1 获取请求参数</h5><p>在<code>SpringMVC</code>中，接收参数的方式有很多种，例如可以通过传统<code>Servlet</code>的<code>API</code>接收参数，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/index2"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index2</span><span class="params">(HttpSession session, HttpServletRequest request)</span></span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.setViewName(<span class="string">"index"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是上文的这种方法并不是一个好的方法。这样会使得它与<code>Servlet</code>容器紧密耦合，不利于扩展和测试</p>
<p>我们通常采用<code>@RequestParam</code>注解的方式来获取参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/index2"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index2</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span>Long id)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>@RequestParam</code>注解实际上实现了如下代码的类似功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String idStr = request.getParameter(<span class="string">"id"</span>);</span><br><span class="line">Long id = Long.parseLong(idStr);</span><br></pre></td></tr></table></figure></p>
<p>此外，默认情况下<code>@RequestParam</code>标注的参数不能为空，若为空，会产生异常。但这个标签由两个有用的配置项来解决这个问题</p>
<ul>
<li><code>request</code>是一个布尔值，若想允许参数为空，可将其设置为<code>false</code></li>
<li><code>defaultValue</code>可以为参数提供默认值</li>
</ul>
<p><code>SpringMVC</code>还提供了<code>@SessionAttribute</code>去从<code>Session</code>中获取对应的数据<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/index2"</span>, method=RequestMethod.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">index2</span><span class="params">(@SessionAttribute(<span class="string">"userName"</span>)</span> String userName)</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="14-3-2-2-实现逻辑和绑定视图"><a href="#14-3-2-2-实现逻辑和绑定视图" class="headerlink" title="14.3.2.2 实现逻辑和绑定视图"></a>14.3.2.2 实现逻辑和绑定视图</h5><p>例子如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/role"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleController</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注入用来处理业务逻辑的roleService</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RoleService roleService = <span class="keyword">null</span>;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/getRole"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getRole</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        Role role = roleService.getRole(id);</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.setViewName(<span class="string">"roleDetails"</span>);</span><br><span class="line">        <span class="comment">//给数据模型添加一个角色对象</span></span><br><span class="line">        mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">        <span class="keyword">return</span> mv;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="14-3-3-视图渲染"><a href="#14-3-3-视图渲染" class="headerlink" title="14.3.3 视图渲染"></a>14.3.3 视图渲染</h4><p>SpringMVC会默认使用JstlView进行渲染，也就是将查询出来的模型绑定到<code>JSTL</code>模型中，这样通过<code>JSTL</code>就可以在<code>JSP</code>中读出数据模型的数据了<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span>%&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">"UTF-8"</span>&gt;</span><br><span class="line">    &lt;meta name=<span class="string">"viewport"</span></span><br><span class="line">          content=<span class="string">"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"</span>&gt;</span><br><span class="line">    &lt;meta http-equiv=<span class="string">"X-UA-Compatible"</span> content=<span class="string">"ie=edge"</span>&gt;</span><br><span class="line">    &lt;title&gt;HelloSpringMVC&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;Hello Spring MVC !&lt;/h1&gt;</span><br><span class="line">    &lt;table&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;th&gt;标签&lt;/th&gt;</span><br><span class="line">            &lt;th&gt;值&lt;/th&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;角色编号&lt;/tb&gt;</span><br><span class="line">            &lt;td&gt;&lt;c:out value="$&#123;role.id&#125;"&gt;&lt;/c:out&gt;&lt;td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;角色名称&lt;/tb&gt;</span><br><span class="line">            &lt;td&gt;&lt;c:out value="$&#123;role.name&#125;"&gt;&lt;/c:out&gt;&lt;td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">            &lt;td&gt;角色备注&lt;/tb&gt;</span><br><span class="line">            &lt;td&gt;&lt;c:out value="$&#123;role.note&#125;"&gt;&lt;/c:out&gt;&lt;td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>
<p>通过数据渲染，我们会得到如下界面<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_6.png" alt=""></p>
<p>但目前在前端技术中，普遍使用<code>Ajax</code>技术，这种情况下往往后台需要返回<code>JSON</code>数据给前端使用，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/getRole"</span>, method=Request.GET)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">getRole</span><span class="params">(@RequestParam(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    Role role = roleService.getRole(id);</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"role"</span>, role);</span><br><span class="line">    <span class="comment">//指定视图类型</span></span><br><span class="line">    mv.setView(<span class="keyword">new</span> MappingJackson2JsonView());</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们请求后会获得<code>JSON</code>数据，如下所示<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_6.png" alt=""></p>
<p>上面请求的的流程图如下<br><img src="/2020/02/04/SSM-14-SpringMVC的初始化和流程/200204_8.png" alt=""><br>由于<code>MappingJackson2JsonView</code>是一个非逻辑视图，因此不需要视图解析器进行解析，它会直接把<code>ModelAndView</code>中的数据通过<code>JSONView</code>转换出来，这样就可以得到<code>JSON</code>数据了。</p>
<h3 id="14-4-小结"><a href="#14-4-小结" class="headerlink" title="14.4 小结"></a>14.4 小结</h3><ul>
<li><code>SpringMVC</code>框架核心内容是流程和组件</li>
<li><code>SpringMVC</code>需要初始化<code>IoC</code>容器和<code>DispatcherServlet</code>请求两个上下文，其中<code>DispatcherServlet</code>请求上下文是<code>SpringIoC</code>上下文的扩展，这样就能使得<code>Spring</code>各个<code>Bean</code>能够形成依赖注入</li>
<li><code>SpringMVC</code>而言，控制器是开发的核心内容，要知道如何获取请求参数，处理逻辑业务，然后将得到的数据通过视图解析器和视图渲染出来展现出来</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/02/SSM-11-面向切面编程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/02/SSM-11-面向切面编程/" itemprop="url">[SSM][11][面向切面编程]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-02T11:34:20+08:00">
                2020-02-02
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SSM/" itemprop="url" rel="index">
                    <span itemprop="name">SSM</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/02/SSM-11-面向切面编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/02/SSM-11-面向切面编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第-11-章-面向切面编程"><a href="#第-11-章-面向切面编程" class="headerlink" title="第 11 章 面向切面编程"></a>第 11 章 面向切面编程</h2><h3 id="11-1-一个简单的约定游戏"><a href="#11-1-一个简单的约定游戏" class="headerlink" title="11.1 一个简单的约定游戏"></a>11.1 一个简单的约定游戏</h3><p>略</p>
<h3 id="11-2-SpringAOP的基本概念"><a href="#11-2-SpringAOP的基本概念" class="headerlink" title="11.2 SpringAOP的基本概念"></a>11.2 SpringAOP的基本概念</h3><h4 id="11-2-1-AOP的概念和使用原因"><a href="#11-2-1-AOP的概念和使用原因" class="headerlink" title="11.2.1 AOP的概念和使用原因"></a>11.2.1 AOP的概念和使用原因</h4><p>先看一个不使用SpringAOP的例子，这里使用MyBatis框架，完成扣减一个产品的库存并且新增一笔交易记录的功能<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePurchaseRecord</span><span class="params">(Long productId, PurchaseRecord record)</span></span>&#123;</span><br><span class="line">    SqlSession sqlSession = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        sqlSession = SqlSessionFactoryUtils.openSqlSession();</span><br><span class="line">        ProductMapper productMapper = sqlSession.getMapper(ProductMapper.class);</span><br><span class="line">        Product product = productMapper.getRole(productId);</span><br><span class="line">        <span class="keyword">if</span>(product.getStock() &gt;= record.getQuantity())&#123;</span><br><span class="line">            product.setStock(product.getStock() - record.getQuantity());</span><br><span class="line">            productMapper.update(product);</span><br><span class="line">            PurchaseRecordMapper purchaseRecordMapper = sqlSession.getMapper(PurchaseRecordMapper.class);</span><br><span class="line">            purchaseRecordMapper.save(record);</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        sqlSession.rollBack();</span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(sqlSession != <span class="keyword">null</span>)&#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这里的购买交易的产品和购买记录都在<code>try...catch...finally...</code>语句中</li>
<li>业务流程中穿插着事务的提交和回滚</li>
<li>并不是一个很好的设计</li>
</ul>
<p>针对上一个例子的缺点，<code>SpringAOP</code>希望开发者能写成下面例子的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> ProductMapper productMapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> PurchaseRecordMapper purchaseRecordMapper = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">//.....</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateRoleNote</span><span class="params">(Long productId, PurchaseRecord record)</span></span>&#123;</span><br><span class="line">    Product product = productMapper.getRole(productId);</span><br><span class="line">    <span class="keyword">if</span>(product.getStock() &gt;= record.getQuantity())&#123;</span><br><span class="line">        product.setStock(product.getStock() - record.getQuantity());</span><br><span class="line">        productMapper.update(product);</span><br><span class="line">        purchaseRecordMapper.save(record);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>这段代码除了一个注解<code>@Transactional</code>，没有任何打开、关闭数据库资源或者提交回滚事务的代码，却能完成与上面例子相同的功能</li>
<li>这段代码主要集中在业务处理上，而不是数据库事务和资源控制，这就是<code>AOP</code>的魅力</li>
</ul>
<p>接下来我们探讨<code>SpringAOP</code>是如何做到这点的。</p>
<p><code>AOP</code>可以通过动态代理模式，带来管控各个对象操作的切面环境，管理包括日志、数据库事务等操作，让我们拥有在反射原有对象方法之前、正常返回之后、异常返回之后插入自己代码的能力，有时我们甚至可以取代原有对象方法。</p>
<p>下面还是以数据库事务的例子来做说明</p>
<ul>
<li>首先我们来了解以下正常<code>SQL</code>的逻辑步骤<ol>
<li>通过数据库连接池来获得数据库连接资源，并进行一定的设置工作</li>
<li>执行对应的<code>SQL</code>语句，对数据进行操作</li>
<li>如果<code>SQL</code>执行过程中发生异常，回滚事务</li>
<li>如果<code>SQL</code>执行过程中没有发生异常，最后提交事务</li>
<li>关闭连接资源</li>
</ol>
</li>
<li><code>SQL</code>逻辑步骤的流程图如下<br>  <img src="/2020/02/02/SSM-11-面向切面编程/200202_0.png" alt=""></li>
<li><p>而作为<code>AOP</code>，完全可以根据这个流程做一定的封装，然后通过动态代理技术，将代码织入到对应的流程中，我们完全可以进行如下设计</p>
<ol>
<li>打开获取数据连接在<code>before</code>方法中完成</li>
<li>执行<code>SQL</code>，通过反射机制调用业务逻辑</li>
<li>如果<code>SQL</code>执行过程中发生异常，回滚事务，如果<code>SQL</code>执行过程中没有发生异常，提交事务，关闭连接资源</li>
</ol>
</li>
<li><p>更重要的，对于数据库事务这种通用的操作来说，<code>SpringAOP</code>已经提供了一些通用的拦截器来处理，并不需要开发者自己实现。开发者只需要修改配置，就可以定制想要的功能。这就是<code>@Transactional</code>标签要做的，当方法标注为<code>@Transcational</code>标签时，方法启用数据库事务功能。如下图所示<br>  <img src="/2020/02/02/SSM-11-面向切面编程/200202_1.png" alt=""></p>
</li>
<li><p>通过这种方式，达成了约定优于配置的原则，使得开发者更关注于业务逻辑本身，而不是资源的控制。</p>
</li>
</ul>
<h4 id="11-2-2-面向切面编程的术语"><a href="#11-2-2-面向切面编程的术语" class="headerlink" title="11.2.2 面向切面编程的术语"></a>11.2.2 面向切面编程的术语</h4><p>这一节来解释一些<code>AOP</code>的常用术语</p>
<h5 id="1-切面"><a href="#1-切面" class="headerlink" title="1. 切面"></a>1. 切面</h5><p>切面就是在一个怎么样的环境中工作，它可以定义后面需要介绍的通知、切点和引入等内容，然后<code>SpringAOP</code>会将其定义的内容织入到约定的流程中，在动态代理中可以把它理解为拦截器，比如类<code>RoleInterceptor</code>就是一个切面类。而常见的比如说，数据库事务就可以理解为一个切面</p>
<h5 id="2-通知"><a href="#2-通知" class="headerlink" title="2 通知"></a>2 通知</h5><p>通知是切面的方法，与动态代理中，拦截器的方法类似，通知有如下种类:</p>
<ul>
<li>前置通知(<code>before</code>): 在动态代理反射原有对象方法前执行的通知</li>
<li>后置通知(<code>after</code>): 在动态代理反射原有对象方法后执行的通知</li>
<li>返回通知(<code>afterRuturning</code>):在动态代理反射原有对象方法正常返回后执行的通知</li>
<li>异常通知(<code>afterThrowing</code>):在动态代理反射原有对象方法产生异常后执行的通知</li>
<li>环绕通知(<code>around</code>):它可以取代当前被拦截对象的方法</li>
</ul>
<h5 id="3-引入"><a href="#3-引入" class="headerlink" title="3 引入"></a>3 引入</h5><p>引入允许我们在现有的类里添加自定义的类和方法</p>
<h5 id="4-切点"><a href="#4-切点" class="headerlink" title="4 切点"></a>4 切点</h5><p>用来告诉<code>SpringAOP</code>在什么时候启动拦截并织入对应的流程中</p>
<h5 id="5-连接点"><a href="#5-连接点" class="headerlink" title="5 连接点"></a>5 连接点</h5><p>连接点就是需要拦截器拦截的方法，比如例子中的<code>savePurchaseRecord</code>就是一个连接点</p>
<h5 id="6-织入"><a href="#6-织入" class="headerlink" title="6 织入"></a>6 织入</h5><p>织入是一个生成代理对象并将切面内容放入到流程中的过程</p>
<p>AOP的流程图如下所示<br><img src="/2020/02/02/SSM-11-面向切面编程/200202_2.png" alt=""></p>
<h4 id="11-2-3-Spring对AOP的支持"><a href="#11-2-3-Spring对AOP的支持" class="headerlink" title="11.2.3 Spring对AOP的支持"></a>11.2.3 Spring对AOP的支持</h4><p><code>SpringAOP</code>是一种基于方法拦截的<code>AOP</code>。在<code>Spring</code>中有4种方法去实现<code>AOP</code>的拦截</p>
<ul>
<li>使用<code>ProxyFactoryBean</code>和对应的接口实现<code>AOP</code></li>
<li>使用<code>XML</code>配置<code>AOP</code></li>
<li>使用<code>@AspectJ</code>注解驱动切面</li>
<li>使用<code>AspectJ</code>注入切面</li>
</ul>
<h3 id="11-3-使用-AspectJ注解开发SpringAOP"><a href="#11-3-使用-AspectJ注解开发SpringAOP" class="headerlink" title="11.3 使用@AspectJ注解开发SpringAOP"></a>11.3 使用<code>@AspectJ</code>注解开发<code>SpringAOP</code></h3><h4 id="11-3-1-选择连接点"><a href="#11-3-1-选择连接点" class="headerlink" title="11.3.1 选择连接点"></a>11.3.1 选择连接点</h4><p><code>Spring</code>是方法级别的<code>AOP</code>框架，所以连接点只能是某个类下的某个方法。用动态代理来理解，就是要拦截哪个方法织入对应的<code>AOP</code>通知。</p>
<p>例子：我们先定义一个接口，和一个实现类，然后将实现类里的方法作为连接点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">(Role role)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"roleServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleServiceImpl</span> <span class="keyword">implements</span> <span class="title">RoleService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printRoleInfo</span><span class="params">(Role role)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"id = "</span> + role.getId());</span><br><span class="line">        System.out.println(<span class="string">"roleName = "</span> + role.getRoleName());</span><br><span class="line">        System.out.println(<span class="string">"note = "</span> + role.getNote());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-2-创建切面"><a href="#11-3-2-创建切面" class="headerlink" title="11.3.2 创建切面"></a>11.3.2 创建切面</h4><p>在<code>Spring</code>中使用<code>@Aspect</code>注解一个类，那么这个类就会被看作切面，就相当于动态代理中的拦截器类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"roleAspect"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoleAspect</span></span>&#123;</span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterReturning</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterReturning......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterThrowing</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"afterThrowing......"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="11-3-3-定义切点"><a href="#11-3-3-定义切点" class="headerlink" title="11.3.3 定义切点"></a>11.3.3 定义切点</h4><p>毕竟不是所有方法都需要使用<code>AOP</code>编程，所以我们的程序要有判断是否启用切面的功能，这也就是切点的定义，确定对于哪些调用启用切面。</p>
<p>如上面的例程所示，<code>Spring</code>是通过<code>@Before</code>这类注解后的正则表达式来判断切点的，例如下面这个表达式<code>execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))</code></p>
<ul>
<li><code>execution</code>: 表示执行方法的时候触发</li>
<li><code>*</code>:代表任意返回类型的方法</li>
<li><code>ComponentDemo.RoleServiceImpl</code>: 代表类的全限定名</li>
<li><code>printRoleInfo</code>: 是被拦截的方法名称</li>
<li><code>(..)</code>: 任意的参数</li>
</ul>
<p>进一步讨论这个正则表达式，它还可以配置如下内容</p>
<table>
<thead>
<tr>
<th>AspectJ</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>arg()</code></td>
<td>规定连接点匹配参数为指定类型的方法</td>
</tr>
<tr>
<td><code>@args()</code></td>
<td>规定连接点匹配指定注解标注的方法</td>
</tr>
<tr>
<td><code>execution</code></td>
<td>匹配连接点的执行方法</td>
</tr>
<tr>
<td><code>this()</code></td>
<td>规定连接点匹配<code>AOP</code>代理的<code>Bean</code></td>
</tr>
<tr>
<td><code>target</code></td>
<td>规定连接点匹配被代理对象为指定的类型</td>
</tr>
<tr>
<td><code>@target()</code></td>
<td>规定连接点匹配特定的执行对象，这些对象要符合指定的注解类型</td>
</tr>
<tr>
<td><code>within()</code></td>
<td>规定连接点匹配指定的包</td>
</tr>
<tr>
<td><code>@within()</code></td>
<td>规定连接点匹配指定的类型</td>
</tr>
<tr>
<td><code>@annotation</code></td>
<td>规定匹配带有指定注解的连接点</td>
</tr>
</tbody>
</table>
<h4 id="11-3-4-测试AOP"><a href="#11-3-4-测试AOP" class="headerlink" title="11.3.4 测试AOP"></a>11.3.4 测试AOP</h4><p>这一节来编写程序测试<code>AOP</code>是否生效</p>
<p>首先需要进行<code>Spring</code> <code>Bean</code>的配置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.EnableAspectJAutoProxy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"ComponentDemo"</span>&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PojoConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>@EnableAspectJAutoProxy</code>代表启用<code>AspectJ</code>框架的自动代理，这时<code>Spring</code>才会生成动态代理对象，进而使用<code>AOP</code></li>
</ul>
<p>然后编写程序的主入口即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ComponentDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(PojoConfig.class);</span><br><span class="line">        Role role = ctx.getBean(Role.class);</span><br><span class="line">        RoleService roleService = ctx.getBean(RoleService.class);</span><br><span class="line">        roleService.printRoleInfo(role);</span><br><span class="line">        ((AnnotationConfigApplicationContext) ctx).close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before......</span><br><span class="line">id = 1</span><br><span class="line">roleName = role_name_1</span><br><span class="line">note = role_note_1</span><br><span class="line">after......</span><br><span class="line">afterReturning......</span><br></pre></td></tr></table></figure></p>
<h4 id="11-3-5-环绕通知"><a href="#11-3-5-环绕通知" class="headerlink" title="11.3.5 环绕通知"></a>11.3.5 环绕通知</h4><p>环绕通知是<code>SpringAOP</code>中最强大的通知，它可以同时实现前置通知和后置通知。它保留了调度被代理对象原有方法的功能，所以它既强大，又灵活。但是由于强大，它的可控制性不那么强，如果不需要大量改变业务逻辑，一般而言并不需要使用它。</p>
<p>例如<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">around</span><span class="params">(ProceedingJoinPoint jp)</span></span>&#123;</span><br><span class="line">       System.out.println(<span class="string">"around before......"</span>);</span><br><span class="line">       <span class="keyword">try</span>&#123;</span><br><span class="line">           jp.proceed();</span><br><span class="line">       &#125;<span class="keyword">catch</span>(Throwable e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(<span class="string">"around after......"</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="11-3-6-织入"><a href="#11-3-6-织入" class="headerlink" title="11.3.6 织入"></a>11.3.6 织入</h4><p>织入是生成代理对象并将切面内容放入约定流程的过程。使用<code>JDK</code>动态代理时，必须拥有接口，而使用<code>CGLib</code> 则不需要，于是<code>Spring</code>就提供了一个规则：当类的实现存在接口的时候，<code>Spring</code>将提供<code>JDK</code>动态代理。而当类不存在接口的时候没有办法使用<code>JDK</code>动态代理，<code>Spring</code>会采用<code>CGLIB</code>来生成代理对象。</p>
<h4 id="11-3-7-给通知传递参数"><a href="#11-3-7-给通知传递参数" class="headerlink" title="11.3.7 给通知传递参数"></a>11.3.7 给通知传递参数</h4><p>有时我们希望给各类通知传递参数，可以使用如下方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Before</span>(<span class="string">"execution(* ComponentDemo.RoleServiceImpl.printRoleInfo(..))"</span> + <span class="string">"&amp;&amp; args(role)"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Role role)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before......"</span> + role.getRoleName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在切点的表达式中，加入了参数的定义，这样便可以传递参数</li>
</ul>
<h4 id="11-3-8-引入"><a href="#11-3-8-引入" class="headerlink" title="11.3.8 引入"></a>11.3.8 引入</h4><p>略</p>
<h3 id="11-4-使用XML配置开发SpringAOP"><a href="#11-4-使用XML配置开发SpringAOP" class="headerlink" title="11.4 使用XML配置开发SpringAOP"></a>11.4 使用<code>XML</code>配置开发<code>SpringAOP</code></h3><p>方法大致和使用注解类似，这里不详细说明</p>
<h3 id="11-5-经典SpringAOP应用程序"><a href="#11-5-经典SpringAOP应用程序" class="headerlink" title="11.5 经典SpringAOP应用程序"></a>11.5 经典<code>SpringAOP</code>应用程序</h3><p>略</p>
<h3 id="11-6-多个切面"><a href="#11-6-多个切面" class="headerlink" title="11.6 多个切面"></a>11.6 多个切面</h3><p>Spring支持使多个切面按照指定的顺序运行，这时候可以使用注解<code>@Order</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect1</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect2</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Aspect2</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring底层是通过责任链来处理多个切面的，如下图<br><img src="/2020/02/02/SSM-11-面向切面编程/200202_3.png" alt=""></p>
<h3 id="11-7-小结"><a href="#11-7-小结" class="headerlink" title="11.7 小结"></a>11.7 小结</h3><p><code>AOP</code>是<code>Spring</code>两大核心内容之一，通过<code>AOP</code>可以将一些比较公用的代码抽取出来，进而减少开发者的工作量</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/NLP-5-关键词提取算法/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/NLP-5-关键词提取算法/" itemprop="url">[NLP][5][关键词提取算法]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:21:40+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index">
                    <span itemprop="name">nlp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/NLP-5-关键词提取算法/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/NLP-5-关键词提取算法/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第5章-关键词提取算法"><a href="#第5章-关键词提取算法" class="headerlink" title="第5章 关键词提取算法"></a>第5章 关键词提取算法</h2><ul>
<li>关键词是代表文章重要内容的一组词，对文本聚类、分类、自动摘要等起重要作用</li>
</ul>
<hr>
<h3 id="5-1-关键词提取技术概述"><a href="#5-1-关键词提取技术概述" class="headerlink" title="5.1 关键词提取技术概述"></a>5.1 关键词提取技术概述</h3><ul>
<li><p>关键词提取算法一般也可以分为有监督和无监督两类</p>
</li>
<li><p>监督式关键词提取</p>
<ul>
<li>简介：主要通过分类的方式进行</li>
<li>介绍：通过构建一个较为丰富和完善的词表，然后通过判断每个文档与词表中每个词的匹配程度，以类似打标签的方式，达到关键词提取的效果</li>
<li>优缺点：有监督的方法能够获取到较高的精度，但缺点是需要大批量的标注数据，人工成本过高</li>
</ul>
</li>
<li><p>无监督关键词提取</p>
<ul>
<li>无监督提取对数据的要求比较低</li>
<li>既不需要一张人工生成、维护的词表，也不需要人工标准语料辅助进行训练</li>
</ul>
</li>
</ul>
<hr>
<h3 id="5-2-关键词提取算法TF-IDF算法"><a href="#5-2-关键词提取算法TF-IDF算法" class="headerlink" title="5.2 关键词提取算法TF-IDF算法"></a>5.2 关键词提取算法TF-IDF算法</h3><ul>
<li><p>TF-IDF算法(Term Frequency-Inverse Document Frequency， 词频-逆文档频次算法)是一种基于统计的计算方法，常用于评估在一个文档集中一个词对某份文档的重要程度</p>
</li>
<li><p>TF-IDF算法由两部分组成:TF算法以及IDF算法</p>
<ul>
<li>TF算法<ul>
<li>简介：统计一个词在一篇文档中出现的频次</li>
<li>基本思想：一个词在文档中出现的次数越多，则其对文档的表达能力就越强</li>
</ul>
</li>
<li>IDF算法<ul>
<li>简介：统计一个词在文档集的多少个文档中出现</li>
<li>基本思想：如果一个词在越少的文档中出现，则其对文档的区分能力也就越强</li>
</ul>
</li>
</ul>
</li>
<li><p>我们将这两种算法综合起来使用，构成TF-IDF算法，从词频、逆文档频次两个角度对词的重要性进行衡量</p>
</li>
<li><p>TF的计算常用式<br>  <img src="/2020/02/01/NLP-5-关键词提取算法/tf.png" alt=""><br>  也就是 tf(word) = (word在文档中出现的次数)/(文档总词数)</p>
</li>
<li><p>IDF的计算常用式<br>  <img src="/2020/02/01/NLP-5-关键词提取算法/idf.png" alt="">  </p>
<ul>
<li><code>|D|</code>表示<strong>文档集</strong>中文档的总数</li>
<li><code>|Di|</code>为文档集中出现词i的文档数量</li>
<li>分母加1是采用了拉普拉斯平滑</li>
</ul>
</li>
<li><p>TF-IDF算法计算式<br>  <img src="/2020/02/01/NLP-5-关键词提取算法/tfidf.png" alt=""></p>
</li>
</ul>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/NLP-4-词性标注和命名实体识别/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/NLP-4-词性标注和命名实体识别/" itemprop="url">[NLP][4][词性标注和命名实体识别]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-01T21:18:38+08:00">
                2020-02-01
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/nlp/" itemprop="url" rel="index">
                    <span itemprop="name">nlp</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/01/NLP-4-词性标注和命名实体识别/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/01/NLP-4-词性标注和命名实体识别/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="4-2-命名实体识别"><a href="#4-2-命名实体识别" class="headerlink" title="4.2 命名实体识别"></a>4.2 命名实体识别</h3><hr>
<h4 id="4-1-1-词性标注简介"><a href="#4-1-1-词性标注简介" class="headerlink" title="4.1.1 词性标注简介"></a>4.1.1 词性标注简介</h4><hr>
<h4 id="4-1-2-词性标注规范"><a href="#4-1-2-词性标注规范" class="headerlink" title="4.1.2 词性标注规范"></a>4.1.2 词性标注规范</h4><hr>
<h4 id="4-1-3-基于条件随机场的词性标注"><a href="#4-1-3-基于条件随机场的词性标注" class="headerlink" title="4.1.3 基于条件随机场的词性标注"></a>4.1.3 基于条件随机场的词性标注</h4><ul>
<li><p><a href="https://www.jianshu.com/p/55755fc649b1" target="_blank" rel="noopener">原文参考地址</a></p>
</li>
<li><p>特征函数</p>
<ul>
<li>它接受四个参数<ol>
<li>句子s</li>
<li>i，用来表示句子s中的第i个单词</li>
<li>l<sub>i</sub>，表示要评分的标注序列给第i个单词标注的词性</li>
<li>l<sub>i-1</sub>，表示要评分的标注序列给第i-1个单词标注的词性</li>
</ol>
</li>
<li>它的输出值是0或者1<ul>
<li>0 表示不符合这个特征</li>
<li>1 表示要评分的标注序列符合这个特征</li>
</ul>
</li>
</ul>
</li>
<li><p>从特征函数到概率</p>
<ul>
<li>定义好一组特征函数后，我们要给每个特征函数f<sub>j</sub>赋予一个权重λ<sub>j</sub>。</li>
<li>现在，只要有一个句子s，有一个标注序列l，我们就可以利用前面定义的特征函数集来对l评分。</li>
<li>下式中有两个求和，外面的求和用来求每一个特征函数f<sub>j</sub>评分值的和，里面的求和用来求句子中每个位置的单词的的特征值的和。</li>
<li>得分公式如下<br><img src="/2020/02/01/NLP-4-词性标注和命名实体识别/score.png" alt=""></li>
<li>对这个分数进行指数化和标准化，我们就可以得到标注序列l的概率值p(l|s)，如下所示：<br><img src="/2020/02/01/NLP-4-词性标注和命名实体识别/p.png" alt=""></li>
</ul>
</li>
<li><p>总结</p>
<ul>
<li>为了建一个条件随机场，我们首先要定义一个特征函数集，每个特征函数都以整个句子s，当前位置i，位置i和i-1的标签为输入</li>
<li>然后为每一个特征函数赋予一个权重</li>
<li>然后针对每一个标注序列l，对所有的特征函数加权求和</li>
<li>必要的话，可以把求和的值转化为一个概率值</li>
</ul>
</li>
</ul>
<hr>
<h3 id="4-2-命名实体识别-1"><a href="#4-2-命名实体识别-1" class="headerlink" title="4.2 命名实体识别"></a>4.2 命名实体识别</h3><h4 id="4-2-1-命名实体识别简介"><a href="#4-2-1-命名实体识别简介" class="headerlink" title="4.2.1 命名实体识别简介"></a>4.2.1 命名实体识别简介</h4><h4 id="4-2-2-基于条件随机场的命名实体识别"><a href="#4-2-2-基于条件随机场的命名实体识别" class="headerlink" title="4.2.2 基于条件随机场的命名实体识别"></a>4.2.2 基于条件随机场的命名实体识别</h4>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">112</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
