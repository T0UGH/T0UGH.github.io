<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="打怪升级日常">
<meta property="og:url" content="http://yoursite.com/page/25/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="打怪升级日常">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/25/">





  <title>打怪升级日常</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>
    <a href="https://github.com/T0UGH" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">打怪升级日常</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">两星炸弹人(╯‵□′)╯炸弹！•••</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/16/JVM-3-垃圾收集器与内存分配策略/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="T0UGH(GuiPing Wang)">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="打怪升级日常">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/" itemprop="url">[JVM][3][垃圾收集器与内存分配策略]</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-02-16T14:52:55+08:00">
                2020-02-16
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/jvm/" itemprop="url" rel="index">
                    <span itemprop="name">jvm</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第3章-垃圾回收器与内存分配策略"><a href="#第3章-垃圾回收器与内存分配策略" class="headerlink" title="第3章 垃圾回收器与内存分配策略"></a>第3章 垃圾回收器与内存分配策略</h2><h3 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h3><p>在1960年诞生于麻省理工学院的<code>Lisp</code>是第一门开始使用动态内存分配和垃圾收集技术的语言。当<code>Lisp</code>还在胚胎时期，其作者<code>JohnMcCarthy</code>就思考过垃圾收集需要完成的三件事情</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭，栈中的帧栈随着方法的进入和退出而有条不紊地执行着入栈和出栈操作。每个帧栈中分配多少内存基本上是在类结构确定下来时就已知的。因此这几个区域的内存分配和回收都具有确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了</p>
<p>而<code>Java</code>堆和方法区却有着显著的不确定性</p>
<ol>
<li>一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样</li>
<li>并且只有在运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象</li>
</ol>
<h3 id="3-2-对象已死？"><a href="#3-2-对象已死？" class="headerlink" title="3.2 对象已死？"></a>3.2 对象已死？</h3><p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象中哪些还存活着，哪些已经死去</p>
<h4 id="3-2-1-引用计数算法"><a href="#3-2-1-引用计数算法" class="headerlink" title="3.2.1 引用计数算法"></a>3.2.1 引用计数算法</h4><p>引用计数算法介绍</p>
<ul>
<li>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一</li>
<li>当引用失效时，计数器值就减一</li>
<li>任何时刻计数器为零的对象就是不可能再被使用的</li>
</ul>
<p>但是在<code>Java</code>领域中，主流的<code>Java</code>虚拟机里面都没有选用引用计数算法来管理内存。</p>
<p>考虑下面这种情况，假如<code>objA.instance = objB</code>且<code>objB.instance = objA</code>。且除此之外，这两个对象再无任何引用，实际上这两个对象已经不可访问了，但是按照引用计数算法却难以将它们删除</p>
<h4 id="3-2-2-可达性分析算法"><a href="#3-2-2-可达性分析算法" class="headerlink" title="3.2.2 可达性分析算法"></a>3.2.2 可达性分析算法</h4><p>当前主流商用程序语言的内存管理子系统，都是通过可达性分析(Reachability Analysis)算法来判定对象是否存活的。</p>
<p>可达性分析算法介绍</p>
<ul>
<li>首先通过一系列称为<code>GC Roots</code>的根对象作为起始节点集</li>
<li>从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)</li>
<li>如果某个对象到<code>GC Roots</code>间没有任何引用链相连，或者从图论的话来说就是从<code>GC Roots</code>到这个对象不可达时，则证明此对象是不可能再被使用的</li>
</ul>
<p>在<code>Java</code>中，固定可作为<code>GC Roots</code>的对象包括以下几种</p>
<ul>
<li>在虚拟机栈(栈帧的本地变量表)中引用的对象</li>
<li>在方法区中类静态属性引用的对象</li>
<li>在方法区中常量引用的对象</li>
<li>在本地方法栈中<code>JNI</code>引用的对象</li>
<li><code>Java</code>虚拟机内部的引用，如基本数据类型对应的<code>Class</code>对象，一些常驻的异常对象等，还有系统类加载器</li>
<li>所有被同步锁(<code>synchronized</code>关键字)持有的对象</li>
<li>反映<code>Java</code>虚拟机内部情况的<code>JMXBean</code>、<code>JVMTI</code>中注册的回调、本地代码缓存等</li>
</ul>
<h4 id="3-2-3-再谈引用"><a href="#3-2-3-再谈引用" class="headerlink" title="3.2.3 再谈引用"></a>3.2.3 再谈引用</h4><p>通过可达性分析算法判定对象是否引用链可达，判定对象是否存活都和”引用”离不开关系</p>
<p>在<code>JDK1.2</code>前，引用是很传统的定义：如果<code>reference</code>类型的数据中存储的数值代表的是另外一块内存的起始地址，就称该<code>reference</code>数据是代表某块内存、某个对象的引用</p>
<p>在<code>JDK1.2</code>后，<code>Java</code>对引用的概念进行了扩充，按照强弱，分为了以下几种</p>
<ul>
<li>强引用(Strongly Reference)：强引用是最传统的“引用”的定义，是指在程序代码中普遍存在的引用赋值，即类似<code>Object obj = new Object()</code>这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象</li>
<li>软引用(Soft Reference)是用来描述一些还有用，但非必要的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象引入回收范围内进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</li>
<li>弱引用(Weak Reference)是用来描述那些非必须对象，但是它的强度要比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾手机发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</li>
<li>虚引用(Phantom Reference)是最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对其生存时间构成影响，也无法通过虚引用来获取一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知</li>
</ul>
<h4 id="3-2-4-生存还是死亡"><a href="#3-2-4-生存还是死亡" class="headerlink" title="3.2.4 生存还是死亡"></a>3.2.4 生存还是死亡</h4><p>要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与<code>GC Roots</code>相连接的引用链，那么它将会第一次标记，随后进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize</code>方法</p>
<p>如果这个对象被判定为确有必要执行<code>finalize</code>方法，那么该对象将会被放置在一个名为<code>F-Queue</code>的队列中，并在稍后由一条由虚拟机自动建立的、低调度优先级的<code>Finalizer</code>线程去执行它们的<code>finalize()</code>方法</p>
<p>如果对象要在<code>finalize</code>中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可。任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次，如果对象面临下一次回收，它的<code>finalize()</code>不会再次执行</p>
<p>但是并不推荐使用这种方法来拯救对象，<code>finalize()</code>能做的所有工作，使用<code>try-finally</code>或者其他方式可以做的更好、更及时</p>
<h4 id="3-2-5-回收方法区"><a href="#3-2-5-回收方法区" class="headerlink" title="3.2.5 回收方法区"></a>3.2.5 回收方法区</h4><p>方法区垃圾收集的性价比通常比较低：在<code>Java</code>堆中，尤其是新生代，对常规应用进行一次垃圾收集通常可以回收<code>70%</code>至<code>99%</code>的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾回收的回收成果远远低于此</p>
<p>方法区的垃圾回收主要回收两部分内容：废弃的常量和不再使用的类型。</p>
<p>假如一个字符串<code>java</code>曾经进入常量池中，但现在没有任何字符串对象引用这个常量，且虚拟机中也没有任何地方引用这个字面量。如果过在此时发生垃圾回收，它就会被清理出常量池</p>
<p>判断一个类型是否属于“不再被使用的类”需要同时满足以下三个条件</p>
<ul>
<li>该类所有的实例都已经被回收，也就是<code>Java</code>堆中不存在该类及其任何派生子类的实例</li>
<li>加载该类的类加载器已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ul>
<h3 id="3-3-垃圾收集算法"><a href="#3-3-垃圾收集算法" class="headerlink" title="3.3 垃圾收集算法"></a>3.3 垃圾收集算法</h3><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为“引用计数式垃圾收集”和“追踪式垃圾收集”两大类，也常被称为“直接垃圾收集”和“间接垃圾收集”</p>
<h4 id="3-3-1-分代收集理论"><a href="#3-3-1-分代收集理论" class="headerlink" title="3.3.1 分代收集理论"></a>3.3.1 分代收集理论</h4><p>分代收集建立在两个分代假说上</p>
<ol>
<li>弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说(String Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>由此我们得出一种设计原则：收集器应该将<code>Java</code>堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域中存储，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用</p>
<p>设计者一般至少把<code>Java</code>堆划分为新生代和老年代两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放</p>
<p>然后分代收集并非是简单的划分内存区域这么容易，它至少存在一个困难：对象不是孤立的，对象之间会存在跨代引用。假如要现在进行一次只局限于新生代区域的收集，但新生代中的对象完全可能被老年代所引用，不得不在固定的<code>GC Root</code>之外，再额外遍历整个老年代的所有对象来确保可达性分析的正确性，这无疑增加了很多开销，这时，我们需要第三个分代假说</p>
<ol start="3">
<li>跨代引用假说：跨代引用相对于同代引用来说仅占极少数，存在互相引用关系的两个对象是应该倾向于同时生存或同时消亡的。</li>
</ol>
<p>为了避免扫描整个老年代，需要在新生代建立一个全局的数据结构，记忆集(Remembered Set)，这个结构将老年代划分为若干小块，标记出老年代的哪一块内存会存在跨代引用。此后当发生<code>MinorGC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到<code>GC Root</code>中扫描</p>
<h4 id="3-3-2-标记-清除算法"><a href="#3-3-2-标记-清除算法" class="headerlink" title="3.3.2 标记-清除算法"></a>3.3.2 标记-清除算法</h4><p>简单来说就是首先标记所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象。标记过程就是对象是否属于垃圾的判定过程</p>
<p>它的主要缺点是</p>
<ol>
<li>执行效率不稳定，如果<code>Java</code>堆中存在大量对象，而其中大部分是需要被回收的，这时必须进行大量的标记和清除工作</li>
<li>内存空间的碎片化问题：标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ol>
<p><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_0.png" alt=""></p>
<h4 id="3-3-3-标记-复制算法"><a href="#3-3-3-标记-复制算法" class="headerlink" title="3.3.3 标记-复制算法"></a>3.3.3 标记-复制算法</h4><p>1969年Fenichel提出了一种称为“半区复制”的垃圾收集算法，它将可用内存按容量分为大小相同的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另外一块上，然后再另一半的内存空间一次清理掉。</p>
<p>这种算法既可以解决需要回收大量对象的问题（因为它只处理存活对象），也解决了碎片化（因为将存活对象移动到一起）</p>
<p><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_1.png" alt=""></p>
<p>但是缺点是过于浪费空间。后来IBM的一项研究表明，新生代中的对象有98%都熬不过第一轮收集。因此并不需要按照1:1的比例来划分新生代的内存空间</p>
<p>1989年，Appel提出了一种回收方式：把新生代分为一块较大的<code>Eden</code>空间和两块较小的<code>Survivor</code>空间，每次分配内存时只使用<code>Eden</code>空间和一块<code>Survivor</code>空间。当垃圾收集时，直接将存活的对象一次性移动到另一块<code>Survivor</code>空间上，清理掉<code>Eden</code>和用过的那块<code>Survivor</code>。HotSpot默认<code>Eden</code>和<code>Survivor</code>的比例是<code>8:1</code></p>
<p>然而任何人都无法保证每次回收都只有10%的对象存活，因此我们需要一个“逃生门”设计：当<code>Survivor</code>不足以容纳所有存活对象时，将启用老年代来处理剩余对象</p>
<h4 id="3-3-4-标记-整理算法"><a href="#3-3-4-标记-整理算法" class="headerlink" title="3.3.4 标记-整理算法"></a>3.3.4 标记-整理算法</h4><p>针对老年代对象的存亡特征，Lueders提出了另外一种有针对性的标记-整理算法。首先标记所有需要回收的对象，然后让所有存活对象向内存空间的一端移动，这样就可以避免碎片化问题</p>
<p><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_2.png" alt=""></p>
<p>然而移动存活对象并更新所有引用这些对象的地方是一种及其负重的操作，而且这种对象在移动时必须暂停用户应用程序。</p>
<p>是否移动对象都存在弊端，移动则垃圾回收时更为复杂，不移动则垃圾分配时更复杂。</p>
<p>有一种和稀泥式的方式：让虚拟机平时多数时间采用标记-清除算法，暂时容忍内存碎片的存在，直到碎片化程度大到影响对象分配时，再采用标记-整理算法收集一次，以获得更规整的内存空间</p>
<h3 id="3-4-HotSpot的算法细节实现"><a href="#3-4-HotSpot的算法细节实现" class="headerlink" title="3.4 HotSpot的算法细节实现"></a>3.4 HotSpot的算法细节实现</h3><h4 id="3-4-1-根节点枚举"><a href="#3-4-1-根节点枚举" class="headerlink" title="3.4.1 根节点枚举"></a>3.4.1 根节点枚举</h4><p>固定可作为<code>GC Roots</code>的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中</p>
<p>迄今为止，所有收集器在根节点枚举这一步骤上都是必须暂停用户线程的，因为根节点枚举必须在一个冻结的时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，即使号称几乎不会发生停顿的<code>CMS</code>、<code>G1</code>、<code>ZGC</code>等收集器，枚举根节点时也是必须要停顿的</p>
<p>当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局地引用位置，虚拟机可以使用一组称为<code>OopMap</code>的数据结构，直接得到哪些地方存放着对象引用。</p>
<h4 id="3-4-2-安全点"><a href="#3-4-2-安全点" class="headerlink" title="3.4.2 安全点"></a>3.4.2 安全点</h4><p>但是导致<code>OopMap</code>内容变化的指令非常多，如果为每条指令都生成对应的<code>OopMap</code>会消耗很多内存，因此<code>HotSpot</code>只是在特定的称为“安全点”的位置记录这些信息，因此这也决定了只有在安全点才可以进行<code>GC</code></p>
<p>对于安全点，还需要考虑，如何在垃圾收集发生时让所有线程都跑到最近的安全点，这里有两种方案</p>
<ul>
<li>抢先式中断：在<code>GC</code>时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点</li>
<li>主动式中断：当<code>GC</code>时，不直接对线程操作，仅仅设置一个标志位，各个线程在执行过程中不断主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起</li>
</ul>
<h4 id="3-4-3-安全区域"><a href="#3-4-3-安全区域" class="headerlink" title="3.4.3 安全区域"></a>3.4.3 安全区域</h4><p>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始<code>GC</code>都是安全的、我们也可以把<code>Safe Region</code>看做是被扩展了的<code>Savepoint</code>。</p>
<p>当用户线程执行到安全区域里面的代码时，首先会标志自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已经声明自己在安全区域内的线程了</p>
<h4 id="3-4-4-记忆集与卡集"><a href="#3-4-4-记忆集与卡集" class="headerlink" title="3.4.4 记忆集与卡集"></a>3.4.4 记忆集与卡集</h4><p>记忆集是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构。</p>
<p>但是如果记录所有的引用记录是极耗内存的，因此我们采用了比较粗的粒度</p>
<ul>
<li>字长精度：每个记录精确到一个机器字长</li>
<li>对象精度：每个记录精确到一个对象</li>
<li>卡精度：每个记录精确到一块内存区域，该区域内有对象含有跨代指针</li>
</ul>
<p>卡精度是我们最常用的方式，其实现方式称为卡表，它定义了记忆集的记录精度、与堆内存的映射关系等。卡表每个元素都对应着其标记的内存区域中一块特定大小的内存块，称为卡页</p>
<p>而一个卡页的内存中通常不止包含一个对象，只要卡页内有一个对象的字段存在跨代指针，那就将对应卡表的数组元素的值标注为1，称为这个元素变脏(Dirty)</p>
<h4 id="3-4-5-写屏障"><a href="#3-4-5-写屏障" class="headerlink" title="3.4.5 写屏障"></a>3.4.5 写屏障</h4><p>我们还需要解决卡表如何维护的问题，例如它们何时变脏、谁来让它们变脏</p>
<p>卡表变脏的时间很明确，应该是发生在引用类型字段赋值的那一刻</p>
<p>我们通过写屏障的方式来使得卡表变脏。写屏障可以看作在虚拟机层面上对“引用类型字段赋值”这个动作的<code>AOP</code>切面，赋值的前后，都在写屏障的覆盖范围内，只是这样每次赋值操作会产生额外的开销</p>
<h4 id="3-4-6-并发的可达性分析"><a href="#3-4-6-并发的可达性分析" class="headerlink" title="3.4.6 并发的可达性分析"></a>3.4.6 并发的可达性分析</h4><p>由于<code>GC Roots</code>相比整个<code>Java</code>堆中的全部对象算是极少数，从<code>GC Roots</code>向下遍历对象图时，假如<code>Java</code>堆过大，对象图过于复杂，则标记带来的停顿时间会很长。现代的<code>GC</code>一般都采用扫描对象图的操作和用户线程并发工作。但这将造成对象消失问题。</p>
<p>为了理解对象消失，首先引入三色标记工具来辅助推导</p>
<ul>
<li>白色：表示对象尚未被垃圾收集器访问过</li>
<li>黑色：对象及这个对象的所有引用都被访问过</li>
<li>灰色：对象被访问过，但是引用没有完全被访问过</li>
</ul>
<p>下图演示了对象消失是如何发生的<br><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_3.png" alt=""></p>
<p>Wilson证明了，当且仅当以下两个条件同时满足时，会产生“对象消失”的问题</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用</li>
</ul>
<p>因此我们要解决对象消失问题，只需破坏两个条件之一</p>
<ul>
<li>增量更新：它要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</li>
<li>原始快照：当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描一遍</li>
</ul>
<h3 id="3-5-垃圾收集器"><a href="#3-5-垃圾收集器" class="headerlink" title="3.5 垃圾收集器"></a>3.5 垃圾收集器</h3><p>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。<code>Java</code>虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大差别，经典收集器如下图所示。</p>
<p><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_4.png" alt=""></p>
<p>如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>
<h4 id="3-5-1-Serial收集器"><a href="#3-5-1-Serial收集器" class="headerlink" title="3.5.1 Serial收集器"></a>3.5.1 Serial收集器</h4><p> <code>Serial</code>收集器是一个单线程的收集器，它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。在用户不可见的情况下把用户正常工作的线程全部停掉，这对很多应用来说都是难以接受的。</p>
<p> <img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_5.png" alt=""></p>
<p>它也有着优于其他收集器的地方：简单而高效（与其他收集器的单线程比），对于限定单个<code>CPU</code>的环境来说， <code>Serial</code>收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。</p>
<h4 id="3-5-2-ParNew收集器"><a href="#3-5-2-ParNew收集器" class="headerlink" title="3.5.2 ParNew收集器"></a>3.5.2 ParNew收集器</h4><p><code>ParNew</code>收集器其实就是<code>Serial</code>收集器的多线程版本</p>
<h4 id="3-5-3-Parallel-Scavenge收集器"><a href="#3-5-3-Parallel-Scavenge收集器" class="headerlink" title="3.5.3 Parallel Scavenge收集器"></a>3.5.3 Parallel Scavenge收集器</h4><p><code>Parallel Scavenge</code>收集器的持点是它的关注点与其他收集器不同，<code>CMS</code>等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而 <code>Parallel Scavenge</code>收集器的目标则是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是<code>CPU</code>用于运行用户代码的时间与<code>CPU</code>总消耗时间的比值，虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
<h4 id="3-5-4-Serial-Old收集器"><a href="#3-5-4-Serial-Old收集器" class="headerlink" title="3.5.4 Serial Old收集器"></a>3.5.4 Serial Old收集器</h4><p><code>Serial old</code>是<code>Serial</code>收集器的老年代版本，它同样是一个单线程牧集器，使用“标记整理”算法。这个收集器的主要意义也是在于给<code>Client</code>模式下的虚拟机使用。</p>
<h4 id="3-5-5-Parallel-Old收集器"><a href="#3-5-5-Parallel-Old收集器" class="headerlink" title="3.5.5 Parallel Old收集器"></a>3.5.5 Parallel Old收集器</h4><p><code>Parallel old</code>是<code>Parallel Scavenge</code>收集器的老年代版本，使用多线程和“标记一整理”算法。</p>
<p>直到<code>Parallel old</code>收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重乔吐量以及<code>CPU</code>资源敏感的场合，都可以优先考虑<code>Parallel Scavenge</code>加<code>Parallel Old</code>收集器。 </p>
<h4 id="3-5-6-CMS收集器"><a href="#3-5-6-CMS收集器" class="headerlink" title="3.5.6 CMS收集器"></a>3.5.6 CMS收集器</h4><p><code>CMS</code>（concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p><code>CMS</code>收集器是基于“标记清除”算法实现的，它的运作过程分为4个步骤</p>
<ol>
<li>初始标记：初始标记仅仅只是标记一下<code>GC Roots</code>能直接关联到的对象，速度很快，需要<code>STOP THE WORLD</code></li>
<li>并发标记：并发标记阶段就是进行<code>GC Root Tracing</code>的过程</li>
<li>重新标记：重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长些，但远比并发标记的时间短。也需要<code>STOP THE WORLD</code></li>
<li>并发清除</li>
</ol>
<p>由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起作，所以，从总体上来说，<code>CMS</code>收集器的内存回收过程是与用户线程一起并发执行的。<br><img src="/2020/02/16/JVM-3-垃圾收集器与内存分配策略/200215_6.png" alt=""></p>
<p>然后<code>CMS</code>有三个明显缺点</p>
<ol>
<li><code>CMS</code>收集器对<code>CPU</code>资源非常敏感</li>
<li><code>CMS</code>收集器无法处理浮动垃圾，可能出现“Concurrent mode Failure”失败而导致另一次<code>Full GC</code>的产生。</li>
<li><code>CMS</code>是一款基于“标记一清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦。</li>
</ol>
<h4 id="3-5-7-Garbage-First收集器"><a href="#3-5-7-Garbage-First收集器" class="headerlink" title="3.5.7 Garbage First收集器"></a>3.5.7 Garbage First收集器</h4><p><code>G1</code>收集器是垃圾收集器计数发展史上的里程碑式的成果，开创了收集器面向局部收集的设计思路和基于<code>Region</code>的内存布局形式。它主要面向服务器应用。</p>
<p>在规划<code>JDK10</code>功能目标时，<code>HotSpot</code>虚拟机提出了统一垃圾收集器接口，将内存回收的行为和实现分离，这样日后要移除或加入某一款收集器都会变得容易很多</p>
<p>G1不再坚持固定大小和固定数量的分代区域划分，而是把连续的<code>Java</code>堆划分为多个大小相等的独立区域(<code>Region</code>)，每个<code>Region</code>都可以根据需要扮演新生代的<code>Eden</code>空间、<code>Survivor</code>空间或者老年代空间。然后收集器根据<code>Region</code>扮演的角色来采用不同的策略处理</p>
<p><code>Region</code>还有一类特殊的<code>Humongous</code>区域，专门用来存储大对象，<code>G1</code>认为只要大小超过了<code>Region</code>容量一半的对象即可判定为大对象。<code>G1</code>的大多数行为都把<code>Humongous</code>作为老年代的一部分来看待</p>
<p><code>G1</code>并不对整个<code>Java</code>堆进行全区域的垃圾收集，它跟踪各个<code>Region</code>中的垃圾堆积的价值大小，价值通过回收所获得的空间大小及回收所需时间来计算，然后在后台维护一个优先级列表，优先处理回收哪些价值收益最大的<code>Region</code></p>
<p><code>G1</code>收集器的运行过程大致分为以下四步</p>
<ul>
<li>初始标记：标记<code>GCRoots</code>可以直接关联到的对象，并且修改<code>TAMS</code>指针。这个指针是用来保证用户线程并发运行时依然可以正确地在可用地<code>Region</code>中分配新对象。这个阶段需要停顿线程</li>
<li>并发标记：从<code>GCRoots</code>开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找到要回收的对象</li>
<li>最终标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段需要停顿线程</li>
<li>筛选回收：负责更新<code>Region</code>的统计数据，对各个<code>Region</code>的回收价值进行排序，指定回收计划。然后把决定回收的那一部分<code>Region</code>的存活对象复制到空的<code>Region</code>中，再清理掉整个旧<code>Region</code>的全部空间。这个阶段需要停顿用户线程，然后由多条收集器线程并行完成</li>
</ul>
<p>从<code>G1</code>开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用地内存分配速率(<code>Allocation Rate</code>)，而不追求一次把整个<code>Java</code>堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运行得十分完美</p>
<h3 id="3-6-低延迟垃圾收集器"><a href="#3-6-低延迟垃圾收集器" class="headerlink" title="3.6 低延迟垃圾收集器"></a>3.6 低延迟垃圾收集器</h3><p>衡量垃圾收集器的三项最重要的指标是：内存占用、吞吐量和延迟，三者共同构成一个“不可能三角”。要在这三方面同时具有卓越表现的完美收集器是极其困难的，一款好的垃圾收集器一般同时达成其中的两项</p>
<p>在这三项中，延迟的重要性日益凸显，原因是随着计算机硬件的发展和性能的提升，我们越来越能容忍收集器多占用一点点内存</p>
<p>因此下面将介绍两款低延迟收集器，<code>Shenandoah</code>和<code>ZGC</code>，几乎整个工作都是并发的，只有初始标记和最终标记这些阶段有短暂的停顿</p>
<h4 id="3-6-1-Shenandoah收集器"><a href="#3-6-1-Shenandoah收集器" class="headerlink" title="3.6.1 Shenandoah收集器"></a>3.6.1 Shenandoah收集器</h4><p><code>Shenandoah</code>是一款只有<code>OpenJDK</code>才会包含的，由<code>RedHat</code>开发的收集器，它在很多方面与<code>G1</code>类似，但是它支持并发的内存整理算法；默认不使用分代；并且摒弃了在<code>G1</code>中耗费大量内存和计算资源去维护的记忆集，改用“连接矩阵”的全局数据结构来记录跨<code>Region</code>的引用关系。连接矩阵可以理解为一张二位表格，如果<code>RegionN</code>有对象指向<code>RegionM</code>，就在表格的N行M列中打一个标记</p>
<p><code>Shenandoah</code>收集器的工作过程大致分为以下九个阶段</p>
<ul>
<li>初始标记：标记<code>GCRoots</code>可以直接关联到的对象，并且修改<code>TAMS</code>指针。这个指针是用来保证用户线程并发运行时依然可以正确地在可用地<code>Region</code>中分配新对象。这个阶段需要停顿线程</li>
<li>并发标记：从<code>GCRoots</code>开始对堆中对象进行可达性分析，递归扫描整个堆中的对象图，找到要回收的对象</li>
<li>最终标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段需要停顿线程</li>
<li>并发清理：这个阶段用于清理那些整个区域内连一个存活对象都没有找到的<code>Region</code></li>
<li>并发回收：这个阶段用于把回收集里面的存活对象先复制一份到其他未被使用的<code>Region</code>中。其困难点在于移动对象时，用户线程可能仍对被移动的对象进行读写访问；此外，移动之后整个内存中所有指向该对象的引用还是旧对象的地址，这很难一瞬间改变。<code>shenandoah</code>通过读屏蔽和被称为<code>Brooks Pointers</code>的转发指针来解决</li>
<li>初始引用更新：这个阶段只是为了建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动工作</li>
<li>并发引用更新：真正开始进行引用更新操作，这个阶段是与用户线程一起并发的，时间长短取决于内存中涉及的引用数量的多少</li>
<li>最终引用更新：用于修正<code>GCRoots</code>中的引用，这个阶段需要停顿</li>
<li>并发清理：经过并发回收和引用更新，这个回收集中再无存活对象，这些<code>Region</code>都变成<code>Immediate Garbage Regions</code>了，最后再调用一次并发清理过程来回收这些<code>Region</code>的内存空间，供以后新对象分配使用</li>
</ul>
<p>为了实现对象移动与用户程序并发，我们需要先了解转发指针的概念。</p>
<p>此前，要做类似的操作，通常要在被移动对象原有的内存上设置保护陷阱，一旦用户程序访问到归属于旧对象的内存空间就会产生自陷中断，进入预设好的异常处理器中，再由其中的代码逻辑把访问转发到复制后的新对象上。但这种方式需要操作系统的支持</p>
<p>新方案是在原有对象布局结构的最前面统一增加一个新的引用字段，在对象不处于并发移动的情况下，该引用指向对象自己。而当对象拥有一份新的副本时，让旧对象的转发指针指向新对象。这样只要就对象的内存仍然存在，未被清理，虚拟机内存中所有通过旧对象访问的代码都会转发至新对象</p>
<p>除此，为了支持转发指针，<code>Shenandoah</code>在读、写屏障中都加入了额外的转发处理，这也造成了性能负担。因为对对象的读操作是很频繁的</p>
<h4 id="3-6-2-ZGC收集器"><a href="#3-6-2-ZGC收集器" class="headerlink" title="3.6.2 ZGC收集器"></a>3.6.2 ZGC收集器</h4><p><code>ZGC</code>是一款基于<code>Region</code>内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法，以低延迟为首要目标的一款垃圾收集器</p>
<p><code>ZGC</code>的<code>Region</code>具有动态性</p>
<ul>
<li>小型<code>Region</code>：容量固定为2MB，用于放置小于256KB的小对象</li>
<li>中型<code>Region</code>：容量固定为32MB，用于放置大于等于256KB但小于4MB的对象</li>
<li>大型<code>Region</code>：容量可动态变化，用于放置大于4MB的大对象，每个大型<code>Region</code>中只能放置一个对象</li>
</ul>
<p><code>ZGC</code>通过染色指针技术来实现并发的整理算法。染色指针直接把标记信息记在引用对象的指针上。它提取出了地址中的高4位，通过这些标志位可以直接看出：其引用对象的三色标记状态、是否进入了重分配集、是否只能通过<code>finalize()</code>方法才能被访问到。</p>
<p>但是，不是所有操作系统都支持用户进程随意更改内存中某些指针的前几位。对此，<code>ZGC</code>采用了经典的虚拟内存技术。它使用分页管理把线性地址空间和物理地址空间分别划分为大小相同的页，然后通过映射表完成线性地址到物理地址的转换。这样就可以做到将地址高4位不同，其他位相同的线性地址映射到同一物理地址。</p>
<p><code>ZGC</code>的运行过程大致分为4个大的阶段</p>
<ul>
<li>并发标记：与G1相同，这个过程也是进行可达性分析，但是不同的是<code>ZGC</code>的标记是在指针上而不是在对象上</li>
<li>并发预备重分配：这个阶段需要根据特定的查询条件统计得出本次收集过程要清理哪些<code>Region</code>，将这些<code>Region</code>组成重分配集</li>
<li>并发重分配：这个过程要把重分配集中的存活对象复制到新的<code>Region</code>上，并为重分配集中的每个<code>Region</code>维护一个转发表，记录从旧对象到新对象的转发关系。得益于染色指针的支持，<code>ZGC</code>收集器能仅仅从引用上就明确得知一个对象是否处于重分配集中，如果用户线程此时并发访问了位于重分配集中的对象，这次访问将会被预置的内存屏障所截获，然后立即根据<code>Region</code>上的转发表记录将访问转发到新复制的对象上，并同时修正更新该引用的值，使其直接指向新对象，<code>ZGC</code>将这种行为称为指针的“自愈”(Self-Healing)能力。这样做的好处是只慢一次。还有一个好处是一旦重分配集中某个<code>Region</code>的存活对象都复制完毕后，这个<code>Region</code>就立即释放用于新对象的分配，哪怕堆中还有很多指向这个对象的未更新指针也没有关系，这些旧指针一旦被使用就可以自愈</li>
<li>并发重映射：重映射要做的是修正整个堆中指向重分配集中旧对象的所有引用，但是<code>ZGC</code>的并发重映射并不是一个急迫的任务。</li>
</ul>
<p><code>ZGC</code>有着令开发人员趋之若鹜的性能，让以前大多数人只是听说，但从未用过的<code>Azul</code>式的垃圾收集器一下子飞入寻常百姓家。当它完全成熟后，将会成为服务端、大内存、低延迟应用首选收集器的有力竞争者</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/24/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><span class="page-number current">25</span><a class="page-number" href="/page/26/">26</a><span class="space">&hellip;</span><a class="page-number" href="/page/111/">111</a><a class="extend next" rel="next" href="/page/26/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://avatars0.githubusercontent.com/u/33653960?s=400&u=eb438b904ecb9d91f3aa9b777155a6488599493b&v=4" alt="T0UGH(GuiPing Wang)">
            
              <p class="site-author-name" itemprop="name">T0UGH(GuiPing Wang)</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">111</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">56</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/T0UGH" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="tough.neu.edu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                Friends
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://neusoftware.top/solo" title="ChengYi" target="_blank">ChengYi</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://mike4ellis.github.io/" title="Mike" target="_blank">Mike</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      
    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">T0UGH(GuiPing Wang)</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人次
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
        appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
