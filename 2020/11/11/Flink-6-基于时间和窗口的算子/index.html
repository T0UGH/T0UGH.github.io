<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000">
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top">
  
  
  <title>[Flink][6][基于时间和窗口的算子] | T0UGU BLOG</title>
  <meta name="description" content="第6章 基于时间和窗口的算子 在本章：  首先，我们将学习如何配置时间特性、时间戳和水位线。 然后，我们将介绍处理函数(process functions)，它提供了对时间戳和水位线的访问并可以注册计时器，属于比较底层的API。 接下来，我们将使用Flink的窗口API，它针对几个最常见的窗口类型都提供了内置实现。 你还将了解如何自定义窗口算子。 最后，我们将讨论数据流的JOIN函数以及处理延迟">
<meta name="keywords" content="大数据,Flink,流处理">
<meta property="og:type" content="article">
<meta property="og:title" content="[Flink][6][基于时间和窗口的算子]">
<meta property="og:url" content="https://t0ugh.biz/2020/11/11/Flink-6-基于时间和窗口的算子/index.html">
<meta property="og:site_name" content="打怪升级日常">
<meta property="og:description" content="第6章 基于时间和窗口的算子 在本章：  首先，我们将学习如何配置时间特性、时间戳和水位线。 然后，我们将介绍处理函数(process functions)，它提供了对时间戳和水位线的访问并可以注册计时器，属于比较底层的API。 接下来，我们将使用Flink的窗口API，它针对几个最常见的窗口类型都提供了内置实现。 你还将了解如何自定义窗口算子。 最后，我们将讨论数据流的JOIN函数以及处理延迟">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110183732.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110185009.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110192139.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211150.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211603.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211833.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201111125659.png">
<meta property="og:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201111130527.png">
<meta property="og:updated_time" content="2020-11-11T05:57:12.671Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Flink][6][基于时间和窗口的算子]">
<meta name="twitter:description" content="第6章 基于时间和窗口的算子 在本章：  首先，我们将学习如何配置时间特性、时间戳和水位线。 然后，我们将介绍处理函数(process functions)，它提供了对时间戳和水位线的访问并可以注册计时器，属于比较底层的API。 接下来，我们将使用Flink的窗口API，它针对几个最常见的窗口类型都提供了内置实现。 你还将了解如何自定义窗口算子。 最后，我们将讨论数据流的JOIN函数以及处理延迟">
<meta name="twitter:image" content="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110183732.png">
  <!-- Canonical links -->
  <link rel="canonical" href="https://t0ugh.biz/2020/11/11/Flink-6-基于时间和窗口的算子/index.html">
  
    <link rel="alternate" href="/atom.xml" title="打怪升级日常" type="application/atom+xml">
  
  
    <link rel="icon" href="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" type="image/x-icon">
  
  <link rel="stylesheet" href="/css/style.css">
  
  
  
  
</head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope="" itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/t0ugh" target="_blank">
          <img class="img-circle img-rotate" src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">T0UGH</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">学生&amp;编程爱好者</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> ShenYang, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search">
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech="">
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope="" itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">Tags</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/t0ugh" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope="" itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>东北大学软件工程本科在读</p><p>我的邮箱:wang.g.p@foxmail.com</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Docker/">Docker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Flink/">Flink</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/GitHub/">GitHub</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java并发/">Java并发</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Junit/">Junit</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MyBatis/">MyBatis</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SSM/">SSM</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/SpringBoot/">SpringBoot</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tensorflow/">Tensorflow</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tomcat/">Tomcat</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/c/">c</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/java/">java</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/jvm/">jvm</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/linux/">linux</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/linux/vim/">vim</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/nlp/">nlp</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/other/">other</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/redis/">redis</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/vue/">vue</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/微服务设计/">微服务设计</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/敏捷开发/">敏捷开发</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/流畅的Python/">流畅的Python</a><span class="category-list-count">11</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/深度学习/">深度学习</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法导论/">算法导论</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/蓝桥杯/">蓝桥杯</a><span class="category-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tags</h3>
    <div class="widget-body">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AOP/">AOP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C++</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CNN/">CNN</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Docker/">Docker</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ES6/">ES6</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Flink/">Flink</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GitHub/">GitHub</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GithubFlow/">GithubFlow</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/">JAVA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaScript/">JavaScript</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Junit/">Junit</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/LSTM/">LSTM</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MNIST/">MNIST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MongoDB/">MongoDB</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/">MyBatis</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/">MySQL</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/NLP/">NLP</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a><span class="tag-list-count">11</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/REST/">REST</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RNN/">RNN</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Redis/">Redis</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Scrum/">Scrum</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/">Spring</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringBoot/">SpringBoot</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringCloud/">SpringCloud</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SpringMVC/">SpringMVC</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/">Tensorflow</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tomcat/">Tomcat</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/YAML/">YAML</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/aof/">aof</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/c/">c</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/jvm/">jvm</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/nlp/">nlp</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rdb/">rdb</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/redis/">redis</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/中文分词/">中文分词</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/关键词提取/">关键词提取</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/分治算法/">分治算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/动态规划/">动态规划</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/大数据/">大数据</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/并发/">并发</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务/">微服务</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/微服务设计/">微服务设计</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/排序/">排序</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷原则/">敏捷原则</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷宣言/">敏捷宣言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/敏捷开发/">敏捷开发</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据库事务/">数据库事务</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/数据结构/">数据结构</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/机器学习/">机器学习</a><span class="tag-list-count">7</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/流处理/">流处理</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/深度学习/">深度学习</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/神经网络/">神经网络</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法导论/">算法导论</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/蓝桥杯/">蓝桥杯</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/词性标注/">词性标注</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/贪心算法/">贪心算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/软件测试/">软件测试</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/AOP/" style="font-size: 13px;">AOP</a> <a href="/tags/C/" style="font-size: 13.17px;">C++</a> <a href="/tags/CNN/" style="font-size: 13px;">CNN</a> <a href="/tags/Docker/" style="font-size: 13.17px;">Docker</a> <a href="/tags/ES6/" style="font-size: 13px;">ES6</a> <a href="/tags/Flink/" style="font-size: 13.58px;">Flink</a> <a href="/tags/Git/" style="font-size: 13px;">Git</a> <a href="/tags/GitHub/" style="font-size: 13.17px;">GitHub</a> <a href="/tags/GithubFlow/" style="font-size: 13px;">GithubFlow</a> <a href="/tags/JAVA/" style="font-size: 13px;">JAVA</a> <a href="/tags/Java/" style="font-size: 13.33px;">Java</a> <a href="/tags/JavaScript/" style="font-size: 13.17px;">JavaScript</a> <a href="/tags/Junit/" style="font-size: 13px;">Junit</a> <a href="/tags/LSTM/" style="font-size: 13px;">LSTM</a> <a href="/tags/MNIST/" style="font-size: 13px;">MNIST</a> <a href="/tags/MongoDB/" style="font-size: 13px;">MongoDB</a> <a href="/tags/MyBatis/" style="font-size: 14px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 13.25px;">MySQL</a> <a href="/tags/NLP/" style="font-size: 13px;">NLP</a> <a href="/tags/Python/" style="font-size: 13.83px;">Python</a> <a href="/tags/REST/" style="font-size: 13px;">REST</a> <a href="/tags/RNN/" style="font-size: 13.08px;">RNN</a> <a href="/tags/Redis/" style="font-size: 13.17px;">Redis</a> <a href="/tags/Scrum/" style="font-size: 13.08px;">Scrum</a> <a href="/tags/Spring/" style="font-size: 13.25px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13.58px;">SpringBoot</a> <a href="/tags/SpringCloud/" style="font-size: 13.08px;">SpringCloud</a> <a href="/tags/SpringMVC/" style="font-size: 13.17px;">SpringMVC</a> <a href="/tags/Tensorflow/" style="font-size: 13.58px;">Tensorflow</a> <a href="/tags/Tomcat/" style="font-size: 13.08px;">Tomcat</a> <a href="/tags/YAML/" style="font-size: 13px;">YAML</a> <a href="/tags/aof/" style="font-size: 13px;">aof</a> <a href="/tags/c/" style="font-size: 13px;">c</a> <a href="/tags/java/" style="font-size: 13.67px;">java</a> <a href="/tags/jvm/" style="font-size: 13.42px;">jvm</a> <a href="/tags/linux/" style="font-size: 13px;">linux</a> <a href="/tags/nlp/" style="font-size: 13.17px;">nlp</a> <a href="/tags/rdb/" style="font-size: 13px;">rdb</a> <a href="/tags/redis/" style="font-size: 13.92px;">redis</a> <a href="/tags/vue/" style="font-size: 13.08px;">vue</a> <a href="/tags/中文分词/" style="font-size: 13px;">中文分词</a> <a href="/tags/关键词提取/" style="font-size: 13px;">关键词提取</a> <a href="/tags/分治算法/" style="font-size: 13px;">分治算法</a> <a href="/tags/动态规划/" style="font-size: 13.17px;">动态规划</a> <a href="/tags/大数据/" style="font-size: 13.58px;">大数据</a> <a href="/tags/并发/" style="font-size: 13.33px;">并发</a> <a href="/tags/微服务/" style="font-size: 13.33px;">微服务</a> <a href="/tags/微服务设计/" style="font-size: 13.33px;">微服务设计</a> <a href="/tags/排序/" style="font-size: 13.17px;">排序</a> <a href="/tags/敏捷原则/" style="font-size: 13px;">敏捷原则</a> <a href="/tags/敏捷宣言/" style="font-size: 13px;">敏捷宣言</a> <a href="/tags/敏捷开发/" style="font-size: 13.25px;">敏捷开发</a> <a href="/tags/数据库事务/" style="font-size: 13.08px;">数据库事务</a> <a href="/tags/数据结构/" style="font-size: 13.33px;">数据结构</a> <a href="/tags/机器学习/" style="font-size: 13.5px;">机器学习</a> <a href="/tags/流处理/" style="font-size: 13.58px;">流处理</a> <a href="/tags/深度学习/" style="font-size: 13.75px;">深度学习</a> <a href="/tags/神经网络/" style="font-size: 13px;">神经网络</a> <a href="/tags/算法/" style="font-size: 13.08px;">算法</a> <a href="/tags/算法导论/" style="font-size: 13.67px;">算法导论</a> <a href="/tags/蓝桥杯/" style="font-size: 13.08px;">蓝桥杯</a> <a href="/tags/词性标注/" style="font-size: 13px;">词性标注</a> <a href="/tags/贪心算法/" style="font-size: 13px;">贪心算法</a> <a href="/tags/软件测试/" style="font-size: 13px;">软件测试</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">20</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">40</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">9</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">19</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Flink/">Flink</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/18/Flink-8-读写外部系统/" class="title">[Flink][8][读写外部系统]</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-18T13:07:04.000Z" itemprop="datePublished">2020-11-18</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Flink/">Flink</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/15/Flink-7-有状态算子和应用/" class="title">[Flink][7][有状态算子和应用]</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-15T10:56:30.000Z" itemprop="datePublished">2020-11-15</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java并发/">Java并发</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/11/Java并发-5-Java中的锁/" class="title">[Java并发][5][Java中的锁]</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-11T09:21:10.000Z" itemprop="datePublished">2020-11-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java并发/">Java并发</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/11/Java并发-4-Java并发编程基础/" class="title">[Java并发][4][Java并发编程基础]</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-11T09:20:40.000Z" itemprop="datePublished">2020-11-11</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/Java并发/">Java并发</a>
              </p>
              <p class="item-title">
                <a href="/2020/11/11/Java并发-3-Java内存模型/" class="title">[Java并发][3][Java内存模型]</a>
              </p>
              <p class="item-date">
                <time datetime="2020-11-11T09:20:05.000Z" itemprop="datePublished">2020-11-11</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
    <article id="post-Flink-6-基于时间和窗口的算子" class="article article-type-post" itemscope="" itemtype="http://schema.org/BlogPosting">
        
            <div class="article-header">
                
                    
  
    <h1 class="article-title" itemprop="name">
      [Flink][6][基于时间和窗口的算子]
    </h1>
  

                        
                            <div class="article-meta">
                                <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2020/11/11/Flink-6-基于时间和窗口的算子/" class="article-date">
	  <time datetime="2020-11-11T05:56:49.000Z" itemprop="datePublished">2020-11-11</time>
	</a>
</span>
                                    
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Flink/">Flink</a>
  </span>

                                        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Flink/">Flink</a>, <a class="article-tag-link" href="/tags/大数据/">大数据</a>, <a class="article-tag-link" href="/tags/流处理/">流处理</a>
  </span>


                                            

                                                <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2020/11/11/Flink-6-基于时间和窗口的算子/#comments" class="article-comment-link">Comments</a></span>
                                                
                            </div>
            </div>
            <div class="article-entry marked-body" itemprop="articleBody">
                
                                    
                                        <div id="toc">
                                            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第6章-基于时间和窗口的算子"><span class="toc-text"> 第6章 基于时间和窗口的算子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#61-配置时间特性"><span class="toc-text"> 6.1 配置时间特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#611-分配时间戳和生成水位线"><span class="toc-text"> 6.1.1 分配时间戳和生成水位线</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6111-周期性水位线分配器"><span class="toc-text"> 6.1.1.1 周期性水位线分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-assignascendingtimestamps"><span class="toc-text"> 1 assignAscendingTimestamps</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-boundedoutofordernesstimestampextractor"><span class="toc-text"> 2 BoundedOutOfOrdernessTimestampExtractor</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6112-定点水位线分配器"><span class="toc-text"> 6.1.1.2 定点水位线分配器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#612-水位线-延迟及完整性问题"><span class="toc-text"> 6.1.2 水位线、延迟及完整性问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62-处理函数process-function"><span class="toc-text"> 6.2 处理函数(Process Function)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#621-timerservice和timer"><span class="toc-text"> 6.2.1 TimerService和Timer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#622-向副输出发送数据emitting-to-side-outputs"><span class="toc-text"> 6.2.2 向副输出发送数据（Emitting to Side Outputs）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#623-coprocessfunction"><span class="toc-text"> 6.2.3 CoProcessFunction</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63-窗口算子"><span class="toc-text"> 6.3 窗口算子</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#631-定义窗口算子"><span class="toc-text"> 6.3.1 定义窗口算子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#632-内置窗口分配器built-in-window-assigners"><span class="toc-text"> 6.3.2 内置窗口分配器(Built-in Window Assigners)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6321-滚动窗口tumbling-windows"><span class="toc-text"> 6.3.2.1 滚动窗口(Tumbling windows)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6322-滑动窗口sliding-windows"><span class="toc-text"> 6.3.2.2 滑动窗口(Sliding windows)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6323-会话窗口session-windows"><span class="toc-text"> 6.3.2.3 会话窗口(Session windows)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#633-在窗口上应用函数"><span class="toc-text"> 6.3.3 在窗口上应用函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6331-reducefunction"><span class="toc-text"> 6.3.3.1 ReduceFunction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6332-aggregatefunction"><span class="toc-text"> 6.3.3.2 AggregateFunction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6333-processwindowfunction"><span class="toc-text"> 6.3.3.3 ProcessWindowFunction</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6334-增量聚合与processwindowfunction结合使用"><span class="toc-text"> 6.3.3.4 增量聚合与ProcessWindowFunction结合使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#634-自定义窗口算子"><span class="toc-text"> 6.3.4 自定义窗口算子</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6341-窗口的生命周期"><span class="toc-text"> 6.3.4.1 窗口的生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#63411-何时创建"><span class="toc-text"> 6.3.4.1.1 何时创建</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#63412-由哪些信息组成"><span class="toc-text"> 6.3.4.1.2 由哪些信息组成</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#63413-何时删除"><span class="toc-text"> 6.3.4.1.3 何时删除</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6342-窗口分配器"><span class="toc-text"> 6.3.4.2 窗口分配器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6343-触发器"><span class="toc-text"> 6.3.4.3 触发器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6344-移除器"><span class="toc-text"> 6.3.4.4 移除器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64-joining-streams-on-time"><span class="toc-text"> 6.4 Joining Streams on Time</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#641-interval-join"><span class="toc-text"> 6.4.1 Interval Join</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#642-window-join"><span class="toc-text"> 6.4.2 Window Join</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65-处理迟到数据"><span class="toc-text"> 6.5 处理迟到数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#651-丢弃迟到事件dropping"><span class="toc-text"> 6.5.1 丢弃迟到事件(Dropping)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#652-重定向迟到事件redirect"><span class="toc-text"> 6.5.2 重定向迟到事件(Redirect)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#653-基于迟到事件更新结果update"><span class="toc-text"> 6.5.3 基于迟到事件更新结果(Update)</span></a></li></ol></li></ol></li></ol>
                                        </div>
                                        
                                            <h2 id="第6章-基于时间和窗口的算子"><a class="markdownIt-Anchor" href="#第6章-基于时间和窗口的算子"></a> 第6章 基于时间和窗口的算子</h2>
<p>在本章：</p>
<ol>
<li>首先，我们将学习如何配置<strong>时间特性</strong>、<strong>时间戳</strong>和<strong>水位线</strong>。</li>
<li>然后，我们将介绍<strong>处理函数(process functions)</strong>，它提供了对时间戳和水位线的访问并可以注册计时器，属于比较底层的API。</li>
<li>接下来，我们将使用Flink的<strong>窗口API</strong>，它针对几个最常见的窗口类型都提供了内置实现。</li>
<li>你还将了解如何<strong>自定义窗口算子</strong>。</li>
<li>最后，我们将讨论数据流的<strong>JOIN函数</strong>以及<strong>处理延迟事件</strong>的策略。</li>
</ol>
<h3 id="61-配置时间特性"><a class="markdownIt-Anchor" href="#61-配置时间特性"></a> 6.1 配置时间特性</h3>
<p>在DataStream API中，您可以使用**时间特性(the time characteristic)**告诉Flink在创建窗口时如何定义时间。时间特性是<code>StreamExecutionEnvironment</code>的一个属性，它接受以下值:</p>
<table>
<thead>
<tr>
<th>值</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ProcessingTime(处理时间)</strong></td>
<td>指定算子根据本地的<strong>机器时钟</strong>来<strong>确定数据流当前的时间</strong>。好处是延迟比较低，坏处是精度很差</td>
</tr>
<tr>
<td><strong>EventTime(事件时间)</strong></td>
<td>指定算子使用来自<strong>数据本身的信息</strong>来确定当前时间。<strong>每个事件</strong>都带有一个<strong>时间戳</strong>，<strong>系统的逻辑时间</strong>由<strong>水位线</strong>定义。</td>
</tr>
<tr>
<td><strong>IngestionTime(摄入时间)</strong></td>
<td>指定每个接收的记录都把<strong>数据源算子的处理时间</strong>作为<strong>事件时间的时间戳</strong>，并<strong>自动生成水位线</strong>。</td>
</tr>
</tbody>
</table>
<p>下面举一个设置时间特性的例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"><span class="comment">// 在应用中使用事件时间</span></span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br></pre></td></tr></table></figure>
<h4 id="611-分配时间戳和生成水位线"><a class="markdownIt-Anchor" href="#611-分配时间戳和生成水位线"></a> 6.1.1 分配时间戳和生成水位线</h4>
<p>为了能正常在<strong>事件时间</strong>的时间特性<strong>下</strong>工作，<strong>应用程序</strong>需要向Flink提供两个重要的信息</p>
<ol>
<li><strong>每个事件</strong>都必须与<strong>时间戳</strong>关联，时间戳通常表示事件实际发生的时间。</li>
<li><strong>事件时间数据流</strong>还需要携带<strong>水位线</strong>，算子从中推断系统的当前事件时间。</li>
</ol>
<p><strong>时间戳</strong>和<strong>水位线</strong>都是通过从1970-01-01 00:00:00以来的<strong>毫秒数</strong>指定。<strong>水位线</strong>告诉<strong>算子</strong>，<strong>不必再等</strong>那些<strong>时间戳小于或等于水位线</strong>的事件。</p>
<p>DataStream API中提供了<code>TimestampAssigner</code>接口（<strong>时间戳分配器</strong>），用于在<strong>事件</strong>被<strong>输入到流应用后</strong>从事件中<strong>提取时间戳</strong>。通常，时间戳分配器会在数据源生成之后立即调用。此外，为了确保依赖事件时间的算子能正常工作，必须在<strong>任何依赖事件时间</strong>的算子计算<strong>之前</strong>调用<strong>时间戳分配器</strong></p>
<p><strong>时间戳分配器</strong>的<strong>工作原理</strong>和其他<strong>转换算子</strong> <strong>类似</strong>。它们会<strong>作用在事件流</strong>上，并<strong>生成</strong>一个<strong>带有时间戳和水位线</strong>的<strong>新数据流</strong>。时间戳分配器<strong>不会更改</strong>DataStream的<strong>数据类型</strong>。</p>
<p>下面展示自定义时间戳分配器的使用方法，主要利用<code>assignTimestampsAndWatermarks()</code>方法</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">	.addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">	<span class="comment">// 使用自定义的时间戳分配器来分配时间戳并生成水位线</span></span><br><span class="line">	.assignTimestampsAndWatermarks(<span class="keyword">new</span> <span class="type">MyAssigner</span>)</span><br></pre></td></tr></table></figure>
<p>自定义时间戳分配器主要分为两种</p>
<ol>
<li><strong>周期性水位线分配器</strong>：周期性地发出水位线</li>
<li><strong>定点水位线分配器</strong>：根据输入事件中的某个属性或者标记来生成水位线</li>
</ol>
<h5 id="6111-周期性水位线分配器"><a class="markdownIt-Anchor" href="#6111-周期性水位线分配器"></a> 6.1.1.1 周期性水位线分配器</h5>
<p>周期性分配水位线的含义是<strong>系统</strong>以<strong>固定的机器时间间隔</strong>来<strong>发出水位线</strong>并推动事件时钟前进。<strong>默认</strong>的间隔时间设置为<strong>200毫秒</strong>。可以使用<code>ExecutionConfig.setAutoWatermarkInterval()</code>方法对<strong>间隔时间</strong>进行<strong>配置</strong>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line">env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">EventTime</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置水位线间隔为每隔5秒一次</span></span><br><span class="line">env.getConfig.setAutoWatermarkInternal(<span class="number">5000</span>)</span><br></pre></td></tr></table></figure>
<p>示例6-3展示了一个<strong>周期性水位线分配器</strong>，它通过跟踪到目前为止遇到的事件的最大时间戳来生成水位线。当需要生成新水印时，分配器返回一个时间戳等于<strong>最大时间戳减去1分钟容忍间隔</strong>的<strong>水位线</strong>。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**定义一个周期性水位线时间戳分配器*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PeriodicAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPeriodicWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span> <span class="comment">// 1分钟的毫秒数，容忍间隔</span></span><br><span class="line">    <span class="keyword">val</span> maxTs: <span class="type">Long</span> = <span class="type">Long</span>.<span class="type">MinValue</span> <span class="comment">// 观察到的最大时间戳</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**用来生成水位线的方法*/</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getCurrentWatermark</span></span>: <span class="type">Watermark</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">Watermark</span>(maxTs - bound)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**用来生成时间戳的方法*/</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(</span><br><span class="line">        r: <span class="type">SensorReading</span></span><br><span class="line">        previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">        <span class="comment">// 更新最大时间戳</span></span><br><span class="line">        maxTs = maxTs.max(r.timestamp)</span><br><span class="line">        <span class="comment">// 返回记录的时间戳</span></span><br><span class="line">        r.timestamp</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**调用这个分配器*/</span></span><br><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">	.addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line">	.assignTimestampAndWatermarks(<span class="keyword">new</span> <span class="type">PeriodicAssigner</span>())</span><br></pre></td></tr></table></figure>
<p>DataStream API内置了<strong>两个</strong>针对<strong>常见情况</strong>的周期性水位线时间戳<strong>分配器</strong>。</p>
<h6 id="1-assignascendingtimestamps"><a class="markdownIt-Anchor" href="#1-assignascendingtimestamps"></a> 1 assignAscendingTimestamps</h6>
<p>如果您的输入元素的时间戳是单调递增的，那么您可以使用方法assignascendingtimestamp。此方法使用<strong>当前时间戳</strong>来<strong>生成水位线</strong>。但是这种方式没有考虑延迟情况，因此可能比较<strong>激进</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> r = stream.assignAscendingTimestamps(e =&gt; e.timestamp)</span><br></pre></td></tr></table></figure>
<h6 id="2-boundedoutofordernesstimestampextractor"><a class="markdownIt-Anchor" href="#2-boundedoutofordernesstimestampextractor"></a> 2 BoundedOutOfOrdernessTimestampExtractor</h6>
<p>周期性水位线生成的另一种常见情况是，你可以<strong>预测到</strong>在输入流中会遇到的<strong>最大延迟</strong>（任何新到元素的时间戳与所有先前到达的元素的时间戳最大值之间的差异）。对于这种情况，Flink提供了<code>BoundedOutOfOrdernessTimestampExtractor</code>，它将<strong>最大预期延迟</strong>作为一个<strong>参数</strong>:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> stream: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"><span class="keyword">val</span> r = stream.assignTimestampAndWatermarks(</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BoundedOutOfOrdernessTimestampExtractor</span>[<span class="type">SensorReading</span>](<span class="type">Times</span>.seconds(<span class="number">10</span>))&#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(e: <span class="type">SensorReading</span>): <span class="type">Long</span> = e.timestamp</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="string">""</span><span class="string">"</span></span><br><span class="line"><span class="string">我们假设延迟为10秒</span></span><br><span class="line"><span class="string">并且实现抽象方法extractTimestamp</span></span><br><span class="line"><span class="string">"</span><span class="string">""</span></span><br></pre></td></tr></table></figure>
<h5 id="6112-定点水位线分配器"><a class="markdownIt-Anchor" href="#6112-定点水位线分配器"></a> 6.1.1.2 定点水位线分配器</h5>
<p>有时，输入流包含一些<strong>指示系统进度</strong>的<strong>特殊元组或标记</strong>。Flink为这种情况提供了<code>assignerwithPunctuatedWatermarks</code>接口。该接口定义了**<code>checkAndGetNextWatermark()</code>方法**，该方法将在<strong>每个事件的<code>extractTimestamp()</code>之后</strong>被<strong>调用</strong>。该方法可以<strong>决定是否生成新的水位线</strong>。</p>
<p>下面举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Assigns timestamps to records and emits a watermark for each reading with sensorId == "sensor_1".</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PunctuatedAssigner</span> <span class="keyword">extends</span> <span class="title">AssignerWithPunctuatedWatermarks</span>[<span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1 min in ms</span></span><br><span class="line">  <span class="keyword">val</span> bound: <span class="type">Long</span> = <span class="number">60</span> * <span class="number">1000</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果该方法返回一个非空、且大于之前值的水位线，算子会将这个新水位线发出</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">checkAndGetNextWatermark</span></span>(r: <span class="type">SensorReading</span>, extractedTS: <span class="type">Long</span>): <span class="type">Watermark</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (r.id == <span class="string">"sensor_1"</span>) &#123;</span><br><span class="line">      <span class="comment">// emit watermark if reading is from sensor_1</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">Watermark</span>(extractedTS - bound)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// do not emit a watermark</span></span><br><span class="line">      <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成时间戳	</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">extractTimestamp</span></span>(r: <span class="type">SensorReading</span>, previousTS: <span class="type">Long</span>): <span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="comment">// assign record timestamp</span></span><br><span class="line">    r.timestamp</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="612-水位线-延迟及完整性问题"><a class="markdownIt-Anchor" href="#612-水位线-延迟及完整性问题"></a> 6.1.2 水位线、延迟及完整性问题</h4>
<p>水位线主要用于平衡<strong>延迟</strong>和<strong>结果的完整性</strong>。</p>
<ul>
<li>如果水位线设置的过于<strong>宽松</strong>，会导致<strong>较大的延迟</strong>并且需要<strong>更多的存储空间</strong>来缓存数据；但是得到的<strong>结果相对准确</strong></li>
<li>如果水位线设置的过于<strong>紧迫</strong>，则<strong>相反</strong></li>
<li>但是无论水位线设置得多宽松，<strong>总会出现迟到数据</strong></li>
<li>对于流处理应用，就是要在延迟和完整性之间做一个<strong>取舍</strong></li>
</ul>
<h3 id="62-处理函数process-function"><a class="markdownIt-Anchor" href="#62-处理函数process-function"></a> 6.2 处理函数(Process Function)</h3>
<p>下面看看如何在<strong>转换算子</strong>中<strong>访问</strong>到<strong>时间戳和水位线</strong>信息。</p>
<p>DataStream API提供一系列相对底层的转换操作——<strong>处理函数</strong>，这些转换的语义很强大，</p>
<ul>
<li>可以<strong>访问</strong>事件的<strong>时间戳</strong>和<strong>水位线</strong>，</li>
<li>还可以<strong>注册</strong>在特定时间触发的<strong>计时器</strong>，</li>
<li>还可以通过**副输出(side output)**功能，发出记录到多个输出流。</li>
</ul>
<p>目前，Flink提供了<strong>8种</strong>不同的<strong>处理函数</strong>:</p>
<ul>
<li>ProcessFunction</li>
<li>KeyedProcessFunction</li>
<li>CoProcessFunction</li>
<li>ProcessJoinFunction</li>
<li>BroadcastProcessFunction</li>
<li>KeyedBroadcastProcessFunction</li>
<li>ProcessWindowFunction</li>
<li>ProcessAllWindowFunction。</li>
</ul>
<p>下面以KeyedProcessFunction为例</p>
<ul>
<li>KeyedProcessFunction是一个<strong>非常灵活</strong>的函数，<strong>作用于KeyedStream</strong>上。</li>
<li>对流的<strong>每条记录</strong>调用该函数，会返回零条、一条或多条记录。</li>
<li>并且它<strong>实现了RichFunction接口</strong>，因此提供了open()、close()和getRuntimeContext()方法。</li>
<li>另外，KeyedProcessFunction[KEY,  IN, OUT]还额外提供了以下两种抽象方法:
<ol>
<li>processElement(v: IN, ctx: Context, out:  Collector[out])：<strong>Context</strong>是进程函数的<strong>灵活之处</strong>。它提供对<strong>当前事件</strong>的<strong>时间戳</strong>、<strong>键</strong>、<strong>TimerService</strong>等的<strong>访问</strong>。此外，Context可以将记录发送到副输出。</li>
<li>onTimer(timestamp:Long, ctx: OnTimerContext, out:  Collector[out])：它是一个回调函数，当之前注册的<strong>计时器触发时</strong>，它会被调用，来<strong>执行</strong>计时器绑定的<strong>逻辑操作</strong>。</li>
</ol>
</li>
</ul>
<p>KeyedProcessFunction接口的源代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A keyed function that processes elements of a stream.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt; Type of the key.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;I&gt; Type of the input elements.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;O&gt; Type of the output elements.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@PublicEvolving</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyedProcessFunction</span>&lt;<span class="title">K</span>, <span class="title">I</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">processElement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        I value, Context ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> timestamp, OnTimerContext ctx, Collector&lt;O&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Information available in an invocation of &#123;<span class="doctag">@link</span> #processElement(Object, Context, Collector)&#125;</span></span><br><span class="line"><span class="comment">	 * or &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Long <span class="title">timestamp</span><span class="params">()</span></span>;</span><br><span class="line">        </span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimerService <span class="title">timerService</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Information available in an invocation of &#123;<span class="doctag">@link</span> #onTimer(long, OnTimerContext, Collector)&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">OnTimerContext</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TimeDomain <span class="title">timeDomain</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> K <span class="title">getCurrentKey</span><span class="params">()</span></span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="621-timerservice和timer"><a class="markdownIt-Anchor" href="#621-timerservice和timer"></a> 6.2.1 TimerService和Timer</h4>
<p>观察上面的源码我们不难发现，<code>Context</code>提供一个<code>timerSercvice()</code>方法，它会返回一个<code>TimerService</code>。这个接口提供了一系列时间相关的操作。具体如下源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TimerService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**返回当前的处理时间*/</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**返回当前的水位线*/</span></span><br><span class="line">	<span class="function"><span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**注册处理时间计时器*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**注册事件时间计时器*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**移除处理时间计时器*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**移除事件时间计时器*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在KeyedProcessFunction中，<strong>每个键</strong>的<strong>每个时间戳</strong>只能注册<strong>一个计时器</strong>，这些计时器会按照时间戳顺序放到一个<strong>优先队列</strong>中。</p>
<p>当需要生成检查点时，<strong>计时器也会被写入检查点</strong>。如果应用程序需要<strong>从故障中恢复</strong>，那么在应用程序重新启动时<strong>过期的所有处理时间计时器</strong>将在应用程序恢复时<strong>立即触发</strong>。</p>
<p>下面我们实现一个KeyedProcessFunction。它监测传感器的温度，如果传感器的温度在处理时间语义中单调增加1秒，就会发出警告:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ProcessFunctionTimers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the streaming execution environment</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use event time for the application</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">ProcessingTime</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ingest sensor stream</span></span><br><span class="line">    <span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">      <span class="comment">// SensorSource generates random temperature readings</span></span><br><span class="line">      .addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> warnings = readings</span><br><span class="line">      <span class="comment">// key by sensor id</span></span><br><span class="line">      .keyBy(_.id)</span><br><span class="line">      <span class="comment">// 调用KeyedProcessFunction的具体实现TempIncreaseAlertFunction</span></span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">TempIncreaseAlertFunction</span>)</span><br><span class="line"></span><br><span class="line">    warnings.print()</span><br><span class="line"></span><br><span class="line">    env.execute(<span class="string">"Monitor sensor temperatures."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Emits a warning if the temperature of a sensor</span></span><br><span class="line"><span class="comment">  * monotonically increases for 1 second (in processing time).</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TempIncreaseAlertFunction</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储上一个到来的传感器温度</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> lastTemp: <span class="type">ValueState</span>[<span class="type">Double</span>] =</span><br><span class="line">    getRuntimeContext.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Double</span>](<span class="string">"lastTemp"</span>, <span class="type">Types</span>.of[<span class="type">Double</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 存储当前活跃的一个计时器</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> currentTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] =</span><br><span class="line">    getRuntimeContext.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">"timer"</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">    )</span><br><span class="line">  <span class="comment">/**处理每个元素*/</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get previous temperature</span></span><br><span class="line">    <span class="keyword">val</span> prevTemp = lastTemp.value()</span><br><span class="line">    <span class="comment">// update last temperature</span></span><br><span class="line">    lastTemp.update(r.temperature)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> curTimerTimestamp = currentTimer.value()</span><br><span class="line">    <span class="comment">// 这个计时器的第一个事件到来了，不做任何处理  </span></span><br><span class="line">    <span class="keyword">if</span> (prevTemp == <span class="number">0.0</span>) &#123;</span><br><span class="line">      <span class="comment">// first sensor reading for this key.</span></span><br><span class="line">      <span class="comment">// we cannot compare it with a previous value.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的温度小于老的温度，在上下文中注销计时器并且清空保存的计时器状态  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r.temperature &lt; prevTemp) &#123;</span><br><span class="line">      <span class="comment">// temperature decreased. Delete current timer.</span></span><br><span class="line">      ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line">      currentTimer.clear()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果新的温度大于老的温度并且当前没有计时器，就创建一个1s后触发的计时器并且保存到内部状态里面  </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (r.temperature &gt; prevTemp &amp;&amp; curTimerTimestamp == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">// temperature increased and we have not set a timer yet.</span></span><br><span class="line">      <span class="comment">// set timer for now + 1 second</span></span><br><span class="line">      <span class="keyword">val</span> timerTs = ctx.timerService().currentProcessingTime() + <span class="number">1000</span></span><br><span class="line">      ctx.timerService().registerProcessingTimeTimer(timerTs)</span><br><span class="line">      <span class="comment">// remember current timer</span></span><br><span class="line">      currentTimer.update(timerTs)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">      </span><br><span class="line">  <span class="comment">/**当计时器触发时会调用这个函数*/</span>		</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(</span><br><span class="line">      ts: <span class="type">Long</span>,</span><br><span class="line">      ctx: <span class="type">KeyedProcessFunction</span>[<span class="type">String</span>, <span class="type">SensorReading</span>, <span class="type">String</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 把这个事件的String放到输出中，相当于发出了一条警报 </span></span><br><span class="line">    out.collect(<span class="string">"Temperature of sensor '"</span> + ctx.getCurrentKey +</span><br><span class="line">      <span class="string">"' monotonically increased for 1 second."</span>)</span><br><span class="line">    <span class="comment">// 清空计时器状态</span></span><br><span class="line">    currentTimer.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="622-向副输出发送数据emitting-to-side-outputs"><a class="markdownIt-Anchor" href="#622-向副输出发送数据emitting-to-side-outputs"></a> 6.2.2 向副输出发送数据（Emitting to Side Outputs）</h4>
<p><strong>副输出(side outputs)<strong>是处理函数的一个特性，它可以从同一个函数</strong>发出多条数据流</strong>，且<strong>副输出</strong>的元素<strong>类型</strong>可以与输入<strong>不同</strong>。</p>
<p>下面直接举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * 对于温度低于32F的读数，会向副输出发出警报</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">SideOutputs</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ingest sensor stream</span></span><br><span class="line">    <span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> monitoredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">      <span class="comment">// monitor stream for readings with freezing temperatures</span></span><br><span class="line">      <span class="comment">// 调用处理函数</span></span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">FreezingMonitor</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// retrieve and print the freezing alarms</span></span><br><span class="line">    monitoredReadings</span><br><span class="line">      .getSideOutput(<span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>))</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// print the main output</span></span><br><span class="line">    readings.print()</span><br><span class="line"></span><br><span class="line">    env.execute()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Emits freezing alarms to a side output for readings with a temperature below 32F. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FreezingMonitor</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// define a side output tag</span></span><br><span class="line">  <span class="comment">// 定义一个副输出标签  </span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> freezingAlarmOutput: <span class="type">OutputTag</span>[<span class="type">String</span>] =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">OutputTag</span>[<span class="type">String</span>](<span class="string">"freezing-alarms"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理每个元素的方法  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 如果SensorReading的温度小于32F则放入Freezing Alarm副输出  </span></span><br><span class="line">    <span class="comment">// emit freezing alarm if temperature is below 32F.</span></span><br><span class="line">    <span class="keyword">if</span> (r.temperature &lt; <span class="number">32.0</span>) &#123;</span><br><span class="line">      ctx.output(freezingAlarmOutput, <span class="string">s"Freezing Alarm for <span class="subst">$&#123;r.id&#125;</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 所有的SensorReading都output到常规输出  </span></span><br><span class="line">    <span class="comment">// forward all readings to the regular output</span></span><br><span class="line">    out.collect(r)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="623-coprocessfunction"><a class="markdownIt-Anchor" href="#623-coprocessfunction"></a> 6.2.3 CoProcessFunction</h4>
<p>对于有两个输入的底层操作，DataStream API还提供了CoProcessFunction。与CoFlatMapFunction类似，CoProcessFunction也提供了一对作用在每个输入上的转换方法<code>processElement1()</code>和<code>processElement2()</code>。</p>
<p>下面直接举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">CoProcessFunctionTimers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set up the streaming execution environment</span></span><br><span class="line">    <span class="keyword">val</span> env = <span class="type">StreamExecutionEnvironment</span>.getExecutionEnvironment</span><br><span class="line"></span><br><span class="line">    <span class="comment">// use event time for the application</span></span><br><span class="line">    env.setStreamTimeCharacteristic(<span class="type">TimeCharacteristic</span>.<span class="type">ProcessingTime</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// switch messages disable filtering of sensor readings for a specific amount of time</span></span><br><span class="line">    <span class="keyword">val</span> filterSwitches: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = env</span><br><span class="line">      .fromCollection(<span class="type">Seq</span>(</span><br><span class="line">        (<span class="string">"sensor_2"</span>, <span class="number">10</span> * <span class="number">1000</span>L), <span class="comment">// sensor_2 前进2秒</span></span><br><span class="line">        (<span class="string">"sensor_7"</span>, <span class="number">60</span> * <span class="number">1000</span>L)) <span class="comment">// sensor_7 前进7秒</span></span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ingest sensor stream</span></span><br><span class="line">    <span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = env</span><br><span class="line">      <span class="comment">// SensorSource generates random temperature readings</span></span><br><span class="line">      .addSource(<span class="keyword">new</span> <span class="type">SensorSource</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> forwardedReadings = readings</span><br><span class="line">      <span class="comment">// 联结读数和开关 connect readings and switches </span></span><br><span class="line">      .connect(filterSwitches)</span><br><span class="line">      <span class="comment">// 设定这两个流分别根据什么来分区 key by sensor ids </span></span><br><span class="line">      .keyBy(_.id, _._1)</span><br><span class="line">      <span class="comment">// 调用下面代码实现的一个CoProcessFunction的接口 apply filtering CoProcessFunction </span></span><br><span class="line">      .process(<span class="keyword">new</span> <span class="type">ReadingFilter</span>)</span><br><span class="line"></span><br><span class="line">    forwardedReadings</span><br><span class="line">      .print()</span><br><span class="line"></span><br><span class="line">    env.execute(<span class="string">"Monitor sensor temperatures."</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReadingFilter</span></span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">CoProcessFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个Boolean类型的状态 允许转发的开关 switch to enable forwarding</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> forwardingEnabled: <span class="type">ValueState</span>[<span class="type">Boolean</span>] =</span><br><span class="line">    getRuntimeContext.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"filterSwitch"</span>, <span class="type">Types</span>.of[<span class="type">Boolean</span>])</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存一个时钟 hold timestamp of currently active disable timer</span></span><br><span class="line">  <span class="keyword">lazy</span> <span class="keyword">val</span> disableTimer: <span class="type">ValueState</span>[<span class="type">Long</span>] =</span><br><span class="line">    getRuntimeContext.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Long</span>](<span class="string">"timer"</span>, <span class="type">Types</span>.of[<span class="type">Long</span>])</span><br><span class="line">    )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理第一条流的数据    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement1</span></span>(</span><br><span class="line">      reading: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 检查开关是否为true，true的时候才转发，false时直接丢弃应该是     </span></span><br><span class="line">    <span class="comment">// check if we may forward the reading</span></span><br><span class="line">    <span class="keyword">if</span> (forwardingEnabled.value()) &#123;</span><br><span class="line">      out.collect(reading)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 处理第二条流的数据    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement2</span></span>(</span><br><span class="line">      switch: (<span class="type">String</span>, <span class="type">Long</span>),</span><br><span class="line">      ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开转发开关</span></span><br><span class="line">    <span class="comment">// enable reading forwarding</span></span><br><span class="line">    forwardingEnabled.update(<span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 设置停止转发的计时器  </span></span><br><span class="line">    <span class="comment">// set disable forward timer</span></span><br><span class="line">    <span class="keyword">val</span> timerTimestamp = ctx.timerService().currentProcessingTime() + switch._2</span><br><span class="line">    <span class="keyword">val</span> curTimerTimestamp = disableTimer.value()</span><br><span class="line">    <span class="comment">// 比较和当前的计时器相比哪个比较大，如果新计时器大就移除老计时器，重新设置为新计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timerTimestamp &gt; curTimerTimestamp) &#123;</span><br><span class="line">      <span class="comment">// remove current timer and register new timer</span></span><br><span class="line">      ctx.timerService().deleteProcessingTimeTimer(curTimerTimestamp)</span><br><span class="line">      ctx.timerService().registerProcessingTimeTimer(timerTimestamp)</span><br><span class="line">      disableTimer.update(timerTimestamp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 计时器被触发时，这个方法会被调用    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onTimer</span></span>(</span><br><span class="line">      ts: <span class="type">Long</span>,</span><br><span class="line">      ctx: <span class="type">CoProcessFunction</span>[<span class="type">SensorReading</span>, (<span class="type">String</span>, <span class="type">Long</span>), <span class="type">SensorReading</span>]#<span class="type">OnTimerContext</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove all state. Forward switch will be false by default.</span></span><br><span class="line">    <span class="comment">// 开关会被设置为false，也就是停止转发</span></span><br><span class="line">    forwardingEnabled.clear()</span><br><span class="line">    disableTimer.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-窗口算子"><a class="markdownIt-Anchor" href="#63-窗口算子"></a> 6.3 窗口算子</h3>
<p><strong>窗口</strong>是流式应用中的常见操作。它们可以在<strong>无限数据流</strong>的<strong>有界区间</strong>上实现<strong>聚合</strong>等操作。通常，这些间隔是使用基于时间的逻辑定义的。窗口算子提供了一种基于有限大小的桶对事件进行分组的方法，并对这些桶中的有限内容进行计算。</p>
<h4 id="631-定义窗口算子"><a class="markdownIt-Anchor" href="#631-定义窗口算子"></a> 6.3.1 定义窗口算子</h4>
<p>窗口算子可以应用于键值分区(keyed)或非键值分区(nonkeyed)的数据流上。<strong>键值分区</strong>上的窗口算子<strong>并行计算</strong>，而<strong>非键值分区</strong>的窗口算子在<strong>单个线程</strong>中处理。</p>
<p>在流上应用窗口算子需要两步：</p>
<ol>
<li>第一步是调用<code>keyBy()</code>指定一个<strong>窗口分配器</strong>，它会决定对输入流中的元素如何划分到各个桶中</li>
<li>第二步是调用某一种<strong>窗口函数</strong>来<strong>处理</strong>分配到窗口中的元素</li>
</ol>
<p>下面的例子展示了分区和不分区的<strong>窗口算子定义方式</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">	.keyBy(...)		<span class="comment">// 分区</span></span><br><span class="line">	.window(...)	<span class="comment">// 指定窗口分配器</span></span><br><span class="line">	.reduce/aggregate/process(...)	<span class="comment">// 指定窗口函数</span></span><br></pre></td></tr></table></figure>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">	.windowAll(...)	<span class="comment">//指定窗口分配器，不分区(window-all，全量窗口)</span></span><br><span class="line">	.reduce/aggregate/process(...)	<span class="comment">// 指定窗口函数</span></span><br></pre></td></tr></table></figure>
<h4 id="632-内置窗口分配器built-in-window-assigners"><a class="markdownIt-Anchor" href="#632-内置窗口分配器built-in-window-assigners"></a> 6.3.2 内置窗口分配器(Built-in Window Assigners)</h4>
<p>Flink为最常见的窗口使用场景提供了内置的窗口分配器。本节我们<strong>只讨论基于时间</strong>的窗口分配器。基于时间的窗口分配器<strong>根据</strong>元素<strong>事件时间</strong>的时间戳或当前<strong>处理时间</strong>将元素<strong>分配</strong>给窗口。<strong>每个时间窗口</strong>有一个<strong>开始时间戳</strong>和一个<strong>结束时间戳</strong>。</p>
<p>所有<strong>内置的窗口分配器</strong>都提供了一个<strong>默认触发器</strong>，当(处理或事件)时间经过<strong>窗口末尾</strong>时，该触发器将触发对窗口的计算，然后指定的<strong>窗口函数</strong>就会<strong>被调用</strong>。</p>
<p>Flink的内置窗口分配器<strong>所创建的窗口</strong>的<strong>类型</strong>为<code>TimeWindow</code>。此<strong>窗口类型</strong>实际上表示两个时间戳之间的<strong>时间区间</strong>（左闭右开）。</p>
<h5 id="6321-滚动窗口tumbling-windows"><a class="markdownIt-Anchor" href="#6321-滚动窗口tumbling-windows"></a> 6.3.2.1 滚动窗口(Tumbling windows)</h5>
<p>滚动窗口分配器将元素放入<strong>不重叠</strong>的<strong>固定大小</strong>的窗口中，如图6-1所示。</p>
<p><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110183732.png" alt=""></p>
<p>Datastream API提供了两个分配器：</p>
<ul>
<li>TumblingEventTimeWindows：用于<strong>事件时间</strong></li>
<li>TumblingProcessingTimeWindow：用于<strong>处理时间</strong></li>
<li>滚动窗口分配器只接收一个参数：<strong>窗口大小</strong></li>
</ul>
<p>例子如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sensorData: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照事件时间来分配窗口</span></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// 按照事件时间，大小为1s，来划分窗口</span></span><br><span class="line">  .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">1</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照处理时间来分配窗口</span></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// 按照处理时间，大小为1s，来划分窗口</span></span><br><span class="line">  .window(<span class="type">TumblingProcessingTimeWindows</span>.of(<span class="type">Time</span>.seconds(<span class="number">1</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用一个更快捷的方法来分配窗口</span></span><br><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// 大小为1s，来划分窗口,具体按照处理时间还是事件时间要结合当前环境来进行判断</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.second(<span class="number">1</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure>
<p>默认情况下，滚动窗口与纪元时间1970-01-01-00:00:00.000对齐。例如，大小为1小时的分配器将在00:00:00、01:00:00、02:00:00等位置定义窗口。或者，你可以在分配器中通过第二个参数指定一个**偏移量。**下面的代码显示了偏移值为15分钟的窗口，它从00:15:00、01:15:00、02:15:00等位置定义窗口：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> avgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// group readings in 1 hour windows with 15 min offset</span></span><br><span class="line">  .window(<span class="type">TumblingEventTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), </span><br><span class="line"><span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure>
<h5 id="6322-滑动窗口sliding-windows"><a class="markdownIt-Anchor" href="#6322-滑动窗口sliding-windows"></a> 6.3.2.2 滑动窗口(Sliding windows)</h5>
<p>滑动窗口分配器将元素分配给<strong>大小固定</strong>且<strong>按指定滑动间隔移动</strong>的窗口，如图6-2所示</p>
<p><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110185009.png" alt=""></p>
<p>对于滑动窗口，必须指定<strong>窗口大小</strong>和<strong>滑动间隔</strong>，以定义新窗口启动的频率。</p>
<ul>
<li>当<strong>滑动间隔小于窗口大小</strong>时，<strong>窗口会重叠</strong>，元素可以分配给多个窗口。</li>
<li>当<strong>滑动间隔大于窗口大小</strong>时，有些元素不会被分配给任何窗口，会被<strong>丢弃</strong>。</li>
</ul>
<p>下面举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件时间</span></span><br><span class="line"><span class="comment">// event-time sliding windows assigner</span></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// create 1h event-time windows every 15 minutes</span></span><br><span class="line">  .window(<span class="type">SlidingEventTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理时间</span></span><br><span class="line"><span class="comment">// processing-time sliding windows assigner</span></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// create 1h processing-time windows every 15 minutes</span></span><br><span class="line">  .window(<span class="type">SlidingProcessingTimeWindows</span>.of(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="comment">// sliding windows assigner using a shortcut method</span></span><br><span class="line"><span class="keyword">val</span> slidingAvgTemp = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// shortcut for window.(SlidingEventTimeWindow.of(size, slide))</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.hours(<span class="number">1</span>), <span class="type">Time</span>(minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">TemperatureAverager</span>)</span><br></pre></td></tr></table></figure>
<h5 id="6323-会话窗口session-windows"><a class="markdownIt-Anchor" href="#6323-会话窗口session-windows"></a> 6.3.2.3 会话窗口(Session windows)</h5>
<p>会话窗口分配器将元素放入<strong>长度可变</strong>但是<strong>不重叠</strong>的窗口中。<strong>会话窗口的边界</strong>由<strong>不活动时间间隔</strong>(session gap)（没有接收到记录的时间间隔）定义。</p>
<p>图6-3说明了如何将元素分配给会话窗口。</p>
<p><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110192139.png" alt=""></p>
<p>下面举一个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** session gap 设置为15分钟*/</span></span><br><span class="line"><span class="comment">// event-time session windows assigner</span></span><br><span class="line"><span class="keyword">val</span> sessionWindows = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// create event-time session windows with a 15 min gap</span></span><br><span class="line">  .window(<span class="type">EventTimeSessionWindows</span>.withGap(<span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(...)</span><br><span class="line"></span><br><span class="line"><span class="comment">// processing-time session windows assigner</span></span><br><span class="line"><span class="keyword">val</span> sessionWindows = sensorData</span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">   <span class="comment">// create processing-time session windows with a 15 min gap</span></span><br><span class="line">  .window(<span class="type">ProcessingTimeSessionWindows</span>.withGap(<span class="type">Time</span>.minutes(<span class="number">15</span>)))</span><br><span class="line">  .process(...)</span><br></pre></td></tr></table></figure>
<p>由于会话窗口的<strong>开始时间</strong>和<strong>结束时间</strong>都<strong>依赖于输入元素</strong>，所以窗口分配器<strong>不能立即</strong>将所有元素<strong>分配</strong>给<strong>正确</strong>的窗口。</p>
<ul>
<li>因此，会话窗口分配器<strong>最初</strong>将<strong>每个输入元素</strong>映射到自己的<strong>单独窗口</strong>中，<strong>开始时间</strong>为元素的<strong>时间戳</strong>，<strong>窗口大小</strong>为<strong>会话间隔</strong>。</li>
<li>然后，<strong>分配器</strong>会将<strong>具有重叠范围</strong>的所有窗口<strong>合并</strong>。</li>
</ul>
<h4 id="633-在窗口上应用函数"><a class="markdownIt-Anchor" href="#633-在窗口上应用函数"></a> 6.3.3 在窗口上应用函数</h4>
<p>如6.3.1小节所示，<strong>窗口的计算逻辑</strong>由<strong>窗口函数</strong>负责定义。</p>
<p>可用于窗口的函数类型有两种</p>
<ol>
<li><strong>增量聚合函数</strong>（Incremental aggregation functions）：
<ul>
<li>它的应用场景是<strong>窗口</strong>内<strong>以状态形式</strong> <strong>存储某个值</strong>并且需要<strong>根据每个加入窗口的元素</strong>对该值进行<strong>更新</strong></li>
<li>此类函数通常非常<strong>节省空间</strong>且最终会将<strong>聚合值</strong>作为单个结果发出</li>
<li>下文介绍的<strong>ReduceFunction</strong>和<strong>AggregateFunction</strong>都是增量聚合函数</li>
</ul>
</li>
<li><strong>全量窗口函数</strong>（Full window functions）
<ul>
<li>全量窗口函数<strong>收集</strong>一个<strong>窗口的所有元素</strong>，并在<strong>计算</strong>时<strong>遍历所有元素</strong>来获取计算结果。</li>
<li>全窗口函数通常<strong>需要更多空间</strong>，但比增量聚合函数<strong>支持更复杂的逻辑</strong>。</li>
<li>下文介绍的<strong>ProcessWindowFunction</strong>就是一个全量窗口函数。</li>
</ul>
</li>
</ol>
<h5 id="6331-reducefunction"><a class="markdownIt-Anchor" href="#6331-reducefunction"></a> 6.3.3.1 ReduceFunction</h5>
<p><strong>ReduceFunction接受两个相同类型的值，并将它们组合成一个类型相同的值。<strong>当在一个Windowed Stream上应用ReduceFunction语义时，ReduceFunction增量地聚合窗口中的元素。窗口只存储聚合的</strong>当前结果</strong>，它是一个<strong>和输入输出类型相同的值</strong>。当接收到新元素时，算子会从窗口读取当前状态并调用ReduceFunction结合新元素来更新状态。</p>
<p>下面举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> minTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">  <span class="comment">// 计算并输出15s窗口中的最小值 	</span></span><br><span class="line">  .reduce((r1, r2) =&gt; (r1._1, r1._2.min(r2._2)))</span><br></pre></td></tr></table></figure>
<h5 id="6332-aggregatefunction"><a class="markdownIt-Anchor" href="#6332-aggregatefunction"></a> 6.3.3.2 AggregateFunction</h5>
<p>AggregateFunction是一个比ReduceFunction<strong>更灵活</strong>的窗口函数，其接口定义如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IN 输入类型</span></span><br><span class="line"><span class="comment">* ACC 累加器类型(内部状态)</span></span><br><span class="line"><span class="comment">* OUT 输出类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">public interface <span class="type">AggregateFunction</span>&lt;<span class="type">IN</span>, <span class="type">ACC</span>, <span class="type">OUT</span>&gt; <span class="keyword">extends</span> <span class="type">Function</span>, <span class="type">Serializable</span> &#123;</span><br><span class="line">  <span class="comment">// 创建一个累加器来启动聚合</span></span><br><span class="line">  <span class="type">ACC</span> createAccumulator();</span><br><span class="line">  <span class="comment">// 向累加器中添加一个输入元素并返回累加器</span></span><br><span class="line">  <span class="type">ACC</span> add(<span class="type">IN</span> value, <span class="type">ACC</span> accumulator);</span><br><span class="line">  <span class="comment">// 根据累加器来返回结果</span></span><br><span class="line">  <span class="type">OUT</span> getResult(<span class="type">ACC</span> accumulator);</span><br><span class="line">  <span class="comment">// 合并两个累加器</span></span><br><span class="line">  <span class="type">ACC</span> merge(<span class="type">ACC</span> a, <span class="type">ACC</span> b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与ReduceFunction不同的是，AggregateFunction的<strong>中间数据类型</strong>和<strong>输出类型</strong> <strong>不依赖</strong>于<strong>输入类型</strong>。</p>
<p>下面举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算每个窗口的传感器读数的平均温度。</span></span><br><span class="line"><span class="keyword">val</span> avgTempPerWindow: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Double</span>)] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature))</span><br><span class="line">  <span class="comment">// 根据id来分key	</span></span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  <span class="comment">// 15秒的窗口	</span></span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">15</span>))</span><br><span class="line">  .aggregate(<span class="keyword">new</span> <span class="type">AvgTempFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// An AggregateFunction to compute the average tempeature per sensor.</span></span><br><span class="line"><span class="comment">// The accumulator holds the sum of temperatures and an event count.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvgTempFunction</span> <span class="keyword">extends</span> <span class="title">AggregateFunction</span> </span></span><br><span class="line"><span class="class">[(<span class="type">String</span>, <span class="type">Double</span>), (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>), (<span class="type">String</span>, <span class="type">Double</span>)] </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建累加器，累加器的  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createAccumulator</span></span>() = &#123;(<span class="string">""</span>, <span class="number">0.0</span>, <span class="number">0</span>) <span class="comment">// (ID, 累加器, 计数器&#125;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 加和  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(in: (<span class="type">String</span>, <span class="type">Double</span>), acc: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (in._1, in._2 + acc._2, <span class="number">1</span> + acc._3)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 求平均作为结果返回                                    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getResult</span></span>(acc: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (acc._1, acc._2 / acc._3)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 合并累加器的方法                                    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(acc1: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>), acc2: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Int</span>)) = &#123;</span><br><span class="line">    (acc1._1, acc1._2 + acc2._2, acc1._3 + acc2._3)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6333-processwindowfunction"><a class="markdownIt-Anchor" href="#6333-processwindowfunction"></a> 6.3.3.3 ProcessWindowFunction</h5>
<p>ProcessWindowFunction是一个Full Window Function，它会将窗口的所有元素<strong>收集</strong>起来<strong>先不做处理</strong>，等<strong>完全收集好</strong>之后，<strong>再处理</strong>。它比增量聚合应用更广，比如计算窗口内数据的中值或者出现频率最高的值等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* IN: 输入类型</span></span><br><span class="line"><span class="comment">* OUT: 输出类型</span></span><br><span class="line"><span class="comment">* KEY: 键的类型</span></span><br><span class="line"><span class="comment">* W: 窗口元数据的类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessWindowFunction</span>&lt;<span class="title">IN</span>, <span class="title">OUT</span>, <span class="title">KEY</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractRichFunction</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对窗口执行计算</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(KEY key, Context ctx, Iterable&lt;IN&gt; vals, </span></span></span><br><span class="line"><span class="function"><span class="params">               Collector&lt;OUT&gt; out)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当窗口要被删除时，清理一些自定义的状态</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(Context ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Context窗口的上下文</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 返回窗口元数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> W <span class="title">window</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前处理时间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回当前事件时间戳</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">currentWatermark</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-window state 每个窗口的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">windowState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State accessor for per-key global state 每个键的全局状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> KeyedStateStore <span class="title">globalState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Emits a record to the side output identified by the OutputTag.</span></span><br><span class="line">    <span class="comment">// 向OutputTag标识的副输出发送记录  </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> &lt;X&gt; <span class="function"><span class="keyword">void</span> <span class="title">output</span><span class="params">(OutputTag&lt;X&gt; outputTag, X value)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>process()</code>和<code>clear()</code>都有一个Context对象作为参数，这个参数功能很强大</p>
<ul>
<li>访问窗口元数据(Window类型)</li>
<li>访问当前处理时间和水位线</li>
<li>管理每个窗口的状态和每个键的全局状态
<ul>
<li><strong>窗口状态</strong>只有<strong>当前窗口</strong>才能访问到</li>
<li><strong>全局状态</strong>可用于在<strong>同一键上的多个窗口</strong>之间共享信息。</li>
</ul>
</li>
<li>副输出</li>
</ul>
<p>注意：<strong>使用了窗口状态</strong>这一功能的ProcessWindowFunction<strong>需要实现clear()<strong>方法，来</strong>在窗口被删除之前清理自定义的窗口状态</strong>。</p>
<p>下面举个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// output the lowest and highest temperature reading every 5 seconds</span></span><br><span class="line"><span class="keyword">val</span> minMaxTempPerWindow: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  <span class="comment">// 这里keyBy中key的类型需要与ProcessWindowFunction的KEY类型参数一致</span></span><br><span class="line">  .keyBy(_.id)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .process(<span class="keyword">new</span> <span class="type">HighAndLowTempProcessFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max:<span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">/**</span></span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">A</span> <span class="title">ProcessWindowFunction</span> <span class="title">that</span> <span class="title">computes</span> <span class="title">the</span> <span class="title">lowest</span> <span class="title">and</span> <span class="title">highest</span> </span></span><br><span class="line"><span class="class"><span class="title">temperature</span></span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">reading</span> <span class="title">per</span> <span class="title">window</span> <span class="title">and</span> <span class="title">emits</span> <span class="title">them</span> <span class="title">together</span> <span class="keyword">with</span> <span class="title">the</span> </span></span><br><span class="line"><span class="class"> <span class="title">*</span> <span class="title">end</span> <span class="title">timestamp</span> <span class="title">of</span> <span class="title">the</span> <span class="title">window</span>.</span></span><br><span class="line"><span class="class"> <span class="title">*</span> [<span class="type">IN</span>, <span class="type">OUT</span>, <span class="type">KEY</span>, <span class="type">W</span>]</span></span><br><span class="line"><span class="class"> <span class="title">*/</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">HighAndLowTempProcessFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span></span></span><br><span class="line"><span class="class">[<span class="type">SensorReading</span>, <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(key: <span class="type">String</span>, <span class="comment">// 键：这里是传感器的ID </span></span><br><span class="line">                         ctx: <span class="type">Context</span>,<span class="comment">// 上下文</span></span><br><span class="line">      					 vals: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],<span class="comment">// 桶中的全部元素 </span></span><br><span class="line">                         out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123; <span class="comment">// 输出</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">val</span> temps = vals.map(_.temperature)</span><br><span class="line">      <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line">      out.collect(<span class="type">MinMaxTemp</span>(key, temps.min, temps.max, windowEnd))</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6334-增量聚合与processwindowfunction结合使用"><a class="markdownIt-Anchor" href="#6334-增量聚合与processwindowfunction结合使用"></a> 6.3.3.4 增量聚合与ProcessWindowFunction结合使用</h5>
<p>很多情况下用于窗口上的<strong>逻辑</strong>都可以<strong>表示为增量聚合</strong>，只不过它还<strong>需要访问窗口的元数据或状态</strong>。可以将增量聚合函数与ProcessWindowFunction结合使用。</p>
<ul>
<li><strong>分配给窗口的元素</strong>将<strong>立即聚合</strong>，</li>
<li>当窗口的触发器触发时，<strong>聚合的结果</strong>将被<strong>传递给ProcessWindowFunction</strong></li>
<li>process()方法的<code>Iterable</code>参数将<strong>只提供单个值</strong>，即增量聚合的结果。</li>
</ul>
<p>在DataStream API中，这实现上述过程的途径是<strong>将ProcessWindowFunction作为reduce()或aggregate()方法的第二个参数</strong>，如下面的代码所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">input</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .timeWindow(...)</span><br><span class="line">  .reduce(</span><br><span class="line">    incrAggregator: <span class="type">ReduceFunction</span>[<span class="type">IN</span>],</span><br><span class="line">    function: <span class="type">ProcessWindowFunction</span>[<span class="type">IN</span>, <span class="type">OUT</span>, <span class="type">K</span>, <span class="type">W</span>])</span><br><span class="line">input</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .timeWindow(...)</span><br><span class="line">  .aggregate(</span><br><span class="line">    incrAggregator: <span class="type">AggregateFunction</span>[<span class="type">IN</span>, <span class="type">ACC</span>, <span class="type">V</span>],</span><br><span class="line">    windowFunction: <span class="type">ProcessWindowFunction</span>[<span class="type">V</span>, <span class="type">OUT</span>, <span class="type">K</span>, <span class="type">W</span>])</span><br></pre></td></tr></table></figure>
<p>下面举一个例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">MinMaxTemp</span>(<span class="params">id: <span class="type">String</span>, min: <span class="type">Double</span>, max:<span class="type">Double</span>, endTs: <span class="type">Long</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">val</span> <span class="title">minMaxTempPerWindow2</span></span>: <span class="type">DataStream</span>[<span class="type">MinMaxTemp</span>] = sensorData</span><br><span class="line">  .map(r =&gt; (r.id, r.temperature, r.temperature))</span><br><span class="line">  .keyBy(_._1)</span><br><span class="line">  .timeWindow(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  .reduce(</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增量计算最低和最高温度 [IN, ACC, V] </span></span><br><span class="line">    (r1: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), r2: (<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)) =&gt; &#123;</span><br><span class="line">      (r1._1, r1._2.min(r2._2), r1._3.max(r2._3))</span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在ProcessWindowFunction中计算最终结果  </span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">AssignWindowEndProcessFunction</span>()</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">// [V, OUT, K, W]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AssignWindowEndProcessFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span></span></span><br><span class="line"><span class="class">[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>), <span class="type">MinMaxTemp</span>, <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      key: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      minMaxIt: <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Double</span>, <span class="type">Double</span>)],</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">MinMaxTemp</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取下序列中的唯一一个元素</span></span><br><span class="line">    <span class="keyword">val</span> minMax = minMaxIt.head</span><br><span class="line">    <span class="comment">// 从上下文中获取窗口的结束时间  </span></span><br><span class="line">    <span class="keyword">val</span> windowEnd = ctx.window.getEnd</span><br><span class="line">    <span class="comment">// 输出  </span></span><br><span class="line">    out.collect(<span class="type">MinMaxTemp</span>(key, minMax._2, minMax._3, windowEnd))</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="634-自定义窗口算子"><a class="markdownIt-Anchor" href="#634-自定义窗口算子"></a> 6.3.4 自定义窗口算子</h4>
<p>基于Flink的<strong>内置窗口分配器</strong> <strong>定义的窗口算子</strong>可以<strong>应对许多常见情况</strong>。但是如果你需要更复杂的逻辑，也可以自定义窗口算子。DataStream API<strong>对外暴露</strong>了<strong>自定义窗口算子</strong>的接口和方法。你可以实现自己的<strong>分配器(assigner)</strong>、<strong>触发器(trigger)<strong>和</strong>移除器(evictor)</strong>，再加上前面一节提到的<strong>窗口函数</strong>，就可以<strong>组合出一个自定义窗口算子</strong>。</p>
<p>当一个<strong>元素到达</strong>一个窗口算子时，它将<strong>被传递给窗口分配器</strong>。该<strong>分配器</strong>会<strong>决定</strong> <strong>元素需要被放置在哪个窗口</strong>。如果这个窗口还不存在，就会直接创建。</p>
<p>如果窗口算子<strong>配置了增量聚合函数</strong>，则会<strong>立即聚合</strong>新添加的元素，并<strong>将结果存储为窗口的状态</strong>。如果窗口算子<strong>没有配置增量聚合函数</strong>，则将新元素<strong>追加到</strong>一个用来存储所有窗口分配元素的<strong>ListState</strong>上。</p>
<p>每当一个元素被添加到一个窗口时，它也被传递到该窗口的<strong>触发器</strong>。触发器定义<strong>何时执行窗口计算</strong>、<strong>何时清除窗口及其状态</strong>。</p>
<p><strong>触发器成功触发后会调用窗口函数</strong>，根据窗口函数的不同，触发器的行为具体来说分以下三种</p>
<table>
<thead>
<tr>
<th>说明</th>
<th>图例</th>
</tr>
</thead>
<tbody>
<tr>
<td>如果算子<strong>只配置了增量聚合函数</strong>，则调用<code>getResult()</code>发出当前聚合结果。</td>
<td><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211150.png" alt=""></td>
</tr>
<tr>
<td>如果算子只配置了<code>ProcessWindowFunction</code>（<strong>全量窗口函数</strong>），那么该函数的<code>process()</code>将被调用并发出结果</td>
<td><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211603.png" alt=""></td>
</tr>
<tr>
<td>如果算子<strong>既配置了增量聚合函数，又配置全量窗口函数</strong>，则对聚合函数的<strong>聚合值</strong> <strong>应用全量窗口函数</strong>并发出结果。（具体见6.3.3.4小节）</td>
<td><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201110211833.png" alt=""></td>
</tr>
</tbody>
</table>
<p><strong>移除器</strong>是一个<strong>可选组件</strong>，可以在调用ProcessWindowFunction<strong>之前</strong>或<strong>之后</strong>注入。移除器可以<strong>从窗口中删除</strong>所收集的<strong>某些元素</strong>。因为它必须遍历所有元素，所以只能在没有指定增量聚合函数的情况下使用它（指定了增量聚合函数的话，此时已经增量聚合结束了，再删除元素会导致计算结果不准确）。</p>
<p>下面的代码展示了如何<strong>组合</strong>前文介绍的各种组件，来<strong>生成自定义算子</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream</span><br><span class="line">  .keyBy(...)</span><br><span class="line">  .window(...)                   <span class="comment">// specify the window assigner 指定分配器</span></span><br><span class="line"> [.trigger(...)]                 <span class="comment">// optional: specify the trigger 指定触发器</span></span><br><span class="line"> [.evictor(...)]                 <span class="comment">// optional: specify the evictor 指定移除器</span></span><br><span class="line">  .reduce/aggregate/process(...) <span class="comment">// specify the window function 指定窗口函数</span></span><br></pre></td></tr></table></figure>
<p>此外，当没有显式指定<code>trigger</code>时，Flink会提供一个默认的<code>trigger</code>，它会在时间戳移动到<strong>窗口右边界</strong>时<strong>触发</strong></p>
<h5 id="6341-窗口的生命周期"><a class="markdownIt-Anchor" href="#6341-窗口的生命周期"></a> 6.3.4.1 窗口的生命周期</h5>
<p>在本节中，我们将讨论窗口的生命周期——何时创建，由哪些信息组成，何时删除。</p>
<h6 id="63411-何时创建"><a class="markdownIt-Anchor" href="#63411-何时创建"></a> 6.3.4.1.1 何时创建</h6>
<p>当<strong>窗口分配器</strong>需要<strong>向窗口分配第一个元素</strong>时，就会<strong>创建</strong>一个窗口。因此，一个窗口至少包含一个元素。</p>
<h6 id="63412-由哪些信息组成"><a class="markdownIt-Anchor" href="#63412-由哪些信息组成"></a> 6.3.4.1.2 由哪些信息组成</h6>
<p>一个窗口由以下不同的状态组成:</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>窗口内容</strong></td>
<td>如果窗口算子配置了ReduceFunction或AggregateFunction，则窗口内容包含<strong>增量聚合的结果</strong>。如果窗口算子配置了ProcessFunction，则窗口内容包含<strong>分配给窗口的元素</strong></td>
</tr>
<tr>
<td><strong>窗口对象</strong></td>
<td>窗口分配器返回零个、一个或多个窗口对象。窗口算子根据返回的对象对元素进行分组。因此<strong>窗口对象中保存</strong>用于<strong>区分窗口的信息</strong>。每个窗口对象都有一个<strong>结束时间戳</strong>，它定义了可以删除窗口及其状态的时间点。</td>
</tr>
<tr>
<td><strong>触发器定时器</strong></td>
<td>可以在触发器中注册计时器，以便在特定的时间点回调</td>
</tr>
<tr>
<td><strong>触发器中的自定义状态</strong></td>
<td>触发器可以定义和使用针对每个窗口、每个键的<strong>自定义状态</strong>。这种状态完全<strong>由触发器控制</strong>，而不是由窗口算子维护。</td>
</tr>
</tbody>
</table>
<h6 id="63413-何时删除"><a class="markdownIt-Anchor" href="#63413-何时删除"></a> 6.3.4.1.3 何时删除</h6>
<p>窗口算子会在<strong>窗口结束时间</strong>(由窗口对象的结束时间戳定义)<strong>删除窗口</strong>。</p>
<p>删除一个窗口时，<strong>窗口算子</strong>会<strong>自动清除</strong> <strong>窗口内容</strong>并丢弃<strong>窗口对象</strong>，但<strong>不会清除</strong> <strong>自定义的触发器状态</strong>和<strong>触发器计时器</strong>。因此，<strong>触发器</strong>必须<strong>实现<code>trigger.clear()</code>方法</strong>来<strong>清理</strong>这些，以<strong>防止状态泄漏</strong>。</p>
<h5 id="6342-窗口分配器"><a class="markdownIt-Anchor" href="#6342-窗口分配器"></a> 6.3.4.2 窗口分配器</h5>
<p>WindowAssigner用于决定将到达的元素分配给哪些窗口。</p>
<p>下面首先看看<code>WindowAssigner</code>接口的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T: 流中的元素类型</span></span><br><span class="line"><span class="comment">// W: 窗口元数据类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssigner</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Returns a collection of windows to which the element is assigned</span></span><br><span class="line">  <span class="comment">// 返回元素分配的目标窗口集合  </span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;W&gt; <span class="title">assignWindows</span><span class="params">(T element, </span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              WindowAssignerContext context)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 返回窗口分配器的默认触发器(用于算子没有显式指定触发器的情况)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Trigger&lt;T, W&gt; <span class="title">getDefaultTrigger</span><span class="params">(StreamExecutionEnvironment env)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Returns the TypeSerializer for the windows of this WindowAssigner</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TypeSerializer&lt;W&gt; <span class="title">getWindowSerializer</span><span class="params">(ExecutionConfig executionConfig)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 判断这个窗口分配器使用的是不是事件时间</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isEventTime</span><span class="params">()</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 窗口分配器的上下文</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WindowAssignerContext</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  	<span class="comment">// 返回当前处理时间</span></span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面展示如何<strong>自定义</strong>一个<strong>窗口分配器</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** A custom window that groups events into 30-second tumbling windows. */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThirtySecondsWindows</span> <span class="keyword">extends</span> <span class="title">WindowAssigner</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>]</span></span><br><span class="line"><span class="class">  <span class="title">//</span> <span class="title">窗口尺寸</span>  </span></span><br><span class="line"><span class="class">  <span class="title">val</span> <span class="title">windowSize</span></span>: <span class="type">Long</span> = <span class="number">30</span> * <span class="number">1000</span>L</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分配窗口  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">assignWindows</span></span>(o: <span class="type">Object</span>,ts: <span class="type">Long</span>,</span><br><span class="line">  	ctx: <span class="type">WindowAssigner</span>.<span class="type">WindowAssignerContext</span>):java.util.<span class="type">List</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算所属窗口的开始时间和结束时间</span></span><br><span class="line">    <span class="comment">// rounding down by 30 seconds</span></span><br><span class="line">    <span class="keyword">val</span> startTime = ts - (ts % windowSize)</span><br><span class="line">    <span class="keyword">val</span> endTime = startTime + windowSize</span><br><span class="line">    <span class="comment">// 返回一个列表，列表中的每个元素都是当前事件所属的窗口  </span></span><br><span class="line">    <span class="comment">// emitting the corresponding time window</span></span><br><span class="line">    <span class="type">Collections</span>.singletonList(<span class="keyword">new</span> <span class="type">TimeWindow</span>(startTime, endTime))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 获取默认触发器	</span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getDefaultTrigger</span></span>(env: environment.<span class="type">StreamExecutionEnvironment</span>)</span><br><span class="line">    : <span class="type">Trigger</span>[<span class="type">Object</span>, <span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">     <span class="comment">// 直接返回一个事件时间触发器</span></span><br><span class="line">     <span class="type">EventTimeTrigger</span>.create()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 窗口序列化器    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getWindowSerializer</span></span>(executionConfig: <span class="type">ExecutionConfig</span>)</span><br><span class="line">    :<span class="type">TypeSerializer</span>[<span class="type">TimeWindow</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TimeWindow</span>.<span class="type">Serializer</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 使用的是处理时间  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isEventTime</span> </span>= <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6343-触发器"><a class="markdownIt-Anchor" href="#6343-触发器"></a> 6.3.4.3 触发器</h5>
<p><strong>触发器</strong>定义了<strong>何时</strong>进行<strong>窗口计算</strong>并<strong>发出结果</strong>。触发器可以根据<strong>时间</strong>或<strong>特定的数据条件</strong>触发。例如对于基于时间窗口的默认触发器来说，当处理时间或水位线超过窗口结束边界的时间戳时，默认触发器将触发。</p>
<p>触发器的功能很强大，它可以访问时间属性和计时器，并且可以使用状态。</p>
<p>每次<strong>调用触发器</strong>时，它都会<strong>生成一个TriggerResult</strong>来决定窗口应该发生什么。TriggerResult可以取以下值之一:</p>
<table>
<thead>
<tr>
<th>TriggerResult</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONTINUE</td>
<td>什么都不做</td>
</tr>
<tr>
<td>FIRE</td>
<td>如果窗口算子配置了<strong>ProcessWindowFunction</strong>，则调用该函数<strong>计算并发出</strong>结果。如果窗口只配置了<strong>增量聚合函数</strong>，则会<strong>发出</strong>当前聚合结果。</td>
</tr>
<tr>
<td>PURGE</td>
<td><strong>窗口内容</strong>将被完全<strong>丢弃</strong>，<strong>窗口</strong>将被<strong>删除</strong>。此外，**ProcessWindowFunction.clear()**方法被调用以清除所有自定义的每个窗口状态。</td>
</tr>
<tr>
<td>FIRE_AND_PURG</td>
<td>首先<strong>计算</strong>窗口(触发)，然后<strong>删除</strong>所有状态和元数据(清除)。</td>
</tr>
</tbody>
</table>
<p>下面展示一下触发器的接口源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Trigger</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 每当有元素被添加到窗口时，这个方法都会被调用  </span></span><br><span class="line">  <span class="comment">// Called for every element that gets added to a window</span></span><br><span class="line">  <span class="function">TriggerResult <span class="title">onElement</span><span class="params">(T element, <span class="keyword">long</span> timestamp, W window, TriggerContext ctx)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当一个处理时间计时器触发时调用  </span></span><br><span class="line">  <span class="comment">// Called when a processing-time timer fires</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onProcessingTime</span><span class="params">(<span class="keyword">long</span> timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 W window, TriggerContext ctx)</span></span>;</span><br><span class="line">  <span class="comment">// 当一个事件时间计时器触发时调用  </span></span><br><span class="line">  <span class="comment">// Called when an event-time timer fires</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> TriggerResult <span class="title">onEventTime</span><span class="params">(<span class="keyword">long</span> timestamp, </span></span></span><br><span class="line"><span class="function"><span class="params">                                            W window, TriggerContext ctx)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 返回触发器是否支持状态的合并  </span></span><br><span class="line">  <span class="comment">// Returns true if this trigger supports merging of trigger state</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canMerge</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 当多个窗口需要合并时调用，多个窗口中触发器的状态也要被合并  </span></span><br><span class="line">  <span class="comment">// Called when several windows have been merged into one window </span></span><br><span class="line">  <span class="comment">// and the state of the triggers needs to be merged</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMerge</span><span class="params">(W window, OnMergeContext ctx)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 这个方法会在一个窗口被清除时调用，它应该清除触发器自定义的各种  </span></span><br><span class="line">  <span class="comment">// Clears any state that the trigger might hold for the given window</span></span><br><span class="line">  <span class="comment">// This method is called when a window is purged</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">(W window, TriggerContext ctx)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于触发器中方法的上下文对象  </span></span><br><span class="line">  <span class="comment">// A context object that is given to Trigger methods to allow them</span></span><br><span class="line">  <span class="comment">// to register timer callbacks and deal with state</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 获取当前处理时间</span></span><br><span class="line">      <span class="comment">// Returns the current processing time</span></span><br><span class="line">      <span class="function"><span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="comment">// 获取当前水位线</span></span><br><span class="line">      <span class="comment">// Returns the current watermark time</span></span><br><span class="line">      <span class="function"><span class="keyword">long</span> <span class="title">getCurrentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">      <span class="comment">// 注册处理时间计时器</span></span><br><span class="line">      <span class="comment">// Registers a processing-time timer</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">registerProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">      <span class="comment">// 注册事件时间计时器</span></span><br><span class="line">      <span class="comment">// Registers an event-time timer</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">registerEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">      <span class="comment">// 删除处理时间计时器</span></span><br><span class="line">      <span class="comment">// Deletes a processing-time timer</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">deleteProcessingTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">      <span class="comment">// 删除事件时间计时器</span></span><br><span class="line">      <span class="comment">// Deletes an event-time timer</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">deleteEventTimeTimer</span><span class="params">(<span class="keyword">long</span> time)</span></span>;</span><br><span class="line">      <span class="comment">// 获取一个作用域为触发器键值和当前窗口的状态对象</span></span><br><span class="line">      <span class="comment">// Retrieves a state object that is scoped to the window and the key of the trigger</span></span><br><span class="line">      &lt;S extends State&gt; <span class="function">S <span class="title">getPartitionedState</span><span class="params">(StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用于onMerge方法的特殊上下文</span></span><br><span class="line">  <span class="comment">// Extension of TriggerContext that is given to the Trigger.onMerge() method</span></span><br><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnMergeContext</span> <span class="keyword">extends</span> <span class="title">TriggerContext</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Merges per-window state of the trigger</span></span><br><span class="line">      <span class="comment">// The state to be merged must support merging</span></span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">mergePartitionedState</span><span class="params">(StateDescriptor&lt;S, ?&gt; stateDescriptor)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是有两点要特别注意：<strong>状态清理</strong>和<strong>合并触发器</strong></p>
<ol>
<li>状态清理：
<ul>
<li>在<strong>触发器中</strong>使用<strong>单窗口状态</strong>时，需要确保在删除窗口时正确删除该状态。否则，算子将<strong>随着时间积累越来越多的状态</strong>。</li>
<li>为了在删除窗口时清除所有状态，<strong>触发器的clear()方法</strong>需要<strong>删除所有自定义的单窗口状态</strong>，并使用TriggerContext对象<strong>删除所有计时器</strong>。</li>
</ul>
</li>
<li>合并触发器
<ul>
<li>在处理合并的时候，一定要注意<strong>合并</strong> <strong>触发器的自定义状态</strong>(onMerge())</li>
</ul>
</li>
</ol>
<p>下面我们举一个自定义触发器的例子</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 一个会每隔1s提前触发一次计算的触发器 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneSecondIntervalTrigger</span> <span class="keyword">extends</span> <span class="title">Trigger</span>[<span class="type">SensorReading</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 处理每个事件  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onElement</span></span>(r: <span class="type">SensorReading</span>, timestamp: <span class="type">Long</span>,</span><br><span class="line">      window: <span class="type">TimeWindow</span>, ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span>): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// firstSeen是一个Boolean类型的状态，初始值为false  </span></span><br><span class="line">    <span class="comment">// firstSeen will be false if not set yet</span></span><br><span class="line">    <span class="keyword">val</span> firstSeen: <span class="type">ValueState</span>[<span class="type">Boolean</span>] = ctx.getPartitionedState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"firstSeen"</span>, classOf[<span class="type">Boolean</span>]))</span><br><span class="line">      </span><br><span class="line">	<span class="comment">// 当第一个事件到达时，注册两个计时器</span></span><br><span class="line">    <span class="comment">// register initial timer only for first element</span></span><br><span class="line">    <span class="keyword">if</span> (!firstSeen.value()) &#123;</span><br><span class="line">      <span class="comment">// compute time for next early firing by rounding watermark to second</span></span><br><span class="line">      <span class="keyword">val</span> t = ctx.getCurrentWatermark + (<span class="number">1000</span> - (ctx.getCurrentWatermark % <span class="number">1000</span>))</span><br><span class="line">      <span class="comment">// 注册第一个计时器，当前水位线+1s</span></span><br><span class="line">      ctx.registerEventTimeTimer(t)</span><br><span class="line">      <span class="comment">// 注册第二个计时器，当前窗口的结束时间</span></span><br><span class="line">      <span class="comment">// register timer for the window end</span></span><br><span class="line">      ctx.registerEventTimeTimer(window.getEnd)</span><br><span class="line">      <span class="comment">// 更新firstSeen状态为true  </span></span><br><span class="line">      firstSeen.update(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回Continue，意思是什么都不做  </span></span><br><span class="line">    <span class="comment">// Continue. Do not evaluate per element</span></span><br><span class="line">    <span class="type">TriggerResult</span>.<span class="type">CONTINUE</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当事件时间计时器触发时，这个方法被调用  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onEventTime</span></span>(</span><br><span class="line">      timestamp: <span class="type">Long</span>,</span><br><span class="line">      window: <span class="type">TimeWindow</span>,</span><br><span class="line">      ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span>): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line">    <span class="comment">// 如果是窗口的结束时间的那个计时器</span></span><br><span class="line">    <span class="keyword">if</span> (timestamp == window.getEnd) &#123;</span><br><span class="line">      <span class="comment">// 执行计算并且清除窗口  </span></span><br><span class="line">      <span class="comment">// final evaluation and purge window state</span></span><br><span class="line">      <span class="type">TriggerResult</span>.<span class="type">FIRE_AND_PURGE</span></span><br><span class="line">   <span class="comment">// 如果+1s的计时器 </span></span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// register next early firing timer</span></span><br><span class="line">      <span class="comment">// 先注册下一个计时器，还是+1s</span></span><br><span class="line">      <span class="keyword">val</span> t = ctx.getCurrentWatermark + (<span class="number">1000</span> - (ctx.getCurrentWatermark % <span class="number">1000</span>))</span><br><span class="line">      <span class="keyword">if</span> (t &lt; window.getEnd) &#123;</span><br><span class="line">        ctx.registerEventTimeTimer(t)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 执行计算  </span></span><br><span class="line">      <span class="comment">// fire trigger to evaluate window</span></span><br><span class="line">      <span class="type">TriggerResult</span>.<span class="type">FIRE</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当处理时间计时器触发时，这个方法被调用，没啥用    </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onProcessingTime</span></span>(</span><br><span class="line">      timestamp: <span class="type">Long</span>,</span><br><span class="line">      window: <span class="type">TimeWindow</span>,</span><br><span class="line">      ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span>): <span class="type">TriggerResult</span> = &#123;</span><br><span class="line">    <span class="comment">// Continue. We don't use processing time timers</span></span><br><span class="line">    <span class="type">TriggerResult</span>.<span class="type">CONTINUE</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 当窗口要被删除时，这个方法被调用，我们需要手动清理firstSeen状态  </span></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">clear</span></span>(window: <span class="type">TimeWindow</span>, ctx: <span class="type">Trigger</span>.<span class="type">TriggerContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear trigger state</span></span><br><span class="line">    <span class="keyword">val</span> firstSeen: <span class="type">ValueState</span>[<span class="type">Boolean</span>] = ctx.getPartitionedState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"firstSeen"</span>, classOf[<span class="type">Boolean</span>]))</span><br><span class="line">      </span><br><span class="line">    firstSeen.clear()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6344-移除器"><a class="markdownIt-Anchor" href="#6344-移除器"></a> 6.3.4.4 移除器</h5>
<p>在Flink的窗口机制中，<strong>移除器</strong>是一个<strong>可选组件</strong>。它可以在<strong>窗口函数</strong>计算<strong>之前</strong>或<strong>之后</strong> <strong>删除窗口中的元素</strong>。</p>
<p>下面示例展示了<code>Evictor</code>接口的源码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Evictor</span>&lt;<span class="title">T</span>, <span class="title">W</span> <span class="keyword">extends</span> <span class="title">Window</span>&gt; <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Optionally evicts elements. Called before windowing function.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">evictBefore</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">   				   W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// Optionally evicts elements. Called after windowing function.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">evictAfter</span><span class="params">(Iterable&lt;TimestampedValue&lt;T&gt;&gt; elements, <span class="keyword">int</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">    W window, EvictorContext evictorContext)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A context object that is given to Evictor methods.</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">EvictorContext</span> </span>&#123;</span><br><span class="line">  	<span class="comment">// Returns the current processing time.</span></span><br><span class="line">  	<span class="function"><span class="keyword">long</span> <span class="title">getCurrentProcessingTime</span><span class="params">()</span></span>;</span><br><span class="line">  	<span class="comment">// Returns the current event time watermark.</span></span><br><span class="line">  	<span class="function"><span class="keyword">long</span> <span class="title">getCurrentWatermark</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="64-joining-streams-on-time"><a class="markdownIt-Anchor" href="#64-joining-streams-on-time"></a> 6.4 Joining Streams on Time</h3>
<p>在处理流时，一个常见的需求是<strong>connect</strong> or <strong>join</strong> the events of two streams。Flink的DataStream API提供了两个内置的算子：<strong>Interval join</strong> 和 <strong>Window join</strong>。在本节中，我们将描述这两个算子。</p>
<h4 id="641-interval-join"><a class="markdownIt-Anchor" href="#641-interval-join"></a> 6.4.1 Interval Join</h4>
<p>Interval Join对于两个流中拥有<strong>相同的键</strong>，并且彼此之间的<strong>时间戳间隔</strong> <strong>不超过指定的间隔</strong>的事件进行join操作。</p>
<p>下图显示的两条流A和B。B中某个事件会与A中的一些事件join成对，<strong>具体步骤</strong>如下</p>
<ul>
<li>以B中某个事件为<strong>基事件</strong></li>
<li><strong>从A中选择</strong>那些相较于基事件，<strong>时间戳间隔</strong>在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mi>h</mi><mo separator="true">,</mo><mo>+</mo><mn>15</mn><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">[-1h, +15min]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mord mathdefault">h</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">+</span><span class="mord">1</span><span class="mord">5</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mclose">]</span></span></span></span>范围内的事件</li>
<li>将这些事件<strong>join成事件对</strong>，来<strong>一起处理</strong>。如下图的<strong>a事件</strong>和<strong>b事件</strong>就会组成<strong>事件对</strong>，<strong>a事件</strong>和<strong>c事件</strong>也会组成<strong>事件对</strong></li>
</ul>
<p><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201111125659.png" alt=""></p>
<p>Interval Join的API使用方法如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input1</span><br><span class="line">  .keyBy(…) <span class="comment">// 按键分区</span></span><br><span class="line">  .between(<span class="type">Time</span>.hour(<span class="number">-1</span>), <span class="type">Time</span>.minute(<span class="number">15</span>)) <span class="comment">// 指定事件的上下界</span></span><br><span class="line">  .process(<span class="type">ProcessJoinFunction</span>) <span class="comment">// JOIN成功的事件对会被发送给这个函数，由它来处理</span></span><br></pre></td></tr></table></figure>
<h4 id="642-window-join"><a class="markdownIt-Anchor" href="#642-window-join"></a> 6.4.2 Window Join</h4>
<p>顾名思义，Window Join是<strong>基于</strong>Flink的<strong>窗口机制</strong>的。两个输入流的元素都被分配到<strong>同一个公共窗口</strong>，并在这个窗口收集完成时进行叉乘积联接，然后交给ProcessJoinFunction计算。</p>
<p>工作流程如下图所示</p>
<p><img src="https://healthlung.oss-cn-beijing.aliyuncs.com/20201111130527.png" alt=""></p>
<p>上图的解释如下</p>
<ul>
<li>两个输入流都<strong>根据</strong>它们各自的<strong>键</strong>属性进行<strong>分区</strong>，</li>
<li><strong>公共窗口分配器</strong>将两个流的事件映射到<strong>公共窗口</strong>，这意味着<strong>公共窗口同时存储着来自两条输入流的事件</strong>。</li>
<li>当<strong>窗口的触发器触发</strong>时，将对两个输入流中的每个元素<strong>组合</strong>（叉乘积）<strong>调用JoinFunction</strong>。</li>
<li>此外还可以<strong>自定义</strong> <strong>触发器</strong>和<strong>移除器</strong>。由于这两个流的事件被映射到相同的窗口中，因此触发器和移除器的行为与常规窗口算子中的触发器和移除器行为完全相同。</li>
</ul>
<p>下面来看看我们怎么使用这个API</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input1.join(input2)</span><br><span class="line">  .where(...)       <span class="comment">// specify key attributes for input1 指定第一条流的key状态</span></span><br><span class="line">  .equalTo(...)     <span class="comment">// specify key attributes for input2 指定第二条流的key状态</span></span><br><span class="line">  .window(...)      <span class="comment">// specify the WindowAssigner 指定窗口分配器</span></span><br><span class="line"> [.trigger(...)]    <span class="comment">// optional: specify a Trigger 指定触发器(可以不指定)</span></span><br><span class="line"> [.evictor(...)]    <span class="comment">// optional: specify an Evictor 指定移除器(可以不指定)</span></span><br><span class="line">  .apply(...)       <span class="comment">// specify the JoinFunction 指定处理函数</span></span><br></pre></td></tr></table></figure>
<p>除了Join之外，还可以使用cogroup()。Join和<strong>CoGroup</strong>的总体逻辑是相似的，Join对来自两个输入的每一对事件调用JoinFunction，而CoGroup对窗口中两条输入序列的遍历器调用GroupFunction。（也就是说参数不同）</p>
<h3 id="65-处理迟到数据"><a class="markdownIt-Anchor" href="#65-处理迟到数据"></a> 6.5 处理迟到数据</h3>
<p><strong>迟到事件</strong>是在<strong>算子需要执行的计算已经完成时</strong> <strong>到达算子</strong>的事件。在<strong>事件时间窗口算子</strong>这种情况下，如果事件到达算子，但是窗口分配器将其分配到了一个<strong>已经完成了计算的窗口</strong>（也就是算子的水位线超过了窗口的结束时间的窗口），则该事件就是迟到的。</p>
<p>DataStream API提供了三种处理迟到事件的方案:</p>
<ul>
<li>Dropping: 简单地<strong>丢弃</strong>迟到事件。</li>
<li>Redirect: 将迟到事件<strong>重定向到单独的流</strong>中。</li>
<li>Update: 根据迟到事件<strong>更新计算结果</strong>，并且发出结果。</li>
</ul>
<p>下面三小节分别介绍这三种情况</p>
<h4 id="651-丢弃迟到事件dropping"><a class="markdownIt-Anchor" href="#651-丢弃迟到事件dropping"></a> 6.5.1 丢弃迟到事件(Dropping)</h4>
<p>处理迟到事件最简单的方法就是丢弃。这也是事件时间窗口的<strong>默认行为</strong>。因此，迟到的元素将不会创建新窗口。</p>
<h4 id="652-重定向迟到事件redirect"><a class="markdownIt-Anchor" href="#652-重定向迟到事件redirect"></a> 6.5.2 重定向迟到事件(Redirect)</h4>
<p>迟到事件还可以使用副输出特性重定向到另一个DataStream，这样就可以根据业务需求来进行各种不同种类的后期处理</p>
<p>下面举个例子，说明如何<strong>将迟到事件重定向到副输出</strong></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理正常流</span></span><br><span class="line"><span class="keyword">val</span> filteredReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = readings</span><br><span class="line">	.process(<span class="keyword">new</span> <span class="type">LateReadingsFilter</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取出副输出</span></span><br><span class="line"><span class="keyword">val</span> lateReadings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = filteredReadings</span><br><span class="line">	.getSideOutput(lateReadingsOutput)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对正常流进行后续处理 print the filtered stream</span></span><br><span class="line">filteredReadings.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对副输出进行后续处理 print messages for late readings</span></span><br><span class="line">lateReadings</span><br><span class="line">	.map(r =&gt; <span class="string">"*** late reading *** "</span> + r.id)</span><br><span class="line">	.print()</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A ProcessFunction that filters out late sensor readings and re-directs them to a side output */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LateReadingsFilter</span> <span class="keyword">extends</span> <span class="title">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>] </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">processElement</span></span>(</span><br><span class="line">      r: <span class="type">SensorReading</span>,</span><br><span class="line">      ctx: <span class="type">ProcessFunction</span>[<span class="type">SensorReading</span>, <span class="type">SensorReading</span>]#<span class="type">Context</span>,</span><br><span class="line">      out: <span class="type">Collector</span>[<span class="type">SensorReading</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// compare record timestamp with current watermark</span></span><br><span class="line">    <span class="keyword">if</span> (r.timestamp &lt; ctx.timerService().currentWatermark()) &#123;</span><br><span class="line">      <span class="comment">// this is a late reading =&gt; redirect it to the side output</span></span><br><span class="line">      <span class="comment">// 迟到的事件重定向到副输出中  </span></span><br><span class="line">      ctx.output(<span class="type">LateDataHandling</span>.lateReadingsOutput, r)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 正常的事件直接输出</span></span><br><span class="line">      out.collect(r)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="653-基于迟到事件更新结果update"><a class="markdownIt-Anchor" href="#653-基于迟到事件更新结果update"></a> 6.5.3 基于迟到事件更新结果(Update)</h4>
<p>另一种策略是重新计算结果并发出更新。但是，为了能够重新计算和更新结果，需要考虑一些问题。</p>
<ul>
<li>支持Update策略的算子需要在第一次<strong>结果发出后</strong> <strong>保存</strong>计算所需的所有<strong>状态</strong>。</li>
<li><strong>下游算子</strong>或<strong>外部系统</strong> <strong>能够处理</strong>得了这些更新。</li>
</ul>
<p>窗口算子API提供了一个方法来显式声明你希望能够处理迟到事件。在使用事件时间窗口时，可以指定一个额外的时间段，称为<strong>延迟容忍度</strong>(allowed lateness)。配置了该属性的窗口不会被立刻删除，而是会被保存到延迟容忍度再删除。</p>
<p>下面举个例子，来看看<strong>延迟容忍度</strong>怎么使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> readings: <span class="type">DataStream</span>[<span class="type">SensorReading</span>] = ???</span><br><span class="line"><span class="keyword">val</span> countPer10Secs: <span class="type">DataStream</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)] = readings</span><br><span class="line">	.keyBy(_.id)</span><br><span class="line">  	.timeWindow(<span class="type">Time</span>.seconds(<span class="number">10</span>))</span><br><span class="line">  	<span class="comment">// process late readings for 5 additional seconds 设置延迟容忍度为5s</span></span><br><span class="line">  	.allowedLateness(<span class="type">Time</span>.seconds(<span class="number">5</span>))</span><br><span class="line">  	<span class="comment">// count readings and update results if late readings arrive</span></span><br><span class="line">  	.process(<span class="keyword">new</span> <span class="type">UpdatingWindowCountFunction</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**这个处理函数会采用Update策略处理迟到事件*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UpdatingWindowCountFunction</span> <span class="keyword">extends</span> <span class="title">ProcessWindowFunction</span>[<span class="type">SensorReading</span>,</span></span><br><span class="line"><span class="class">	(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>), <span class="type">String</span>, <span class="type">TimeWindow</span>] </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">process</span></span>(</span><br><span class="line">      id: <span class="type">String</span>,</span><br><span class="line">      ctx: <span class="type">Context</span>,</span><br><span class="line">      elements: <span class="type">Iterable</span>[<span class="type">SensorReading</span>],</span><br><span class="line">      out: <span class="type">Collector</span>[(<span class="type">String</span>, <span class="type">Long</span>, <span class="type">Int</span>, <span class="type">String</span>)]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// count the number of readings</span></span><br><span class="line">    <span class="keyword">val</span> cnt = elements.count(_ =&gt; <span class="literal">true</span>)</span><br><span class="line">    <span class="comment">// 这个状态用来标记是否是首次计算</span></span><br><span class="line">    <span class="keyword">val</span> isUpdate = ctx.windowState.getState(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">ValueStateDescriptor</span>[<span class="type">Boolean</span>](<span class="string">"isUpdate"</span>, <span class="type">Types</span>.of[<span class="type">Boolean</span>]))</span><br><span class="line">    <span class="keyword">if</span> (!isUpdate.value()) &#123;</span><br><span class="line">      <span class="comment">// 首次计算并发出结果</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"first"</span>))</span><br><span class="line">      isUpdate.update(<span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不是首次计算，发出更新</span></span><br><span class="line">      out.collect((id, ctx.window.getEnd, cnt, <span class="string">"update"</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

                                                
            </div>
            <div class="article-footer">
                <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://t0ugh.biz/2020/11/11/Flink-6-基于时间和窗口的算子/" title="[Flink][6][基于时间和窗口的算子]" target="_blank" rel="external">https://t0ugh.biz/2020/11/11/Flink-6-基于时间和窗口的算子/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/t0ugh" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="https://i.loli.net/2020/03/21/WAKimNUecFR64uo.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/t0ugh" target="_blank"><span class="text-dark">T0UGH</span><small class="ml-1x">学生&amp;编程爱好者</small></a></h3>
        <div>很拽很拽很拽很拽很拽很拽很拽很拽</div>
      </div>
    </figure>
  </div>
</div>


            </div>
    </article>
    
        
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


            
</div>

    <nav class="bar bar-footer clearfix" data-stick-bottom="">
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2020/11/11/Tomcat-1-Tomcat介绍/" title="[Tomcat][1][Tomcat介绍]"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2020/11/08/Flink-5-DataStreamAPI/" title="[Flink][5][DataStreamAPI]"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
        

            
</main>

  <footer class="footer" itemscope="" itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/t0ugh" target="_blank" title="Github" data-toggle="tooltip" data-placement="top"><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle="tooltip" data-placement="top"><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>
<script src="/js/plugin.min.js"></script>
<script src="/js/application.js"></script>

    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>





   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: 'E1MH6h0YP3yhA0PJsohNBgiT-gzGzoHsz',
    appKey: 'YOiN6zLq3XGfKmlR0b8vyHtN',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>